{"instanceClassId":1501,"assignedInstanceClassId":0,"instanceName":"com.cisco.dcbu.dcm.model.cfgtemplate.ConfigTemplate:name=fabric_upgrade_11_1:type=false","name":"fabric_upgrade_11_1","description":" ","userDefined":true,"parameters":[],"tags":"","supportedPlatforms":"All","content":"##template properties\nname =fabric_upgrade_11_1;\ndescription = ;\ntags = ;\nuserDefined = false;\nsupportedPlatforms = All;\ntemplateType = POLICY;\ntemplateSubType = NA;\ncontentType = PYTHON;\nimplements = ;\ndependencies = ;\npublished = false;\nimports = ;\n##\n##template variables\n\n#    Copyright (c) 2019-2023 by Cisco Systems, Inc.\n#    All rights reserved.\n\n##\n##template content\n\nfrom com.cisco.dcbu.vinci.rest.services.jython import *\nfrom com.cisco.dcbu.vinci.rest.services.jython import PTIWrapper as PTI\nfrom com.cisco.dcbu.vinci.rest.services.jython import ResourceManagerWrapper as RM\nfrom com.cisco.dcbu.vinci.rest.services.jython import InterfaceManagerWrapper as IM\nfrom com.cisco.dcbu.vinci.rest.services.jython import TopDownOverlayWrapper as TD\nfrom com.cisco.dcbu.vinci.rest.services.jython import ElasticServiceWrapper as ES\nfrom com.cisco.dcbu.vinci.rest.services.jython import BackupRestoreWrapper as BRW\nfrom com.cisco.dcbu.vinci.rest.services.jython import InterfaceTypeEnum\nfrom com.cisco.dcbu.topdown.resource import LanUpgradeInterface\nfrom com.cisco.dcbu.pti.resource import CtrlPolicySearch\nfrom com.cisco.dcbu.easy.resource import CtrlFabric\nfrom com.cisco.dcbu.topdown.util import TopDownMigrationUtils\nfrom com.cisco.dcbu.topdown.resource import LanVRF\nfrom com.cisco.dcbu.topdown.resource import LanVRFAttach\nfrom com.cisco.dcbu.topdown.resource import LanAttachByVRF\nfrom com.cisco.dcbu.topdown.resource import LanSwitchDetailsByVRF\nfrom com.cisco.dcbu.topdown.resource import LanNetwork\nfrom com.cisco.dcbu.topdown.resource import LanAttachDetailsByNetwork\nfrom com.cisco.dcbu.topdown.resource import LanAttachByNetwork\nfrom com.cisco.dcbu.topdown.resource import LanAttach\nfrom com.cisco.dcbu.topdown.resource import LanNetworkStatus\nfrom com.cisco.dcbu.topdown.resource import LanSwitchDetailsByNetwork\nfrom com.cisco.dcbu.sm.server.web.cfgtemplates import ConfigTemplateHandler\nfrom com.cisco.dcbu.tor.service import ToRWrapper\nfrom com.cisco.dcbu.tor.impl import TorImpl\nfrom com.cisco.dcbu.tor.resource import ToRLeaf\nfrom com.cisco.dcbu.jython.resource import Category\nfrom com.cisco.dcbu.jython.resource import EntityType as ET\nfrom com.cisco.dcbu.easy.util.jython.impl import FabricErrorLogger\n\nfrom topology import *\nfrom utility import *\nfrom underlay import *\nimport subprocess\nfrom collections import OrderedDict\n\nimport sys, traceback\nimport re\nimport glob\nimport os\nimport json\nimport logging\nimport datetime\nimport time\nimport inspect\nimport filecmp\nimport struct\nimport socket\nimport itertools\nfrom distutils.version import LooseVersion\n\nPOLICY_TEMPLATE_BASE_DIR = \"/usr/local/cisco/dcm/dcnm/data/templates/\"\n\n# Switch import related base directory and filenames\nSH_RUN_FILENAME = \"show_run\"\nSH_RUN_ALL_FILENAME = \"show_run_all\"\nMATCH_RESULT_FILENAME = \"result.txt\"\nINTF_MATCH_RESULT_FILENAME = \"intfResult.txt\"\nOVERLAY_INFO_FILENAME = \"overlay_info.txt\"\nIMPORT_METADATA_FILENAME = \"import_meta\"\n\nOVERLAY_PREFIX = \"----OVERLAY:\"\n\n# DCNM HA conf\nhaConf = \"/usr/local/cisco/dcm/fm/ha/ha-setup.conf\"\n\n# SSH connection read timeout value in milliseconds (10 minutes)\nSSH_CONN_READ_TIMEOUT = 600000\n\nINTF_FIRST_LVL_SPACING = \"  \"\n\nTOPDOWN_VRF_PROFILE_FREEFORM_PRIO      = 1540\nTOPDOWN_NETWORK_PROFILE_FREEFORM_PRIO  = 1550\n\n# VRF Lite IFC Python Template Name\nVRF_LITE_IFC_PYTHON_POLICY = \"Ext_VRF_Lite_Jython\"\n\nMAX_TOPDOWN_NETWORK_NAME_LENGTH = 64\n\nMGMT_VRF_NAME = \"management\"\nDEFAULT_VRF_NAME = \"default\"\n#New special vrf present in N9k systems with version 10.3.x\nEGRESS_LB_VRF = \"egress-loadbalance-resolution-\"\nGF_MGMT_VRF_FF_PTI_DESC = \"management vrf configuration\"\nBF_PRE_INTF_FF_PTI_DESC = \"Pre Interfaces Configuration\"\n\nBF_NETWORK_ATTACH_BATCH_SIZE = 100\n\nNET_PROFILE_DHCP_SERVERS_VAR = \"dhcpServers\"\nNET_PROFILE_DHCP_SERVERS_MAX = 16\n\nNO_DISK_SPACE_ERR_MSG = \"No space left on device\".lower()\n\n# template metadata dictionary\n# Note: defaults if a key is not provided:\n#               \"etype\" -> \"SWITCH\"\n#               \"source\" -> \"UNDERLAY\"\ntemplate_metadata = {\n    # Common Global\n    \"password_no_strength\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"nfm_switch_snmp_user\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"pre_config\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"pre_config_9300PX\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"tcam_pre_config_9300\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"tcam_pre_config_9500\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"tcam_pre_config_vxlan\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"nfm_switch_user\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"ssh_key_rsa\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"host_11_1\" : {\"source\":\"\", \"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"switchnm_11_1\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"v4_mgmt_default_gateway\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"v6_mgmt_default_gateway_11_1\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"dnsList\" :     {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"dns-vrfList\" : {\"source\" : \"\", \"prio\" : 911},\n    \"power_redundancy_combined\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"power_redundancy\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_dhcp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_ospf\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_ospfv3\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_ospf_auth\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"bfd_ospf\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"keychain\" : {\"source\" : \"ISIS_AUTH_UNDERLAY\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_isis_auth\" : {\"source\" : \"ISIS_AUTH_UNDERLAY\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"bfd_isis_af_ipv4\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"base_isis_level2\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"isis_overload\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_isis_level2_internal\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_multicast_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_pim_asm_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_pim_bidir_11_1\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bfd_pim\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_bgp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"anycast_rp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"syslog_server\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"syslog_server_sev\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"syslog_server_vrf\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"syslog_server_vrf_no_sev\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"ntp_server\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"ntp_prefer_server\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"clock_protocol\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"clock_timezone\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"clock_summertime\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"aaa_radius\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_radius_key\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"aaa_radius_use_vrf\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_radius_src_interface\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_radius_deadtime\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_tacacs\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_tacacs_key\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"aaa_tacacs_use_vrf\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_tacacs_src_interface\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"base_aaa\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL3},\n    \"bgp_overlay_ipv4_vrf_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_ipv6_vrf_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv4_redist_rmap_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv6_redist_rmap_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv4_max_bgp_paths_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv6_max_bgp_paths_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv4_max_ibgp_paths_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv6_max_ibgp_paths_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_cluster_id\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"evpn_multisite\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"evpn_multisite_pip\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"evpn_bgp_neighbor_auth\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"bfd_bgp_neighbor\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"feature_bfd\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"feature_nxapi\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"nxapi_http_port\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"nxapi_https_port\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"hardware_profile_port_mode\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"banner\": {\"source\": \"\", \"prio\": ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"apply_profile\": {\"source\": \"\", \"prio\": ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_bgp_external\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n\n    # Applies only to a vPC Pair\n    \"base_feature_vpc\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_vpc_domain_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_peer_switch\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_domain_ipv6_nd_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_domain_mgmt\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_domain_mgmt_no_src_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_delay_restore\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_domain_autorecovery\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_VPC_TOP_LVL1},\n    \"vpc_domain_autorecovery_default\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_VPC_TOP_LVL1},\n    \"vpc_peer_link_vlan\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_peer_link_vlan_9300PX\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_domain_virtual_peerlink\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n\n    # Applies only to a Leaf\n    \"base_feature_leaf_upg\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"eth_cfs\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"ipv4_cfs\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"ipv6_cfs\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"feature_ospf\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_ospfv3\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_isis\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_tacacs\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_pim\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_ngoam\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_lacp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_nv_overlay\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP + 1},\n    \"feature_ngmvpn\": {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"trm_multicast_multipath\": {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"feature_interface_vlan_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_vlan_based_vnsegment_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_dhcp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"evpn_bgp_rr_neighbor\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"v6_evpn_bgp_rr_neighbor\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"mvpn_bgp_rr_neighbor\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"l3_trm\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_peer_template\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"bgp_neighbor_inherit\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"anycast_gateway\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"system_jumbomtu\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"system_nve_infra_vlan\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"route_map\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"enable_ngoam\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"evpn_bgp_advertise_pip\": {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"extra_config_leaf\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_BOTTOM},\n    \"base_fex\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_fex_N7k\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"enable_fex\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"vlan_vnseg_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"vlan_name_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"overlay_vrf_ipv4_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"overlay_vrf_ipv6_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"vrf_desc_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"evpn_vni_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"evpn_vni_rt_both_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n\n    # Applies only to a Spine\n    \"base_feature_spine_upg\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"vpc_serial_simulated\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"evpn_bgp_rr\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"v6_evpn_bgp_rr\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"mvpn_bgp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"mvpn_bgp_rr_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"extra_config_spine\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_BOTTOM},\n\n    # Common Interface\n    \"nve_advertise_vmac\": {\"eType\" : \"INTERFACE\", \"source\" : \"UNDERLAY\", \"prio\" : ConfigPriority.nve_interface},\n    \"mgmt_interface_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"mgmt0\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"breakout_interface\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"loopback_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.loopback_interface},\n    \"loopback_interface_with_tag\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.loopback_interface},\n    \"v6_loopback_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.loopback_interface},\n    \"v6_loopback_interface_with_tag\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.loopback_interface},\n    \"phantom_loopback_interface_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.loopback_interface},\n    \"unnumbered_fabric_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"pim_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n\n    \"int_freeform\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"trunk_interface\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"access_interface\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n\n    \"trunk_interface_fex\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_trunk_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_access_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_dot1q_tunnel_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_routed_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n\n    \"int_vlan\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_subif\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.routed_interface},\n\n    \"port_channel_trunk_interface_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_port_channel_trunk_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n\n    \"int_port_channel_trunk_member_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : 510},\n    \"int_port_channel_dot1q_tunnel_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_port_channel_dot1q_tunnel_member_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : 510},\n    \"int_port_channel_access_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_port_channel_access_member_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : 510},\n    \"int_l3_port_channel\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_l3_port_channel_member\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_HOST_INTF},\n    \"int_vpc_trunk_host_standalone_11_1\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\": ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_dot1q_tunnel\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_trunk_host\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_trunk_po_member_11_1\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_access_host_standalone_11_1\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\": ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_access_host\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_access_po_member_11_1\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"bpduguard_disable\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"bpduguard_enable\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"porttype_fast_trunk\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"access_vlan\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"ospf_interface_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"v6_ospf_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"isis_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"isis_p2p_interface\": {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"v6_isis_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"isis_interface_auth\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"isis_interface_auth_no_lvl\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"ospf_p2p_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"ospf_interface_auth\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"pim_interface_hello_auth\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"bfd_no_echo_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"bfd_interface_auth\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \n    \"shut_interface_force\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"shut_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"no_shut_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_desc\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_mtu\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_speed\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_no_nego_auto\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL2},\n    \"interface_orphan_port\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL2},\n    \"port_channel_mode_on\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"port_channel_mode\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"int_fabric_num_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.fabric_interface},\n    \"int_fabric_unnum_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.fabric_interface},\n    \"int_fabric_ipv6_link_local\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.fabric_interface},\n    \"int_vpc_peer_keep_alive_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_fabric_loopback_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_LOOPBACK},\n    \"int_fabric_phantom_rp_loopback_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_LOOPBACK},\n    \"int_port_channel_fex\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_aa_fex_standalone_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"temp\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_port_channel_aa_fex\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_fex_po_member_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"fex_port_channel_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"fex_po_member_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"vlan_interface_fwd_mode_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"int_loopback\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_LOOPBACK},\n\n    # Applies only to a Leaf\n    \"int_nve\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_NVE},\n    \"int_mgmt\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.INTF_MGMT},\n    \"nve_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_NVE},\n    \"nve_holddown_time\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_NVE},\n    \"nve_anycast_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_NVE},\n    \"nve_interface_vni_mcast_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"nve_interface_vni_suppress_arp_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"nve_interface_vni_ir_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"nve_interface_vni_vrf_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_ipv4_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_ipv4_tag_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_ipv6_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_ipv6_tag_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_sec_ip_v4_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_sec_ip_v4_tag_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_dhcp_relay_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_dhcp_relay_vrf_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_dhcp_relay_src_lo_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_ipv6_link_local_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n\n    \"route-map\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"interface_vrf\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"overlay_vlan_intf_fwd_mode\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n\n    # Applies only to a vPC Pair\n    \"vpc_nve_loopback\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vpc_nve_loopback_with_tag_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"int_fabric_vlan_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"vlan_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"vpc_peer_link\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"int_vpc_peer_link_po\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"int_vpc_peer_link_po_member_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"vpc_peer_link_po_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"vpc_peer_link_member_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"port_channel_vpc_id_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n\n    # Applies only to ECL\n    \"base_feature_agg\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_bgp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"router_ospf\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"router_ospfv3\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"spanning_tree_classic\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"spanning_tree_classic_config\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"int_vpc_uplink_access\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_uplink_access_po\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_uplink_access_po_member\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    }\n\n# policy templates that apply to both spine and leafs\ncommon_templates_list = [\n    \"keychain\",\n    \"pre_config\",\n    \"pre_config_9300PX\",\n    \"tcam_pre_config_9300\",\n    \"tcam_pre_config_9500\",\n    \"tcam_pre_config_vxlan\",\n    \"nfm_switch_user\",\n    \"ssh_key_rsa\",\n    \"host_11_1\",\n    \"switchnm_11_1\",\n    \"v4_mgmt_default_gateway\",\n    \"v6_mgmt_default_gateway_11_1\",\n    \"nfm_switch_snmp_user\",\n    \"base_feature_vpc\",\n    \"feature_isis\",\n    \"feature_lacp\",\n    \"feature_pim\",\n    \"feature_pbr\",\n    \"feature_ngoam\",\n    \"feature_nv_overlay\",\n    \"feature_ngmvpn\",\n    \"trm_multicast_multipath\",\n    \"feature_interface_vlan_11_1\",\n    \"feature_vlan_based_vnsegment_11_1\",\n    \"feature_dhcp\",\n    \"base_bgp\",\n    \"base_ospf_auth\",\n    \"base_isis_auth\",\n    \"base_isis_level2\",\n    \"base_isis_level2_internal\",\n    \"isis_overload\",\n    \"base_multicast_11_1\",\n    \"base_pim_asm_11_1\",\n    \"base_pim_bidir_11_1\",\n    \"base_dhcp\",\n    \"dnsList\",\n    \"dns-vrfList\",\n    \"ntp_server\",\n    \"ntp_prefer_server\",\n    \"clock_protocol\",\n    \"clock_summertime\",\n    \"clock_timezone\",\n    \"syslog_server\",\n    \"syslog_server_sev\",\n    \"syslog_server_vrf\",\n    \"syslog_server_vrf_no_sev\",\n    \"anycast_rp\",\n    \"bgp_peer_template\",\n    \"bgp_neighbor_inherit\",\n    \"system_nve_infra_vlan\",\n    \"evpn_multisite\",\n    \"copp_policy\",\n    \"vpc_domain_l3_pka_vrf_11_1\",\n    \"evpn_bgp_neighbor_auth\",\n    \"feature_bfd\",\n    \"bfd_ospf\",\n    \"bfd_isis_af_ipv4\",\n    \"bfd_pim\",\n    \"bfd_bgp_neighbor\",\n    \"feature_nxapi\",\n    \"nxapi_http_port\",\n    \"nxapi_https_port\",\n    \"route_map\",\n    \"banner\",\n    \"apply_profile\",\n    \"evpn_bgp_rr_neighbor\",\n    \"v6_evpn_bgp_rr_neighbor\",\n    \"mvpn_bgp_rr_neighbor\",\n    ]\n\n# policy templates for NxCloud that apply to all devices\nnxcloud_templates_list = [\n    \"intersight_proxy_internal\",\n    \"intersight_proxy_port_internal\",\n    \"intersight_src_intf_internal\",\n    \"intersight_use_vrf_internal\"\n    ]\n\ninterface_templates_list = [\n    \"interface_ipv4_11_1\",\n    \"interface_ipv6_11_1\",\n    \"routed_interface_no_ip_redirects\",\n    \"ospf_p2p_interface\",\n    \"ospf_interface_auth\",\n    \"pim_interface_hello_auth\",\n    \"isis_p2p_interface\",\n    \"isis_interface_auth\",\n    \"isis_interface_auth_no_lvl\",\n    \"phantom_loopback_interface_11_1\",\n    \"interface_port_type_fabric\",\n    \"bfd_no_echo_interface\",\n    \"bfd_interface_auth\",\n    \"pim_interface\",\n    \"unnumbered_fabric_interface\",\n    \"unnumbered_fabric_interface_nov6\",\n    \"routed_interface\",\n    \"eth_sub_interface\",\n    \"eth_sub_interface_tag\",\n    \"p2p_routed_interface\",\n    \"p2p_routed_interface_tag\",\n    \"nve_advertise_vmac\",\n    \"nve_holddown_time\",\n    \"interface_vrf\",\n    \"mgmt_interface_11_1\",\n    \"breakout_interface\",\n    \"cdp_disable_interface_11_1\",\n    \"trunk_interface\",\n    \"access_interface\",\n    \"port_channel_access_interface\",\n    \"port_channel_trunk_interface_11_1\",\n    \"dot1q_tunnel_interface\",\n    \"port_channel_dot1q_tunnel_interface\",\n    \"bpduguard_disable\",\n    \"bpduguard_enable\",\n    \"porttype_fast_trunk\",\n    \"porttype_fast_enable\",\n    \"access_vlan\",\n    \"native_vlan\",\n    \"interface_desc\",\n    \"interface_mtu\",\n    \"interface_speed\",\n    \"interface_no_nego_auto\",\n    \"interface_orphan_port\",\n    \"port_channel_mode_on\",\n    \"port_channel_mode\",\n    \"port_channel_routed_interface\"\n]\n\nv4_underlay_templates_list = [\n    \"feature_ospf\",\n    \"base_ospf\",\n    \"vlan_interface\",\n    ]\n\ninterface_v4_underlay_templates_list = [\n    \"ospf_interface_11_1\",\n    \"isis_interface\",\n    \"loopback_interface\",\n    \"loopback_interface_with_tag\"\n    ]\n\nv6_underlay_templates_list = [\n    \"feature_ospfv3\",\n    \"base_ospfv3\"\n    ]\n\ninterface_v6_underlay_templates_list = [\n    \"v6_ospf_interface\",\n    \"v6_isis_interface\",\n    \"v6_loopback_interface\",\n    \"v6_loopback_interface_with_tag\",\n    \"v6_vlan_interface\",\n    \"v6_vlan_interface_link_local\",\n    \"interface_ipv6_link_local\",\n    \"interface_ipv6_link_local_bia\"\n    ]\n\n# policy templates that apply to leafs only\nleaf_templates_list = [\n    \"anycast_gateway\",\n    \"evpn_bgp_rr_neighbor_send_comm_both\",\n    \"l3_trm\",\n    \"enable_ngoam\",\n    \"evpn_bgp_advertise_pip\",\n    \"system_jumbomtu\",\n    \"base_feature_leaf_upg\",\n    \"eth_cfs\",\n    \"ipv4_cfs\",\n    \"ipv6_cfs\"\n    ]\n\ninterface_leaf_templates_list = [\n    \"nve_interface\",\n    \"nve_anycast_interface\",\n    ]\n\n# policy related to overlays on leafs \nleaf_overlay_templates_list = [\n    \"vlan_vnseg_11_1\",\n    \"vlan_name_11_1\",\n    \"overlay_vrf_ipv4_11_1\",\n    \"overlay_vrf_ipv6_11_1\",\n    \"vrf_desc_11_1\",\n    \"evpn_vni_11_1\",\n    \"evpn_vni_rt_both_11_1\",\n    \"bgp_overlay_ipv4_vrf_11_1\",\n    \"bgp_overlay_ipv6_vrf_11_1\",\n    \"bgp_overlay_vrf_ipv4_redist_rmap_11_1\",\n    \"bgp_overlay_vrf_ipv6_redist_rmap_11_1\",\n    \"bgp_overlay_vrf_ipv4_max_bgp_paths_11_1\",\n    \"bgp_overlay_vrf_ipv6_max_bgp_paths_11_1\",\n    \"bgp_overlay_vrf_ipv4_max_ibgp_paths_11_1\",\n    \"bgp_overlay_vrf_ipv6_max_ibgp_paths_11_1\"\n]\n\ninterface_leaf_overlay_templates_list = [\n    \"nve_interface_vni_mcast_11_1\",\n    \"nve_interface_vni_suppress_arp_11_1\",\n    \"nve_interface_vni_ir_11_1\",\n    \"nve_interface_vni_vrf_11_1\",\n    \"interface_ipv4_tag_11_1\",\n    \"interface_ipv6_tag_11_1\",\n    \"vlan_interface_sec_ip_v4_11_1\",\n    \"vlan_interface_sec_ip_v4_tag_11_1\",\n    \"vlan_interface_dhcp_relay_11_1\",\n    \"vlan_interface_dhcp_relay_vrf_11_1\",\n    \"vlan_interface_dhcp_relay_src_lo_11_1\",\n    \"vlan_interface_ipv6_link_local_11_1\",\n    \"vlan_interface_fwd_mode_11_1\",\n]\n\n# policy templates that apply to spines only\nspine_templates_list =[\n    \"evpn_bgp_rr\",\n    \"v6_evpn_bgp_rr\",\n    \"evpn_bgp_rr_send_comm_both\",\n    \"mvpn_bgp\",\n    \"mvpn_bgp_rr_11_1\",\n    \"base_feature_spine_upg\",\n    \"bgp_cluster_id\",\n    #\"interface_qos_service_policy\",\n    ]\n\n# policy templates that apply to vPC leaves only\nleaf_vpc_templates_list =[\n    \"base_vpc_domain_11_1\",\n    \"vpc_peer_switch\",\n    \"vpc_nve_loopback\",\n    \"vpc_peer_link_po_interface\",\n    \"vpc_peer_link_member_interface\",\n    ]\n\nleaf_vpc_host_templates_list =[\n    \"port_channel_vpc_id_11_1\"\n    ]\n\nleaf_vpc_additional_templates_list =[\n    \"vpc_domain_mgmt\",\n    \"vpc_domain_mgmt_no_src_11_1\",\n    \"vpc_domain_ipv6_nd_11_1\",\n    \"vpc_delay_restore\",\n    \"vpc_domain_autorecovery\",\n    \"vpc_nve_loopback_with_tag_11_1\",\n    \"vpc_domain_autorecovery_default\",\n    \"vpc_domain_virtual_peerlink_dscp\"\n    ]\n\n# shut/no shut policy templates that apply to all.\n# These need to be at the end of the lists.. the subsequent code assumes this\ninterface_shut_no_shut_templates_list =[\n    \"shut_interface_force\",\n    \"shut_interface\",\n    \"no_shut_interface\"\n    ]\n\nfabric_bgp_tmpl_type, fabric_bgp_tmpl_name = \"\", \"\"\n\n# FEX policy templates that apply to leaves only\nleaf_fex_templates_list =[\n    \"base_fex\",\n    \"base_fex_N7k\",\n    \"enable_fex\",\n    \"trunk_interface_fex\",\n    \"access_interface_fex\",\n    \"fex_port_channel_interface\",\n    \"fex_po_member_interface\"\n]\n\n# policy templates that apply to agg devices\nagg_templates_list = [\n    \"keychain\",\n    \"pre_config\",\n    \"nfm_switch_user\",\n    \"ssh_key_rsa\",\n    \"host_11_1\",\n    \"switchnm_11_1\",\n    \"v4_mgmt_default_gateway\",\n    \"v6_mgmt_default_gateway_11_1\",\n    \"nfm_switch_snmp_user\",\n    \"base_feature_vpc\",\n    \"feature_lacp\",\n    \"feature_pim\",\n    \"feature_pbr\",\n    \"feature_interface_vlan_11_1\",\n    \"feature_dhcp\",\n    \"feature_bgp\",\n    \"base_bgp\",\n    #\"base_bgp_external\",\n    \"base_ospf_auth\",\n    \"base_pim_asm_11_1\",\n    \"base_pim_bidir_11_1\",\n    \"base_dhcp\",\n    \"dnsList\",\n    \"dns-vrfList\",\n    \"ntp_server\",\n    \"ntp_prefer_server\",\n    \"clock_protocol\",\n    \"clock_summertime\",\n    \"clock_timezone\",\n    \"syslog_server\",\n    \"syslog_server_sev\",\n    \"syslog_server_vrf\",\n    \"syslog_server_vrf_no_sev\",\n    \"copp_policy\",\n    \"vpc_domain_l3_pka_vrf_11_1\",\n    \"feature_nxapi\",\n    \"nxapi_http_port\",\n    \"nxapi_https_port\",\n    \"route_map\",\n    \"banner\",\n    \"system_jumbomtu\",\n    \"base_feature_agg\",\n    \"eth_cfs\",\n    \"feature_ospf\",\n    \"base_ospf\",\n    \"router_ospf\",\n    \"router_ospfv3\",\n    \"extra_config_leaf\",\n    \"feature_tacacs\",\n    \"vlan_name_11_1\",\n    \"vlan_netflow\",\n    \"vrf_desc_11_1\",\n    \"vrf_ospf_auth\",\n    \"vrf_af\",\n    #\"spanning_tree_classic\",\n    #\"spanning_tree_classic_config\",\n    \"base_vpc_domain_11_1\",\n    \"vpc_peer_link_po_interface\",\n    \"vpc_peer_link_member_interface\",\n    \"port_channel_vpc_id_11_1\",\n    \"vpc_domain_mgmt\",\n    \"vpc_domain_mgmt_no_src_11_1\",\n    \"vpc_domain_ipv6_nd_11_1\",\n    \"vpc_delay_restore\",\n    \"vpc_domain_autorecovery\",\n    \"vpc_domain_autorecovery_default\",\n    \"bgp_overlay_vrf_ipv4_max_bgp_paths_11_1\",\n    \"bgp_overlay_vrf_ipv6_max_bgp_paths_11_1\",    \n    ]\n\n\nECL_interface_templates_list = [\n    \"interface_ipv4_11_1\",\n    \"interface_ipv6_11_1\",\n    \"routed_interface_no_ip_redirects\",\n    #\"vlan_interface_sec_ip_v4_11_1\",\n    #\"vlan_interface_sec_ip_v4_tag_11_1\",\n    \"vlan_interface_dhcp_relay_11_1\",\n    \"vlan_interface_dhcp_relay_vrf_11_1\",\n    \"interface_ipv4_tag_11_1\",\n    \"interface_ipv6_tag_11_1\",\n    \"routed_interface\",\n    \"eth_sub_interface\",\n    \"interface_subintf\",\n    \"eth_sub_interface_tag\",\n    \"p2p_routed_interface\",\n    \"p2p_routed_interface_tag\",\n    \"interface_vrf\",\n    \"mgmt_interface_11_1\",\n    \"breakout_interface\",\n    \"cdp_disable_interface_11_1\",\n    \"trunk_interface\",\n    \"access_interface\",\n    \"port_channel_access_interface\",\n    \"port_channel_trunk_interface_11_1\",\n    \"dot1q_tunnel_interface\",\n    \"port_channel_dot1q_tunnel_interface\",\n    \"bpduguard_disable\",\n    \"bpduguard_enable\",\n    \"porttype_fast_trunk\",\n    \"porttype_fast_enable\",\n    \"access_vlan\",\n    \"native_vlan\",\n    \"interface_desc\",\n    \"interface_mtu\",\n    \"interface_speed\",\n    \"interface_no_nego_auto\",\n    \"interface_orphan_port\",\n    \"port_channel_mode_on\",\n    \"port_channel_mode\",\n    \"port_channel_routed_interface\",\n    \"ospf_interface_auth\",\n    \"ospf_interface_11_1\",\n    \"v6_ospf_interface\",\n]\n\n'''\ninterface_agg_templates_list = [\n    \"int_vpc_uplink_access\",\n    \"int_vpc_uplink_access_po\",\n    \"int_vpc_uplink_access_po_member\",  \n    ]\n'''\n\ndef getVpcTemplateList(isNotTahoe):\n    templatesList = []\n    templatesList.extend(leaf_vpc_templates_list)\n    templatesList.extend(leaf_vpc_host_templates_list)\n    templatesList.extend(leaf_vpc_additional_templates_list)\n\n    return templatesList\n\ndef getVpcMandatoryTemplateList(isNotTahoe):\n    templatesList =[\n        \"vpc_nve_loopback\",\n        \"vpc_peer_link_po_interface\",\n        \"vpc_peer_link_member_interface\",\n        \"port_channel_vpc_id_11_1\"\n        ]\n    return templatesList\n\ndef getECLVpcMandatoryTemplateList(isNotTahoe):\n    templatesList =[\n        \"vpc_peer_link_po_interface\",\n        \"vpc_peer_link_member_interface\",\n        \"port_channel_vpc_id_11_1\"\n        ]\n    return templatesList\n\n\ndef getTemplateList(migrModeStr, isNotTahoe, isExternalFab, isSpineOrAgg, fabricTechnology):\n    includeCommon = True\n    templatesList = []\n    if migrModeStr == \"reSync\":\n        templatesList.extend([\"system_jumbomtu\", \"vpc_pair_vpc_domain_vrf_mgmt\",\n                              \"vpc_pair_vpc_domain_non_default_vrf\", \"vpc_peer_link_po_interface\",\n                              \"vpc_pair_vpc_domain_vrf_mgmt_no_hold\", \"vpc_pair_vpc_domain_non_default_vrf_no_hold\"])\n        templatesList.extend(interface_templates_list)\n        templatesList.extend(leaf_vpc_host_templates_list)\n        templatesList.extend(interface_leaf_templates_list)\n        if not isExternalFab:\n            templatesList.extend(interface_leaf_overlay_templates_list)\n        templatesList.extend(interface_v4_underlay_templates_list)\n        templatesList.extend(interface_v6_underlay_templates_list)\n    elif migrModeStr == \"changeIP\":\n        includeCommon = False\n        # we are interested in the vrf context management and mgmt0 intf\n        templatesList.extend([\"cdp_disable_interface_11_1\", \"interface_desc\", \"v4_mgmt_default_gateway\",\n                              \"dns-vrfList\", \"interface_speed\", \"interface_ipv4_11_1\", \"interface_ipv6_11_1\"])\n    else:\n        if fabricTechnology != \"VLANFabric\":\n            templatesList.extend(common_templates_list)\n            if Util.exe(FabricWrapper.isFeatureEnabled(\"nxcloud\")):\n                fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n                ALLOW_NXC = fabricSettings.get(\"ALLOW_NXC\", \"false\")\n                if ALLOW_NXC == \"true\":\n                    templatesList.extend(nxcloud_templates_list)\n            templatesList.extend(interface_templates_list)\n            if UNDERLAY_IS_V6 == \"false\":\n                templatesList.extend(v4_underlay_templates_list)\n                templatesList.extend(interface_v4_underlay_templates_list)\n            else:\n                templatesList.extend(v6_underlay_templates_list)\n                templatesList.extend(interface_v6_underlay_templates_list)\n            templatesList.extend(spine_templates_list)\n            templatesList.extend(leaf_templates_list)\n            templatesList.extend(interface_leaf_templates_list)\n    \n            if not isSpineOrAgg:\n                # we can move more of the leaf specific policies here, but, the existing lists are not accurate\n                # will keep them as-is\n                templatesList.extend(leaf_overlay_templates_list)\n                templatesList.extend(interface_leaf_overlay_templates_list)\n    \n            templatesList.extend(getVpcTemplateList(isNotTahoe))\n        else:    \n            if Util.exe(FabricWrapper.isFeatureEnabled(\"nxcloud\")):\n                fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n                ALLOW_NXC = fabricSettings.get(\"ALLOW_NXC\", \"false\")\n                if ALLOW_NXC == \"true\":\n                    templatesList.extend(nxcloud_templates_list)\n            templatesList.extend(ECL_interface_templates_list)\n            templatesList.extend(agg_templates_list)\n            #templatesList.extend(interface_agg_templates_list)\n\n    if includeCommon:\n        # common lists\n        templatesList.extend(leaf_fex_templates_list)\n    # this must be at the end\n    templatesList.extend(interface_shut_no_shut_templates_list)\n    return templatesList\n\ndef IP2Int(ip):\n    o = map(int, ip.split('.'))\n    res = (16777216 * o[0]) + (65536 * o[1]) + (256 * o[2]) + o[3]\n    return res\n\ndef Int2IP(ipnum):\n    o1 = int(ipnum / 16777216) % 256\n    o2 = int(ipnum / 65536) % 256\n    o3 = int(ipnum / 256) % 256\n    o4 = int(ipnum) % 256\n    return '%(o1)s.%(o2)s.%(o3)s.%(o4)s' % locals()\n\n# ipAddr and prefix are strings\ndef getSubnetStringWithPrefix(ipAddr, prefix):\n    # calculate the fabric interface subnet pool\n    localIPNetInt = IP2Int(ipAddr)\n    netMaskInt = (0xFFFFFFFF << (32 - int(prefix)))\n    netInt = localIPNetInt & netMaskInt\n    netIntStr = Int2IP(netInt)\n    Wrapper.print(\"ipAddr [%s/%s] netMaskInt [%s] netInt [%s]\" % \n                        (ipAddr, prefix, Int2IP(netMaskInt), netIntStr))\n\n    return (netIntStr + \"/\" +prefix)\n\n#TODO:Move this to fabric utility to avoid duplication\ndef ipv6BitOps(a1, a2, operator=0):\n    a1 = struct.unpack('4I', a1)\n    a2 = struct.unpack('4I', a2)\n    fop = [ lambda x,y: x | y,\n            lambda x,y: x & y,\n            lambda x,y: x ^ y\n          ]  \n    ret = map(fop[operator%len(fop)], a1, a2)\n    t = ''.join(map(lambda x: struct.pack('I', x), ret))\n    return t\n    \ndef ipV6AndOps(a1, a2):\n    return ipv6BitOps(a1, a2, 1)\n\ndef getV6MaskFromPrefix(m):\n    m = int(m)\n    t = []\n    for i in xrange(0, 4):\n        t.append(max(0, 2**32  - 2**(32-min(32, m))))\n        m -= 32\n    return ''.join(map(lambda x: struct.pack('!I', x), t))\n\ndef getV6PToN(ip):\n    if not ip:\n        return \"\"\n    return socket.inet_pton(socket.AF_INET6, ip) \n\ndef getV6NToP(nb):\n    return socket.inet_ntop(socket.AF_INET6, nb) \n\ndef getV6NetworkFromCIDR(ip, prefix):\n    mask = getV6MaskFromPrefix(prefix)\n    ptonIP = getV6PToN(ip)\n    return socket.inet_ntop(socket.AF_INET6, ipV6AndOps(ptonIP, mask))\n\ndef isValidV6IpAddr(addr):\n    try:\n        socket.inet_pton(socket.AF_INET6, addr)\n        return True\n    except socket.error:\n        return False\n\n# utility API to return a list of integers from an integer range string\n# input: \"1-3,5,7,10-12\"\n# output: [1, 2, 3, 5, 7, 10, 11, 12]\ndef getIntegerRange(rangeStr):\n    return sum(((list(range(*[int(j) + k for k,j in enumerate(i.split('-'))]))\n                        if '-' in i else [int(i)]) for i in rangeStr.split(',')), [])\n\ndef getTemplateMatchResults(matchResults, templateName):\n    matchRes = matchResults.get(templateName, None)\n    #Wrapper.print(\"Template [%s] matchRes [%s]\" % (templateName, matchRes))\n    if (matchRes != None) and (len(matchRes) == 0):\n        # treat this as if the template does not exist\n        #Wrapper.print(\"Template [%s]. # of matches = [%d]\" % \n        #                        (templateName, len(matchRes)))\n        matchRes = None\n\n    return matchRes\n\ndef getIntfEntityName(nvPair, templateName):\n    entityName = None\n    # need to get the interface name\n    try:\n        entityName = nvPair[\"INTF_NAME\"]\n    except:\n        #Wrapper.print (\"Error - Could not get INTF_NAME value for template [%s]\" % templateName)\n        # check some special cases where the interface variable is not 'INTF_NAME'\n        if (templateName == \"mgmt_interface_11_1\"):\n            entityName = \"mgmt0\"\n        elif (templateName == \"vlan_interface\" or templateName == \"v6_vlan_interface\" or templateName == \"v6_vlan_interface_link_local\" or templateName == \"nve_advertise_vmac\"):\n            entityName = nvPair[\"INTF_NAME\"]\n        elif (templateName == \"fex_port_channel_interface\"):\n            entityName = \"port-channel\" + nvPair[\"PCID\"]\n        else:\n            # not sure how to handle this case\n            Wrapper.print (\"Error - Could not get INTF_NAME value\")\n    return entityName\n\ndef getEntityName(devSerial, entityType, nvPair, templateName):\n    entityName = None\n    if (entityType == \"INTERFACE\"):\n        entityName = getIntfEntityName(nvPair, templateName)\n    else:\n        # for 'SWITCH' entity type, the entity name is \"SWITCH\"\n        entityName = \"SWITCH\"\n\n    return entityName\n\ndef getEType(templateName):\n    eType = \"SWITCH\"\n    try:\n        eType = template_metadata[templateName][\"eType\"]\n    except:\n        pass\n    return eType\n\ndef getSrc(templateName):\n    src = \"UNDERLAY\"\n    try:\n        src = template_metadata[templateName][\"source\"]\n    except:\n        pass\n    return src\n\ndef getPrio(templateName):\n    prio = 500\n    try:\n        prio = template_metadata[templateName][\"prio\"]\n    except:\n        pass\n    return prio\n\n#get loopback interface string \ndef getLbIntfName(type):\n    if type == \"bgp\":\n        return \"loopback\" + BGP_LB_ID\n    elif type == \"nve\":\n        return \"loopback\" + NVE_LB_ID\n    elif type == \"anycast\":\n        return \"loopback\" + ANYCAST_LB_ID\n    elif type == \"rp\":\n        return \"loopback\" + RP_LB_ID\n    elif type == \"phantom_rp1\":\n        return \"loopback\" + PHANTOM_RP_LB_ID1\n    elif type == \"phantom_rp2\":\n        return \"loopback\" + PHANTOM_RP_LB_ID2\n\ndef createPTI(devSerial, nvPair, templateName, entityName, ptiSource, rmId, isUpdate=True):\n    funcName = sys._getframe(0).f_code.co_name  # used in below error\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    if (entityName == None):\n        # invalid name\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":createPTI\"),\n           \"Internal failure trying to create policy [%s] - entity name not provided\" % (templateName), devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n\n    entityType = getEType(templateName)\n    ptiPrio = getPrio(templateName)\n\n    # get ready to create the PTI\n    if (rmId == -1):\n        if isUpdate:\n            Util.exe(PTIWrapper.createOrUpdate(devSerial, entityType, entityName, ptiSource,\n                                       ptiPrio, templateName, nvPair))\n        else:\n            Util.exe(PTIWrapper.create(devSerial, entityType, entityName, ptiSource,\n                                       ptiPrio, templateName, nvPair))\n    else:\n        if isUpdate:\n            Util.exe(PTIWrapper.createOrUpdate(devSerial, entityType, entityName, ptiSource,\n                                       ptiPrio, rmId, templateName, nvPair))\n        else:\n            Util.exe(PTIWrapper.create(devSerial, entityType, entityName, ptiSource,\n                                       ptiPrio, rmId, templateName, nvPair))\n\n    \"\"\"\n    MsgStr = (\"[%s]. Entity/Name [%s/%s] Prio = %d NVPairs = %s\" % \n               (templateName, entityType, entityName, ptiPrio, nvPair))\n    Wrapper.print(\"PTI Created - [%s]\" % MsgStr)\n    \"\"\"\n    return respObj\n\ndef createPtis(devSerial, nvPairList, templateName, isUpdate=True):\n    for nvPair in nvPairList:\n        entityName = getEntityName(devSerial, getEType(templateName), nvPair, templateName)\n        createPTI(devSerial, nvPair, templateName, entityName, getSrc(templateName), -1, isUpdate)\n\n#a call from outside the template to create matched ptis\ndef createMatchedPtisExternal(inputParams):\n    createMatchedPtis(inputParams[\"devSerial\"],inputParams[\"matchResult\"],\n                      inputParams[\"templateName\"])\n\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    return respObj\n\ndef createMatchedPtis(devSerial, matchResult, templateName, isUpdate=True):\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        createPtis(devSerial, nvPairList, templateName, isUpdate)\n\ndef deleteAndCreateMatchedPtis(devSerial, matchResult, templateName):\n    Wrapper.print(\"deleteAndCreateMatchedPtis - devSerial [%s] templateName [%s]\" % \n                        (devSerial, templateName))\n    entityType = getEType(templateName)\n    entityName = getEntityName(devSerial, entityType, None, templateName)\n\n    # delete existing PTIs\n    PTIWrapper.delete(devSerial, entityType, entityName, getSrc(templateName), templateName)\n        \n    # create new PTIs\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        createPtis(devSerial, nvPairList, templateName, False)\n\ndef getIntfMatchMultiNvPairs(matchResult, intfName, templateList):\n    matches = {}\n\n    for templateName in templateList:\n        # get the match results for the template\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            # need to look for the nvPair that matches the intf\n            for nvPair in nvPairList:\n                interfaceName = getIntfEntityName(nvPair, templateName)\n                if ((interfaceName != None) and (interfaceName == intfName)):\n                    # this is of interest to us\n                    if templateName not in matches:\n                        matches[templateName] = []\n                    matches[templateName].append(nvPair)\n        #else:\n        #    Wrapper.print(\"getIntfMatchMultiNvPairs: No matches for [%s] on intf [%s]\" % \n        #                (templateName, intfName))\n    return matches\n\ndef getIntfMatchNvPairs(matchResult, intfName, templateList):\n    matches = {}\n\n    for templateName in templateList:\n        # get the match results for the template\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            # need to look for the nvPair that matches the intf\n            for nvPair in nvPairList:\n                interfaceName = getIntfEntityName(nvPair, templateName)\n                if ((interfaceName != None) and (interfaceName == intfName)):\n                    # we found what we are looking for\n                    matches.update({templateName : nvPair})\n                    break\n        #else:\n        #    Wrapper.print(\"getIntfMatchNvPairs: No matches for [%s] on intf [%s]\" % \n        #                (templateName, intfName))\n    return matches\n\ndef isIntfProcessed(intfMatchResult):\n    isProcessed = False\n    try:\n        isProcessed = intfMatchResult[\"isProcessed\"]\n    except:\n        pass\n    return isProcessed\n\ndef getFabErrEntity(fnName, entityName=None):\n    if entityName:\n        return fnName + \":\" + entityName\n    else:\n        return fnName\n\ndef isIpv6Addr(ip):\n    if \":\" in ip:\n        return True\n    else:\n        return False\n\ndef getVlanList(vlanRange):\n    vlanList = vlanRange.split(\",\")\n    allVlanList = []\n    for vlan in vlanList:\n        if \"-\" in vlan:\n            vRange = filter(None,vlan.split(\"-\"))\n            if len(vRange) == 2:\n                start = int(vRange[0])\n                end = int(vRange[1]) + 1 \n                for i in range(start, end):\n                    allVlanList.append(str(i))\n        else:\n            allVlanList.append(vlan)\n    return filter(None,allVlanList)\n\ndef putSwitchIntoBfMigrMode(fabricName, devSerial):\n    setMigrationState(fabricName, devSerial, {\"POST_ADD\":\"false\", \"UNDERLAY\" : \"true\", \"OVERLAY\" : \"false\"}, \"Brownfield Add\")\n\ndef putSwitchIntoChangeDiscIPAddressMigrMode(fabricName, devSerial):\n    setMigrationState(fabricName, devSerial, {\"CHANGE_DISC_IP\":\"true\"}, \"Discovery IP Address Change\")\n\ndef putSwitchIntoOverlayMigrMode(fabricName, devSerial):\n    formattedName = getFormattedSwitchName(devSerial)\n    Wrapper.print(\"=======ACTION: FAB [%s]. Put switch [%s] into overlay migration mode\" % (fabricName, formattedName))\n    ptis = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\",\"\", \"switch_migration_state\"))\n    for pti in ptis:\n        nvPairs = pti.getNvPairs()\n        if nvPairs:\n            Wrapper.print(\"putSwitchIntoOverlayMigrMode: Switch [%s] Migration [%s] NvPair = [%s]\" % \n                                    (devSerial, formattedName, nvPairs))\n            newNvPairs = copy.deepcopy(nvPairs)\n            newNvPairs[\"OVERLAY\"] = \"true\"\n            Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, \"switch_migration_state\", newNvPairs))\n        break\n\ndef takeSwitchOutOfUnderlayMigrMode(fabricName, devSerial):\n    formattedName = getFormattedSwitchName(devSerial)\n    Wrapper.print(\"=======ACTION: FAB [%s]. Take switch [%s] out of underlay migration mode\" % (fabricName, formattedName))\n    ptis = Util.getSwitchMigrationModePtis(devSerial)\n    for pti in ptis:\n        nvPairs = pti.getNvPairs()\n        # assume only underlay migration needs to be done\n        delPti = True\n        if nvPairs:\n            Wrapper.print(\"takeSwitchOutOfUnderlayMigrMode: Switch [%s] Migration [%s] NvPair = [%s]\" % \n                                    (devSerial, formattedName, nvPairs))\n            if nvPairs.get(\"OVERLAY\", \"false\") == \"true\":\n                # overlay still needs to be migrated\n                newNvPairs = copy.deepcopy(nvPairs)\n                newNvPairs[\"UNDERLAY\"] = \"false\"\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, \"switch_migration_state\", newNvPairs))\n                delPti = False\n        if delPti:\n            Util.exe(PTIWrapper.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_migration_state\"))\n        break\n\n# checks if the switch is in underlay migration mode\ndef isSwitchInUnderlayMigration(devSerial):\n    #   \"UNDERLAY\" : the value indicates the following:\n    #                   > not present or \"true\" - underlay migration not completed\n    #                   > \"false\"  - underlay migration not completed\n    retVal = False\n    policies = Util.getSwitchMigrationModePtis(devSerial)\n    if len(policies) > 0:\n        retVal = True\n        for pti in policies:\n            nvPairs = pti.getNvPairs()\n            if nvPairs:\n                Wrapper.print(\"isSwitchInUnderlayMigration: Switch [%s] Migration [%s] NvPair = [%s]\" % \n                                        (devSerial, Util.getMigrationDetailString(nvPairs), nvPairs))\n                if nvPairs.get(\"UNDERLAY\", \"true\") == \"false\":\n                    retVal = False\n                break\n    return retVal\n\n# checks if the switch is in underlay migration mode\ndef isSwitchInOverlayMigration(devSerial):\n    #   \"OVERLAY\" : - This will be ignored if POST_ADD = \"true\"\n    #                 if present, then the value indicates the following:\n    #                   > \"false\" - overlay migration completed\n    #                   > \"true\"  - overlay migration not completed\n    retVal = False\n    policies = Util.getSwitchMigrationModePtis(devSerial)\n    for pti in policies:\n        nvPairs = pti.getNvPairs()\n        if nvPairs:\n            Wrapper.print(\"isSwitchInOverlayMigration: Switch [%s] Migration [%s] NvPair = [%s]\" % \n                                    (devSerial, Util.getMigrationDetailString(nvPairs), nvPairs))\n            if nvPairs.get(\"OVERLAY\", \"false\") == \"true\":\n                retVal = True\n            break\n    return retVal\n\ndef delMigrationState(FABRIC_NAME, devSerial):\n    Wrapper.print(\"=======ACTION: FAB [%s]. Switch [%s] - Take out of migration mode\" % (FABRIC_NAME, devSerial))\n    PTIWrapper.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_migration_state\")\n\n#\n# The 'switch_migration_state' PTI has the following variables:\n#  {\n#   \"POST_ADD\" : - if present, then the value indicates the following:\n#                   > \"true\"  - greenfield add (preserveConfig = no)\n#                   > \"false\" - brownfiled add (preserveConfig = yes) - import underlay & overlay\n#                - if not present, then it is a upgrade case - import underlay only\n#   \"UNDERLAY\" : the value indicates the following:\n#                   > not present or \"true\" - underlay migration not completed\n#                   > \"false\"  - underlay migration completed\n#   \"OVERLAY\" : - This will be ignored if POST_ADD = \"true\"\n#                 if present, then the value indicates the following:\n#                   > \"false\" - overlay migration completed\n#                   > \"true\"  - overlay migration not completed\n#  }\n#\ndef setMigrationState(FABRIC_NAME, devSerial, nvPair, desc=\"\"):\n    Wrapper.print(\"=======ACTION: FAB [%s]. Switch [%s] - Move into migration mode [%s] NVPair = [%s]\" % \\\n        (FABRIC_NAME, devSerial, Util.getMigrationDetailString(nvPair), nvPair))\n    # check if PTI exists\n    ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_migration_state\"))\n    if len(ptiList) > 0:\n        # update the first instance\n        Util.exe(PTIWrapper.updateInstance(ptiList[0].getPolicyId(), nvPair))\n    else:\n        # create a new policy with the provided description string\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, \"switch_migration_state\", nvPair, desc))\n\ndef isModelN7k(topologyDataObj, sn):\n    model = topologyDataObj.getSwitchModel(sn)\n    if model.startswith(\"N7\") or \":\" in sn:\n      return True\n    else:\n      return False\n      \ndef switchCleanupWithoutReloadN7k(devSerial, dcnmUser):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    sshObj = None\n    Wrapper.print(\"%s(): Entering switch cleanup for : [%s]\" % (funcName, devSerial))\n    try:\n        sshObj = Util.exe(InventoryWrapper.getSSHConnection(devSerial, dcnmUser))\n    except Exception as e:\n        Wrapper.print(\"%s(): Failed to get SSH connection for : [%s] [%s]. Will skip\" %\n                      (funcName, devSerial, str(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":SSH\"),\n                               \"Failed to get SSH connection for switch cleanup. \"\n                               \"Please try again Recalculate & Deploy\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n    try:\n        sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n\n        Wrapper.print(\"%s(): delete older files = [%s]\" % (funcName, devSerial))\n        firstCmdOut = sshObj.send('''echo 'delete EASY-SW-RUNNING-CONFIG' | vsh''', sshConnReadTimeout)\n        firstCmd = '''echo 'delete EASY-SW-RUNNING-CONFIG' | vsh'''\n        Wrapper.print(\"%s(): [%s] Attempting to send first command [%s] response %s.\" % (funcName, devSerial, firstCmd, firstCmdOut))\n        if \"Permission denied\" in firstCmdOut:\n            errorMsg = (\"Switch [%s]: Insufficient privileges to read switch configuration. \"\n                        \"Please change the discovery user role to have network-admin privileges and \"\n                        \"retry Recalculate & Deploy.\" % devSerial)\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n        sshObj.send('''echo 'delete INTF_BRIEF_CONFIG' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): collect run = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show run > EASY-SW-RUNNING-CONFIG''', sshConnReadTimeout)\n        cmd = '''show file bootflash:EASY-SW-RUNNING-CONFIG | section '^interface mgmt0' '''\n        mgmtCmdOut = sshObj.send(cmd, sshConnReadTimeout)\n        if (len(mgmtCmdOut) == 0):\n            noSwitchDiskSpaceError(devSerial, respObj)\n            return respObj\n\n        Wrapper.print(\"%s(): collect int brief = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show int br > INTF_BRIEF_CONFIG''', sshConnReadTimeout)\n\n        # clean the switch for greenfield import with following\n        Wrapper.print(\"%s(): Cleaning config profiles = [%s]\" % (funcName, devSerial))\n        Wrapper.print(\"%s(): no apply for profiles = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc apply | sed 's/apply/no apply/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): no configure for profiles = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc 'configure profile' | sed 's/configure profile/no configure profile/g' | vsh''', sshConnReadTimeout)\n        #Wrapper.print(\"%s(): remove ppm db = [%s]\" % (funcName, devSerial))\n        #sshObj.send('''show system internal config-profile config database | ex 'config attributes:' |  awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n\n        Wrapper.print(\"%s(): cleaning fex config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"feature-set fex\" | ex \"install feature-set fex\" | grep -v allow | sort | sed 's/feature-set fex/no feature-set fex/g' | vsh''', sshConnReadTimeout)\n\n        Wrapper.print(\"%s(): cleaning system jumbo mtu config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system jumbomtu\" | sed 's/system jumbomtu/no system jumbomtu/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning access list config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"ip access-list\" | sed 's/ip access-list/no ip access-list/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning route-map config = [%s]\" % (funcName, devSerial))\n        #TODO:Needs to be enhanced to only use route-map definition rather than every line that has route-maps?\n        sshObj.send('''show run rpm | inc route-map | sort | sed 's/route-map/no route-map/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning vpc peer link port-channel config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"interface port-channel\" | sort | sed 's/interface port-channel/no interface port-channel/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning features = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc feature | ex tacacs+ | grep -v allow | sort | sed 's/feature/no feature/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning VRFs = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"vrf context \" | ex management | sed 's/vrf context/no vrf context/g' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'no nv overlay evpn' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"cfs\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"snmp-server host\" | grep traps | sed 's/snmp-server host/no snmp-server host/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning loopback = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | grep Lo | cut -c -6 | sed 's/Lo/no interface Lo/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning port channels = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG  | grep Po | ex Port-channel | ex Port | cut -c -6 | sed 's/Po/no interface Po/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning Vlans = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"vlan 1\" | sed 's/vlan/no vlan/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning all Ethernet interfaces = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | grep Eth | grep -v Ethernet | cut -d ' ' -f 1 | sed 's/Eth/default interface Eth/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Unshutting Ethernet interfaces = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | grep Eth | grep -v Ethernet | cut -d ' ' -f 1 | sed 's/Eth/interface Eth/g' | sed 's/$/ ; no shutdown/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): remove switch from maintenance mode = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system mode maintenance\" | sed 's/system mode maintenance/no system mode maintenance non-interactive/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning completed for [%s]\" % (funcName, devSerial))\n        maintenanceMode = True\n        for i in range(10):\n            Wrapper.print(\"%s(): Check if switch [%s] is out of maintenance mode\" % (funcName, devSerial))\n            cmd = \"show system mode | grep 'System Mode: Maintenance'\"\n            cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n            if (len(cmdOut) == 0):\n                maintenanceMode = False\n                Wrapper.print(\"%s(): switch [%s] is out of maintenance mode\" % (funcName, devSerial))\n                break\n            else:\n                Wrapper.print(\"%s(): sleeping [count %s] for 10 seconds to get the switch out of maintenance mode = [%s]\" % (funcName, (i+1), devSerial))\n                time.sleep(10)\n        if maintenanceMode == True:\n            sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system mode maintenance\" | sed 's/system mode maintenance/no system mode maintenance non-interactive/g' | vsh''', sshConnReadTimeout)\n            cmd = \"show system mode | grep 'System Mode: Maintenance'\"\n            cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n            if (len(cmdOut) != 0):\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                                   \"Please get the switch out of maintenance mode\", devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"configure maintenance profile maintenance-mode\" | sed 's/configure maintenance profile maintenance-mode/no configure maintenance profile maintenance-mode/g' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"configure maintenance profile normal-mode\" | sed 's/configure maintenance profile normal-mode/no configure maintenance profile normal-mode/g' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'delete MIN-EASY-SW-RUNNING-CONFIG' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'delete ef-minimum-config' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show run > MIN-EASY-SW-RUNNING-CONFIG''', sshConnReadTimeout)\n        #Skip the boot variable and tcam checks for N7k platforms\n\n        # clean the switch for greenfield import, keep the minimum config\n        # as the switch will go through reload\n        Wrapper.print(\"%s(): Replacing config for [%s]\" % (funcName, devSerial))\n        sshObj.send('''show run | ex fex >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep hostname >>  ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep switchname >>  ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'no password' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep username >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'ip domain-lookup' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run radius >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run tacacs+ >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run aaa >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'interface breakout module' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'snmp-server user' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run aaa >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep switch-packets >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''echo 'vlan 1' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run vrf management | begin 'vrf context' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run interface mgmt0 | b version | exclude version >> ef-minimum-config''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): minimum config replace started = [%s]\" % (funcName, devSerial))\n        sshObj.send('''echo 'configure replace bootflash:ef-minimum-config' | vsh ''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): minimum config replace completed = [%s]\" % (funcName, devSerial))\n        Wrapper.print(\"%s(): Delete temporary files completed = [%s]\" % (funcName, devSerial))\n        cmd = \"echo 'copy running-config startup-config'\"\n        cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n    except Exception as e:\n        Wrapper.print(\"%s(): Exception!!! Switch [%s] cleanup, exception[%s] \" % (funcName, devSerial, repr(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                               \"Error cleaning switch configuration. \"\n                               \"Please retry Recalculate & Deploy.\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n    finally:\n        Wrapper.print(\"%s(): Closing SSH connection %s\"%(funcName, devSerial))\n        sshObj.close()\n        sshObj = None\n        Wrapper.print(\"%s(): Exiting switch cleanup for without reload: [%s]\" % (funcName, devSerial))\n    return respObj\n\ndef switchCleanupWithoutReload(devSerial, dcnmUser):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    sshObj = None\n    Wrapper.print(\"%s(): Entering switch cleanup for : [%s]\" % (funcName, devSerial))\n    try:\n        sshObj = Util.exe(InventoryWrapper.getSSHConnection(devSerial, dcnmUser))\n    except Exception as e:\n        Wrapper.print(\"%s(): Failed to get SSH connection for : [%s] [%s]. Will skip\" %\n                      (funcName, devSerial, str(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":SSH\"),\n                               \"Failed to get SSH connection for switch cleanup. \"\n                               \"Please try again Recalculate & Deploy\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n    try:\n        sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n\n        Wrapper.print(\"%s(): delete older files = [%s]\" % (funcName, devSerial))\n        firstCmdOut = sshObj.send('''echo 'delete EASY-SW-RUNNING-CONFIG' | vsh''', sshConnReadTimeout)\n        firstCmd = '''echo 'delete EASY-SW-RUNNING-CONFIG' | vsh'''\n        Wrapper.print(\"%s(): [%s] Attempting to send first command [%s] response %s.\" % (funcName, devSerial, firstCmd, firstCmdOut))\n        if \"Permission denied\" in firstCmdOut:\n            errorMsg = (\"Switch [%s]: Insufficient privileges to read switch configuration. \"\n                        \"Please change the discovery user role to have network-admin privileges and \"\n                        \"retry Recalculate & Deploy.\" % devSerial)\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n        sshObj.send('''echo 'delete INTF_BRIEF_CONFIG' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): collect run = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show run > EASY-SW-RUNNING-CONFIG''', sshConnReadTimeout)\n        cmd = '''show file bootflash:EASY-SW-RUNNING-CONFIG | section '^interface mgmt0' '''\n        mgmtCmdOut = sshObj.send(cmd, sshConnReadTimeout)\n        if (len(mgmtCmdOut) == 0):\n            noSwitchDiskSpaceError(devSerial, respObj)\n            return respObj\n\n        Wrapper.print(\"%s(): collect int brief = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show int br > INTF_BRIEF_CONFIG''', sshConnReadTimeout)\n\n        # clean the switch for greenfield import with following\n        Wrapper.print(\"%s(): Cleaning config profiles = [%s]\" % (funcName, devSerial))\n        Wrapper.print(\"%s(): no apply for profiles = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc apply | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): no configure for profiles = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc 'configure profile' | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): remove ppm db = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show system internal config-profile config database | ex 'config attributes:' |  awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n\n        Wrapper.print(\"%s(): cleaning fex config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"feature-set fex\" | ex \"install feature-set fex\" | grep -v allow | sort | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n\n        Wrapper.print(\"%s(): cleaning system jumbo mtu config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system jumbomtu\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning access list config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"ip access-list\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning route-map config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show run rpm | inc route-map | sort | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning vpc peer link port-channel config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"interface port-channel\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning features = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc feature | ex tacacs+ | grep -v allow | sort | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'no nv overlay evpn' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"cfs\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"snmp-server host\" | grep traps | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning loopback = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | grep Lo | cut -c -6 | awk '{print \"no interface \"$1}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning port channels = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG  | grep Po | ex Port-channel | ex Port | cut -c -6 | awk '{print \"no interface \"$1}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning infra-vlans = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"infra-vlan\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning Vlans = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"vlan 1\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning access interfaces = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | inc \"access\" | grep \"Eth\" | awk '{print \"interface \" $1 \" ; shut ; no description ; no switchport  ; no shut\"}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning routed interfaces = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | inc \"routed\" | grep \"Eth\" | awk '{print \"interface \" $1 \" ; shut ; no description ; switchport ; no switchport ; no shut\"}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning trunk interfaces = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | inc \"trunk\" | grep \"Eth\" | awk '{print \"interface \" $1 \" ; shut ; no description ; no switchport  ; no mtu  ; no shut\"}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): remove switch from maintenance mode = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system mode maintenance\" | awk '{print \" no \"$0 \" non-interactive\"}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning completed for [%s]\" % (funcName, devSerial))\n        maintenanceMode = True\n        for i in range(10):\n            Wrapper.print(\"%s(): Check if switch [%s] is out of maintenance mode\" % (funcName, devSerial))\n            cmd = \"show system mode | grep 'System Mode: Maintenance'\"\n            cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n            if (len(cmdOut) == 0):\n                maintenanceMode = False\n                Wrapper.print(\"%s(): switch [%s] is out of maintenance mode\" % (funcName, devSerial))\n                break\n            else:\n                Wrapper.print(\"%s(): sleeping [count %s] for 10 seconds to get the switch out of maintenance mode = [%s]\" % (funcName, (i+1), devSerial))\n                time.sleep(10)\n        if maintenanceMode == True:\n            sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system mode maintenance\" | awk '{print \" no \"$0 \" non-interactive\"}' | vsh''', sshConnReadTimeout)\n            cmd = \"show system mode | grep 'System Mode: Maintenance'\"\n            cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n            if (len(cmdOut) != 0):\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                                   \"Please get the switch out of maintenance mode\", devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"configure maintenance profile maintenance-mode\" | awk '{print \" no \"$0 }' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'delete MIN-EASY-SW-RUNNING-CONFIG' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'delete ef-minimum-config' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show run > MIN-EASY-SW-RUNNING-CONFIG''', sshConnReadTimeout)\n        cmd = \"show file MIN-EASY-SW-RUNNING-CONFIG | grep 'boot nxos'\"\n        cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n        if (len(cmdOut) == 0):\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                                   \"Boot variables are not set on the switch. \"\n                                   \"Please try again after setting bootvars\", devSerial)\n            respObj.setFailureRetCode()\n            return respObj\n        cmd = \"show file MIN-EASY-SW-RUNNING-CONFIG | grep 'hardware access-list tcam'\"\n        cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | inc \"hardware access-list tcam\" | awk '{print \" no \"$0 }' | vsh''', sshConnReadTimeout)\n        if (len(cmdOut) > 0):\n            Wrapper.print(\"%s(): Configured tcams [%s] for switch [%s]\" % (funcName, cmdOut, devSerial))\n            respObj.addWarnReport(getFabErrEntity(funcName, devSerial),\n                                   \"Had non default TCAM carving configured, which is/are removed during switch import. \"\n                                   \"Please be aware switch reload is must after any TCAM carving configuration change. \"\n                                   \"Please make sure to reload the switch from the Switches page \"\n                                   \"after Recalculate & Deploy.\", devSerial)\n            respObj.setWarningRetCode()\n\n        # clean the switch for greenfield import, keep the minimum config\n        # as the switch will go through reload\n        Wrapper.print(\"%s(): Replacing config for [%s]\" % (funcName, devSerial))\n        sshObj.send('''show run vdc | ex fex >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep redundancy-mode >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep hostname >>  ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep switchname >>  ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'no password' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep username >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'ip domain-lookup' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run radius >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run tacacs+ >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run aaa >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'interface breakout module' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'copp profile' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'snmp-server user' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run aaa >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep switch-packets >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''echo 'vlan 1' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run vrf management | begin 'vrf context' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'system routing' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'hardware profile portmode' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run interface mgmt0 | b version | exclude version >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'boot nxos' >> ef-minimum-config''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): minimum config replace started = [%s]\" % (funcName, devSerial))\n        sshObj.send('''echo 'configure replace bootflash:ef-minimum-config' | vsh ''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): minimum config replace completed = [%s]\" % (funcName, devSerial))\n        Wrapper.print(\"%s(): Delete temporary files completed = [%s]\" % (funcName, devSerial))\n        cmd = \"echo 'copy running-config startup-config'\"\n        cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n    except Exception as e:\n        Wrapper.print(\"%s(): Exception!!! Switch [%s] cleanup, exception[%s] \" % (funcName, devSerial, repr(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                               \"Error cleaning switch configuration. \"\n                               \"Please retry Recalculate & Deploy.\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n    finally:\n        Wrapper.print(\"%s(): Closing SSH connection %s\"%(funcName, devSerial))\n        sshObj.close()\n        sshObj = None\n        Wrapper.print(\"%s(): Exiting switch cleanup for without reload: [%s]\" % (funcName, devSerial))\n    return respObj\n\ndef switchCleanupWithReload(gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = gVarDictObj.get(\"deviceSerial\")\n    fabricName = gVarDictObj[\"FABRIC_NAME\"]\n\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n\n    Wrapper.print(\"%s(): Fabric [%s] Switch [%s] - START\" % (funcName, fabricName, devSerial))\n    sshObj = None\n    try:\n        sshObj  = gVarDictObj[\"deviceSSHConnObj\"] \n        #sshObj = Util.exe(getOptSSHConnection(devSerial))\n    except Exception as e:\n        Wrapper.print(\"%s(): Failed to get SSH connection for : [%s] [%s]. Will skip\" % \n                      (funcName, devSerial, str(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":SSH\"),\n                               \"Failed to get SSH connection for switch cleanup. \"\n                               \"Please try again Recalculate & Deploy\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n\n    try:\n        sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n        shCfgFileName = 'show file EASY-SW-RUNNING-CONFIG '\n        minCfgFileName = 'ef-minimum-config'\n\n        Wrapper.print(\"%s(): check boot param = [%s]\" % (funcName, devSerial))\n        cmd = shCfgFileName + \"| grep 'boot nxos'\"\n        cmdOut = getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout)\n        if (len(cmdOut) == 0):\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                                   \"Boot variables are not set on the switch. \"\n                                   \"Please try again after setting bootvars\", devSerial)\n            respObj.setFailureRetCode()\n            return respObj\n\n        Wrapper.print(\"%s(): delete older files = [%s]\" % (funcName, devSerial))\n        getSSHCmdOuput(devSerial, sshObj, 'delete EASY_SW_INTF_BRIEF', sshConnReadTimeout)\n        getSSHCmdOuput(devSerial, sshObj, 'delete poap_replay* ', sshConnReadTimeout)\n\n        cmdOut = getSSHCmdOuput(devSerial, sshObj, '''show interface brief > EASY_SW_INTF_BRIEF''', sshConnReadTimeout)\n        if NO_DISK_SPACE_ERR_MSG in cmdOut.lower():\n            noSwitchDiskSpaceError(devSerial, respObj)\n            return respObj\n\n        # clean the switch for greenfield import, keep the minimum config\n        # as the switch will go through reload\n\n        cmdList = [\n            '''show run vdc | ex fex | ex 'system vlan' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep redundancy-mode >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'ssh key dsa' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'ip domain-lookup' >> ''' + minCfgFileName,\n            shCfgFileName + '''| section ^radius >> ''' + minCfgFileName,\n            shCfgFileName + '''| section '^ip tacacs' >> ''' + minCfgFileName,\n            shCfgFileName + '''| section ^tacacs >> ''' + minCfgFileName,\n            shCfgFileName + '''| section ^aaa >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'copp profile' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'snmp-server user' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep switch-packets >> ''' + minCfgFileName,\n            '''echo 'vlan 1' >> ''' + minCfgFileName,\n            shCfgFileName + '''| section '^vrf context management' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'system routing' >> ''' + minCfgFileName,\n            shCfgFileName + '''| section '^interface mgmt0' >> ''' + minCfgFileName,\n            shCfgFileName + '''| section '^line console' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'boot nxos' >> ''' + minCfgFileName,\n            '''show file EASY_SW_INTF_BRIEF | grep Eth | ex '\\.'| grep -v Ethernet | awk '{print \"interface \" $1 \" ; no shut\"}' >> ''' + minCfgFileName,\n            'copy bootflash:ef-minimum-config scheduled-config',\n            'guestshell destroy',\n            'write erase',\n        ]\n\n        Wrapper.print(\"%s(): Fabric [%s] Switch [%s] - Capturing minimum config...\" % (funcName, fabricName, devSerial))\n        for cmd in cmdList:\n            cmdOut = getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout)\n            # we may run out of disk space as we append contents.. check for the condition\n            if NO_DISK_SPACE_ERR_MSG in cmdOut.lower():\n                noSwitchDiskSpaceError(devSerial, respObj)\n                return respObj\n\n        Wrapper.print(\"%s(): Fabric [%s] Switch [%s] - Reloading Switch...\" % (funcName, fabricName, devSerial))\n        getSSHCmdOuput(devSerial, sshObj, 'reload', int(1000))\n        Wrapper.print(\"%s(): Fabric [%s] Switch [%s] - Reloading started...\" % (funcName, fabricName, devSerial))\n        t1 = datetime.datetime.now()\n        PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, \"reload\", {\"st1\":str(t1)})\n    except Exception as e:\n        Wrapper.print(\"%s: Fabric [%s] Switch [%s]. Cleaning failed! Exception [%s]\" % (funcName, fabricName, devSerial, traceback.format_exc()))\n        respObj.addErrorReport(devSerial + \"Switch Cleaning\",\n                               \"Error cleaning switch configuration. Please retry Recalculate & Deploy.\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n    finally:\n        Wrapper.print(\"%s(): Fabric [%s] Switch [%s] - END\" % (funcName, fabricName, devSerial))\n    return respObj\n\ndef setFabricSettingValue(fabricSettings, key, value):\n    Wrapper.print(\"setFabricSettingValue: [%s] -> [%s]\" % (key, value))\n    fabricSettings[key] = value\n    return True\n\ndef preUpgradeExt(dictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        global FABRIC_NAME\n\n        FABRIC_NAME = dictObj[\"FABRIC_NAME\"]\n        upgradeFromVersion = dictObj.get('UPGRADE_FROM', \"\")\n        # Note: the backend will provide UPGRADE_FROM = \"\" if the from and to versions are the same\n        isUpgrade = (upgradeFromVersion != \"\")\n\n        Wrapper.print(\"==========%s: Start - Fabric [%s] upgradeFromVersion [%s] isUpgrade [%r]\" % (funcName,\n                                                        FABRIC_NAME, upgradeFromVersion, isUpgrade))\n\n        # get the current fabric settings\n        fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n\n        Wrapper.print(\"%s: Fabric [%s] fabricSettings %s\" % (funcName, FABRIC_NAME, fabricSettings))\n\n        # set/update the fabric settings\n        isSettingChange = False\n\n        # ENABLE_EVPN was introduced in 11.2 and may not be initialized in upgrade from pre-11.2 releases\n        if \"ENABLE_EVPN\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ENABLE_EVPN\", \"true\")\n\n        if fabricSettings[\"LINK_STATE_ROUTING\"] == \"ebgp\":\n            # eBGP fabric template\n            overlayMode = \"config-profile\" if fabricSettings[\"ENABLE_EVPN\"] == \"true\" else \"cli\"\n            if ((\"OVERLAY_MODE\" not in fabricSettings) or (fabricSettings[\"OVERLAY_MODE\"] == \"\")):\n                isSettingChange = setFabricSettingValue(fabricSettings, \"OVERLAY_MODE\", overlayMode)\n            if ((\"OVERLAY_MODE_PREV\" not in fabricSettings) or (fabricSettings[\"OVERLAY_MODE_PREV\"] == \"\")):\n                isSettingChange = setFabricSettingValue(fabricSettings, \"OVERLAY_MODE_PREV\",\n                                                        fabricSettings.get(\"OVERLAY_MODE\", overlayMode))\n\n            if \"UNDERLAY_IS_V6\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"SUPER_SPINE_BGP_AS\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNDERLAY_IS_V6\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNDERLAY_IS_V6_PREV\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"USE_LINK_LOCAL\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"LOOPBACK0_IPV6_RANGE\", \"\")\n\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ROUTE_MAP_TAG\", \"12345\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"DISABLE_ROUTE_MAP_TAG\", \"false\")\n                #isSettingChange = setFabricSettingValue(fabricSettings, \"BFD_IBGP_ENABLE\", \"false\")\n                #isSettingChange = setFabricSettingValue(fabricSettings, \"BFD_AUTH_ENABLE\", \"false\")\n                #isSettingChange = setFabricSettingValue(fabricSettings, \"BFD_AUTH_KEY\", \"\")\n\n                if fabricSettings[\"BGP_AS_MODE\"] == \"Dual-AS\":\n                    isSettingChange = setFabricSettingValue(fabricSettings, \"BGP_AS_MODE\", \"Same-Tier-AS\")\n            else:\n                if \"DISABLE_ROUTE_MAP_TAG\" not in fabricSettings:\n                    if \"ROUTE_MAP_TAG\" in fabricSettings and fabricSettings[\"ROUTE_MAP_TAG\"] == \"\":\n                        isSettingChange = setFabricSettingValue(fabricSettings, \"DISABLE_ROUTE_MAP_TAG\", \"true\")\n                    else:\n                        isSettingChange = setFabricSettingValue(fabricSettings, \"DISABLE_ROUTE_MAP_TAG\", \"false\")\n\n            if \"ALLOW_LEAF_SAME_AS\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ALLOW_LEAF_SAME_AS\", \"false\")\n\n            if \"LOOPBACK1_IPV6_RANGE\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"LOOPBACK1_IPV6_RANGE\", \"\")\n        else:\n            # Easy Fabric template\n            if \"BGP_AS_PREV\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"BGP_AS_PREV\", fabricSettings[\"BGP_AS\"])\n\n            if \"OVERLAY_MODE\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"OVERLAY_MODE\", \"config-profile\")\n            if ((\"OVERLAY_MODE_PREV\" not in fabricSettings) or (fabricSettings[\"OVERLAY_MODE_PREV\"] == \"\")):\n                isSettingChange = setFabricSettingValue(fabricSettings, \"OVERLAY_MODE_PREV\",\n                                                        fabricSettings.get(\"OVERLAY_MODE\", \"config-profile\"))\n\n            if \"PM_ENABLE\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"PM_ENABLE\", \"false\")\n            if ((\"PM_ENABLE_PREV\" not in fabricSettings) or (fabricSettings[\"PM_ENABLE_PREV\"] == \"\")):\n                isSettingChange = setFabricSettingValue(fabricSettings, \"PM_ENABLE_PREV\", \n                                                        fabricSettings.get(\"PM_ENABLE\", \"false\"))\n\n            if fabricSettings[\"LINK_STATE_ROUTING\"] == \"ospf\" and fabricSettings[\"ISIS_P2P_ENABLE\"] == \"false\":\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ISIS_P2P_ENABLE\", \"\")\n\n            if \"ANYCAST_BGW_ADVERTISE_PIP\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ANYCAST_BGW_ADVERTISE_PIP\", \"false\")\n\n            if \"ISIS_OVERLOAD_ENABLE\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ISIS_OVERLOAD_ENABLE\", \"true\")\n            if \"ISIS_OVERLOAD_ELAPSE_TIME\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ISIS_OVERLOAD_ELAPSE_TIME\", \"60\")\n\n            if \"STP_ROOT_OPTION\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"STP_ROOT_OPTION\", \"unmanaged\")\n\n            if \"INBAND_MGMT\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"INBAND_MGMT\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"INBAND_MGMT_PREV\", \"false\")\n\n            if \"BOOTSTRAP_ENABLE_PREV\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"BOOTSTRAP_ENABLE_PREV\", fabricSettings[\"BOOTSTRAP_ENABLE\"])\n\n            if \"SEED_SWITCH_CORE_INTERFACES\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"SEED_SWITCH_CORE_INTERFACES\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"SPINE_SWITCH_CORE_INTERFACES\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNNUM_DHCP_START\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNNUM_DHCP_END\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNNUM_DHCP_START_INTERNAL\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNNUM_DHCP_END_INTERNAL\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"INBAND_DHCP_SERVERS\", \"\")\n\n            if \"EXTRA_CONF_TOR\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"EXTRA_CONF_TOR\", \"\")\n            if \"abstract_extra_config_tor\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"abstract_extra_config_tor\", \"extra_config_tor\")\n            if \"HOST_INTF_ADMIN_STATE\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"HOST_INTF_ADMIN_STATE\", \"true\")\n            if \"BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS\", \"false\")\n\n            if \"AUTO_VRFLITE_IFC_DEFAULT_VRF\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"AUTO_VRFLITE_IFC_DEFAULT_VRF\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"AUTO_SYMMETRIC_DEFAULT_VRF\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"DEFAULT_VRF_REDIS_BGP_RMAP\", \"\")\n\n            if \"VRF_LITE_AUTOCONFIG\" in fabricSettings and \\\n                (fabricSettings[\"VRF_LITE_AUTOCONFIG\"] == \"Back2BackOnly\" or fabricSettings[\"VRF_LITE_AUTOCONFIG\"] == \"ToExternalOnly\"):\n                 isSettingChange = setFabricSettingValue(fabricSettings, \"VRF_LITE_AUTOCONFIG\", \"Back2Back&ToExternal\")\n\n            if \"EXTRA_CONF_AGG\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"EXTRA_CONF_AGG\", \"\")\n            if \"EXTRA_CONF_ACCESS\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"EXTRA_CONF_ACCESS\", \"\")\n\n            # introduced in NDFC 12.1.3\n            if \"ESR_OPTION\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ESR_OPTION\", \"PBR\")\n            if \"SLA_ID_RANGE\" not in fabricSettings:\n                defaultRange = \"10000-19999\"\n                isSettingChange = setFabricSettingValue(fabricSettings, \"SLA_ID_RANGE\", defaultRange)\n                Util.processRespObj(respObj, RM.addOrUpdatePoolData(FABRIC_NAME, \"SLA_ID\", defaultRange))\n            if \"OBJECT_TRACKING_NUMBER_RANGE\" not in fabricSettings:\n                defaultRange = \"100-299\"\n                isSettingChange = setFabricSettingValue(fabricSettings, \"OBJECT_TRACKING_NUMBER_RANGE\", defaultRange)\n                Util.processRespObj(respObj, RM.addOrUpdatePoolData(FABRIC_NAME, \"OBJECT_TRACKING_NUMBER_POOL\", defaultRange))\n\n        # # common settings\n        if \"ENABLE_NETFLOW\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ENABLE_NETFLOW\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ENABLE_NETFLOW_PREV\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"NETFLOW_EXPORTER_LIST\", \"\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"NETFLOW_RECORD_LIST\", \"\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"NETFLOW_MONITOR_LIST\", \"\")\n\n        if \"ENABLE_PVLAN\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ENABLE_PVLAN\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ENABLE_PVLAN_PREV\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"default_pvlan_sec_network\", \"\")\n\n        if \"NXAPI_HTTPS_PORT\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"NXAPI_HTTPS_PORT\", \"443\")\n\n        if \"NXAPI_HTTP_PORT\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"NXAPI_HTTP_PORT\", \"80\")\n\n        if \"AUTO_UNIQUE_VRF_LITE_IP_PREFIX\" not in fabricSettings:\n            # added in 12.1.3\n            isSettingChange = setFabricSettingValue(fabricSettings, \"AUTO_UNIQUE_VRF_LITE_IP_PREFIX\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"AUTO_UNIQUE_VRF_LITE_IP_PREFIX_PREV\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"PER_VRF_LOOPBACK_AUTO_PROVISION\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"PER_VRF_LOOPBACK_AUTO_PROVISION_PREV\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"PER_VRF_LOOPBACK_IP_RANGE\", \"\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"BANNER\", \"\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ADVERTISE_PIP_ON_BORDER\", \"false\")\n\n        if \"ALLOW_NXC\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ALLOW_NXC\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ALLOW_NXC_PREV\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"OVERWRITE_GLOBAL_NXC\", \"false\")\n\n        if fabricSettings[\"abstract_trunk_host\"] == \"int_trunk_host_11_1\":\n            isSettingChange = setFabricSettingValue(fabricSettings, \"abstract_trunk_host\", \"int_trunk_host\")\n        if fabricSettings[\"abstract_routed_host\"] == \"int_routed_host_11_1\":\n            isSettingChange = setFabricSettingValue(fabricSettings, \"abstract_routed_host\", \"int_routed_host\")\n        if fabricSettings[\"temp_vpc_peer_link\"] == \"int_vpc_peer_link_po_11_1\":\n            isSettingChange = setFabricSettingValue(fabricSettings, \"temp_vpc_peer_link\", \"int_vpc_peer_link_po\")\n\n        if \"TOPDOWN_CONFIG_RM_TRACKING\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"TOPDOWN_CONFIG_RM_TRACKING\", \"\")\n\n        settingsToDelete = None\n        if \"TE_ENABLE\" in fabricSettings:\n            # remove the TE Agent fabric settings parameters\n            settingsToDelete = [\"TE_ENABLE\", \"TE_ACCOUNT_TOKEN\", \"TE_INTERNET_VRF\", \"TE_DNS_DOMAIN\", \n                \"TE_DNS_SERVER_IP_LIST\", \"TE_NTP_SERVER_IP_LIST\", \"TE_PROXY_ENABLE\", \"TE_PROXY_IP\", \"TE_PROXY_BYPASS\"]\n            isSettingChange = True\n\n        if isUpgrade:\n            if upgradeFromVersion in [\"11.5.4\"]:\n                # clear the scheduled fabric backups in settings. Customers must reenable them\n                isSettingChange = setFabricSettingValue(fabricSettings, \"enableRealTimeBackup\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"enableScheduledBackup\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"scheduledTime\", \"\")\n            if fabricSettings[\"LINK_STATE_ROUTING\"] != \"ebgp\" and upgradeFromVersion in [\"11.5.4\", \"12.1.1e\", \"12.1.2e\", \"12.1.2p\"]:\n                topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(FABRIC_NAME)))\n                devices = topologyDataObj.get(TopologyInfoType.SWITCHES)\n                devices = filter(None, devices)\n                if len(devices) > 0:\n                    isSettingChange = setFabricSettingValue(fabricSettings, \"UPGRADE_FROM_VERSION\", upgradeFromVersion)\n\n        if isSettingChange:\n            # we made some changes.. update the fabric settings with the new values\n            Util.processRespObj(respObj, FabricWrapper.update(FABRIC_NAME, fabricSettings, settingsToDelete))\n\n        # PTI regen for devices has been moved to Post Upgrade handling in configSave()\n        if fabricSettings.get(\"UPGRADE_FROM_VERSION\", \"\") != \"\":\n            errorMsg = (\"[%s]: Post Upgrade processing is needed. Please perform Recalculate Config \"\n                        \"after fabric is out of upgrade mode to complete upgrade from %s\" %\n                        (FABRIC_NAME, upgradeFromVersion))\n            Wrapper.print(\"%s: %s\" % (funcName, errorMsg))\n            FabricErrorLogger.error(FABRIC_NAME, Category.Fabric, ET.Fabric, FABRIC_NAME+\":Upgrade\", errorMsg, False, \"\", \"\")\n\n        if (isUpgrade and (upgradeFromVersion in [\"12.1.1e\"])):\n            # special processing for Inband POAP\n            inbandPoapEnabledFlag = isInbandPoapEnabled(fabricSettings)\n            Wrapper.print(\"%s: Inband POAP inbandPoapEnabledFlag [%r]\" % (funcName, inbandPoapEnabledFlag))\n            if (inbandPoapEnabledFlag and (fabricSettings.get(\"FABRIC_INTERFACE_TYPE\", \"p2p\") == \"unnumbered\")):\n                dictObj[\"devices\"] = devices\n                dictObj[\"fabricSettings\"] = fabricSettings\n\n                Util.processRespObj(respObj, PTI.executePyTemplateMethod(\"Easy_Fabric_Extn_11_1\", dictObj, \"handleInbandPoapUpgrade\"))\n\n    except Exception as e:\n        msg = \"Unexpected error during upgrade processing\"\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(FABRIC_NAME + \":UPGRADE\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        Wrapper.print(\"==========%s: End - Fabric [%s] Success = [%r]\" % (funcName, FABRIC_NAME, respObj.isRetCodeSuccess()))\n        respObj.setValue(respObj)\n        return respObj\n\ndef updateBpduGuardinPtis(ptiSerial, templateName):\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(ptiSerial)\n    srchOpt.setTemplateName(templateName)\n    ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    for pti in ptiList:\n        if pti.isDeleted():\n            continue\n\n        origNvPairs = pti.getNvPairs()\n        if origNvPairs.get(\"BPDUGUARD_ENABLED\", \"none\") != \"none\":\n            continue\n\n        # set the value to the expected one and update\n        nvPairs = copy.deepcopy(origNvPairs)\n        nvPairs[\"BPDUGUARD_ENABLED\"] = \"no\"\n        PTIWrapper.updateInstance(pti.getPolicyId(), nvPairs)\n\ndef setSwitchErrorReason(errDevices, errReasonStr, respObj):\n    Wrapper.print(\"setSwitchErrorReason: %s\" % errReasonStr)\n    for deviceSn in errDevices:\n        errDevices[deviceSn] = errReasonStr\n    if respObj.isRetCodeSuccess():\n        respObj.addErrorReport(\"CHANGE_DISCOVERY_IP\", errReasonStr)\n        respObj.setFailureRetCode()\n\n# returns a JSON dump of a dictionary of switches that failed\ndef doPreChangeDiscoveryIP(gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n\n    fabricName = gVarDictObj[\"FABRIC_NAME\"]\n    devices = gVarDictObj[\"serialNumbers\"]\n    isCleanup = gVarDictObj[\"isCleanup\"].lower()\n\n    fabDetails = Util.exe(FabricWrapper.get(fabricName))\n    fabSettings = fabDetails.getNvPairs()\n    fabTech = fabDetails.getFabricTechnology()\n    isFabricMonitorMode = \"true\"\n    if fabTech != \"LANMonitor\":\n        isFabricMonitorMode = gVarDictObj.get(\"IS_READ_ONLY\", \"false\")\n\n    isEasyFabInbandMgmt = fabSettings.get(\"INBAND_MGMT\", \"false\")\n    # dictionary of switch serials that failed.. we will set all to failed to begin with and remove successful ones\n    errDevices = {}\n    for deviceSn in devices:\n        errDevices[deviceSn] = \"Failed - Not processed\"\n    try:\n        Wrapper.print(\"%s : FAB [%s] Template [%s] fabTech [%s] isFabricMonitorMode [%s] isCleanup [%s] devices %s\" % (funcName,\n            fabricName, fabDetails.getTemplateName(), fabTech, isFabricMonitorMode, isCleanup, devices))\n\n        topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(fabricName)))\n        # check to make sure all are Nexus switches\n        for deviceSn in devices:\n            # # support for Cat9K and NXOS\n            devModel = topologyDataObj.getSwitchModel(deviceSn)\n            isNXOS  = Util.isNXOSDevice(deviceSn, devModel)\n\n            # check if the 'import_type' PTI is associated with the switch\n            # Note: will be available for switches in External/LAN_Classic fabric to indicate inband/OOB import\n            # if not present, assume OOB since that is the default\n            importTypePtis = Util.exe(PTIWrapper.get(deviceSn, \"SWITCH\", \"SWITCH\", \"\", \"import_type\"))\n            if len(importTypePtis) > 0:\n                devImpType = importTypePtis[0].getNvPairs()[\"TYPE\"]\n            else:\n                if isEasyFabInbandMgmt == \"true\":\n                    devImpType = \"inband\"\n                else:\n                    # OOB case - N9K (mgmt0) and Cat9K (g0/0) get covered here\n                    devImpType = \"mgmt\"\n\n            migrateMode, migrateModeDetail = Util.getSwitchMigrationModeStr(deviceSn)\n\n            Wrapper.print(\"%s: Switch [%s] devModel [%s] isNXOS [%r] devImpType [%s] migrateMode [%s] \"\n                \"migrateModeDetail [%s]\" % (funcName, deviceSn, devModel, isNXOS, devImpType, migrateMode, migrateModeDetail))\n            \n            if not isNXOS:\n                if fabTech != \"IOS-XE_VXLANFabric\":\n                    errDevices[deviceSn] = \"Cannot change Discovery IP for non Nexus switch.\"\n                    if respObj.isRetCodeSuccess():\n                        respObj.addErrorReport(getFabErrEntity(funcName), \"Failed to change discovery IP\")\n                        respObj.setFailureRetCode()\n                    continue\n\n            if devImpType != \"mgmt\":\n                if fabTech != \"VXLANFabric\":\n                    errDevices[deviceSn] = \"Cannot change discovery IP for switch imported via inband interface\"\n                    if respObj.isRetCodeSuccess():\n                        respObj.addErrorReport(getFabErrEntity(funcName), \"Failed to change discovery IP\")\n                        respObj.setFailureRetCode()\n                    continue\n\n            if migrateMode is None:\n                if isCleanup == \"false\":\n                    if isFabricMonitorMode == \"false\":\n                        putSwitchIntoChangeDiscIPAddressMigrMode(fabricName, deviceSn)\n                        # update switch config status for migration mode\n                        Util.exe(FabricWrapper.updateSwitchCfgStateForMigrationMode(deviceSn))\n\n                del errDevices[deviceSn]\n            elif (migrateMode != \"changeIP\"):\n                if isCleanup == \"false\":\n                    # report error if not in changeIP mode\n                    errDevices[deviceSn] = \"Already in migration mode. Cannot change the Discovery IP address\"\n                    if respObj.isRetCodeSuccess():\n                        respObj.addErrorReport(getFabErrEntity(funcName), \"Failed to change discovery IP\")\n                        respObj.setFailureRetCode()\n                else:\n                    # switch not in change IP migration mode.. we do not care\n                    del errDevices[deviceSn]\n            else:\n                # switch is in change ip migration mode\n                if isCleanup == \"true\":\n                    if isFabricMonitorMode == \"false\":\n                        delMigrationState(fabricName, deviceSn)\n                del errDevices[deviceSn]\n    except Exception as e:\n        Wrapper.print(\"%s: Unexpected Exception. %s\" % (funcName, traceback.format_exc()))\n        if isinstance(e, respObjError):\n            msg = (\"Unexpected error during change discovery IP handling\")\n            respObj.addErrorReport(getFabErrEntity(funcName), msg)\n            respObj.setFailureRetCode()\n            Util.processRespObj(respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        jsonStr = json.dumps(errDevices)\n        respObj.setValue(jsonStr)\n        Wrapper.print(\"FAB [%s] Finish [%s] Success = [%r] errDevices %s\" % (fabricName, funcName, respObj.isRetCodeSuccess(), jsonStr))\n        return respObj\n\ndef preAddExt(gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        devSerial = gVarDictObj[\"deviceSerial\"]\n        devModel = gVarDictObj[\"deviceModel\"]\n        fabricName = gVarDictObj[\"FABRIC_NAME\"]\n        isPreserveConfigSet = gVarDictObj[\"devicePreserveConfig\"]\n        Wrapper.print(\"==========preAddExt: Fabric = %s, Serial [%s], Model [%s], Preserve = %s\" %\n                      (fabricName, devSerial, devModel, isPreserveConfigSet))\n\n        modelCheckPass = True\n        if \"FF\" in gVarDictObj and gVarDictObj[\"FF\"] == \"Easy_Fabric_Classic\":\n            #Allow N7k and N9k devices for Enhanced Classic LAN fabrics\n            if (not devModel.startswith(\"N9K-\")) and (not devModel.startswith(\"N7\")):\n                modelCheckPass = False\n        else:\n            # Allow N9K/N3K devices for Easy fabric\n            if (not devModel.startswith(\"N9K-\")) and (not devModel.startswith(\"N3K-\")):\n                modelCheckPass = False\n                \n        if not modelCheckPass:\n            respObj.addErrorReport(getFabErrEntity(preAddExt.__name__, devSerial),\n                                   \"This fabric does not support model %s.\" % devModel)\n            respObj.setFailureRetCode()\n            return respObj\n\n        #Allow N7k devices for Enhanced Classic LAN fabrics\n        if devModel.startswith(\"N7\"):\n            fabDetails = Util.exe(FabricWrapper.get(fabricName))\n            fabTech = fabDetails.getFabricTechnology()\n            if fabTech == \"VLANFabric\":\n                sshObj = gVarDictObj.get(\"deviceSSHConnObj\")\n                Wrapper.print(\"==========preAddExt: Fabric = %s, Serial [%s], Model [%s], Preserve = [%s], sshObj [%s]\" %\n                                (fabricName, devSerial, devModel, isPreserveConfigSet, sshObj))\n                if \":\" not in devSerial and sshObj:\n                    isAdminVdc = adminVdcCheck(gVarDictObj[\"deviceSSHConnObj\"], devSerial, respObj)\n                    if isAdminVdc:\n                        respObj.addErrorReport(getFabErrEntity(preAddExt.__name__, devSerial),\n                                                \"This fabric doesn't support Nexus 7000 Admin VDC.\")\n                        respObj.setFailureRetCode()\n                        return respObj\n\n                if sshObj:\n                    isFabricPath = getSwitchFPFeatureState(gVarDictObj[\"deviceSSHConnObj\"], devSerial, respObj)\n                    if isFabricPath:\n                        respObj.addErrorReport(getFabErrEntity(preAddExt.__name__, devSerial),\n                                               \"This fabric doesn't support switch with feature-set fabricpath installed in it.\")\n                        respObj.setFailureRetCode()\n                        return respObj\n \n        # check a few things before allowing adding\n        doAddSwitchEntryCheck(gVarDictObj, respObj)\n\n        Wrapper.print(\"Done with preAddExt\")\n        respObj.setValue(respObj)\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef getSwitchCmdOutput(sshObj, devSerial, cmdStr, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n    cmdOut = None\n    try:\n        Wrapper.print(\"%s: [%s] Getting output of cmd [%s]\" % (funcName, devSerial, cmdStr))\n        cmdOut = sshObj.send(cmdStr, sshConnReadTimeout);\n        tmpCmdOut = cmdOut\n        if cmdOut and len(cmdOut) > 80:\n            tmpCmdOut = cmdOut[:80]\n        Wrapper.print(\"%s(): [%s] Attempting to send first command [%s] response %s.\" % (funcName, devSerial, cmdStr, tmpCmdOut))\n        if \"Permission denied\" in cmdOut:\n            errorMsg = (\"Switch [%s]: Insufficient privileges to read switch configuration. \"\n                        \"Please change the discovery user role to have network-admin privileges and \"\n                        \"retry Recalculate & Deploy.\" % devSerial)\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n    except:\n        e = sys.exc_info()[0]\n        Wrapper.print(\"%s: Unexpected error executing CLI [%s] on switch . Exception = [%s]\" % (funcName, cmdStr, traceback.format_exc()))\n        respObj.addErrorReport(funcName,\n            \"Unexpected error executing CLI [%s] on switch. Please check and retry\" % (cmdStr), devSerial)\n        respObj.setFailureRetCode()\n    return cmdOut\n\ndef getSwitchCmdJsonOutput(sshObj, devSerial, cmdStr, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    cmdOut = getSwitchCmdOutput(sshObj, devSerial, cmdStr, respObj)\n    cmdJson = \"\"\n    if cmdOut == None:\n        return cmdJson\n    if ((len(cmdOut) >= 2) and (not cmdOut.startswith(\"Syntax error while parsing\"))):\n        try:\n            # convert to JSON object\n            cmdJson = json.loads(cmdOut)\n            #Wrapper.print(\"%s: JSON obj [%s]\" % (funcName, cmdJson))\n        except:\n            # some invalid JSON syntax\n            e = sys.exc_info()[0]\n            Wrapper.print(\"%s: Unexpected error converting to JSON format . Exception = [%s]\" % (funcName, traceback.format_exc()))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                \"Unexpected JSON content executing CLI [%s] on switch. Received output [%s]. Please check and retry\" % (cmdStr, \n                                        cmdOut), devSerial)\n            respObj.setFailureRetCode()\n            return cmdJson\n    else:\n        if (cmdOut.strip() != \"\"):\n            # we got an unexpected output\n            Wrapper.print(\"%s: Unexpected RAW switch output [%s]\" % (funcName, cmdOut))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                \"Unexpected error executing CLI [%s] on switch. Received output [%s]. Please check and retry\" % (cmdStr, \n                                        cmdOut), devSerial)\n            respObj.setFailureRetCode()\n    return cmdJson\n\ndef processVpcRow(vpcRow, vpcEntries):\n    if type(vpcRow) == list:\n        Wrapper.print(\"processVpcRow: ROW is a list. len = [%d]\" % len(vpcRow))\n        for vpcEntry in vpcRow:\n            #Wrapper.print(\"processVpcRow: adding vpc entry [%s]\" % vpcEntry)\n            vpcEntries.append(vpcEntry)\n    else:\n        vpcEntries.append(vpcRow)\n\n\ndef adminVdcCheck(sshObj, devSerial, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    isAdminVdc = False\n    cmdJson = getSwitchCmdJsonOutput(sshObj, devSerial, \"show vdc detail | json\", respObj)\n    if cmdJson == \"\":\n        Wrapper.print(\"%s: Switch [%s] did not report any feature status\" % (funcName, devSerial))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                               \"Could not get vdc details for the switch. Please resolve and retry\", devSerial)\n        respObj.setFailureRetCode()\n        return isAdminVdc\n    try:\n        vdcDict = cmdJson[\"TABLE_vdc\"][\"ROW_vdc\"]\n        if vdcDict:\n            if isinstance(vdcDict,list):\n                for item in vdcDict:\n                    Wrapper.print(\"%s: Switch [%s] vdcId [%s] vtype = [%s]\" % (funcName, devSerial, item[\"vdc_id\"], item[\"vtype\"].lower()))\n                    if item[\"vdc_id\"] == 1 and item[\"vtype\"].lower() == \"admin\":\n                        isAdminVdc = True\n                        break\n            elif isinstance(vdcDict,dict):\n                Wrapper.print(\"%s: Switch [%s] vdcId [%s] vtype = [%s]\" % (funcName, devSerial, vdcDict[\"vdc_id\"], vdcDict[\"vtype\"].lower()))\n                if vdcDict[\"vdc_id\"] == 1 and vdcDict[\"vtype\"].lower() == \"admin\":\n                    isAdminVdc = True\n            else:\n                Wrapper.print(\"%s: Switch [%s] dict [%s]\" % (funcName, devSerial, vdcDict))\n    except:\n        pass\n    return isAdminVdc\n\n\ndef getSwitchFPFeatureState(sshObj, devSerial, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    isFabricPathEn = False\n    cmdStr = \"show feature-set fabricpath\"\n    cmdOut = getSwitchCmdOutput(sshObj, devSerial, cmdStr, respObj)\n    Wrapper.print(\"%s: Switch [%s] cmdOut [%s]\" % (funcName, devSerial, cmdOut))\n    if (cmdOut != \"\" and \"fabricpath\" in cmdOut.lower() and ((\"installed\" in cmdOut.lower() and \"uninstalled\" not in cmdOut.lower()) or \"enabled\" in cmdOut.lower())):\n        isFabricPathEn = True \n    return isFabricPathEn\n\n\ndef getSwitchVpcFeatureState(sshObj, devSerial, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    isVpc = False\n    cmdJson = getSwitchCmdJsonOutput(sshObj, devSerial, \"show feature | json\", respObj)\n    if cmdJson == \"\":\n        Wrapper.print(\"%s: Switch [%s] did not report any feature status\" % (funcName, devSerial))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n            \"Could not get vPC feature status. Please resolve and retry\", devSerial)\n        respObj.setFailureRetCode()\n        return isVpc\n\n    try:\n        for featureEntry in cmdJson[\"TABLE_cfcFeatureCtrlTable\"][\"ROW_cfcFeatureCtrlTable\"]:\n            if featureEntry[\"cfcFeatureCtrlName2\"].lower() != \"vpc\":\n                continue\n\n            Wrapper.print(\"%s: switch [%s] feature vpc state = [%s]\" % (funcName, devSerial, featureEntry[\"cfcFeatureCtrlOpStatus2\"]))\n            if featureEntry[\"cfcFeatureCtrlOpStatus2\"].lower() == \"enabled\":\n                isVpc = True\n            break\n    except:\n        cmdStr = \"show feature | grep vpc\"\n        cmdOut = getSwitchCmdOutput(sshObj, devSerial, cmdStr, respObj)\n        if cmdOut != \"\" and \"vpc\" in cmdOut.lower() and \"enabled\" in cmdOut.lower():\n            isVpc = True \n    return isVpc\n\ndef getParentFabricName(fabricName, respObj):\n    parentFab = None\n    resp = FabricWrapper.getParentFabricName(fabricName)\n    if resp.isRetCodeSuccess():\n        # it is indeed a member fabric.. get MSD name\n        parentFab = resp.getValue()\n    return parentFab\n\n# invoked from MSD_Fabric fabric template\n# Called during add member fabric to MSD\n# The input dictionary object 'dict', must have the following data:\n#   \"MSD_FABRIC_NAME\" - name of the MSD Fabric\n#   \"FABRIC_NAME\"   - name of the fabric being added as a member\n#\n#   - Do not allow the add if member fabric's routing or nve loopback id is the same as multisite loopback id\n#   - Do not allow the add if there are one or more BF switches already in the fabric pending migration\ndef addFabricAsMemberEntryCheck(dict):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n\n    fabName = dict[\"FABRIC_NAME\"]\n    msdFabName = dict[\"MSD_FABRIC_NAME\"]\n\n    fabricSettings = Util.exe(FabricWrapper.get(fabName)).getNvPairs()\n    msdFabricSettings = Util.exe(FabricWrapper.get(msdFabName)).getNvPairs()\n    bgpLoopbackId = fabricSettings.get(\"BGP_LB_ID\", \"\")\n    nveLoopbackId = fabricSettings.get(\"NVE_LB_ID\", \"\")\n    msLoopbackId = msdFabricSettings.get(\"MS_LOOPBACK_ID\", \"\")\n\n    if msLoopbackId == bgpLoopbackId or msLoopbackId == nveLoopbackId:\n        errorMsg = (\"Cannot add fabric [%s] to the MSD [%s] since '%s Loopback Id' in [%s] is the same as\"\n             \" 'Multi-Site VTEP VIP Loopback Id' %s in [%s]\"\n             % (fabName, msdFabName, \"Routing\" if msLoopbackId==bgpLoopbackId else \"NVE\", fabName, msLoopbackId, msdFabName))\n        respObj.addErrorReport(funcName, errorMsg)\n        respObj.setFailureRetCode()\n        return respObj\n\n    if msdFabricSettings[\"ENABLE_PVLAN\"] == \"false\":\n        # error if new member has ENABLE_PVLAN true\n        if \"ENABLE_PVLAN\" in fabricSettings and fabricSettings[\"ENABLE_PVLAN\"] == \"true\":\n            errorMsg = (\"Cannot add fabric [%s] to the MSD [%s] since 'Private VLAN' is enabled in [%s] while not enabled in %s\"\n                % (fabName, msdFabName, fabName, msdFabName))\n            Wrapper.print(\"%s: %s\" % (funcName, errorMsg))\n            respObj.addErrorReport(funcName, errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n    topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(fabName)))\n    devices = topologyDataObj.get(TopologyInfoType.SWITCHES)\n    devices = filter(None, devices)\n\n    bgw_present = False\n    for deviceSn in devices:\n        migrateMode, migrateModeDetail = Util.getSwitchMigrationModeStr(deviceSn)\n        if migrateMode and (migrateMode == \"brownAdd\"):\n            Wrapper.print(\"%s: %s - Switch [%s] is in BF migration mode\" % (funcName, fabName, deviceSn))\n            # this switch is in migration mode... fail the add of the GF switch\n            errorMsg = (\"Cannot add fabric [%s] to the MSD [%s] since there are some Brownfield switch(es) \"\n                \"pending migration. Please complete the migration and retry.\" % (fabName, msdFabName))\n            respObj.addErrorReport(funcName, errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n        if not bgw_present:\n            switchRole = topologyDataObj.get(TopologyInfoType.GET_SWITCH_ROLE, deviceSn)\n            if \"gateway\" in switchRole:\n                bgw_present = True\n\n    if not bgw_present:\n        fabricType = Util.exe(Helper.getFabricType(fabName))\n        if fabricType == \"Switch_Fabric\":\n            warningMsg = \"Fabric %s does not have any devices with 'border gateway' role. Please go to %s and assign gateway(s) followed by 'Recalculate & Deploy' in %s\" % (fabName, fabName, fabName)\n            Wrapper.print(\"%s: %s\" % (funcName, warningMsg))\n            respObj.setWarningRetCode()\n            respObj.addWarnReport(funcName, warningMsg)\n\n    return respObj\n\n# invoked from Easy_Fabric fabric template\n# Called during add/bootstrap switch into the fabric\n# The input dictionary object 'dict', must have the following data:\n#   \"FABRIC_NAME\"   - name of the fabric\n#   \"devicePreserveConfig\" - \"true\" for BF, \"false\" for GF\n#   \"deviceSerial\"  - serial # of switch being added. If 'devicePreserveConfig' is \"false\", then this\n#                     is optional.\n# GF switch:\n#   - Do not allow the add if there are one or more BF switches already in the fabric pending migration\n# \n# BF switch:\n#   - Do not allow the add under the following conditions:\n#       > current fabric is a member of a MSD\n#       > there is atleast one switch that is not in BF migration mode, i.e, migration has been initiated/completed\n#       > vpc switch that has some inconsistencies\n#\ndef addSwitchEntryCheck(dict):\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    \n    doAddSwitchEntryCheck(dict, respObj)\n    return respObj\n\ndef checkSwitchDiscoveryIntf(devSerial, isPreserveConfigSet, dict, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    # discovery must be over mgmt0 for OOB and BGP loopback intf for inband\n    # check to make sure the discovery IP matches the expected interface\n    # Note: we cannot detect the condition where the discovery IP address on a non mgmt vrf (inband)\n    # is the same as the discovery IP address\n    discoveryIP = dict[\"deviceIPv4\"]\n    sshObj = dict[\"deviceSSHConnObj\"]\n    isV6 = isIpv6Addr(discoveryIP)\n    inbandMgmtFlag = True if (dict.get(\"INBAND_MGMT\", \"false\") == \"true\") else False\n\n    Wrapper.print(\"%s: Switch [%s] discoveryIP [%s] Inband [%r] isV6 [%r]\" % (funcName, devSerial, discoveryIP, inbandMgmtFlag, isV6))\n\n    if isV6:\n        normalizedDiscoveryIP =  Util.exe(FabricWrapper.getNormalizedIPv6(discoveryIP))\n        Wrapper.print(\"%s: After normalization: Switch [%s] normalizedDiscoveryIP [%s]\" %\n                      (funcName, devSerial, normalizedDiscoveryIP))\n        normalizedIpToCheck = normalizedDiscoveryIP + \"/\"\n\n    if inbandMgmtFlag:\n        discoveryIntfName = (\"loopback%s\" % (dict[\"BGP_LB_ID\"]))\n    else:\n        discoveryIntfName = \"mgmt0\"\n    newRespObj = WrappersResp.getRespObj()\n    newRespObj.setSuccessRetCode()\n    cmd = (\"sh running interface %s | section '^interface %s'\" % (discoveryIntfName, discoveryIntfName))\n    cmdOut= getSwitchCmdOutput(sshObj, devSerial, cmd, newRespObj)\n    Wrapper.print(\"%s: Switch [%s] cmd [%s] cmdOut [%s]\" % (funcName, devSerial, cmd, cmdOut))\n    if not newRespObj.isRetCodeSuccess():\n        Util.processRespObj(respObj, newRespObj)\n        return respObj\n\n    ipToCheck = discoveryIP + \"/\"\n    isError = False\n    ipv4AddrList = []\n    ipv6AddrList = []\n    for line in cmdOut.splitlines():\n        stripLine = line.strip()\n        if stripLine.startswith(\"ip address \"):\n            ipv4AddrList.append(stripLine.split()[2])\n        elif stripLine.startswith(\"ipv6 address \"):\n            ipv6AddrList.append(stripLine.split()[2])\n        elif stripLine.startswith(\"shutdown\"):\n            # intf is shutdown, so obvisouly discovery is over some other interface\n            isError = True\n            break\n\n    errMsg = (\"Must be discovered over interface [%s] and discovery IP address [%s] must \"\n                    \"match configuration.\" % (discoveryIntfName, discoveryIP))\n    if not isError:\n        # check further\n        matchFound = False\n        if not isError:\n            if isV6:\n                for ipv6Addr in ipv6AddrList:\n                    if ipv6Addr.startswith(ipToCheck):\n                        matchFound = True\n                    elif ipv6Addr.startswith(normalizedIpToCheck):\n                        matchFound = True\n            else:\n                for ipv4Addr in ipv4AddrList:\n                    if ipv4Addr.startswith(ipToCheck):\n                        matchFound = True\n      \n        if not matchFound:\n            #If no ip addresses match seed IP then its an error case\n            isError = True\n        else:\n            # do not allow v6 inband mgmt\n            if isV6 and inbandMgmtFlag:\n                isError = True\n                errMsg = \"Only IPv4 Inband Management is supported.\"\n\n    if isError:\n        respObj.addErrorReport(funcName, errMsg, devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n\ndef doAddSwitchEntryCheck(dict, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    fabName = dict[\"FABRIC_NAME\"]\n    devSerial = dict.get(\"deviceSerial\", None) # this will be None for bootstrap case\n    isPreserveConfigSet = dict[\"devicePreserveConfig\"]\n\n    if ((isPreserveConfigSet == True) and (devSerial is not None)):\n        checkSwitchDiscoveryIntf(devSerial, isPreserveConfigSet, dict, respObj)\n        if respObj.isRetCodeFailure():\n            return respObj\n\n    topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(fabName)))\n    devices = topologyDataObj.get(TopologyInfoType.SWITCHES)\n    devices = filter(None, devices)\n\n    if isPreserveConfigSet == False:\n        # do not allow GF switch if inband mgmt is enabled\n        if (dict.get(\"INBAND_MGMT\", \"false\") == \"true\") and (devSerial is not None):\n            errorMsg = (\"Cannot add the Greenfield switch(es) to the fabric with Inband Management enabled. Please check and retry.\")\n            respObj.addErrorReport(funcName, errorMsg, devSerial)\n            respObj.setFailureRetCode()\n            return\n\n        # do not allow a GF switch if there are any switches in BF migration mode\n        for deviceSn in devices:\n            migrateMode, migrateModeDetail = Util.getSwitchMigrationModeStr(deviceSn)\n            if migrateMode and (migrateMode == \"brownAdd\"):\n                Wrapper.print(\"%s: %s - Switch [%s] is in BF migration mode\" % (funcName, fabName, deviceSn))\n                # this switch is in migration mode... fail the add of the GF switch\n                errorMsg = (\"Cannot add the Greenfield switch(es) to the fabric since there are some \"\n                           \"Brownfield switches pending migration. Please complete the migration and retry.\")\n                if devSerial:\n                    respObj.addErrorReport(funcName, errorMsg, devSerial)\n                else:\n                    respObj.addErrorReport(funcName, errorMsg)\n                respObj.setFailureRetCode()\n                break\n        return\n\n    # Brownfield checks\n    # do not allow BF switches under the following conditions:\n    #   1. fabric is a member of a MSD\n    #   2. atleast one switch in the fabric is not in the migration mode\n    if devSerial == None:\n        errorMsg = \"Internal Error: The Brownfield switch serial # must be provided.\"\n        respObj.addErrorReport(funcName, errorMsg)\n        return respObj\n\n    # condition #1\n    parentFab = getParentFabricName(fabName, respObj)\n    if parentFab:\n        # it is indeed a member fabric.. report error\n        respObj.addErrorReport(funcName, \"Adding Brownfield switch [%s] to a member fabric is not allowed. \"\n            \"Fabric is a member of MSD [%s]. \" % (devSerial, parentFab))\n        respObj.setFailureRetCode()\n        return respObj\n\n    # condition #2\n    for deviceSn in devices:\n        migrateMode, migrateModeDetail = Util.getSwitchMigrationModeStr(deviceSn)\n        if migrateMode != \"brownAdd\":\n            Wrapper.print(\"%s: %s - Switch [%s] is not in migration mode\" % (funcName, fabName, deviceSn))\n            # this switch is not in migration mode... fail the add of the BF switch\n            errorMsg = (\"Adding a switch [%s] with Preserve-Config=Yes is not supported in a fabric with existing switches. \"\n                        \"Please re-add the switch with Preserve-Config=No.\" % devSerial)\n            respObj.addErrorReport(funcName, errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n    # open connection to switch and check if vPC, if yes, then make sure there are no inconsistencies\n    isVpc = getSwitchVpcFeatureState(dict[\"deviceSSHConnObj\"], devSerial, respObj)\n    if not respObj.isRetCodeSuccess():\n        return\n\n    if not isVpc:\n        return\n    cmdJson = getSwitchCmdJsonOutput(dict[\"deviceSSHConnObj\"], devSerial, \"show vpc | json\", respObj)\n    if cmdJson != \"\":\n        # check to make sure there are no inconsistencies\n        reasonStr = None\n        reportedStr = None\n        \"\"\"\n        if (cmdJson.get(\"virtual-peerlink\") == \"Enabled\"):\n            Wrapper.print(\"%s: [%s] Virtual vPC feature is not supported\"%(funcName, devSerial))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                                   \"Switch [%s]: Virtual vPC feature is not supported with preserved config yes option\" % (devSerial))\n            respObj.setFailureRetCode()\n            return\n        \"\"\"\n        if (cmdJson[\"vpc-peer-status\"] != \"peer-ok\"):\n            reasonStr = \"vPC Peer is not OK\"\n            reportedStr = cmdJson[\"vpc-peer-status\"]\n        elif (cmdJson[\"vpc-peer-keepalive-status\"] != \"peer-alive\"):\n            reasonStr = \"vPC Peer Keep-Alive error\"\n            reportedStr = cmdJson[\"vpc-peer-keepalive-status\"]\n        elif (cmdJson[\"vpc-per-vlan-peer-consistency\"] != \"consistent\"):\n            reasonStr = \"vPC Per VLAN Inconsistency\"\n            reportedStr = cmdJson[\"vpc-per-vlan-peer-consistency\"]\n\n        if reasonStr:\n            Wrapper.print(\"%s: Inconsistent vPC state Reason: [%s]. Reported state [%s]\" % (funcName, reasonStr, reportedStr))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                \"Inconsistent vPC state [%s]. Please resolve the inconsistencies and retry\" % (reasonStr), devSerial)\n            respObj.setFailureRetCode()\n            return\n\n        # now look through all the vpc interface inconsistencies\n        if \"TABLE_vpc\" in cmdJson:\n            reasonStr = \"\"\n            Wrapper.print(\"%s: Number of VPCs : [%s]\" % (funcName, cmdJson[\"num-of-vpcs\"]))\n            vpcEntries = []\n            # 1. list of dictionaries of 'ROW_vpc' if there are > 50 vpcs (this case needs to be handled)\n            #           \"TABLE_vpc\": [\n            #              {\n            #               \"ROW_vpc\": [\n            #                   {}\n            #                ]\n            #              }\n            #             ]\n            # 2. a dictionary of 'ROW_vpc' if are less than 50 vpcs\n            #           \"TABLE_vpc\": {\n            #               \"ROW_vpc\": [\n            #                   {}\n            #                ]\n            # 3. an entry with the vpc details is there is exactly one vpc\n            #           \"TABLE_vpc\": {\n            #               \"ROW_vpc\":\n            #                   {}\n            #            }\n            if type(cmdJson[\"TABLE_vpc\"]) == list:\n                Wrapper.print(\"%s: vPC table is list. len = %d\" % (funcName, len(cmdJson[\"TABLE_vpc\"])))\n                for vpcRow in cmdJson[\"TABLE_vpc\"]:\n                    processVpcRow(vpcRow[\"ROW_vpc\"], vpcEntries)\n            else:\n                processVpcRow(cmdJson[\"TABLE_vpc\"][\"ROW_vpc\"], vpcEntries)\n\n            Wrapper.print(\"%s: # of vPC entries = %d\" % (funcName, len(vpcEntries)))\n            for vpcIntfEntry in vpcEntries:\n                # {\n                #     \"vpc-id\": \"101\",\n                #     \"vpc-ifindex\": \"Po101\",\n                #     \"vpc-port-state\": \"0\",\n                #     \"phy-port-if-removed\": \"disabled\",\n                #     \"vpc-thru-peerlink\": \"1\",\n                #     \"vpc-consistency\": \"inconsistent\",\n                #     \"vpc-consistency-status\": \"SYSERR_MCECM_PEER_NOT_CFG\",\n                #     \"up-vlan-bitset\": \"-\",\n                #     \"es-attr\": \"DF: Invalid\"\n                # }\n                if vpcIntfEntry[\"vpc-consistency\"].lower() == \"inconsistent\":\n                    Wrapper.print(\"%s: inconsistent vpc intf entry: [%s]\" % (funcName, vpcIntfEntry))\n                    reasonStr += (Util.newLine() + (\"vPC [%s] Interface [%s] is in error/inconsistent state.\" % (vpcIntfEntry[\"vpc-id\"], vpcIntfEntry[\"vpc-ifindex\"])))\n\n            if reasonStr != \"\":\n                Wrapper.print(\"%s: Inconsistent vPC interface state. Reason: [%s]\" % (funcName, reasonStr))\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                    \"Inconsistent vPC interfaces. Please resolve the inconsistencies and retry. Reason [%s]\" % (reasonStr), devSerial)\n                respObj.setFailureRetCode()\n                return\n\ndef getOptSSHConnection(fabricName, devSerial, dcnmUser):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        fabricSettings = Util.exe(FabricWrapper.get(fabricName)).getNvPairs()\n        if fabricSettings.get(\"AAA_REMOTE_IP_ENABLED\") == \"false\":\n            sshObj = Util.exe(InventoryWrapper.getSSHConnection(devSerial, dcnmUser))\n        else:\n            sshObj = Util.exe(InventoryWrapper.getVSHConnection(devSerial, dcnmUser))\n        respObj.setValue(sshObj)\n        return respObj\n    except Exception as e:\n        Wrapper.print(\"%s(): Failed to get SSH connection for : [%s] [%s]. Will skip\" % \n                      (funcName, devSerial, str(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":SSH\"),\n                               \"Failed to get SSH connection. \"\n                               \"Please ensure LAN credentials and retry Recalculate & Deploy\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n\ndef isTCAMAllocationEnable(sn, fabricSettings):\n    tcamAllocEn = fabricSettings.get(\"TCAM_ALLOCATION\", \"true\")\n    if tcamAllocEn == \"true\":\n        return True\n    elif tcamAllocEn != \"true\":\n        tcamOvrwtptiList = Util.exe(PTIWrapper.get(sn, \"SWITCH\", \"SWITCH\", \"\", \"tcam_disable_overwrite\"))\n        if len(tcamOvrwtptiList) > 0 and tcamOvrwtptiList[0].isDeleted() == False:\n            return True\n    return False\n\ndef delImportProgressPti(devSerial):\n    ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"import_in_progress\"))\n    for pti in ptiList:\n        PTI.deleteInstance(pti.getPolicyId())\n\ndef postAddExt(gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    devSerial = gVarDictObj[\"deviceSerial\"]\n    fabricName = gVarDictObj[\"FABRIC_NAME\"]\n\n    try:\n        preserveConfig = gVarDictObj[\"devicePreserveConfig\"]\n        Wrapper.print(\"==========%s(): Start. Fabric = [%s], Serial [%s], # keys = [%d] Preserve = %s\" % \n                      (funcName, fabricName, devSerial, len(gVarDictObj), preserveConfig))\n\n        topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(fabricName)))\n        model = topologyDataObj.get(TopologyInfoType.SWITCH_MODEL, devSerial)\n        hostName = topologyDataObj.get(TopologyInfoType.HOSTNAME, devSerial)\n        mgmtIp = topologyDataObj.get(TopologyInfoType.MGMT_IP, devSerial)\n        isV6 = isIpv6Addr(mgmtIp)\n        fabricSettings = Util.exe(FabricWrapper.get(fabricName)).getNvPairs()\n        ff = fabricSettings.get(\"FF\")\n        inbandMgmtFlag = fabricSettings.get(\"INBAND_MGMT\", \"false\")\n        seedIp = Util.exe(Helper.getSeedIp(devSerial))\n        dcnmUser = gVarDictObj[\"dcnmUser\"]\n        \n        Wrapper.print(\"%s(): FF [%s] User [%s] Switch Serial/Name/Mgmt IP/Seed IP = [%s/%s/%s] InbandMgmt [%s]\" % (funcName,\n                    ff, dcnmUser, devSerial, mgmtIp, seedIp, inbandMgmtFlag))        \n\n        if not preserveConfig:\n            # greenfield\n            # For n7k, if admin/default VDC, then dont do any clean up. For user VDC, always do cleanup without reload.\n            #adminVDC = False\n            #userVDC = False\n            isN7k = True if model.startswith(\"N7\") else False\n                #if \":\" in devSerial:\n                #    Wrapper.print(\"%s(): Detected N7k user VDC %s\" %(funcName, devSerial))\n                #    userVDC = True\n                #else:\n                #    Wrapper.print(\"%s(): Detected N7k admin VDC %s\" %(funcName, devSerial))\n                #    adminVDC = True\n            \n            setMigrationState(fabricName, devSerial, {\"POST_ADD\":\"true\", \"UNDERLAY\" : \"true\"}, \"Greenfield Add\")\n\n            if ff == \"Easy_Fabric_IPFM\":\n                is9300, is9400, is9500, is9800 = Util.isIPFMDevice(topologyDataObj, devSerial)\n                isN9kv = Util.isN9kv(topologyDataObj, devSerial)\n                if not (is9300 or is9400 or is9500 or is9800 or isN9kv):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Import\"),\n                                           \"This is not a supported platform for IPFM. Please delete the switch from the fabric\", devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n\n            ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"import_in_progress\"))\n            if len(ptiList) > 0:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Import\"),\n                                       \"Switch import is not yet completed, please wait for switch import to finish then perform Recalculate & Deploy\", devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n            PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.SIM_PTI, \"import_in_progress\", {})\n\n            #Do clean up only if inband mgmt knob is disabled\n            if inbandMgmtFlag != \"true\":\n              if isN7k:\n                  switchCleanupWithoutReloadN7k(devSerial, dcnmUser)\n              elif gVarDictObj[\"GRFIELD_DEBUG_FLAG\"] == \"Enable\":\n                  t1 = datetime.datetime.now()\n                  respObj = switchCleanupWithoutReload(devSerial, dcnmUser)\n                  t2 = datetime.datetime.now()\n                  if respObj.isRetCodeFailure():\n                      delImportProgressPti(devSerial)\n                      Wrapper.print (\"%s(): *****SWITCH CLEANUP ABORTED***** at %s (took %s)\"% (funcName, t2, (t2-t1)))\n                      return respObj\n                  Wrapper.print (\"%s(): *****SWITCH CLEANUP COMPLETED***** at %s (took %s)\"% (funcName, t2, (t2-t1)))            \n\n            mt1 = datetime.datetime.now()\n            Wrapper.print (\"%s(): ******MIN INTENT LEARNING STARTED***** at %s\"% (funcName, mt1))\n\n            sshObj = None\n            try:\n                sshObj = Util.exe(getOptSSHConnection(fabricName, devSerial, dcnmUser))\n            except Exception as e:\n                delImportProgressPti(devSerial)\n                Wrapper.print(\"%s(): Failed to get SSH connection for : [%s] [%s]. Will skip\" % \n                              (funcName, devSerial, str(e)))\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":SSH\"),\n                                       \"Failed to get SSH connection. \"\n                                       \"Please ensure LAN credentials and retry Recalculate & Deploy\", devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n\n            try:\n                gVarDictObj[\"deviceSSHConnObj\"] = sshObj\n                gVarDictObj[\"deviceSerial\"] = devSerial\n                gVarDictObj[\"IMPORT_FILE_BASE_DIR\"] = Util.getBrownfieldDir()\n                gVarDictObj[\"POLICY_TEMPLATE_BASE_DIR\"] = POLICY_TEMPLATE_BASE_DIR\n                # Wrapper.print(\"%s(): [%s] Getting 'show run'\" % (funcName, devSerial))\n                valid, shRunFileName = createBasicGFIntent(gVarDictObj, False, respObj, inbandMgmtFlag)\n                \n                if not valid:\n                    delImportProgressPti(devSerial)\n                    Wrapper.print(\"%s(): Error creating basic Intent for [%s]\"%(funcName, devSerial))\n                    #respObj.addErrorReport(getFabErrEntity(funcName, devSerial), \n                                            #\"Error while creating the basic intents for device, \"\n                                            #\"Please retry configSave/Deploy\", devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                #Handle scenario for GF add when Inband Mgmt is enabled\n                #Switch can be discovered via mgmt0 or via a front-panel port. So handle both.\n                #Currently inbandMgmt is only for Easy_Fabric\n                if inbandMgmtFlag != \"true\":\n                  #clean switch for non-inband mgmt scenarios\n                  if gVarDictObj[\"GRFIELD_DEBUG_FLAG\"] != \"Enable\" and not isN7k:\n                      t1 = datetime.datetime.now()\n                      respObj = switchCleanupWithReload(gVarDictObj)\n                      t2 = datetime.datetime.now()\n                      if respObj.isRetCodeFailure():\n                          delImportProgressPti(devSerial)\n                          Wrapper.print (\"%s(): *****SWITCH CLEANUP ABORTED***** at %s (took %s)\"% (funcName, t2, (t2-t1)))\n                          return respObj\n                      Wrapper.print (\"%s(): *****SWITCH CLEANUP COMPLETED***** at %s (took %s)\"% (funcName, t2, (t2-t1)))\n            except Exception as e:\n                delImportProgressPti(devSerial)\n                Wrapper.print(\"%s(): Exception matching running: [%s]\" % (funcName, repr(e)))\n                #respObj.addErrorReport(getFabErrEntity(funcName, devSerial), \n                #                       \"Error in older configuration clean up for switch. \"\n                #                       \"Please retry Recalculate & Deploy\", devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n            finally:\n                Wrapper.print(\"%s(): Closing SSH connection\"%(funcName))\n                gVarDictObj[\"deviceSSHConnObj\"].close()\n                del gVarDictObj[\"deviceSSHConnObj\"]\n                sshObj = None\n\n            if ff != \"Easy_Fabric_IPFM\":\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                                   ConfigPriority.CONFIG_PRIO_TOP, \"pre_config\", {}))\n\n                if isTCAMAllocationEnable(devSerial, fabricSettings):\n                    # If the device is a modular switch, its default switch role is spine.\n                    # No need to do tcam carving on a spine until its switch role is changed\n                    # to some other role when the switch is ready for Recalculate & Deploy.\n                    if not Util.isModularN9k(model) and Util.isN9kT2Vtep(topologyDataObj, devSerial):\n                        # Configure the ARP-ETHER TCAM for VxLAN as the device can be a VTEP\n                        # This requires an existing TCAM region to free up space for ARP-ETHER; therefore,\n                        # tcam_pre_config_9300/9500 must be configured before tcam_pre_config_vxlan\n                        #\n                        # Special case for the Nexus 9332PQ as it uses the same default allocation as the Nexus 9500\n                        if \"C9332PQ\" in model:\n                            Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                               ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1,\n                                                               \"tcam_pre_config_9500\", {}))\n                        else:\n                            Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                               ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1,\n                                                               \"tcam_pre_config_9300\", {}))\n                        Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2,\n                                                           \"tcam_pre_config_vxlan\", {}))\n\n            if ff == \"Easy_Fabric_IPFM\":\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                                   ConfigPriority.CONFIG_PRIO_TOP, \"base_feature_ipfm\", {})) \n\n            mt2 = datetime.datetime.now()\n            Wrapper.print (\"%s(): ******MIN INTENT LEARNING AND CREATION COMPLETED for [%s]***** at %s (took %s)\"% (funcName, devSerial, mt2, (mt2-mt1)))\n\n            #TODO: Is this really required. Skipping it for inband mgmt and inband POAP scenarios.\n            if inbandMgmtFlag != \"true\":\n              if gVarDictObj[\"DHCP_ENABLE\"] == \"true\":\n                  DHCPUtil.dhcpDeviceBlock(DHCPUtil.ADD_HOST, fabricName, devSerial, mgmtIp, gVarDictObj[\"MGMT_GW\"])\n\n            # create the jumbo mtu PTI to match the fabric setting and the l2 host intf mtu will be computed correctly\n            mtuVal = gVarDictObj[\"L2_HOST_INTF_MTU\"]\n            Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n                \"system_jumbomtu\", {\"MTU\" : mtuVal}))\n\n            # create the internal PTI to track the switch jumbomtu setting\n            Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n                \"switch_mtu_state\", {\"JUMBO_MTU_VAL\" : mtuVal}))\n\n            dcnmSNMPInfo = Util.exe(FabricWrapper.getSNMPTrapInfo())\n            dictObj = {\"FABRIC_NAME\" : fabricName, \"SERIAL\" : devSerial,\n                        \"FABRIC_SETTINGS\" : fabricSettings, \"SNMP_INFO\" : dcnmSNMPInfo}\n            Util.processRespObj(respObj, PTI.executePyTemplateMethod(\"fabric_utility_11_1\", dictObj, \"manageSnmpTrapHostPolicy\"))\n\n            allPhyInterfaces = Util.exe(IM.get(InterfaceTypeEnum.ALL_PHY, fabricName, devSerial))\n            fexInterfaces = Util.exe(IM.get(InterfaceTypeEnum.ALL_HIF, fabricName, devSerial))\n            subIntf = Util.exe(IM.get(InterfaceTypeEnum.SUBINTF, fabricName, devSerial))\n            hostInterfaces = list(set(allPhyInterfaces) - set(subIntf) - set(fexInterfaces))\n      \n            if ff == \"Easy_Fabric_IPFM\":\n                hostTemplateName = \"int_ipfm_l3_port\"\n                nvPairs = {\n                           \"INTF_VRF\" : \"default\",\n                           \"IP\" : \"\",\n                           \"PREFIX\" : \"\",\n                           \"ROUTING_TAG\" : \"\",\n                           \"MTU\": \"9216\",\n                           \"SPEED\": \"Auto\",\n                           \"PTP\": \"false\",\n                           \"PTP_PROFILE\": \"\",\n                           \"BW_CAPACITY_PERCENT\": \"\",\n                           \"UCAST_BW_PERCENT\": \"\",\n                           \"WAN_LINK\": \"false\",\n                           \"BORDER_ROUTER\": \"false\",\n                           \"DESC\": \"\",\n                           \"CONF\": \"\",\n                           \"ADMIN_STATE\": \"true\",\n                           \"GF\": \"\"\n                          }\n            else:\n                hostTemplateName = \"int_trunk_host\"\n                nvPairs = {\n                           \"BPDUGUARD_ENABLED\": \"no\",\n                           \"PORTTYPE_FAST_ENABLED\": \"true\",\n                           \"MTU\": MTU_STR_JUMBO,\n                           \"SPEED\": \"Auto\",\n                           \"ALLOWED_VLANS\": \"none\",\n                           \"DESC\": \"\",\n                           \"CONF\": \"\",\n                           \"ADMIN_STATE\": fabricSettings.get(\"HOST_INTF_ADMIN_STATE\", \"true\"),\n                           \"GF\":\"\",\n                           \"PTP\":\"false\",\n                           \"ENABLE_NETFLOW\": \"false\",\n                           \"NETFLOW_MONITOR\": \"\"\n                          }\n\n            if ff != \"Easy_Fabric_Classic\":\n                # If fabric is Easy Classic, do not attach interface policies to host interfaces in postAdd().\n                # It's because agg/access has different config for PORTTYPE_FAST_ENABLED.\n                # Let the first R&D take care of the host interface config when switch role is known.\n                for hostIntf in hostInterfaces:\n                    nvPairs.update({\"INTF_NAME\": hostIntf})\n                    Util.exe(PTI.createOrUpdate(devSerial, \"INTERFACE\", hostIntf, \"\",\n                             ConfigPriority.trunk_host, hostTemplateName, nvPairs))\n\n            Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1,\n                                        \"ptp_sim\", {\"FEATURE_PTP\":\"false\"}))\n            delMigrationState(fabricName, devSerial)\n            delImportProgressPti(devSerial)\n        else:\n            putSwitchIntoBfMigrMode(fabricName, devSerial)\n            #TODO: Is this really required. Skipping it for inband mgmt and inband POAP scenarios.\n            if inbandMgmtFlag != \"true\":\n              if gVarDictObj[\"DHCP_ENABLE\"] == \"true\":\n                  DHCPUtil.dhcpDeviceBlock(DHCPUtil.ADD_HOST, fabricName, devSerial, mgmtIp, gVarDictObj[\"MGMT_GW\"])            \n            cleanupBrownfieldImportData(fabricName, devSerial, respObj)\n    except Exception as e:\n        delImportProgressPti(devSerial)\n        Wrapper.print(\"%s(): Fabric = [%s], Serial [%s]. Exception [%s]\" % (funcName, fabricName, devSerial, traceback.format_exc()))\n        msg = (\"Switch [%s]: Unexpected error during post add processing\" % (devSerial))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":POST_ADD\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        Wrapper.print(\"==========%s(): Done. Fabric = [%s], Serial [%s]. Success = [%r]\" % (funcName, fabricName, devSerial, respObj.isRetCodeSuccess()))\n        respObj.setValue(respObj)\n        return respObj\n\ndef getRunConfFileName(isShRunAll):\n    return ('bootflash:EASY-SW-RUNNING-CONFIG_ALL' if isShRunAll else 'bootflash:EASY-SW-RUNNING-CONFIG')\n\ndef getMinRunConfigFileName(isShRunAll):\n    return ('bootflash:ef-minimum-config_all' if isShRunAll else 'bootflash:ef-minimum-config')\n\ndef createMgmtVrfPti(devSerial, cfg):\n    Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_VRF_MANAGEMENT,\n                               \"switch_freeform\", {\"CONF\": cfg}, GF_MGMT_VRF_FF_PTI_DESC))\n\ndef noSwitchDiskSpaceError(devSerial, respObj):\n    errorMsg = (\"Capturing base configuration of the device failed possibly due to not \"\n                \"enough space in bootflash. Please check the bootflash usage and delete unused files. \"\n                \"Once space is freed up, please retry adding the switch to the fabric.\")\n    respObj.addErrorReport(devSerial + \": No Disk Space\", errorMsg, devSerial)\n    respObj.setFailureRetCode()\n\ndef createBasicGFIntent(gVarDictObj, isShRunAll, respObj, inbandMgmtFlag):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = gVarDictObj[\"deviceSerial\"]\n    fabricName = gVarDictObj[\"FABRIC_NAME\"]\n    \n    switchBaseDir = getSwitchBaseDir(devSerial, fabricName, gVarDictObj[\"IMPORT_FILE_BASE_DIR\"])\n    Wrapper.print(\"%s(): START: Fabric [%s] device [%s] switchBaseDir [%s]\" % (funcName, fabricName, devSerial, switchBaseDir))\n\n    if not os.path.exists(switchBaseDir):\n        os.makedirs(switchBaseDir)\n\n    sshObj = gVarDictObj['deviceSSHConnObj']\n\n    fileName = switchBaseDir + \"show_run_all\" if isShRunAll else switchBaseDir + \"show_run\"\n    runCfgFileName = getRunConfFileName(isShRunAll)\n    minCfgFileName = getMinRunConfigFileName(isShRunAll)\n    delRunConfFileCmd = 'delete ' + runCfgFileName + \" no\"\n    delMinConfFileCmd = 'delete ' + minCfgFileName + \" no\"\n    showRunToFileCmd = 'show running-config' + (' all' if isShRunAll else '') + ''' > ''' + runCfgFileName\n    shFile = \"show file \"\n    shCfgFileName = shFile + runCfgFileName\n\n    cmdList1 = [\n                shCfgFileName + ''' | i '^hostname' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | i '^switchname' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | i '^no password strength' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | i '^username' | i password | i role >> ''' + minCfgFileName,\n                shCfgFileName + ''' | i '^ssh key rsa' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | i '^hardware profile portmode' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | section '^feature tacacs' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | section '^interface breakout module' >> ''' + minCfgFileName\n               ]\n    cmdList2 = [\n                shCfgFileName + ''' | section '^radius' ''',\n                shCfgFileName + ''' | section '^ip tacacs' ''',\n                shCfgFileName + ''' | section '^tacacs' ''',\n                shCfgFileName + ''' | section '^aaa' ''',\n                shCfgFileName + ''' | section '^vrf context management' ''',\n                shCfgFileName + ''' | section '^interface mgmt0' ''',\n                ]\n    Wrapper.print(\"%s(): device %s cmdList1 [%s] and cmdList2 [%s]\" % (funcName, devSerial, \",\".join(cmdList1), \",\".join(cmdList2)))\n    cmd = cmdOut1 = cmdOut2 = aaaConfig = \"\"\n    sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n    errorCmd = \"\"\n    try:\n        firstCmdOut = getSSHCmdOuput(devSerial, sshObj, delMinConfFileCmd, sshConnReadTimeout)\n        if \"Permission denied\" in firstCmdOut:\n            errorMsg = (\"Switch [%s]: Insufficient privileges to read switch configuration. \"\n                        \"Please change the discovery user role to have network-admin privileges and \"\n                        \"retry Recalculate & Deploy.\" % devSerial)\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n        getSSHCmdOuput(devSerial, sshObj, delRunConfFileCmd, sshConnReadTimeout)\n\n        # save current switch running config to file\n        cmdOut = getSSHCmdOuput(devSerial, sshObj, showRunToFileCmd, sshConnReadTimeout)\n        if NO_DISK_SPACE_ERR_MSG in cmdOut.lower():\n            noSwitchDiskSpaceError(devSerial, respObj)\n            return respObj\n\n        for cmd in cmdList1:\n            errorCmd = cmd\n            cmdOut = getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout)\n\n            # we may run out of disk space as we append contents.. check for the condition\n            if NO_DISK_SPACE_ERR_MSG in cmdOut.lower():\n                noSwitchDiskSpaceError(devSerial, respObj)\n                return respObj\n            \n        cmd = shFile + minCfgFileName \n        errorCmd = cmd\n        cmdOut1 = getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout)\n        minCmdOpList = cmdOut1.splitlines()\n\n        PTI.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"nfm_switch_user\")\n        PTI.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_user_with_expiry\")\n        for op in minCmdOpList:\n            if op.startswith(\"hostname\"):\n                errorCmd = \"hostname\"\n                hostname = op[8:].strip()\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                      ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                      \"host_11_1\", {\"SWITCH_NAME\": hostname}))\n            if op.startswith(\"switchname\"):\n                errorCmd = \"switchname\"\n                switchname = op[10:].strip()\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                   \"switchnm_11_1\", {\"SWITCH_NAME\": switchname}))\n            if op.startswith(\"ssh key rsa\"):\n                errorCmd = \"ssh key rsa\"\n                rsaBits = op.lstrip(\"ssh key rsa \")\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                   \"ssh_key_rsa_force\", {\"BITS\": rsaBits}))\n            if op.startswith(\"hardware profile portmode\"):\n                errorCmd = \"hardware profile mode\"\n                portMode = op.lstrip(\"hardware profile portmode \")\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                   \"hardware_profile_port_mode\", {\"PORT_MODE\": portMode}))\n            if op.startswith(\"no password strength\"):\n                errorCmd = \"no password strength\"\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                   \"password_no_strength\", {}))\n            if op.startswith(\"feature tacacs\"):\n                errorCmd = \"feature tacacs\"\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                   \"feature_tacacs\", {}))\n            if op.startswith(\"username\") and \"password\" in op:\n                errorCmd = \"username\"\n                usrNameCmdOut = op\n                usersDict = {}\n                templateName = \"\"\n                isExpirySet = isError = False\n                try:\n                    usrNameCmdList = filter(None, usrNameCmdOut.splitlines())\n                    for cmd in usrNameCmdList:\n                        unameNvPairs = {}\n                        un = filter(None, cmd.split(\" \"))\n                        if \"expire\" not in un and len(un) == 7:\n                            unameNvPairs = {\"USERNAME\": un[1], \"PASSWORD_ENCRYPT\":un[4], \"USER_ROLE\":un[6]}\n                            usersDict.update({un[1]: unameNvPairs})\n                            templateName = \"nfm_switch_user\"\n                        elif len(un) == 9:\n                            unameNvPairs = {\"USERNAME\": un[1], \"PASSWORD_ENCRYPT\":un[4], \"EXPIRE_TIME\":un[6], \"USER_ROLE\":un[8]} \n                            usersDict.update({un[1]: unameNvPairs})\n                        else:\n                            isError = True\n                            break\n                except:\n                    isError = True\n                if isError:\n                    respObj.addErrorReport(funcName + devSerial, \"Error during (%s) intent creation. \"\n                                           \"Please check and correct username configuration on the switch and retry Recalculate & Deploy.\"%(errorCmd), devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                for user in usersDict: \n                    unameNvPairs = usersDict.get(user)\n                    if \"EXPIRE_TIME\" not in unameNvPairs:\n                        templateName = \"nfm_switch_user\"\n                    else:\n                        templateName = \"switch_user_with_expiry\"\n                    Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, templateName, unameNvPairs))\n\n            if op.startswith('interface breakout module'):\n                errorCmd = \"interface breakout module\"\n                brkOutFFCmds = []\n                brkOutCmdList = op.splitlines() \n                for cmd in brkOutCmdList:\n                    breakoutInfoList = cmd.split(\"interface breakout \")[1].split(\" \") \n                    brkoutSlot = brkoutMap = brkoutPorts = \"\"\n                    Wrapper.print(\"%s(): breakoutInfoList [%s]\" % (funcName, breakoutInfoList))\n                    if len(breakoutInfoList) < 6:\n                        # Do not have map and/or ports in the breakout command, capture the command in freeform\n                        # Modular chassis N9K-C950x allows a breakout command without port/map\n                        brkOutFFCmds.append(cmd)\n                        continue\n                    if breakoutInfoList:\n                        brkoutSlot = breakoutInfoList[1]\n                        brkoutMap = breakoutInfoList[5]\n                        brkoutPorts = getIntegerRange(breakoutInfoList[3])\n                        Wrapper.print(\"%s(): brkoutSlot = [%s], brkoutMap = [%s], brkoutPorts = [%s]\" % (funcName, brkoutSlot, brkoutMap, brkoutPorts))\n                    for port in brkoutPorts:\n                        nvPairs = {}\n                        nvPairs.update({\"SLOT\":brkoutSlot})\n                        nvPairs.update({\"MAP\":brkoutMap})\n                        nvPairs.update({\"PORT\":str(port)})\n                        entityName = \"Ethernet\" + nvPairs[\"SLOT\"] + \"/\" + nvPairs[\"PORT\"]\n                        ptiSource = getSrc(\"breakout_interface\")\n                        Wrapper.print(\"%s:() Entity Name [%s] nvPairs [%s]\" % (funcName, entityName, nvPairs))\n                        # create individual PTIs for each port\n                        createPTI(devSerial, nvPairs, \"breakout_interface\", entityName, ptiSource, -1)\n                \n                ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n                for pti in ptiList:\n                    if pti.getDescription() == \"Additional Breakout Configuration\":\n                        PTI.deleteInstance(pti.getPolicyId())\n                if len(brkOutFFCmds) > 0:\n                    Wrapper.print(\"%s(): brkOutFFCmds %s\" % (funcName, brkOutFFCmds))\n                    Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_TOP,\n                                               \"switch_freeform\", {\"CONF\": Util.newLine().join(brkOutFFCmds)},\n                                               \"Additional Breakout Configuration\"))\n                    \n        for cmd in cmdList2:\n            errorCmd = cmd\n            cmdOut2 = getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout)\n            if \"interface mgmt0\" in cmd:\n                if (len(cmdOut2) == 0):\n                    noSwitchDiskSpaceError(devSerial, respObj)\n                    return respObj\n                if cmdOut2 and cmdOut2.startswith(\"interface mgmt0\"):\n                    intfName = \"mgmt0\"\n                    cdpEnable = \"true\"\n                    mgmtCmdList = cmdOut2.split(Util.newLine())\n                    for op in mgmtCmdList:\n                        if \"no cdp enable\" in op.strip():\n                            cdpEnable = \"false\"\n                            break\n                    mgmtCmdList = filter(None, mgmtCmdList)\n                    descCmdList = filter(lambda x: \"description\" in x, mgmtCmdList)\n                    desc = descCmdList[0].strip()[12:].strip() if len(descCmdList) > 0 else \"\"\n                    intFreeFormCmdList = filter(lambda x: \"interface mgmt0\" not in x, mgmtCmdList)\n                    intFreeFormCmdList = filter(lambda x: \"cdp\" not in x, intFreeFormCmdList)\n                    intFreeFormCmdList = filter(lambda x: \"vrf member management\" not in x, intFreeFormCmdList)\n                    intFreeFormCmdList = filter(lambda x: \"description\" not in x, intFreeFormCmdList)\n                    intFreeFormCmdList = filter(lambda x: \"shut\" not in x, intFreeFormCmdList)\n    \n                    Wrapper.print(\"%s(): cdp enable %s for: %s\" % (funcName, cdpEnable, devSerial))\n    \n                    nvPairs = {\"CONF\":\"\"}\n                    nvPairs.update({\"CONF\": Util.newLine().join(intFreeFormCmdList)})\n                    Wrapper.print(\"%s(): NV pairs: %s\" %(funcName, str(nvPairs.get(\"CONF\"))))\n                    Util.exe(PTIWrapper.createOrUpdate(devSerial, \"INTERFACE\", \"mgmt0\", \"\", ConfigPriority.INTF_MGMT, \"int_mgmt\",\n                                                       {\"INTF_NAME\": \"mgmt0\",\n                                                        \"CDP_ENABLE\":cdpEnable, \n                                                        \"ADMIN_STATE\": \"true\", \n                                                        \"DESC\":desc,\n                                                        \"CONF\":nvPairs.get(\"CONF\")}))\n                else:\n                    errString = (\"Error reading the switch configuration for cmd [%s]. Response from switch = [%s], please retry Recalculate & Deploy.\" % (cmd, cmdOut2))\n                    Wrapper.print(errString)\n            if \"vrf context management\" in cmd:\n                if (len(cmdOut2) == 0):\n                    noSwitchDiskSpaceError(devSerial, respObj)\n                    return respObj\n                if cmdOut2 and cmdOut2.startswith(\"vrf context management\"):\n                    Wrapper.print (\"mgmt vrf %s\"%(cmdOut2))\n                    cmdOut2filtered = cmdOut2\n                    vrfMgmtsplit = cmdOut2.splitlines()\n                    dnsServermgmt = \"\"\n                    PTI.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"dns-vrfList\")\n                    for mgmtLine in vrfMgmtsplit:\n                        if mgmtLine.strip().startswith(\"ip name-server\") and not \"use-vrf\" in mgmtLine.strip():\n                            dnsServermgmt = mgmtLine\n                            dnsIPServer = dnsServermgmt[17:].strip()\n                            Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_VRF_MANAGEMENT,\n                                                       \"dns-vrfList\",{\"NAME_SERVER_VRF\":MGMT_VRF_NAME, \"NAME_SERVER_ADDRESSLIST\":dnsIPServer}))\n                    if dnsServermgmt:                   \n                        cmdOut2filtered = Util.newLine().join(list(filter(lambda x: dnsServermgmt not in x, vrfMgmtsplit)))\n                    ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n                    for pti in ptiList:\n                        if pti.getDescription() == GF_MGMT_VRF_FF_PTI_DESC:\n                            PTI.deleteInstance(pti.getPolicyId())\n                    createMgmtVrfPti(devSerial, cmdOut2filtered)\n                else:\n                    errString = (\"Error reading the switch configuration for cmd [%s]. Response from switch = [%s], please retry Recalculate & Deploy.\" % (cmd, cmdOut2))\n                    Wrapper.print(errString)\n\n            if \"ip tacacs\" in cmd and \" ip tacacs\" in cmdOut2:\n                if aaaConfig:\n                    aaaConfig = aaaConfig + Util.newLine() + cmdOut2\n                else:\n                    aaaConfig += cmdOut2\n            if ((\"aaa\" in cmd and \"aaa\" in cmdOut2) or (\"radius\" in cmd and \"radius\" in cmdOut2) or (\"tacacs\" in cmd and \"tacacs\" in cmdOut2)):\n                if aaaConfig:\n                    aaaConfig = aaaConfig + Util.newLine() + cmdOut2\n                else:\n                    aaaConfig += cmdOut2\n        if aaaConfig:\n            errorCmd = \"AAA\"\n            ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n            for pti in ptiList:\n                if pti.getDescription() == \"NDFC AAA extra configuration\":\n                    PTI.deleteInstance(pti.getPolicyId())\n            Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.AAA_SWITCH_FF,\n                                       \"switch_freeform\", {\"CONF\": aaaConfig}, \n                                       \"NDFC AAA extra configuration\"))\n\n        cmdOut = cmdOut1 + cmdOut2\n        Wrapper.print(\"%s(): %s cmdOut [%s].\" % (funcName, devSerial, cmdOut))\n\n        cmdOut += getSSHCmdOuput(devSerial, sshObj, \"echo '!====Show run complete===='\", sshConnReadTimeout)\n        Wrapper.print(\"%s(): [%s] got cmd complete response. cmd out len = [%d]. First Line = [%s]\" %\n                      (funcName, devSerial, len(cmdOut), cmdOut.splitlines()[0]))\n\n    except Exception as e:\n        Wrapper.print(\"%s: [%s] Unexpected error getting switch cmd [%s] output . Exception = [%s]\" % (funcName, devSerial, cmd, traceback.format_exc()))\n        msg = (\"Switch [%s] - Error during configuration read or intent creation. Please resolve the errors and retry Recalculate & Deploy.\" % (devSerial))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":\" + funcName, msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n        return False, None\n\n    errString = None\n    if (len(cmdOut) < 64) or ('!====Show run complete====' not in cmdOut):\n        # unusually small size file.. something is wrong\n        Wrapper.print(\"%s: Possible invalid switch response = [%s] for SN [%s]\" % (funcName, cmdOut, devSerial))\n        errString = (\"Error reading the switch configuration. Response from switch = [%s], please retry Recalculate & Deploy.\" % (cmdOut))\n    else:\n        # check for error strings in the response which indicate an incomplete config\n        errorStrings = [\"did not respond within the expected timeframe\"]\n        for errorStr in errorStrings:\n            if errorStr in cmdOut:\n                errString = (\"Error response [%s] seen in output of command [%s]. Please retry Recalculate & Deploy.\" % (errorStr, cmd))\n                break\n    if errString:\n        respObj.setFailureRetCode()\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errString, devSerial)\n        return False, None\n    return True, fileName\n\ndef getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout):\n    funcName = sys._getframe(0).f_code.co_name\n\n    cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n    firstLine = \"\"\n    if len(cmdOut) > 0:\n        firstLine = cmdOut.splitlines()[0]\n    Wrapper.print(\"%s: Switch [%s]: Cmd [%s] Response: len = [%d]. First Line = [%s]\" %\n                  (funcName, devSerial, cmd, len(cmdOut), firstLine))  \n\n    return cmdOut\n\ndef getShowRun(gVarDictObj, fileName, cmd, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = gVarDictObj[\"deviceSerial\"]\n    devModel = gVarDictObj[\"devModel\"]\n\n    sshObj = gVarDictObj['deviceSSHConnObj']\n    sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n    try:\n        Wrapper.print(\"%s: [%s] Attempting to get [%s] response.\" % (funcName, devSerial, cmd))\n        if devModel.startswith(\"N\") and not devModel.endswith(\"v\"):\n            cmdOut = Util.exe(FabricWrapper.getCmdOutput(devSerial, cmd))\n            Wrapper.print(\"%s: [%s] got cmd [%s] response. cmd out len = [%d], cmd out lines = [%s]. First Line = [%s]\" %\n                      (funcName, devSerial, cmd, len(cmdOut), len(cmdOut.splitlines()), cmdOut.splitlines()[0]))\n            cmdOut += Util.newLine() + \"!====%s complete====\"%(cmd)\n        else:\n            cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n            Wrapper.print(\"%s: [%s] got cmd [%s] response. cmd out len = [%d], cmd out lines = [%s]. First Line = [%s]\" %\n                      (funcName, devSerial, cmd, len(cmdOut), len(cmdOut.splitlines()), cmdOut.splitlines()[0]))\n            cmdOut += sshObj.send(\"echo '!====%s complete===='\"%(cmd), sshConnReadTimeout)\n \n        Wrapper.print(\"%s: [%s] got cmd complete response. cmd out len = [%d]. First Line = [%s]\" %\n                      (funcName, devSerial, len(cmdOut), cmdOut.splitlines()[0]))\n    except Exception as e:\n        Wrapper.print(\"%s: [%s] Unexpected error getting switch cmd [%s] output . Exception = [%s]\" % (funcName, \n            devSerial, cmd, traceback.format_exc()))\n        Util.handleException((\"Switch [%s] - Error collecting [%s]. Please retry.\" % (devSerial, cmd)), e, respObj)\n        return False, None\n    \n    errString = None\n    if (len(cmdOut) < 512) or ('!====%s complete===='%(cmd) not in cmdOut):\n        # unusually small size file.. something is wrong\n        Wrapper.print(\"%s: [%s] Possible invalid switch response = [%s]\" % (funcName, devSerial, cmdOut))\n        errString = (\"Error reading the switch configuration. Please retry! Response from switch = [%s]\" % (cmdOut))\n    else:\n        # check for error strings in the response which indicate an incomplete config\n        errorStrings = [\"did not respond within the expected timeframe\"]\n        for errorStr in errorStrings:\n            if errorStr in cmdOut:\n                errString = (\"Error response [%s] seen in output of command [%s]. Please retry!\" % (errorStr, cmd))\n                break\n\n    if errString:\n        respObj.setFailureRetCode()\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errString, devSerial)\n        return False, None\n\n    cfgFile = None\n    try:\n        Wrapper.print(\"%s: [%s] Open file [%s]\" % (funcName, devSerial, fileName))\n        with open(fileName, \"w\") as cfgFile:\n            Wrapper.print(\"%s: [%s] Write to file [%s]\" % (funcName, devSerial, fileName))\n            cfgFile.write(cmdOut);\n            Wrapper.print(\"%s: [%s] Saved config to file [%s]\" % (funcName, devSerial, fileName))\n    except Exception as e:\n        Wrapper.print(\"%s: Unexpected error writing to file [%s]. Exception = [%s]\" % (funcName, fileName, repr(e)))\n        Util.handleException((\"Switch [%s] - Error saving the switch configuration to file [%s]. Please retry.\" % (devSerial, fileName)), e, respObj)\n        return False, None\n    return True, fileName\n\ndef getSwitchBaseDir(devSerial, fabricName, baseDir):\n    return baseDir + fabricName + \"/\" + devSerial + \"/\"\n\ndef writeToFile(fileName, text, respObj):\n    file = None\n    try:\n        file = open(fileName, \"w\")\n        file.write(text) \n    except Exception as e:\n        Wrapper.print(\"writeToFile: Exception. Filename = [%s], Exception [%s]\" % (fileName, traceback.format_exc()))\n        Util.handleException((\"Error writing to file [%s]\" % fileName), e, respObj)\n    finally:\n        if file != None:\n            Wrapper.print(\"writeToFile: closing file = [%s]\" % (fileName))\n            file.close()\n\n# The input files must exist\ndef doMatch(gVarDictObj, shRunFileName, shRunAllFileName, templateList, respObj, fabTech):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = gVarDictObj[\"deviceSerial\"]\n    \n    isShowRunFilePresent = os.path.isfile(shRunFileName)\n    isShowRunAllFilePresent = os.path.isfile(shRunAllFileName)\n    Wrapper.print(\"%s: %s [%s] Present [%s] [%s] Present [%s]\"% (funcName, devSerial,\n        shRunFileName, isShowRunFilePresent, shRunAllFileName, isShowRunAllFilePresent))\n\n    if not isShowRunFilePresent or not isShowRunAllFilePresent:\n        respObj.addErrorReport(funcName, \"One or more switch running config input files for template matching are not \"\n            \"present. Please check and retry.\", devSerial)\n        respObj.setFailureRetCode()\n        return None, None\n\n    #match the 'templateList' with switch config\n    Wrapper.print(\"[%s] : Start Matching %d templates\" % (devSerial, len(templateList)))\n    if fabTech != \"VLANFabric\":\n\t    matchParams = {\"devSerial\" : devSerial, \"runCfg\" : shRunFileName, \"runAllCfg\" : shRunAllFileName,\n\t\t\t   \"tmplBaseDir\" : gVarDictObj[\"POLICY_TEMPLATE_BASE_DIR\"], \"tmplList\" : templateList,\n\t\t\t   \"incIntfRes\" : True, \"incBrownfieldInfo\" : True, \n\t\t\t   \"exclTopCmds\" : ['config terminal', 'vdc','rmon',\n\t\t\t   'feature telemetry', 'feature icam', 'telemetry',\n\t\t\t   'feature analytics', 'flow exporter', 'flow record', 'flow monitor',\n\t\t\t   'flow profile', 'flow filter', 'flow system config', 'flow event'],\n\t\t\t   \"fabricName\" : gVarDictObj[\"FABRIC_NAME\"]\n\t    }\n    else:\n\t    matchParams = {\"devSerial\" : devSerial, \"runCfg\" : shRunFileName, \"runAllCfg\" : shRunAllFileName,\n\t\t\t   \"tmplBaseDir\" : gVarDictObj[\"POLICY_TEMPLATE_BASE_DIR\"], \"tmplList\" : templateList,\n\t\t\t   \"incIntfRes\" : True, \"incBrownfieldInfo\" : True, \n\t\t\t   \"exclTopCmds\" : ['config terminal', 'vdc','rmon',\n\t\t\t   'feature telemetry', 'feature icam', 'telemetry',\n\t\t\t   'feature analytics', \n\t\t\t   'flow profile', 'flow filter', 'flow system config', 'flow event'],\n\t\t\t   \"fabricName\" : gVarDictObj[\"FABRIC_NAME\"]\n\t    }\n\n    startTime = datetime.datetime.now()\n    matchResult = {}\n    interfacesRes = {}\n    try:\n        matchResult, interfacesRes = find_template_match(matchParams)\n    except Exception as e:\n        msg = (\"[%s] - Unexpected error matching templates\" % (devSerial))\n        Util.handleException(msg, e, respObj)\n        return None, None\n\n    endTime = datetime.datetime.now()\n\n    Wrapper.print(\"%s: [%s] Template Matching Results - Total time= %s seconds\" % \n                                (funcName, devSerial, (endTime - startTime)))\n    \"\"\"\n    Wrapper.print(json.dumps(matchResult, indent=4, sort_keys=True))\n    Wrapper.print(\"doMatch: [%s] Template Interface Matching Results:\" % devSerial)\n    Wrapper.print(json.dumps(interfacesRes, indent=4, sort_keys=True))\n    \"\"\"\n\n    return matchResult, interfacesRes\n\ndef updateGblDict(gVarDictObj, varName, varVal):\n    oldVal = gVarDictObj[varName]\n    gVarDictObj[varName] = varVal\n    Wrapper.print(\"updateGblDict: updated variable [%s] Val [%s] -> [%s]\" % (varName, oldVal, gVarDictObj[varName]))\n\ndef redefineGlobals(gVarDictObj):\n    global ACTIVE_MIGRATION\n    global FF, BGP_AS, FABRIC_NAME, ANYCAST_GW_MAC, REPLICATION_MODE, RP_MODE, RP_COUNT\n    global MULTICAST_GROUP_SUBNET, FABRIC_INTERFACE_TYPE, LINK_STATE_ROUTING, LINK_STATE_ROUTING_TAG, OSPF_AREA_ID\n    global ENABLE_FABRIC_VPC_DOMAIN_ID, FABRIC_VPC_DOMAIN_ID, VPC_PEER_LINK_VLAN, ENABLE_VPC_PEER_LINK_NATIVE_VLAN,VPC_PEER_LINK_ALL_VLAN_DISABLE\n    global POWER_REDUNDANCY_MODE, EXTRA_CONF_LEAF, EXTRA_CONF_SPINE, EXTRA_CONF_TOR\n    global BGP_LB_ID, NVE_LB_ID, ANYCAST_LB_ID, RP_LB_ID, PHANTOM_RP_LB_ID1, PHANTOM_RP_LB_ID2\n    global IBGP_PEER_TEMPLATE, IBGP_PEER_TEMPLATE_LEAF, BRFIELD_DEBUG_FLAG, GRFIELD_DEBUG_FLAG, SITE_ID\n    global VPC_ENABLE_IPv6_ND_SYNC, ENABLE_TRM\n    global BGP_AUTH_ENABLE, BGP_AUTH_KEY_TYPE, BGP_AUTH_KEY\n    global OSPF_AUTH_ENABLE, OSPF_AUTH_KEY_ID, OSPF_AUTH_KEY\n    global PIM_HELLO_AUTH_ENABLE, PIM_HELLO_AUTH_KEY\n    global ENABLE_TENANT_DHCP\n    global ISIS_LEVEL, ISIS_P2P_ENABLE, ISIS_AUTH_ENABLE, ISIS_AUTH_KEYCHAIN_NAME, ISIS_AUTH_KEYCHAIN_KEY_ID, ISIS_AUTH_KEY, ISIS_OVERLOAD_ENABLE, ISIS_OVERLOAD_ELAPSE_TIME\n    global BFD_ENABLE, BFD_IBGP_ENABLE, BFD_OSPF_ENABLE, BFD_ISIS_ENABLE, BFD_PIM_ENABLE, BFD_AUTH_ENABLE\n    global BFD_AUTH_KEY_ID, BFD_AUTH_KEY\n    global UNDERLAY_IS_V6, USE_LINK_LOCAL, EXTRA_CONF_INTRA_LINKS, BROWNFIELD_NETWORK_NAME_FORMAT, BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS\n    global FEATURE_PTP, FEATURE_PTP_INTERNAL, PTP_VDC_ID, PTP_DOMAIN_ID \n    global ENABLE_DEFAULT_QUEUING_POLICY, DEAFULT_QUEUING_POLICY_CLOUDSCALE, DEAFULT_QUEUING_POLICY_R_SERIES, DEAFULT_QUEUING_POLICY_OTHER\n    global TCAM_ALLOCATION, OVERLAY_MODE, FHRP_PROTOCOL, VRF_LITE_PROTOCOL\n    global OSPFv3_ROUTING_TAG, OSPFv3_AREA_ID\n\n    ACTIVE_MIGRATION        = gVarDictObj[\"ACTIVE_MIGRATION\"]\n    FF                      = gVarDictObj[\"FF\"]\n    BGP_AS                  = gVarDictObj.get(\"BGP_AS\", \"\")\n    FABRIC_NAME             = gVarDictObj[\"FABRIC_NAME\"]\n    ANYCAST_GW_MAC          = gVarDictObj.get(\"ANYCAST_GW_MAC\", \"\")\n    REPLICATION_MODE        = gVarDictObj.get(\"REPLICATION_MODE\", \"\")\n    RP_MODE                 = gVarDictObj.get(\"RP_MODE\", \"asm\")\n    RP_COUNT                = gVarDictObj.get(\"RP_COUNT\", \"2\")\n    MULTICAST_GROUP_SUBNET  = gVarDictObj.get(\"MULTICAST_GROUP_SUBNET\",\"239.1.1.0/25\")\n    FABRIC_INTERFACE_TYPE   = gVarDictObj.get(\"FABRIC_INTERFACE_TYPE\", \"\")\n    LINK_STATE_ROUTING      = gVarDictObj.get(\"LINK_STATE_ROUTING\", \"\")\n    LINK_STATE_ROUTING_TAG  = gVarDictObj.get(\"LINK_STATE_ROUTING_TAG\", \"\")\n    OSPF_AREA_ID            = gVarDictObj.get(\"OSPF_AREA_ID\", \"0.0.0.0\")\n    ENABLE_TRM              = gVarDictObj.get(\"ENABLE_TRM\", \"false\")\n    VPC_PEER_LINK_VLAN      = gVarDictObj.get(\"VPC_PEER_LINK_VLAN\", \"3600\")\n    ENABLE_VPC_PEER_LINK_NATIVE_VLAN = gVarDictObj.get(\"ENABLE_VPC_PEER_LINK_NATIVE_VLAN\", \"false\")\n    VPC_PEER_KEEP_ALIVE_OPTION =  gVarDictObj.get(\"VPC_PEER_KEEP_ALIVE_OPTION\", MGMT_VRF_NAME)\n    VPC_ENABLE_IPv6_ND_SYNC = gVarDictObj.get(\"VPC_ENABLE_IPv6_ND_SYNC\", \"true\")\n    ENABLE_FABRIC_VPC_DOMAIN_ID = gVarDictObj.get(\"ENABLE_FABRIC_VPC_DOMAIN_ID\", \"false\")\n    FABRIC_VPC_DOMAIN_ID    = gVarDictObj.get(\"FABRIC_VPC_DOMAIN_ID\", \"\")\n    if ENABLE_FABRIC_VPC_DOMAIN_ID == \"false\":\n        FABRIC_VPC_DOMAIN_ID = \"\"\n\n    POWER_REDUNDANCY_MODE   = gVarDictObj[\"POWER_REDUNDANCY_MODE\"]\n    EXTRA_CONF_LEAF         = gVarDictObj.get(\"EXTRA_CONF_LEAF\", \"\")\n    EXTRA_CONF_SPINE        = gVarDictObj.get(\"EXTRA_CONF_SPINE\", \"\")\n    EXTRA_CONF_TOR          = gVarDictObj.get(\"EXTRA_CONF_TOR\", \"\")\n    BGP_LB_ID               = gVarDictObj.get(\"BGP_LB_ID\", \"\")\n    NVE_LB_ID               = gVarDictObj.get(\"NVE_LB_ID\", \"1\")\n    ANYCAST_LB_ID           = gVarDictObj.get(\"ANYCAST_LB_ID\", \"\")\n    RP_LB_ID                = gVarDictObj.get(\"RP_LB_ID\", \"254\")\n    PHANTOM_RP_LB_ID1       = gVarDictObj.get(\"PHANTOM_RP_LB_ID1\", \"2\")\n    PHANTOM_RP_LB_ID2       = gVarDictObj.get(\"PHANTOM_RP_LB_ID2\", \"3\")\n    BRFIELD_DEBUG_FLAG      = gVarDictObj[\"BRFIELD_DEBUG_FLAG\"]\n    GRFIELD_DEBUG_FLAG      = gVarDictObj[\"GRFIELD_DEBUG_FLAG\"]\n    IBGP_PEER_TEMPLATE      = gVarDictObj.get(\"IBGP_PEER_TEMPLATE\", \"\")\n    IBGP_PEER_TEMPLATE_LEAF = gVarDictObj.get(\"IBGP_PEER_TEMPLATE_LEAF\", \"\")\n    UNDERLAY_IS_V6          = gVarDictObj.get(\"UNDERLAY_IS_V6\", \"false\")\n\n    BGP_AUTH_ENABLE         = gVarDictObj.get(\"BGP_AUTH_ENABLE\", \"false\")\n    BGP_AUTH_KEY_TYPE       = gVarDictObj.get(\"BGP_AUTH_KEY_TYPE\", \"3\")\n    OSPF_AUTH_ENABLE        = gVarDictObj.get(\"OSPF_AUTH_ENABLE\", \"false\")\n    OSPF_AUTH_KEY_ID        = gVarDictObj.get(\"OSPF_AUTH_KEY_ID\", \"127\")\n    if BGP_AUTH_ENABLE != \"true\":\n        # ignore the auth key\n        BGP_AUTH_KEY = \"\"\n    else:\n        BGP_AUTH_KEY        = gVarDictObj.get(\"BGP_AUTH_KEY\", \"\")\n\n    if OSPF_AUTH_ENABLE != \"true\":\n        # ignore the auth key\n        OSPF_AUTH_KEY = \"\"\n    else:\n        OSPF_AUTH_KEY       = gVarDictObj.get(\"OSPF_AUTH_KEY\", \"\")\n    \n    if ((REPLICATION_MODE == \"Multicast\") and (UNDERLAY_IS_V6 == \"false\")):\n        PIM_HELLO_AUTH_ENABLE   = gVarDictObj.get(\"PIM_HELLO_AUTH_ENABLE\", \"false\")\n    else:\n        PIM_HELLO_AUTH_ENABLE = \"false\"\n\n    if PIM_HELLO_AUTH_ENABLE == \"true\":\n        PIM_HELLO_AUTH_KEY = gVarDictObj.get(\"PIM_HELLO_AUTH_KEY\", \"\")\n    else:\n        PIM_HELLO_AUTH_KEY = \"\"\n\n    ISIS_LEVEL                  = gVarDictObj.get(\"ISIS_LEVEL\", \"level-2\")\n    ISIS_P2P_ENABLE             = gVarDictObj.get(\"ISIS_P2P_ENABLE\", \"true\")\n    ISIS_AUTH_ENABLE            = gVarDictObj.get(\"ISIS_AUTH_ENABLE\", \"false\")\n    ISIS_AUTH_KEYCHAIN_KEY_ID   = gVarDictObj.get(\"ISIS_AUTH_KEYCHAIN_KEY_ID\", \"127\")\n    if ISIS_AUTH_ENABLE != \"true\":\n        # ignore the auth key\n        ISIS_AUTH_KEY = \"\"\n        ISIS_AUTH_KEYCHAIN_NAME = \"\"\n    else:\n        ISIS_AUTH_KEYCHAIN_NAME = gVarDictObj.get(\"ISIS_AUTH_KEYCHAIN_NAME\", \"\")\n        ISIS_AUTH_KEY           = gVarDictObj.get(\"ISIS_AUTH_KEY\", \"\")\n    ISIS_OVERLOAD_ENABLE        = gVarDictObj.get(\"ISIS_OVERLOAD_ENABLE\", \"true\")\n    ISIS_OVERLOAD_ELAPSE_TIME   = gVarDictObj.get(\"ISIS_OVERLOAD_ELAPSE_TIME\", \"60\")\n\n    if LINK_STATE_ROUTING == \"ospf\":\n        ISIS_AUTH_ENABLE = \"false\"\n    elif LINK_STATE_ROUTING == \"is-is\":\n        OSPF_AUTH_ENABLE = \"false\"\n    \n    ENABLE_TENANT_DHCP          = gVarDictObj.get(\"ENABLE_TENANT_DHCP\", \"true\")\n    USE_LINK_LOCAL              = gVarDictObj.get(\"USE_LINK_LOCAL\", \"true\")\n\n    FEATURE_PTP                 = gVarDictObj.get(\"FEATURE_PTP\", \"false\")\n    FEATURE_PTP_INTERNAL        = gVarDictObj.get(\"FEATURE_PTP_INTERNAL\", \"false\")\n    PTP_LB_ID                   = gVarDictObj.get(\"PTP_LB_ID\", \"\")\n    PTP_DOMAIN_ID               = gVarDictObj.get(\"PTP_DOMAIN_ID\", \"\")\n\n    if UNDERLAY_IS_V6 == \"true\":\n        FABRIC_INTERFACE_TYPE = \"p2p\"\n        REPLICATION_MODE = \"Ingress\"\n        FEATURE_PTP = \"false\"\n\n    bfdDisabled = False\n    if (UNDERLAY_IS_V6 == \"true\"):\n        BFD_ENABLE = \"false\"\n        bfdDisabled = True\n    else:\n        BFD_ENABLE          = gVarDictObj.get(\"BFD_ENABLE\", \"false\")\n        if BFD_ENABLE == \"false\":\n            bfdDisabled = True\n\n    if bfdDisabled:\n        # ignore all the BFD settings... they may be inconsistent based on how the settings are toggled\n        BFD_IBGP_ENABLE = \"false\"\n        BFD_OSPF_ENABLE = \"false\"\n        BFD_ISIS_ENABLE = \"false\"\n        BFD_PIM_ENABLE = \"false\"\n        BFD_AUTH_ENABLE = \"false\"\n        BFD_AUTH_KEY_ID = \"100\"\n        BFD_AUTH_KEY = \"\"\n    else:\n        BFD_IBGP_ENABLE     = gVarDictObj.get(\"BFD_IBGP_ENABLE\", \"false\")\n        BFD_OSPF_ENABLE     = gVarDictObj.get(\"BFD_OSPF_ENABLE\", \"false\")\n        BFD_ISIS_ENABLE     = gVarDictObj.get(\"BFD_ISIS_ENABLE\", \"false\")\n        BFD_PIM_ENABLE      = gVarDictObj.get(\"BFD_PIM_ENABLE\", \"false\")\n        if (FABRIC_INTERFACE_TYPE == \"p2p\"):\n            BFD_AUTH_ENABLE     = gVarDictObj.get(\"BFD_AUTH_ENABLE\", \"false\")\n            BFD_AUTH_KEY_ID     = gVarDictObj.get(\"BFD_AUTH_KEY_ID\", \"100\")\n            BFD_AUTH_KEY        = gVarDictObj.get(\"BFD_AUTH_KEY\", \"\").upper()\n        else:\n            BFD_AUTH_ENABLE = \"false\"\n            BFD_AUTH_KEY_ID = \"100\"\n            BFD_AUTH_KEY    = \"\"\n\n    EXTRA_CONF_INTRA_LINKS  = gVarDictObj.get(\"EXTRA_CONF_INTRA_LINKS\", \"\")\n    BROWNFIELD_NETWORK_NAME_FORMAT  = gVarDictObj.get(\"BROWNFIELD_NETWORK_NAME_FORMAT\", \"Auto_Net_VNI$$VNI$$_VLAN$$VLAN_ID$$\")\n    BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS  = gVarDictObj.get(\"BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS\", \"false\")\n    ENABLE_DEFAULT_QUEUING_POLICY = gVarDictObj.get(\"ENABLE_DEFAULT_QUEUING_POLICY\", \"\")\n    if ENABLE_DEFAULT_QUEUING_POLICY == \"true\":\n        DEAFULT_QUEUING_POLICY_CLOUDSCALE = gVarDictObj.get(\"DEAFULT_QUEUING_POLICY_CLOUDSCALE\", \"\")\n        DEAFULT_QUEUING_POLICY_R_SERIES = gVarDictObj.get(\"DEAFULT_QUEUING_POLICY_R_SERIES\", \"\")\n        DEAFULT_QUEUING_POLICY_OTHER = gVarDictObj.get(\"DEAFULT_QUEUING_POLICY_OTHER\", \"\")\n    else:\n        DEAFULT_QUEUING_POLICY_CLOUDSCALE = \"\"\n        DEAFULT_QUEUING_POLICY_R_SERIES = \"\"\n        DEAFULT_QUEUING_POLICY_OTHER = \"\"\n    OVERLAY_MODE                = gVarDictObj.get(\"OVERLAY_MODE\", \"config-profile\")\n    SITE_ID                     = gVarDictObj.get(\"SITE_ID\", \"\")\n    TCAM_ALLOCATION             = gVarDictObj.get(\"TCAM_ALLOCATION\", \"true\")\n    FHRP_PROTOCOL               = gVarDictObj.get(\"FHRP_PROTOCOL\", \"hsrp\")\n    VRF_LITE_PROTOCOL           = gVarDictObj.get(\"VRF_LITE_PROTOCOL\", \"none\")\n    OSPFv3_ROUTING_TAG          = gVarDictObj.get(\"OSPFv3_ROUTING_TAG\", \"\")\n    OSPFv3_AREA_ID              = gVarDictObj.get(\"OSPFv3_AREA_ID\", \"0.0.0.0\")\n    VPC_PEER_LINK_ALL_VLAN_DISABLE = gVarDictObj.get(\"VPC_PEER_LINK_ALL_VLAN_DISABLE\", \"false\")\n\ndef processUpgradeRespObjWithMsg(entity, message, respObj, newResp):\n    respObj.addErrorReport(entity, message)\n    respObj.setFailureRetCode()\n    Util.processRespObj(respObj, newResp)\n\ndef processThreadStatus(dataDict, switchInfoDict, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    for serial in dataDict:\n        statusDict = dataDict[serial]\n        infoDict = switchInfoDict[serial]\n        swStatus = statusDict[\"Progress\"]\n        if swStatus != \"Complete\":\n            # the operation did not complete successfully and also without an exception being caught/reported\n\n            # the respObj should already have the requried error entry\n            Wrapper.print(\"%s: Switch [%s] Role [%s] Progress [%s]\" % (funcName, infoDict[\"fmtName\"], infoDict[\"switchRole\"], swStatus))\n            respObj.addErrorReport(getFabErrEntity(funcName, serial),\n                \"Role [%s]. Unexpected error encountered processing configuration. Last Status [%s]. \"\n                \"Please review errors and retry Recalculate & Deploy \" % (infoDict[\"switchRole\"], swStatus), serial)\n            respObj.setFailureRetCode()\n\ndef parallelDeviceMatch(devices, globalOverlayInfo, aaaRemoteAuthEn, isExternalFab, dcnmUser, topologyObj):\n    funcName = sys._getframe(0).f_code.co_name\n    try:\n\n        respObj = WrappersResp.getRespObj()\n        respObj.setSuccessRetCode()\n\n        switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"]\n\n        # dictionary to hold processing status of all switches in the fabric\n        switchStatusDict = OrderedDict()\n\n        # parameters that are common for all threads\n        gblParams = {}\n        gblParams[\"IMPORT_FILE_BASE_DIR\"] = Util.getBrownfieldDir()\n        gblParams[\"POLICY_TEMPLATE_BASE_DIR\"] = POLICY_TEMPLATE_BASE_DIR\n        gblParams[\"FABRIC_NAME\"] = FABRIC_NAME\n        gblParams[\"globalOverlayInfo\"] = globalOverlayInfo\n        gblParams[\"aaaRemoteAuthEn\"] = aaaRemoteAuthEn\n        gblParams[\"dcnmUser\"] = dcnmUser\n        gblParams[\"topologyObj\"] = topologyObj\n\n        # range is 10 - 40\n        progressBase = 10\n        threadCount = 10\n        processedDevices = 0\n        outerLoop = 0\n        numDevices = len(devices)\n        while outerLoop < numDevices:\n            devicesThread = []\n            innerLoop = 0\n            numToProcess = (threadCount if (numDevices - processedDevices >= threadCount ) else (numDevices%threadCount))\n            while innerLoop < numToProcess:\n                deviceSn = devices[processedDevices]\n                processedDevices = processedDevices+1\n                infoDict = switchInfoDict[deviceSn]\n\n                \"\"\"\n                sshObj = None\n                try:\n                    sshObj = Util.exe(getOptSSHConnection(FABRIC_NAME, deviceSn, dcnmUser))\n                except Exception as e:\n                    Wrapper.print(\"PDM: Failed to get SSH connection for : [%s] [%s]. Will skip\" %\n                                  (deviceSn, str(e)))\n                    respObj.addErrorReport(getFabErrEntity(\"PDM\", deviceSn+\":SSH\"),\n                                           \"Failed to get SSH connection. \"\n                                           \"Please ensure LAN credentials and retry Recalculate & Deploy\", deviceSn)\n                    respObj.setFailureRetCode()\n                    innerLoop = innerLoop+1\n                    continue\n                \"\"\" \n                if infoDict[\"switchRole\"] == \"tor\" and not isExternalFab:\n                    respObj.addErrorReport(getFabErrEntity(\"PDM\", deviceSn+\":SSH\"),\n                                           \"Brownfield import of a ToR switch is not supported in this release. \"\n                                           \"Please delete the switch from the fabric\", deviceSn)\n                    respObj.setFailureRetCode()\n                    innerLoop = innerLoop+1\n                    continue\n                \n                statusDict = {\"Progress\" : \"Pending\"}\n                switchStatusDict[deviceSn] = statusDict\n\n                switchParams = {}\n                switchParams[\"deviceSerial\"] = deviceSn\n                if globalOverlayInfo[\"fabricTechnology\"] == \"VLANFabric\":\n                    Wrapper.print(\"Getting template list for ECL current Device [%s]\"%(deviceSn))\n                    switchParams[\"templateList\"] = getTemplateList(infoDict[\"migrationMode\"], infoDict.get(\"n9kIsNotTahoe\", None), \n                                                                        isExternalFab, (infoDict[\"switchRole\"] == \"aggregation\"), globalOverlayInfo[\"fabricTechnology\"])\n                else:\n                    switchParams[\"templateList\"] = getTemplateList(infoDict[\"migrationMode\"], infoDict.get(\"n9kIsNotTahoe\", None), \n                                                                        isExternalFab, (infoDict[\"switchRole\"] == \"spine\"), globalOverlayInfo[\"fabricTechnology\"])\n                  \n                #switchParams[\"deviceSSHConnObj\"] = sshObj\n                switchParams[\"processedDevices\"] = processedDevices\n                switchParams[\"statusDict\"] = statusDict\n                switchParams[\"infoDict\"] = infoDict\n                switchParams[\"switchOverlayInfo\"] = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n\n                #showRunAndMatchThread(gblParams, switchParams, respObj)\n\n                thread = threading.Thread(target=showRunAndMatchThread, args=(gblParams, switchParams, respObj))\n                devicesThread.append({\"thread\": thread, \"params\" : switchParams})\n                thread.start()\n                Wrapper.print(\"XXXXXXX PDM:   Thread started     XXXXXXXX [%s] -> %s\" % (infoDict[\"fmtName\"], thread))\n\n                innerLoop = innerLoop+1\n                Wrapper.print(\"Processed devices [%s] numbertoProcess [%s] current Device [%s] i:j [%s]:[%s]\"%\n                              (processedDevices,numToProcess,deviceSn, outerLoop, innerLoop))\n            \n            for info in devicesThread:\n                switchParams = info[\"params\"]\n                deviceSn = switchParams[\"deviceSerial\"]\n                infoDict = switchParams[\"infoDict\"]\n                thread = info[\"thread\"]\n                thread.join()\n\n                Wrapper.print(\"XXXXXXX PDM:   Thread Joined     XXXXXXXX [%s] -> %s\" % (infoDict[\"fmtName\"], thread))\n\n                #if switchParams[\"deviceSSHConnObj\"]:\n                    #Wrapper.print(\"%s: [%s] Closing SSH connection\" % (funcName, deviceSn))\n                    #switchParams[\"deviceSSHConnObj\"].close()\n                # note: progress does not change from the time the thread was started\n                progress = progressBase + int(float(switchParams[\"processedDevices\"])/float(numDevices) * 30)\n                FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"Brownfield - %d of %d - Switch [%s] \"\n                    \"Matched Switch Configuration\" % (switchParams[\"processedDevices\"], numDevices, infoDict[\"fmtName\"])))\n            if respObj.isRetCodeFailure():\n                # do not process additional switches if there are some failures already\n                break\n\n            outerLoop = outerLoop+innerLoop\n        processThreadStatus(switchStatusDict, switchInfoDict, respObj)\n    except Exception as e:\n        msg = (\"Unexpected error during switch configuration collection and policy matching. Please retry Recalculate & Deploy.\")\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"PARALLEL_CONFIG_MATCH\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        return respObj\n        \ndef getFilenameWithIndex(switchBaseDir, filename, index):\n    return (\"%s%s%s\" % (switchBaseDir, filename, (\"\" if index == 0 else (\".\" + str(index)))))\n\ndef getImportFileIndexToUse(switchBaseDir, currentIndex):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: Basedir [%s] currentIndex [%d]\" % (funcName, switchBaseDir, currentIndex))\n\n    # set of import related files to check\n    filesToCheck = [SH_RUN_FILENAME, SH_RUN_ALL_FILENAME, OVERLAY_INFO_FILENAME]\n\n    # check to make sure the index is not in use\n    newIndex = currentIndex\n    while True:\n        fileExists = False\n        for filename in filesToCheck:\n            updFilename = getFilenameWithIndex(switchBaseDir, filename, newIndex)\n            isFilePresent = os.path.isfile(updFilename)\n            if isFilePresent:\n                # since the file is already present.. pick a new index and continue\n                Wrapper.print(\"%s: [%s] is [%spresent]\" % (funcName, updFilename, (\"\" if isFilePresent else \"not \")))\n                newIndex = newIndex + 1\n                fileExists = True\n                break\n        if not fileExists:\n            # we found a good index to use\n            break\n\n    Wrapper.print(\"%s: Return Basedir [%s] newIndex [%d]\" % (funcName, switchBaseDir, newIndex))\n    return newIndex\n\ndef getFormattedSwitchName(serialNum):\n    formattedStr = serialNum if serialNum else \"Uknown\"\n    hostName = None\n    if serialNum:\n        hostName = InventoryWrapper.getHostNameString(serialNum)\n    return (\"%s%s\" % ((hostName+\"/\" if hostName else \"\"), (serialNum if serialNum else \"Unknown\")))\n\n# check if the description has the unique DCNM L4-7 services format\n# fw:inside:ext:SN-1:E1/1:RP-1\n# lb:one:ext:SN-1:E1/1:RP-1\n# <type>:<inside/outside/one/two>:<external fabric name>:<FW device serial in exteral fab>:\n#                               <intf on FW>:<route peering name to provide to services>\ndef getServicesDescParts(formattedStr):\n    funcName = sys._getframe(0).f_code.co_name\n\n    #Wrapper.print(\"%s: processing string [%s]\" % (funcName, formattedStr))\n    parts = formattedStr.split(\":\")\n    if len(parts) != 6:\n        return None\n\n    if ((parts[0] not in [\"fw\", \"lb\", \"vnf\"]) or (parts[1] not in [\"one\", \"two\", \"inside\", \"outside\"])):\n        Wrapper.print(\"%s: Desc [%s] Not a valid service node syntax %s, %s\" % (funcName, formattedStr, parts[0], parts[1]))\n        return None\n\n    return parts\n\ndef showRunAndMatchThread(gblParams, switchParams, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    statusDict = switchParams[\"statusDict\"]\n    infoDict = switchParams[\"infoDict\"]\n    switchOverlayInfo = switchParams[\"switchOverlayInfo\"]\n    statusDict[\"Progress\"] = \"Started\"\n    devSerial = switchParams[\"deviceSerial\"]\n    aaaRemoteAuthEn = gblParams[\"aaaRemoteAuthEn\"]\n    globalOverlayInfo = gblParams[\"globalOverlayInfo\"]\n    fmtName = infoDict[\"fmtName\"]\n    fabricName = gblParams[\"FABRIC_NAME\"]\n    dcnmUser = gblParams[\"dcnmUser\"]\n    topologyObj =  gblParams[\"topologyObj\"] \n    sshObj1 = None\n    sshObj2 = None\n\n    try:\n        templateList = switchParams[\"templateList\"]\n        origTemplateList = copy.deepcopy(templateList)\n        #sshObj = switchParams['deviceSSHConnObj']\n        sshObj1 = None\n        try:\n            sshObj1 = Util.exe(getOptSSHConnection(FABRIC_NAME, devSerial, dcnmUser))\n        except Exception as e:\n            Wrapper.print(\"PDM: Failed to get SSH connection for : [%s] [%s]. Will skip\" % (devSerial, str(e)))\n            respObj.addErrorReport(getFabErrEntity(\"PDM\", devSerial+\":SSH\"),\n                                   \"Failed to get SSH connection. \"\n                                   \"Please ensure LAN credentials and retry Recalculate & Deploy\", devSerial)\n            respObj.setFailureRetCode()\n\n        switchBaseDir = getSwitchBaseDir(devSerial, gblParams[\"FABRIC_NAME\"], gblParams[\"IMPORT_FILE_BASE_DIR\"])\n        if not os.path.exists(switchBaseDir):\n            os.makedirs(switchBaseDir)\n\n        importMetadataFileName = switchBaseDir + IMPORT_METADATA_FILENAME\n        isImportMetadataFilePresent = os.path.isfile(importMetadataFileName)\n        Wrapper.print(\"%s: [%s] metadata file [%s] is [%spresent]\" % (funcName, \n                fmtName, importMetadataFileName, (\"\" if isImportMetadataFilePresent else \"not \")))\n\n        reuseResFilename = switchBaseDir + \".reuseRes\"\n\n        # get the last known switch config 'last-index' data we stored for this switch earlier (if any)\n        statusDict[\"Progress\"] = \"Checking Saved Switch last-index\"\n        importMetadataFromFile = updatedImportMetadata = None\n        reuseResults = forceResueResults = False\n        isReuseFilePresent = os.path.isfile(reuseResFilename)\n        Wrapper.print(\"%s: [%s] Reuse file [%s] is [%spresent]. BRFIELD_DEBUG_FLAG [%s]\" % (funcName, \n                fmtName, reuseResFilename, (\"\" if isReuseFilePresent else \"not \"), BRFIELD_DEBUG_FLAG))\n\n        #Wrapper.print(\"%s: [%s] templates [%d] %s\" % (funcName, devSerial, len(origTemplateList), origTemplateList))\n\n        if isReuseFilePresent or BRFIELD_DEBUG_FLAG == \"Enable\":\n            # force the reuse of earlier results for debug purposes..\n            # the assumption is that the result files exixts from earlier runs.. not having so\n            # will lead to unexpected results\n            Wrapper.print(\"%s: [%s] *** FORCE REUSING MATCH RESULTS ***\" % (funcName, fmtName))\n            forceResueResults = True\n\n        if not forceResueResults:\n            if isImportMetadataFilePresent:\n                newRespObj = getFileContents(importMetadataFileName, True)\n                if newRespObj.isRetCodeSuccess():\n                    importMetadataFromFile = newRespObj.getValue()\n                    #Wrapper.print(\"%s: [%s] metadata [%s]\" % (funcName, importMetadataFileName, importMetadataFromFile))\n                else:\n                    # a file open/read failure.. report error\n                    Util.processRespObj(respObj, newRespObj)\n                    return respObj\n\n            # get the current cfg last-index from switch\n            statusDict[\"Progress\"] = \"Getting Switch last-index\"\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n\n            cmd = \"show accounting log last-index\"\n            cfgLastIndexFromSwitchOut = getSwitchCmdOutput(sshObj1, devSerial, cmd, newRespObj)\n\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj\n\n            lastIndexFromSwitch = cfgLastIndexFromSwitchOut.split(\":\")[1].strip()\n\n            isTemplateListChanged = False\n            updatedImportMetadata = {\"templateList\" : origTemplateList, \n                                     \"last_index\" : lastIndexFromSwitch\n                                    }\n            if not importMetadataFromFile:\n                # init the meta data that we need to save back\n                updatedImportMetadata[\"cfgfile_ext_index\"] = 0\n            else:\n                updatedImportMetadata[\"cfgfile_ext_index\"] = importMetadataFromFile[\"cfgfile_ext_index\"]\n\n            if importMetadataFromFile and cfgLastIndexFromSwitchOut:\n                # check if the template list has changed (could happen if the switch role changes among other things)\n                # if the template list is changed, the earlier results are invalid\n                isTemplateListChanged = (importMetadataFromFile[\"templateList\"] != origTemplateList)\n                Wrapper.print(\"%s: [%s] template list prev [%d] new [%d].. isTemplateListChanged [%r]\" % (funcName,\n                    fmtName, len(importMetadataFromFile[\"templateList\"]), len(origTemplateList), isTemplateListChanged))\n\n                if not isTemplateListChanged:\n                    # check indices and determine if we can reuse the results\n                    cfgLastIndexFile = importMetadataFromFile[\"last_index\"]\n                    cfgLastIndexSwitch = lastIndexFromSwitch\n                    Wrapper.print(\"%s: [%s] cfg last-index file [%s] switch [%s]\" % (funcName, fmtName,\n                        cfgLastIndexFile, cfgLastIndexSwitch))\n\n                    if cfgLastIndexFile == cfgLastIndexSwitch:\n                        # no config changes detected on switch.. we can reuse the earlier results\n                        Wrapper.print(\"%s: [%s] *** REUSING MATCH RESULTS *** No configuration change \"\n                            \"detected\" % (funcName, fmtName))\n                        reuseResults = True\n                    else:\n                        # the 'last-index' is known to change on switch for non config changes also.. check further\n                        # to make sure there are some configuration changes\n                        statusDict[\"Progress\"] = \"Getting Switch Config Change With start-seqnum\"\n                        newRespObj = WrappersResp.getRespObj()\n                        newRespObj.setSuccessRetCode()\n                        cmd = (\"show accounting log start-seqnum %s | include configure | count\" % (cfgLastIndexFile))\n                        cfgCount = getSwitchCmdOutput(sshObj1, devSerial, cmd, newRespObj)\n                        if not newRespObj.isRetCodeSuccess():\n                            Util.processRespObj(respObj, newRespObj)\n                            return respObj\n                        else:\n                            strippedOutput = cfgCount.strip()\n                            Wrapper.print(\"%s: [%s] output of cmd [%s] is [%s]\" % (funcName, fmtName, cmd, strippedOutput))\n                            if strippedOutput == \"0\":\n                                Wrapper.print(\"%s: [%s] *** REUSING MATCH RESULTS *** No real configuration change \"\n                                    \"detected\" % (funcName, fmtName))\n                                reuseResults = True\n\n        # delete the cfg last-index file since we will create it at the end.. this will prevent issues with\n        # stale match results if the current matching does not complete successfully\n        if not forceResueResults and isImportMetadataFilePresent:\n            statusDict[\"Progress\"] = \"Deleting Config last-index file\"\n            os.remove(importMetadataFileName)\n        \n        if not reuseResults:\n            devModel = topologyObj.getSwitchModel(devSerial)\n            combinedDict = {\"deviceSerial\" : devSerial, \"deviceSSHConnObj\" : sshObj1,\n                \"FABRIC_NAME\" : gblParams[\"FABRIC_NAME\"], \"IMPORT_FILE_BASE_DIR\" : gblParams[\"IMPORT_FILE_BASE_DIR\"],\n                \"POLICY_TEMPLATE_BASE_DIR\" : gblParams[\"POLICY_TEMPLATE_BASE_DIR\"], \"devModel\":devModel}\n\n            # get the file index to use for the files we will create now for this run\n            fileIndexToUse = getImportFileIndexToUse(switchBaseDir, updatedImportMetadata[\"cfgfile_ext_index\"])\n\n            # filenames to use to store data\n            shRunFileName = getFilenameWithIndex(switchBaseDir, SH_RUN_FILENAME, fileIndexToUse)\n            shRunAllFileName = getFilenameWithIndex(switchBaseDir, SH_RUN_ALL_FILENAME, fileIndexToUse)\n\n            # update the meta data that we need to save back\n            updatedImportMetadata[\"cfgfile_ext_index\"] = fileIndexToUse\n            updatedImportMetadata[\"last_index\"] = lastIndexFromSwitch\n\n            statusDict[\"Progress\"] = \"Getting Show Running\"\n            Wrapper.print(\"%s: [%s] Getting 'show run'\" % (funcName, fmtName))\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            valid, junk = getShowRun(combinedDict, shRunFileName, \"show running-config\", newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj\n        \n            Wrapper.print(\"%s: [%s] Getting 'show run all'\" % (funcName, fmtName))\n            statusDict[\"Progress\"] = \"Getting Show Running All\"\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            valid, junk = getShowRun(combinedDict, shRunAllFileName, \"show running-config all\", newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj\n        sshObj1.close()\n        sshObj1 = None\n\n        matchResult = interfacesRes = None\n        \n        if not reuseResults:\n            # parse some config blocks from the switch running configs\n            statusDict[\"Progress\"] = \"Gathering config blocks from Show Running\"\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            cfgBlocks = getShowRunConfigBlocks(shRunFileName, newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj\n\n            combinedDict[\"deviceSSHConnObj\"] = None\n\n            statusDict[\"Progress\"] = \"Template Matching\"\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            # the 'templateList' is manipulated inside this API !\n            matchResult, interfacesRes = doMatch(combinedDict, shRunFileName, shRunAllFileName, templateList, newRespObj, globalOverlayInfo[\"fabricTechnology\"])    \n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj\n\n            # save the result files\n            statusDict[\"Progress\"] = \"Saving Match Results Data\"\n            matchResult[\".SH_RUN_CFG_BLOCKS\"] = cfgBlocks\n            matchResultsFileName = getFilenameWithIndex(switchBaseDir, MATCH_RESULT_FILENAME, fileIndexToUse)\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            writeToFile(matchResultsFileName, json.dumps(matchResult, indent=4, sort_keys=True), newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj    \n\n            statusDict[\"Progress\"] = \"Saving Interface Match Results Data\"\n            interfaceMatchResultsFileName = getFilenameWithIndex(switchBaseDir, INTF_MATCH_RESULT_FILENAME, fileIndexToUse)\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            writeToFile(interfaceMatchResultsFileName, json.dumps(interfacesRes, indent=4, sort_keys=True), newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj    \n\n        if not forceResueResults:\n            # create/update the 'cfg_last_index' file with the new data\n            statusDict[\"Progress\"] = \"Saving Metadata\"\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            jsonMetadata = json.dumps(updatedImportMetadata, indent=4, sort_keys=True)\n            Wrapper.print(\"%s: Switch [%s] Saving metadata [%s]\" % (funcName, fmtName, importMetadataFileName))\n            writeToFile(importMetadataFileName, jsonMetadata, newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj    \n\n        if infoDict[\"migrationMode\"] == \"brownAdd\":\n            if not matchResult:\n                # we are reusing the earlier result.. open the file\n                matchResultsFileName = getFilenameWithIndex(switchBaseDir, MATCH_RESULT_FILENAME, updatedImportMetadata[\"cfgfile_ext_index\"])            \n                Wrapper.print(\"%s: [%s] Retrieving match results from [%s]\" % (funcName, fmtName, matchResultsFileName))\n                matchResult = Util.exe(getJSONFileContents(matchResultsFileName))\n\n            #DONT NEED TO DO THIS FOR ECL\n            if globalOverlayInfo[\"fabricTechnology\"] != \"VLANFabric\":\n                # get the VXLAN overlay info from switch\n                statusDict[\"Progress\"] = \"Getting VXLAN Information from switch\"\n                newRespObj = WrappersResp.getRespObj()\n                newRespObj.setSuccessRetCode()\n                sshObj2 = None\n                try:\n                    sshObj2 = Util.exe(getOptSSHConnection(FABRIC_NAME, devSerial, dcnmUser))\n                except Exception as e:\n                    Wrapper.print(\"PDM: Failed to get SSH connection for : [%s] [%s]. Will skip\" % (devSerial, str(e)))\n                    respObj.addErrorReport(getFabErrEntity(\"PDM\", devSerial+\":SSH\"),\n                                          \"Failed to get SSH connection. \"\n                                          \"Please ensure LAN credentials and retry Recalculate & Deploy\", devSerial)\n                    respObj.setFailureRetCode()\n                getSwitchVxlanInfo(infoDict, switchOverlayInfo, matchResult, sshObj2, newRespObj)\n                if not newRespObj.isRetCodeSuccess():\n                    Util.processRespObj(respObj, newRespObj)\n                    return respObj    \n                sshObj2.close()\n                sshObj2 = None\n            \n            \"\"\"\n            # Note: Disable support till all the cases are handled\n            #\n            # collect service leaf info\n            fabricSettings = Util.exe(FabricWrapper.get(fabricName)).getNvPairs()\n            swVxlanInfoDict = switchOverlayInfo[\"SWITCH_VXLAN_INFO\"]\n            hasCfgProfiles = True if matchResult[\"FEATURES_INFO\"][\"CFG_PROFILES\"] else False\n            pbrEnabled = False\n            if hasCfgProfiles:\n                nvPairList = getTemplateMatchResults(matchResult, \"feature_pbr\")\n                if (nvPairList != None):\n                    pbrEnabled = True\n            Wrapper.print(\"%s: [%s] pbrEnabled [%s] hasCfgProfiles [%r]\" % (funcName, fmtName, pbrEnabled, hasCfgProfiles))\n            if pbrEnabled and swVxlanInfoDict and hasCfgProfiles:\n                statusDict[\"Progress\"] = \"Getting L4-7 Service Information from switch\"\n                # potential for a service leaf.. check further\n                #   - get all the overlay network svi descriptions\n                overlaySviDescDict = getCfgProfileOverlaySviInfo(devSerial, matchResult)\n                for vlanId in overlaySviDescDict:\n                    sviEntry = overlaySviDescDict[vlanId]\n                    Wrapper.print(\"%s: vlanId [%s] sviEntry [%s] VLANs %s\" % (funcName, vlanId, sviEntry,\n                                        swVxlanInfoDict[\"vlanIdInfo\"][\"VLANS\"]))\n                    if ((vlanId not in swVxlanInfoDict[\"vlanIdInfo\"][\"VLANS\"]) or (\"desc\" not in sviEntry)):\n                        # maybe the profile is not applied.. do not process\n                        continue\n\n                    vniStr = swVxlanInfoDict[\"vlanIdInfo\"][\"VLANS\"][vlanId][\"vni\"]\n                    \n                    # the svi description can have a prefix\n                    descParts = sviEntry[\"desc\"].split(\" \")\n                    Wrapper.print(\"%s: SVI [%s] desc [%s] Num %d parts %s\" % (funcName, vlanId, sviEntry[\"desc\"], len(descParts), descParts))\n                    if len(descParts) == 0:\n                        parts = getServicesDescParts(sviEntry[\"desc\"])\n                    else:\n                        for part in descParts:\n                            # check to see if this part is the formatted services description\n                            parts = getServicesDescParts(part)\n                            if parts:\n                                # we found a valid service svi desc\n                                break\n\n                    if parts == None:\n                        continue\n                    \n                    serviceNodeType = parts[0]\n                    serviceNetworkType = parts[1]\n\n                    # note: the vrf name always be in lower case because that is how configs are deployed\n                    # the real VRF entry could be with different case\n                    vrfName = sviEntry[\"vrfName\"]\n\n                    if globalOverlayInfo[\"SERVICES\"] == None:\n                        globalOverlayInfo[\"SERVICES\"] = {}\n                    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n\n                    if \"serviceSwMaps\" not in servicesInfo:\n                        # first entry.. so create needed stuff\n                        servicesInfo[\"serviceNodes\"] = {}   # key is service node name\n                        servicesInfo[\"serviceNets\"] = {}    # key is vni\n                        servicesInfo[\"serviceAclPrefixStr\"] = []\n                        servicesInfo[\"serviceRmPrefixStr\"] = []\n                        servicesInfo[\"serviceSwMaps\"] = {} # key is service switch serial and value is dict of diff info\n\n                    if devSerial not in servicesInfo[\"serviceSwMaps\"]:\n                        servicesInfo[\"serviceSwMaps\"][devSerial] = {\"nodes\" : [], \"vnis\" : [], \"vrfs\" : [], \"lo\" : []}\n                    \n                    if vniStr not in servicesInfo[\"serviceNets\"]:\n                        ipParts = sviEntry[\"ipv4\"].split(\"/\")\n                        subnetStr = Util.getSubnetStringWithPrefix(ipParts[0], ipParts[1])\n                        servicesInfo[\"serviceNets\"][vniStr] = {\"networkName\" : sviEntry[\"profileName\"], \"vrfName\" : vrfName,\n                            \"ipv4\" : sviEntry[\"ipv4\"], \"mask\" : ipParts[1], \"subnet\" : subnetStr}\n                    \n                    devMapping = servicesInfo[\"serviceSwMaps\"][devSerial]\n                    entitylist = devMapping[\"vnis\"]\n                    if vniStr not in entitylist:\n                        entitylist.append(vniStr)\n\n                    entitylist = devMapping[\"vrfs\"]\n                    if vrfName not in entitylist:\n                        entitylist.append(vrfName)\n\n                    # add a mapping entry from the switch serial -> service node entries\n                    serviceNodeName = parts[3]\n                    entitylist = devMapping[\"nodes\"]\n                    if serviceNodeName not in entitylist:\n                        entitylist.append(serviceNodeName)\n\n                    # add an entry for the service node\n                    serviceNodes = servicesInfo[\"serviceNodes\"]\n                    if serviceNodeName not in serviceNodes:\n                        extFabName = parts[2]\n                        serviceNodeInfo = {\"extFabricName\": extFabName, \"swSerial\": devSerial, \n                                           \"serviceNodeType\" : serviceNodeType, \"snIntf\" : parts[4],\n                                           \"routePeers\" : {}}\n                        serviceNodes[serviceNodeName] = serviceNodeInfo\n                        Wrapper.print(\"%s: Sw [%s] Added Service Node [%s] Entry %s\" % (funcName, devSerial, serviceNodeName,\n                            serviceNodeInfo))\n                    else:\n                        serviceNodeInfo = serviceNodes[serviceNodeName]\n                        if serviceNodeInfo[\"swSerial\"] != devSerial:\n                            # this must be the vPC peer\n                            serviceNodeInfo[\"peerSwSerial\"] = devSerial\n\n                    switchOverlayInfo[\"isServiceLeaf\"] = True\n\n                    serviceNodeInfo = serviceNodes[serviceNodeName]\n                    routePeers = serviceNodeInfo[\"routePeers\"]\n                    routePeerName = parts[5]\n                    if routePeerName not in routePeers:\n                        rmPrefixStr = (\"rm_%s\" % (vrfName))\n                        if rmPrefixStr not in servicesInfo[\"serviceRmPrefixStr\"]:\n                            servicesInfo[\"serviceRmPrefixStr\"].append(rmPrefixStr)\n\n                        routePeers[routePeerName] = {\"nets\" : {}, \"isInter\" : False, \"vrfName\" : vrfName,\n                                                     \"rmPrefix\" : rmPrefixStr, \"peerOption\" : \"none\",\n                                                     \"servicePolicies\" : {}}\n\n                    rpEntry = routePeers[routePeerName]\n                    if serviceNetworkType not in rpEntry[\"nets\"]:\n                        rpEntry[\"nets\"][serviceNetworkType] = {\"vni\" : vniStr}\n                        if (serviceNodeType == \"fw\"):\n                            if (rpEntry[\"vrfName\"] != vrfName):\n                                # this is an inter tenant FW case\n                                rpEntry[\"isInter\"] = True\n                                # this can change once more configs are parsed\n                                rpEntry[\"peerOption\"] = \"static\"\n                                rpEntry[\"vrfName\"] = \"\"\n                                rpEntry[\"rmPrefix\"] = \"\"\n                        else:\n                            # this can change once more configs are parsed\n                            rpEntry[\"peerOption\"] = \"static\"\n\n                # do some final processing of services info found on this switch\n                servicesInfo = globalOverlayInfo[\"SERVICES\"]\n                if (servicesInfo and (devSerial in servicesInfo[\"serviceSwMaps\"])):\n                    for serviceNodeName in servicesInfo[\"serviceSwMaps\"][devSerial][\"nodes\"]:\n                        serviceNodeInfo = servicesInfo[\"serviceNodes\"][serviceNodeName]\n\n                        for rpEntry in serviceNodeInfo[\"routePeers\"].values():\n                            if rpEntry[\"peerOption\"] != \"none\":\n                                for netTypeEntry in rpEntry[\"nets\"].values():\n                                    netTypeEntry[\"ptNvPairs\"] = {}\n                                    #netTypeEntry[\"ptNvPairs\"] = {\"VRF_NAME\" : servicesInfo[\"serviceNets\"][netTypeEntry[\"vni\"]][\"vrfName\"]}\n\n                            # build acl name prefix networks\n                            if \"aclPrefix\" not in rpEntry:\n                                if rpEntry[\"isInter\"]:\n                                    aclStr = \"\"\n                                else:\n                                    aclStr = (\"acl_%s_\" % (rpEntry[\"vrfName\"]))\n                                    if aclStr not in servicesInfo[\"serviceAclPrefixStr\"]:\n                                        servicesInfo[\"serviceAclPrefixStr\"].append(aclStr)\n                                rpEntry[\"aclPrefix\"] = aclStr\n            \"\"\"\n\n        Wrapper.print(\"%s: [%s] Closing SSH connection\" % (funcName, fmtName))\n        #sshObj.close()\n        #switchParams[\"deviceSSHConnObj\"] = None\n\n        statusDict[\"Progress\"] = \"Complete\"\n        return respObj\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error gathering information. Last Status [%s]\" % (fmtName, statusDict[\"Progress\"]))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":INFO_GATHER\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        if sshObj1:\n            sshObj1.close()\n            sshObj1 = None\n        if sshObj2:\n            sshObj2.close()\n            sshObj2 = None\n\n        \n# invoked when switch is being deleted (removed) from the fabric.. cleanup the brownfield data as appropriate\n#  - rename the metadata file so that future BF improt into a fabric of the same name will start fresh\n#  - keep the other show run, matching results etc. for record\ndef cleanupBrownfieldImportData(fabricName, devSerial, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    fmtName = getFormattedSwitchName(devSerial)\n    try:\n        switchBaseDir = getSwitchBaseDir(devSerial, fabricName, Util.getBrownfieldDir())\n        importMetadataFileName = switchBaseDir + IMPORT_METADATA_FILENAME\n        isImportMetadataFilePresent = os.path.isfile(importMetadataFileName)\n        Wrapper.print(\"%s: [%s] BF metadata file [%s] is [%spresent]\" % (funcName, \n                fmtName, importMetadataFileName, (\"\" if isImportMetadataFilePresent else \"not \")))\n        if not isImportMetadataFilePresent:\n            # since the file does not exist.. nothing to do\n            return\n\n        # we need to rename the file so that future BF imports start fresh\n        renameFileName = (\"%s.%s\" % (importMetadataFileName, datetime.datetime.now()))\n        Wrapper.print(\"%s: [%s] Renaming [%s] -> [%s]\" % (funcName, fmtName, importMetadataFileName, renameFileName))\n        os.rename(importMetadataFileName, renameFileName)\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error cleaning up Brownfield data\" % fmtName)\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":CLEANUP\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n\ndef redefineExternalFabGlobals(gVarDictObj):\n    global FABRIC_NAME, BRFIELD_DEBUG_FLAG, BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS\n\n    FABRIC_NAME                     = gVarDictObj[\"FABRIC_NAME\"]\n    BRFIELD_DEBUG_FLAG              = gVarDictObj[\"BRFIELD_DEBUG_FLAG\"]\n    BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS = \"true\"\n\ndef handleUpgradeOrBrownfield(gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    try:\n        respObj = WrappersResp.getRespObj()\n        respObj.setSuccessRetCode()\n\n        isExternalFab = gVarDictObj.get(\"IS_EXTERNAL\", False)\n\n        Wrapper.print(\"%s: isExternalFab [%r]\" % (funcName, isExternalFab))\n        #Wrapper.print(\"%s: gVarDictObj - %s\" % (funcName, json.dumps(gVarDictObj, indent=4, sort_keys=True)))\n        if isExternalFab:\n            redefineExternalFabGlobals(gVarDictObj)\n        else:\n            redefineGlobals(gVarDictObj)\n\n        #Get the fabric technology and pass it down\n        fabDetails = Util.exe(FabricWrapper.get(FABRIC_NAME))\n        fabTech = fabDetails.getFabricTechnology()\n        \n        fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n        numUpg = 0\n        numResync = 0\n        numChangeIP = 0\n        numChangeMgmtMode = 0\n        aggSwitches = []\n        accessSwitches = []        \n        if isExternalFab:\n            # host port resync case only\n            hostPortResyncSwitches = gVarDictObj.get(\"RESYNC_SW_LIST\", None)\n            switchInfoDict = gVarDictObj.get(\"SW_INFO\", None)\n            if ((hostPortResyncSwitches == None) or (switchInfoDict == None)):\n                # bad data\n                pass\n            numResync = len(hostPortResyncSwitches)\n        else:\n            #get the whole topology from topology database\n            topologyDataObj = gVarDictObj[\"topologyObj\"]\n            devices = topologyDataObj.get(TopologyInfoType.SWITCHES)\n            devices = filter(None, devices)\n            devices.sort()\n\n            inbandPoapEnabled = isInbandPoapEnabled(fabricSettings)\n            inbandPoapSeedSwitches = None\n            numInbandPoapSeeds = 0\n\n            # get all the inband POAP seed switches\n            if inbandPoapEnabled == \"true\":\n                inbandPoapSeedSwitches = Util.exe(FabricWrapper.getAllInbandPOAPSeedSwitches())\n\n            upgradeOrBrownfieldSwitches = []\n            greenfieldSwitches = []\n            hostPortResyncSwitches = []\n            changeIPSwitches = []\n            changeMgmtModeSwitches = []\n            switchInfoDict = {}\n            inventoryStrList = []\n            numBrown = 0\n            superSpines = []\n            aggregationSwitches = []\n            fmtStr = \"%-15s %-30s %-15s %-20s %-20s %-25s %-30s %-20s %-s\"\n            inventoryStrList.append(fmtStr %\n                    (\"Serial\", \"Switchname\", \"Role\", \"Version\", \"Model\", \"Migration Mode\", \"vPC Peer\", \"Disc Status\", \"Inband Seed\"))\n\n            for deviceSn in devices:\n                # check if switch is in forced BF mode\n                Wrapper.print(\"%s: Checking Model [%r]\" % (funcName, deviceSn))\n                model = topologyDataObj.getSwitchModel(deviceSn)\n                if model is None:\n                    # something is not right.. \n                    respObj.addErrorReport(getFabErrEntity(funcName, \"ModelCheck:\" + deviceSn),\n                        \"Unable to determine model info. Plese ensure switch discovery is ok and retry.\", deviceSn)\n                    respObj.setFailureRetCode()\n                    continue\n\n                migrateMode, migrateModeDetail = Util.getSwitchMigrationModeStr(deviceSn)\n                formattedName = getFormattedSwitchName(deviceSn)\n                n9kIsNotTahoe = True\n                if Util.isN9kTahoe(topologyDataObj, deviceSn):\n                   n9kIsNotTahoe = False\n\n                swStatus = topologyDataObj.get(TopologyInfoType.SW_STATUS_FROM_SN, deviceSn)\n\n                vpcPeer = None\n                isVPC = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, deviceSn))\n                if isVPC:\n                    vpcPeer = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, FABRIC_NAME, deviceSn))\n\n                seedSwStr = \"N/A\"\n                if inbandPoapSeedSwitches is not None:\n                    if deviceSn in inbandPoapSeedSwitches:\n                        seedSwStr = \"Yes\" \n                        numInbandPoapSeeds += 1\n                    else:\n                        seedSwStr = \"No\"\n\n                dict = {\"deviceSerial\" : deviceSn, \"migrationMode\" : migrateMode, \"detail\" : migrateModeDetail,\n                        \"deviceModel\" : model, \"isN9K\" : True, \"n9kIsNotTahoe\" : n9kIsNotTahoe,\n                        \"switchRole\" : topologyDataObj.getSwitchRole(deviceSn),\n                        \"hostName\" : topologyDataObj.getHostName(deviceSn),\n                        \"fmtName\" : formattedName,\n                        \"imageVer\" : Util.exe(ImageManagementWrapper.getNXOSVersion(deviceSn)),\n                        \"vpcPeer\" : vpcPeer,\n                        \"discStatus\" : swStatus,\n                        \"seedSwitch\" : seedSwStr\n                        }\n                if \"super\" in dict[\"switchRole\"]:\n                    superSpines.append(deviceSn)\n                if \"aggregation\" in dict[\"switchRole\"]:\n                    aggregationSwitches.append(deviceSn)\n \n                switchInfoDict[deviceSn] = dict\n                if migrateMode is not None:\n                    if migrateMode != \"greenAdd\":\n                        if migrateMode == \"reSync\":\n                            hostPortResyncSwitches.append(deviceSn)\n                        elif migrateMode == \"changeIP\":\n                            changeIPSwitches.append(deviceSn)\n                        elif migrateMode == \"mgmtModeChg\":\n                            changeMgmtModeSwitches.append(deviceSn)\n                        else:\n                            upgradeOrBrownfieldSwitches.append(deviceSn)\n                            if migrateMode == \"brownAdd\":\n                                numBrown += 1\n                    else:\n                        greenfieldSwitches.append(deviceSn)\n                migrateModeStr = (\"%s [%s]\" % (dict[\"migrationMode\"], dict[\"detail\"]))\n                vpcPeerStr = \"N/A\" if vpcPeer == None else (\"%s\" % (getFormattedSwitchName(vpcPeer)))\n                inventoryStrList.append(fmtStr % (deviceSn,\n                    dict[\"hostName\"], dict[\"switchRole\"], dict[\"imageVer\"], dict[\"deviceModel\"],\n                    migrateModeStr, vpcPeerStr, dict[\"discStatus\"], dict[\"seedSwitch\"]))\n\n            if respObj.isRetCodeFailure():\n                # we failed quite early.. dump topo info for debug\n                #Wrapper.print(\"%s: Fabric = [%s]. Topology%s%s\" % (funcName, FABRIC_NAME, Util.newLine(),topologyDataObj.getTopoStr()));\n                Wrapper.print(\"%s: Fabric = [%s]. Topology\" % (funcName, FABRIC_NAME))\n                return respObj\n\n            greenfieldSwitches.sort()\n            upgradeOrBrownfieldSwitches.sort()\n            hostPortResyncSwitches.sort()\n\n            numGreen = len(greenfieldSwitches)\n            numUpg = len(upgradeOrBrownfieldSwitches)\n            numResync = len(hostPortResyncSwitches)\n            numChangeIP = len(changeIPSwitches)\n            numChangeMgmtMode = len(changeMgmtModeSwitches)\n            Wrapper.print(\"%s: Fabric [%s]: Num Devices [%d] G [%d] R [%d] B [%d] U [%d] C [%d] M [%d]\" % (funcName,\n                    FABRIC_NAME, len(devices), numGreen, numResync, numBrown, numUpg, numChangeIP, numChangeMgmtMode))\n            Wrapper.print(\"Fabric [%s] Inventory:%s%s\" % (FABRIC_NAME, Util.newLine(), Util.newLine().join(inventoryStrList)))\n\n            if upgradeOrBrownfieldSwitches and inbandPoapSeedSwitches is not None:\n                if numInbandPoapSeeds == 0:\n                    respObj.addErrorReport(getFabErrEntity(funcName, FABRIC_NAME),\n                        \"No Inband POAP seed switches found! Please identify the Inband POAP seed switches and \"\n                        \"retry the Recalculate and Deploy.\")\n                    respObj.setFailureRetCode()\n                    return respObj\n\n            if numGreen > 0:\n                isDeployAllowed = Util.exe(PTIWrapper.checkDeployAllowed(FABRIC_NAME))\n                if not isDeployAllowed:\n                    respObj.addErrorReport(getFabErrEntity(funcName, FABRIC_NAME),\n                            \"Recalculate & Deploy for the fabric cannot be performed, if switches are in migration mode \"\n                            \"and Fabric deployment mode is not enabled and/or dcnm user role is Network-Stager.\")\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                # take greenfield switches out of migration mode (if any)\n                for deviceSn in greenfieldSwitches:\n                    gVarDictObj[\"DICTIONARY_OBJ\"] = switchInfoDict[deviceSn]\n                    #duplicate below two as postAdd doesn't pass \"DICTIONARY_OBJ\" as key\n                    gVarDictObj[\"deviceSerial\"] = deviceSn\n                    gVarDictObj[\"devicePreserveConfig\"] = False\n                    try:\n                        newRespObj = postAddExt(gVarDictObj)\n                        Util.processRespObj(respObj, newRespObj)\n                        if not newRespObj.isRetCodeSuccess():\n                            Wrapper.print(\"Switch [%s]: Greenfield recovery failed\" % deviceSn)\n                    except Exception as e:\n                        Util.handleException((\"Switch [%s]: Greenfield recovery\" % deviceSn), e, respObj)\n\n                for deviceSn in greenfieldSwitches:\n                    if Util.isSwitchInMigrationState(deviceSn):\n                        respObj.addErrorReport(getFabErrEntity(funcName),\n                            \"Still in migration mode. Please resolve all errors and retry Recalculate & Deploy\", deviceSn)\n                        respObj.setFailureRetCode()\n\n                if respObj.isRetCodeFailure():\n                    return respObj\n\n            needToReturn = False\n            vpcSrcToDstMacMap = {}\n            vVpcSpineQos = {}\n            if numUpg > 0:\n                # before proceeding.. report an erorr if the fabric is a MSD member if there are any switches\n                # in BF migration mode\n                parentFab = getParentFabricName(FABRIC_NAME, respObj)\n                if parentFab:\n                    # it is indeed a member fabric.. report error\n                    respObj.addErrorReport(getFabErrEntity(funcName),\n                        \"Fabric is a member of MSD [%s]. Please retry Recalculate & Deploy operation after \"\n                        \"removing the fabric from the MSD and completing the Brownfield migration \"\n                        \"or removing the Brownfield imported switches.\" % (parentFab))\n                    respObj.setFailureRetCode()\n                else:\n                    # either an error occured or not a member.. assume the latter and proceed\n                    pass\n\n                if fabTech == \"VLANFabric\" and len(aggregationSwitches) > 2:\n                    respObj.addErrorReport(getFabErrEntity(funcName, FABRIC_NAME+\":Unsupported topology\"),\n                           \"Only one pair of aggregation switches are supported in this fabric with \"\n                           \"option Preserve Config = Yes.\")\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                for deviceSn in superSpines:\n                    dict = switchInfoDict[deviceSn]\n                    switchRole = dict[\"switchRole\"]\n                    respObj.addErrorReport(getFabErrEntity(funcName, deviceSn+\":Unsupported role\"),\n                           \"[%s] Role is not supported with option Preserve Config = Yes.\" % (switchRole), deviceSn)\n                    respObj.setFailureRetCode()\n                   \n                FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 5, \"Brownfield - Checking vPC pairs in fabric\") \n                for deviceSn in upgradeOrBrownfieldSwitches:\n                    dict = switchInfoDict[deviceSn]\n                    # check to make sure all the vpc pair switches are in the fabric\n                    sshObj = None\n                    try:\n                        # check to make sure discovery status is ok\n                        if dict[\"discStatus\"] != \"ok\":\n                            respObj.addErrorReport(funcName,\n                                \"Discovery state is not ok. Please ensure switch is discovered correctly and retry Recalculate & Deploy.\", deviceSn)\n                            respObj.setFailureRetCode()\n                            continue\n\n                        try:\n                            sshObj = Util.exe(getOptSSHConnection(FABRIC_NAME, deviceSn, gVarDictObj[\"dcnmUser\"]))\n                        except Exception as e:\n                            Wrapper.print(\"%s: Failed to get SSH connection for : [%s] [%s]\" % \n                                          (funcName, deviceSn, str(e)))\n                            respObj.addErrorReport(getFabErrEntity(funcName, deviceSn+\":SSH\"),\n                                   \"Failed to get SSH connection. Please ensure LAN credentials and retry Recalculate & Deploy\", deviceSn)\n                            respObj.setFailureRetCode()\n                            continue\n\n                        isVpc = getSwitchVpcFeatureState(sshObj, deviceSn, respObj)\n                        if isVpc:\n                            cmdJson = getSwitchCmdJsonOutput(sshObj, deviceSn, \"show vpc role | json\", respObj)\n                            if cmdJson != \"\":\n                                if \"vpc-peer-system-mac\" in cmdJson:\n                                    Wrapper.print(\"%s: [%s]: local -> peer mac : [%s] -> [%s]\" % \n                                        (funcName, deviceSn, cmdJson['vpc-local-system-mac'], cmdJson['vpc-peer-system-mac']))\n                                    vpcSrcToDstMacMap[cmdJson['vpc-local-system-mac']] = {'switchSn' : deviceSn, 'peerMac' : cmdJson['vpc-peer-system-mac']}\n                                else:\n                                    # an image version that we cannot do this check.. we will skip\n                                    Wrapper.print(\"%s: [%s]: Skipping Missing vPC Peer check. Cmd Response [%s]\" % \n                                        (funcName, deviceSn, cmdJson))\n                        if fabricSettings.get(\"FABRIC_VPC_QOS\") == \"true\":\n                            dict = switchInfoDict[deviceSn]\n                            switchRole = dict[\"switchRole\"]\n                            if \"spine\" in switchRole:\n                                newRespObj = WrappersResp.getRespObj()\n                                newRespObj.setSuccessRetCode()\n                                qosPolicyName = fabricSettings.get(\"FABRIC_VPC_QOS_POLICY_NAME\", \"spine_qos_for_fabric_vpc_peering\")\n                                cmapCmd = 'show running-config ipqos | section \"^class-map type qos match-all %s\"'%qosPolicyName\n                                cmapCmdOut = getSwitchCmdOutput(sshObj, deviceSn, cmapCmd, newRespObj)\n                                if not newRespObj.isRetCodeSuccess():\n                                    Util.processRespObj(respObj, newRespObj)\n                                    respObj.setFailureRetCode()\n                                pmapCmd = 'show running-config ipqos | section \"^policy-map type qos %s\"'%qosPolicyName\n                                pmapCmdOut = getSwitchCmdOutput(sshObj, deviceSn, pmapCmd, newRespObj)\n                                if not newRespObj.isRetCodeSuccess():\n                                    Util.processRespObj(respObj, newRespObj)\n                                    respObj.setFailureRetCode()\n                                if cmapCmdOut and pmapCmdOut:\n                                    vVpcSpineQos[deviceSn] = {\"classMap\":cmapCmdOut, \"policyMap\":pmapCmdOut}\n                                    Wrapper.print(\"%s: [%s]: vVpcSpineQos [%s]\" % (funcName, deviceSn, vVpcSpineQos))\n                    finally:\n                        if sshObj:\n                            Wrapper.print(\"%s: Closing SSH connection for : [%s]\" %  (funcName, deviceSn))\n                            sshObj.close()\n\n                # look through all vpc switches to make sure the peer is in the fabric\n                Wrapper.print(\"%s: [%s]: vpcSrcToDstMacMap : [%s]\" % (funcName, deviceSn, vpcSrcToDstMacMap))\n                for srcSysMac in vpcSrcToDstMacMap:\n                    entry = vpcSrcToDstMacMap[srcSysMac]\n                    switchSn = entry['switchSn']\n                    if entry['peerMac'] not in vpcSrcToDstMacMap:\n                        Wrapper.print(\"%s: vPC Peer for Switch [%s] with Local System Mac [%s] not found in fabric\" %\n                                      (funcName, switchSn, srcSysMac))\n                        respObj.addErrorReport(getFabErrEntity(funcName, switchSn+\":vPC Peer\"),\n                                       \"vPC Peer not found in fabric. \"\n                                       \"Please add the vPC peer switch to the fabric and retry Recalculate & Deploy\", switchSn)\n                        respObj.setFailureRetCode()\n\n        if respObj.isRetCodeFailure():\n            return respObj\n\n        if numChangeMgmtMode:\n            for deviceSn in changeMgmtModeSwitches:\n                targetMode = None\n                ptiList = Util.exe(PTIWrapper.get(deviceSn, \"SWITCH\", \"SWITCH\", \"\", \"switch_migration_state\"))\n                for pti in ptiList:\n                    if pti.isDeleted():\n                        continue\n                    targetMode = pti.getNvPairs().get(\"TARGET_MGMT_MODE\", None)\n                    break\n\n                Wrapper.print(\"%s: Switch [%s] Target Mgmt Mode [%s]\" % (funcName, deviceSn, targetMode))\n                newDiscIP = None\n                if targetMode == \"OOB\":\n                    newDiscIntf = \"mgmt0\"\n                    intfTmplName = \"int_mgmt\"\n                    newDiscVrf = \"management\"\n                else:\n                    newDiscIntf = \"loopback\" + fabricSettings.get(\"BGP_LB_ID\", \"0\")\n                    intfTmplName = \"int_fabric_loopback_11_1\"\n                    newDiscVrf = \"default\"\n\n                intfPti = None\n                srchOpt = CtrlPolicySearch()\n                srchOpt.setSerialNumber(deviceSn)\n                srchOpt.setEntityName(newDiscIntf)\n                srchOpt.setTemplateName(intfTmplName)\n                srchOpt.setTemplateContentType(\"PYTHON\")\n                intfPtis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                for pti in intfPtis:\n                    if pti.isDeleted():\n                        continue\n                    intfPti = pti\n                    break\n\n                if intfPti is None:\n                    respObj.addErrorReport(getFabErrEntity(funcName, deviceSn+\":DiscoveryIPChange\"),\n                                   \"Interface policy for interface [%s] not found. \"\n                                   \"Please double check and retry Recalculate & Deploy\" % (newDiscIntf), deviceSn)\n                    respObj.setFailureRetCode()\n                    continue\n\n                if targetMode == \"OOB\":\n                    #   - make sure the mgmt0 intf intent is present\n                    #   - get the mgmt0 IP address\n                    intfFF = intfPti.getNvPairs().get(\"CONF\", None)\n                    for line in intfFF.split(Util.newLine()):\n                        stripLine = line.strip()\n                        if stripLine.startswith(\"ip address \"):\n                            parts = stripLine.split(\" \")\n                            newDiscIP = parts[2].split(\"/\")[0]\n                            break\n                else:\n                    #   - make sure the lo0 intf intent is present\n                    #   - get the IP address\n                    newDiscIP = intfPti.getNvPairs().get(\"IP\", None)\n\n                if newDiscIP is None:\n                    respObj.addErrorReport(getFabErrEntity(funcName, deviceSn+\":DiscoveryIPChange\"),\n                                   \"IP address for interface [%s] not found. \"\n                                   \"Please double check and retry Recalculate & Deploy\" % (newDiscIntf), deviceSn)\n                    respObj.setFailureRetCode()\n                    continue\n\n                # do the discovery IP change for the switches\n                Util.exe(InventoryWrapper.changeDiscoveryIP(deviceSn, newDiscIP))\n\n                # update the discovery intf and vrf\n                Util.exe(InventoryWrapper.updateDiscoveryIntfAndVrf(deviceSn, newDiscIntf, newDiscVrf))\n\n                # take switch out of migration mode\n                delMigrationState(FABRIC_NAME, deviceSn)\n\n            if respObj.isRetCodeSuccess():\n                # we successfully updated the mgmt mode, but, discovery may not have completed.\n                # Report error to ask user to retry\n                respObj.addErrorReport(getFabErrEntity(funcName, deviceSn+\":DiscoveryIPChange\"),\n                               \"The discovery mode for switches have been updated, but, discovery may not have completed. \"\n                               \"Please check to make sure Discovery Status is 'Ok' and retry Recalculate & Deploy\")\n                respObj.setFailureRetCode()\n                return respObj\n\n        elif numUpg or numResync or numChangeIP:\n            doPreview = True\n            if numUpg:\n                progressPrefix = \"Brownfield\"\n                if fabTech == \"VLANFabric\":\n                    for deviceSn in upgradeOrBrownfieldSwitches:\n                        dict = switchInfoDict[deviceSn]\n                        #Adding agg switches to be processed first\n                        if \"aggregation\" in dict[\"switchRole\"].lower():\n                            aggSwitches.append(deviceSn)\n                        elif \"access\" in dict[\"switchRole\"].lower():\n                            accessSwitches.append(deviceSn)\n                    Wrapper.print(\"%s: BF: Fabric [%s] aggSwitches %d : %s accessSwitches %d : %s\" % (funcName, FABRIC_NAME, \n                                  len(aggSwitches), aggSwitches, len(accessSwitches), accessSwitches))\n                    switchList = aggSwitches + list(set(upgradeOrBrownfieldSwitches) - set(aggSwitches))\n                else:\n                    # sort the list to process spine role switches first\n                    spineSwitches = []\n                    for deviceSn in upgradeOrBrownfieldSwitches:\n                        dict = switchInfoDict[deviceSn]\n                        if \"spine\" in dict[\"switchRole\"].lower():\n                            spineSwitches.append(deviceSn)\n    \n                    Wrapper.print(\"%s: BF: Fabric [%s] spineSwitches %d : %s\" % (funcName, FABRIC_NAME, len(spineSwitches), spineSwitches))\n                    switchList = spineSwitches + list(set(upgradeOrBrownfieldSwitches) - set(spineSwitches))                    \n                # no need for preview call in normal brownfield cases\n                doPreview = False\n            elif numResync:\n                progressPrefix = \"Host Port Resync\"\n                switchList = hostPortResyncSwitches\n            else:\n                progressPrefix = \"Change Discovery IP\"\n                switchList = changeIPSwitches\n\n            try:\n                if (progressPrefix == \"Brownfield\"):\n                    # check and record that the import process is starting\n                    Util.exe(FabricWrapper.setFabricActivity(FABRIC_NAME, \"Brownfield Import\"))\n\n                if doPreview:\n                    # build a comma separated list of switch serials\n                    swSerialList = \",\".join(switchList)\n                    # trigger a preview to inform CC of the switches in migration mode\n                    newResp = FabricWrapper.configPreview(FABRIC_NAME, swSerialList, True, True, True)\n                    if not newResp.isRetCodeSuccess():\n                        Wrapper.print(\"handleUpgradeOrBrownfield: Switch [%s] Preview call failed\" %  (swSerialList))\n                        Util.processRespObj(respObj, newResp)\n\n                if respObj.isRetCodeFailure():\n                    return respObj\n\n                globalOverlayInfo = {\n                    \"networkProfileName\" : fabricSettings.get(\"default_network\", None) if fabTech != \"VLANFabric\" else fabricSettings.get(\"network_template\", None),\n                    \"networkExtProfileName\" : fabricSettings.get(\"network_extension_template\", None),\n                    \"vrfProfileName\" : fabricSettings.get(\"default_vrf\", None) if fabTech != \"VLANFabric\" else fabricSettings.get(\"vrf_template\", None),\n                    \"vrfExtProfileName\" : fabricSettings.get(\"vrf_extension_template\", None),\n\n                    # parameters for CLI based overlay migrations\n                    \"overlayVlanNameSupported\" : \"true\",\n                    # if this flag is set to \"true\", the overlay NX-OS CLIs will be removed after deploying the\n                    # NDFC overlay profiles. Use case is for config-profile mode\n                    \"cleanupOverlayOrigCliCfg\" : \"true\",\n\n                    # routing loopback name\n                    \"routingLoName\" : \"Loopback\" + fabricSettings.get(\"BGP_LB_ID\", \"\"),\n\n                    # parameters for Cfg Profile based overlay migration\n                    \"cfgProfileInfo\" : {\"hasCfgProfile\" : None, \"refSwitch\" : None},\n\n                    # dictionary of switch related info, key is switch serial\n                    \"SWITCH_INFO\" : switchInfoDict,\n\n                    # dictionary of 'switchOverlayInfo' objects. key is switch serial (string)\n                    \"SWITCH_OVERLAYS\" : {},\n\n                    # overlay LanAttachByVRF object. key is vrf vni id (str)\n                    \"VRF_ATTACH\" : {},\n                    # overlay LanAttachByNetwork object. key is network vni id (str) \n                    \"NETWORK_ATTACH\" : {},\n\n                    # Dictionary holding this info\n                    # switches - data parsed from switches\n                    # vpcHostPairs - data related to vpc pair switches\n                    # networks - overlay network info\n                    \"HOST_PORT_RESYNC\" : None,\n\n                    \"SERVICES\" : None,\n\n                    \"isExternalFab\" : isExternalFab,\n                    \n                    \"fabricTechnology\" : fabTech\n                }\n\n                for deviceSn in switchList:\n                    dict = switchInfoDict[deviceSn]\n\n                    # check to make sure discovery status is ok\n                    if dict[\"discStatus\"] != \"ok\":\n                        respObj.addErrorReport(funcName,\n                            \"Discovery state is not ok. Please ensure switch is discovered correctly and retry Recalculate & Deploy.\", deviceSn)\n                        respObj.setFailureRetCode()\n                        continue\n\n                    # master dictionary of all overlay info on switch\n                    #   SERIAL - serial # of switch\n                    #   SWITCH_VXLAN_INFO - VXLAN info obtained from switch\n                    #   VRFS_NAME2VNI - dictionary of VRF name to vni (string) mapping. Key is the VRF name\n                    #   VRFS_BY_ID - dictionary of VRF. Key is the VRF VNI (string). value is vrfEntry\n                    #   NETWORKS_BY_ID - dictionary of networks. Key is the network vni (string)\n                    #   NETWORKS_VLAN2VNI - dictionary of mapping network vlan id (integer) to vni string. Key is the vlan vni (integer)\n                    #   ALL_VLANS - list of all vlan ids (integers) found on switch\n                    #   OVERLAY_VLANS - list of overlay vlan ids (integers) - this includes network and vrf vlan ids. This will be valid for\n                    #                   both Brownfield\n                    #   PRE_INTF_FF - unaccounted configs that need to show up before interfaces\n                    #   POST_INTF_FF - unaccounted configs that need to show up after interfaces\n                    #   IFCS - list of IFCS found on border switches\n                    #          { \"VRF_LITE\" :\n                    #                       []\n                    #          }\n                    switchOverlayInfo = {\n                                         \"SERIAL\" : deviceSn,\n                                         \"SWITCH_VXLAN_INFO\" : None,\n                                         \"NETWORKS_BY_ID\" : {},\n                                         \"NETWORKS_VLAN2VNI\" : {},\n                                         # key is lower case vrf name, value = {\"origName\" : original vrf name, \"vni\" : vni id string}\n                                         \"VRFS_NAME2VNI\" : {},\n                                         \"VRFS_BY_ID\" : {},\n                                         \"ALL_VLANS\" : [],\n                                         \"OVERLAY_VLANS\" : [],\n                                         \"PRE_INTF_FF\" : [],\n                                         \"POST_INTF_FF\" : [],\n                                         \"BGP_FF\" : [],\n                                         \"switchRole\" : dict[\"switchRole\"],\n                                         \"doOverlayExtn\" : \"false\",\n                                         \"isVpc\" : None,\n                                         \"IFCS\" : {\"VRF_LITE\" : {}},\n                                         \"isServiceLeaf\" : False,\n                                         \"hasServiceAttachment\": False\n                                        }\n\n                    globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn] = switchOverlayInfo\n\n                if respObj.isRetCodeFailure():\n                    return respObj\n\n                isFabricInbandMgmt = True if fabricSettings.get(\"INBAND_MGMT\", \"false\") == \"true\" else False\n\n                doTemplateMatching = False\n                if numUpg or numResync or (numChangeIP and not isFabricInbandMgmt):\n                    # no need for full template matching for inband change IP.. it is just underlay routing looback intf\n                    doTemplateMatching = True\n\n                Wrapper.print (\"%s: FABRIC [%s] isFabricInbandMgmt [%r] doTemplateMatching [%r]\"% (funcName, FABRIC_NAME, isFabricInbandMgmt, doTemplateMatching))\n                if doTemplateMatching:\n                    aaaRemoteAuthEn = (True if fabricSettings.get(\"AAA_REMOTE_IP_ENABLED\", \"false\") == \"true\" else False)\n                    Wrapper.print (\"=========FABRIC [%s] MEASURING TIME START=========== %s\"% (FABRIC_NAME, datetime.datetime.now()))\n                    FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 10, (\"%s - Gathering information from switches\" % (progressPrefix))) \n                    Util.exe(parallelDeviceMatch(switchList, globalOverlayInfo, aaaRemoteAuthEn, isExternalFab, gVarDictObj[\"dcnmUser\"], gVarDictObj[\"topologyObj\"]))\n                    Wrapper.print (\"=========FABRIC [%s] MEASURING TIME END=========== %s\"% (FABRIC_NAME, datetime.datetime.now()))\n\n                if numUpg:\n                    # Handle the Upgrade/Brownfield case\n                    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n                    serviceSwDict = servicesInfo.get(\"serviceSwMaps\", None) if servicesInfo else None\n                    if serviceSwDict:\n                        # check to make sure the required external fabric exist\n                        extFabList = []\n                        for serviceNodeName in servicesInfo[\"serviceNodes\"]:\n                            extFabName = servicesInfo[\"serviceNodes\"][serviceNodeName][\"extFabricName\"]\n                            if extFabName not in extFabList:\n                                extFabList.append(extFabName)\n                                newRespObj = FabricWrapper.get(extFabName)\n                                if newRespObj.isRetCodeFailure():\n                                    # most likely the external fabric does not exist\n                                    msg = (\"L4-7 Services detected in the fabric. Please ensure an External Fabric with name [%s] \"\n                                        \"is created and available for use to hold the service node(s). Please create and retry.\" % (extFabName))\n                                    processUpgradeRespObjWithMsg(\"SERVICES\", msg, respObj, newRespObj)\n\n                        if respObj.isRetCodeFailure():\n                            return respObj\n\n                        swList = serviceSwDict.keys()\n                        # update the switch list to process the service nodes first\n                        switchList = set(switchList) - set(swList)\n                        newSwitchList = swList + list(switchList)\n\n                        switchList = newSwitchList\n                        Wrapper.print(\"%s: Fabric [%s] Updated switch list %s\" % (funcName, FABRIC_NAME, switchList))\n\n                        if servicesInfo:\n                            Wrapper.print(\"%s: Services Info %s\" % (funcName, json.dumps(servicesInfo, indent=4, sort_keys=True)))\n\n                    if fabTech != \"VLANFabric\":\n                        # check all the non-spine switch versions to determine the overlay migration behavior\n                        # relevant for CLI based vxlan config migration only\n                        for deviceSn in switchList:\n                            dict = switchInfoDict[deviceSn]\n                            switchRole = dict[\"switchRole\"]\n                            if switchRole.lower() == \"spine\":\n                                continue\n                            nxosImageVer = dict[\"imageVer\"]\n                            if globalOverlayInfo[\"overlayVlanNameSupported\"] == \"true\":\n                                if nxosImageVer.startswith(\"7.0(3)I4\"):\n                                    globalOverlayInfo[\"overlayVlanNameSupported\"] = \"false\"\n                            if ((fabricSettings.get(\"OVERLAY_MODE\") == \"config-profile\") and \n                                (globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"] == \"true\")):\n                                # 7.0(3)I7(6), 9.2(3) and newer has the fix for CSCvn67117\n                                if ((nxosImageVer in [\"9.2(1)\", \"9.2(2)\"]) or\n                                   (LooseVersion(nxosImageVer) < LooseVersion('7.0(3)I7(6)'))):\n                                    globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"] = \"false\"\n    \n                            if ((globalOverlayInfo[\"overlayVlanNameSupported\"] == \"false\") and (globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"] == \"false\")):\n                                # no need to check further\n                                break\n\n                    Wrapper.print(\"%s: Fabric [%s] networkProfileName [%s] networkExtProfileName [%s] vrfProfileName [%s] \"\n                                \"vrfExtProfileName [%s]\" % (funcName, FABRIC_NAME, globalOverlayInfo[\"networkProfileName\"],\n                                globalOverlayInfo[\"networkExtProfileName\"], globalOverlayInfo[\"vrfProfileName\"],\n                                globalOverlayInfo[\"vrfExtProfileName\"]))\n                    Wrapper.print(\"%s: Fabric [%s] overlayVlanNameSupported [%s] cleanupOverlayOrigCliCfg [%s]\" % \\\n                                (funcName, FABRIC_NAME, globalOverlayInfo[\"overlayVlanNameSupported\"],\n                                globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"]))\n\n                    if inbandPoapEnabled == \"true\":\n                        # save the inband POAP seed switch info to be able to restore back on a failure since PTIs are cleaned\n                        for deviceSn in switchList:\n                            if deviceSn not in inbandPoapSeedSwitches:\n                                continue\n                            switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n                            ptiList = Util.exe(PTI.get(deviceSn, \"SWITCH\", \"SWITCH\", \"\", \"seed_switch\"))\n                            for pti in ptiList:\n                                switchInfo[\"inbandPoapSeedSwitch\"] = pti.getNvPairs()\n                                break\n\n                    # device underlay progress range is 40% - 60%\n                    progressBase = 40\n                    numProcessed = 0\n                    for deviceSn in switchList:\n                        numProcessed += 1\n                        progress = progressBase + int(float(numProcessed)/float(numUpg) * 20)\n                        \n                        dict = switchInfoDict[deviceSn]\n                        # get the file names to be used for the migration\n                        getMigrationFileNames(dict)\n                        # get the matching results\n                        dict[\"matchResult\"] = Util.exe(getJSONFileContents(dict[\"matchResultsFileName\"]))\n                        dict[\"interfacesRes\"] = Util.exe(getJSONFileContents(dict[\"interfaceMatchResultsFileName\"]))\n                        #Initialize agg-access (leaf-tor) or access-agg (tor-leaf) po downlink/uplink interface list\n                        switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n                        switchInfo[\"accessUplinkIntfs\"] = []\n\n                        gVarDictObj[\"DICTIONARY_OBJ\"] = dict\n                        #duplicate below two as postAdd doesn't pass \"DICTIONARY_OBJ\" as key\n                        gVarDictObj[\"deviceSerial\"] = deviceSn\n                        gVarDictObj[\"globalOverlayInfo\"] = globalOverlayInfo\n                        gVarDictObj[\"vpcSrcToDstMacMap\"] = vpcSrcToDstMacMap\n                        gVarDictObj[\"vVpcSpineQos\"] = vVpcSpineQos\n\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                            (\"%s - %d of %d - Switch [%s] Processing Underlay\" % (progressPrefix, numProcessed, numUpg, dict[\"fmtName\"])))\n                        try:\n                            newRespObj = WrappersResp.getRespObj()\n                            newRespObj.setSuccessRetCode()\n                            if fabTech == \"VLANFabric\":\n                                ECLfabricUpgrade(gVarDictObj, newRespObj)\n                            else:\n                                fabricUpgrade(gVarDictObj, newRespObj)\n                            if not newRespObj.isRetCodeSuccess():\n                                Util.processRespObj(respObj, newRespObj)\n                                if newRespObj.isRetCodeFailure():\n                                    Wrapper.print(\"Switch [%s]: Fabric upgrade failed\" % dict[\"fmtName\"])\n                                    # do not go further into the device upgrade if the consistency checks did not pass\n                                    continue\n\n                            newRespObj = WrappersResp.getRespObj()\n                            newRespObj.setSuccessRetCode()\n                            deviceUpgrade(gVarDictObj, newRespObj, not respObj.isRetCodeFailure())\n                            if not newRespObj.isRetCodeSuccess():\n                                Util.processRespObj(respObj, newRespObj)\n                                if newRespObj.isRetCodeFailure():\n                                    Wrapper.print(\"Switch [%s]: Device upgrade failed\" % dict[\"fmtName\"])\n\n                            # clear out the match results to avoid holding large data\n                            dict[\"matchResult\"] = dict[\"interfacesRes\"] = None\n                        except Exception as e:\n                            msg = (\"Switch [%s]: Unexpected error during Brownfield/Upgrade Processing\" % dict[\"fmtName\"])\n                            if isinstance(e, respObjError):\n                                processUpgradeRespObjWithMsg(deviceSn + \":BROWNFIELD\", msg, respObj, e.value)\n                            else:\n                                Util.handleException(msg, e, respObj)\n\n                    if respObj.isRetCodeFailure():\n                        # underlay migration failed\n                        resetSwitchMigration(FABRIC_NAME, switchList, globalOverlayInfo, gVarDictObj)\n\n                        respObj.addErrorReport(funcName,\n                            \"Switches are still in migration mode. Please resolve all errors and retry Recalculate & Deploy.\")\n                        respObj.setFailureRetCode()\n                        return respObj\n\n                    if servicesInfo:\n                        Wrapper.print(\"%s: After Services Info %s\" % (funcName, json.dumps(servicesInfo, indent=4, sort_keys=True)))\n\n                    if fabTech == \"VLANFabric\":\n                        #For ECL BF cases, now discover and set the access-agg pairing \n                        Wrapper.print(\"%s: Performing accessAggPairing accessSwitches %s\" % (funcName, accessSwitches))\n                        Util.exe(accessAggPairingBF(topologyDataObj, respObj))\n\n                        #For each access switch, determine the access-agg connected interfaces and set those\n                        for accessSn in accessSwitches:\n                            Util.exe(Util.validateAccessConnection(FABRIC_NAME, topologyDataObj, accessSn, respObj))\n                            handleTorLeafPairingBF(topologyDataObj, accessSn, respObj, globalOverlayInfo)\n                            if respObj.isRetCodeFailure():\n                                resetSwitchMigration(FABRIC_NAME, switchList, globalOverlayInfo, gVarDictObj)\n                                return respObj\n    \n                        #Print the uplink/download interfaces on access-agg side \n                        for snEntry in switchList:\n                            Wrapper.print(\"%s: Device %s Uplink/Download Interfaces %s\" % \n                                         (funcName, snEntry, globalOverlayInfo[\"SWITCH_INFO\"][snEntry][\"accessUplinkIntfs\"]))\n                        \n                        ECLhandleOverlayMigration(FABRIC_NAME, switchList, globalOverlayInfo, respObj, gVarDictObj, topologyDataObj)\n                    else:\n                        handleOverlayMigration(FABRIC_NAME, switchList, globalOverlayInfo, respObj, gVarDictObj)\n                elif numResync:\n                    # the host interface DB\n                    #   switches - dictionary of interfaces and corresponding info. Key is intf name (vpc key pair for vpcs)\n                    #              value is a dictionary that holds the following:\n                    #                   - current information found in IM\n                    #                   - new info obtained from switch\n                    hostPortResyncDict = {\"switches\" : {}, \"vpcHostPairs\" : {}, \"networks\" : {},\n                                          \"vpcPairMapping\" : {\"swToKp\" : {}, \"kPToSw\" : {}}}\n                    globalOverlayInfo[\"HOST_PORT_RESYNC\"] = hostPortResyncDict\n\n                    # build a dictionary to figure out the vpc pairings\n                    vpcMap = hostPortResyncDict[\"vpcPairMapping\"]\n                    for deviceSn in hostPortResyncSwitches:\n                        dict = switchInfoDict[deviceSn]\n\n                        # get the match related file names to be used for the resync\n                        getMigrationFileNames(dict)\n                        # get the matching results\n                        dict[\"matchResult\"] = Util.exe(getJSONFileContents(dict[\"matchResultsFileName\"]))\n                        dict[\"interfacesRes\"] = Util.exe(getJSONFileContents(dict[\"interfaceMatchResultsFileName\"]))\n\n                        hostPortResyncDict[\"switches\"][deviceSn] = {}\n\n                        if isExternalFab:\n                        #if dict[\"vpcPeer\"] == None: # not paired yet\n                            # check the vpc domain keep alive configs to build the vpc pair mappings that will be used to \n                            # determine the vpc pairings if not done yet\n                            nvPairs = None\n                            templateName = \"vpc_pair_vpc_domain_vrf_mgmt_no_hold\"\n                            nvPairList = getTemplateMatchResults(dict[\"matchResult\"], templateName)\n                            if (nvPairList != None):\n                                nvPairs = copy.deepcopy(nvPairList[0])\n                            if (nvPairs == None):\n                                templateName = \"vpc_pair_vpc_domain_vrf_mgmt\"\n                                nvPairList = getTemplateMatchResults(dict[\"matchResult\"], templateName)\n                                if (nvPairList != None):\n                                    nvPairs = copy.deepcopy(nvPairList[0])\n                            if (nvPairs == None):\n                                templateName = \"vpc_pair_vpc_domain_non_default_vrf_no_hold\"\n                                nvPairList = getTemplateMatchResults(dict[\"matchResult\"], templateName)\n                                if (nvPairList != None):\n                                    nvPairs = copy.deepcopy(nvPairList[0])\n                            if (nvPairs == None):\n                                templateName = \"vpc_pair_vpc_domain_non_default_vrf\"\n                                nvPairList = getTemplateMatchResults(dict[\"matchResult\"], templateName)\n                                if (nvPairList != None):\n                                    nvPairs = copy.deepcopy(nvPairList[0])\n\n                            if nvPairs:\n                                vpcMap[\"kPToSw\"][nvPairs[\"KEEP_ALIVE_LOCAL_IP\"]] = deviceSn\n                                vpcMap[\"swToKp\"][deviceSn] = {\"pairInfo\" : nvPairs}\n\n                    Wrapper.print(\"%s: vpcMap %s\" % (funcName, json.dumps(vpcMap, indent=4, sort_keys=True)))\n                    # check to make sure the vPC pair switches are in the resync list\n                    switchListWithSingleVpcSwitch = []\n                    for deviceSn in hostPortResyncSwitches:\n                        dict = switchInfoDict[deviceSn]\n\n                        if dict[\"vpcPeer\"] == None:\n                            # switch is not paired yet\n                            switchListWithSingleVpcSwitch.append(deviceSn)\n\n                            # do the vpc pair consistency check (both the switches must be in the resync list)\n                            kpEntry = vpcMap[\"swToKp\"].get(deviceSn, None)\n                            if not kpEntry:\n                                # standalone switch\n                                continue\n\n                            kpNvPairs = kpEntry[\"pairInfo\"]\n                            # switch has the keep alive config.. make sure the peer switch is also accounted for\n                            peerSerial = vpcMap[\"kPToSw\"].get(kpNvPairs[\"KEEP_ALIVE_PEER_IP\"], None)\n                            if peerSerial == None:\n                                # error.. the peer switch must be part of the resyn list\n                                respObj.addErrorReport(\"HOST_PORT_RESYNC:VPC_PAIR\",\n                                    \"vPC configuration detected, but, peer switch with keepalive IP [%s] not in the host port resync mode. \"\n                                    \"Please ensure that the vPC peer switch is also in the host port resyn mode and \"\n                                    \"retry Recalculate & Deploy.\" % (kpNvPairs[\"KEEP_ALIVE_PEER_IP\"]), deviceSn)\n                                respObj.setFailureRetCode()\n                                continue\n\n                            # update our peer switch info\n                            #vpcMap[\"swToKp\"][deviceSn][\"peerSw\"] = peerSerial\n\n                            # setting this will indicate that the switch is a vPC switch, but, not yet paired\n                            hostPortResyncDict[\"switches\"][deviceSn][\".vpcPeer\"] = peerSerial\n                        else:\n                            peerSerial = dict[\"vpcPeer\"]\n\n                        vpcPairkey = Util.exe(Helper.getKey(\"DevicePair\", deviceSn, peerSerial))\n                        if vpcPairkey in hostPortResyncDict[\"vpcHostPairs\"]:\n                            continue\n\n                        vpcPeerSwitchDict = switchInfoDict[peerSerial]\n                        vpcPairDict = {\"vpc_pair\" : {\"ptiID\" : None, \"nvPairs\" : None}}\n                        serials = vpcPairkey.split(Helper.DELIMITER)\n                        if serials[0] == deviceSn:\n                            vpcPairDict[\"peer1Sn\"] = deviceSn\n                            vpcPairDict[\"peer2Sn\"] = peerSerial\n                            vpcPairDict[\"fmtName\"] = ((\"%s <-> %s\") % (dict[\"fmtName\"], vpcPeerSwitchDict[\"fmtName\"]))\n                        else:\n                            vpcPairDict[\"peer1Sn\"] = peerSerial\n                            vpcPairDict[\"peer2Sn\"] = deviceSn\n                            vpcPairDict[\"fmtName\"] = ((\"%s <-> %s\") % (vpcPeerSwitchDict[\"fmtName\"], dict[\"fmtName\"]))\n\n                        if isExternalFab:\n                            # check if the vPC pair is paired with vpc_pair policy\n                            srchOpt = CtrlPolicySearch()\n                            srchOpt.setSerialNumber(vpcPairkey)\n                            srchOpt.setTemplateName(\"vpc_pair\")\n                            ptiList = Util.exe(PTI.getPTIs(srchOpt))\n                            for pti in ptiList:\n                                if pti.isDeleted():\n                                    continue\n\n                                vpcPairDict[\"vpc_pair\"][\"ptiID\"] = pti.getPolicyId()\n                                #vpcPairDict[\"vpc_pair\"][\"nvPairs\"] = copy.deepcopy(pti.getNvPairs())\n                                break\n\n                            peer1NvPairs = vpcMap[\"swToKp\"][vpcPairDict[\"peer1Sn\"]][\"pairInfo\"]\n                            peer2NvPairs = vpcMap[\"swToKp\"][vpcPairDict[\"peer2Sn\"]][\"pairInfo\"]\n\n                            kpVrf = peer1NvPairs.get(\"KEEP_ALIVE_VRF\", None)\n                            if kpVrf == None:\n                                kpVrf = MGMT_VRF_NAME\n                            nvpairs = { \"DOMAIN_ID\" : peer1NvPairs[\"DOMAIN_ID\"],\n                                        \"PEER1_KEEP_ALIVE_LOCAL_IP\": peer1NvPairs[\"KEEP_ALIVE_LOCAL_IP\"],\n                                        \"PEER2_KEEP_ALIVE_LOCAL_IP\": peer2NvPairs[\"KEEP_ALIVE_LOCAL_IP\"],\n                                        \"KEEP_ALIVE_VRF\": kpVrf,\n                                        \"KEEP_ALIVE_HOLD_TIMEOUT\": peer1NvPairs.get(\"KEEP_ALIVE_HOLD_TIMEOUT\", \"3\"),\n                                        \"isVpcPlus\": \"false\",\n                                        \"fabricPath_switch_id\": \"\",\n                                        \"isVTEPS\": \"false\",\n                                        \"NVE_INTERFACE\": \"\",\n                                        \"PEER1_SOURCE_LOOPBACK\": \"\",\n                                        \"PEER2_SOURCE_LOOPBACK\": \"\",\n                                        \"PEER1_PRIMARY_IP\": \"\",\n                                        \"PEER2_PRIMARY_IP\": \"\",\n                                        \"LOOPBACK_SECONDARY_IP\": \"\",\n                                        \"PEER1_DOMAIN_CONF\": \"\",\n                                        \"PEER2_DOMAIN_CONF\": \"\"\n                                      }\n\n                            vpcPairDict[\"vpc_pair\"][\"nvPairs\"] = nvpairs\n\n                        # add an entry to our vpc pair dictionary\n                        hostPortResyncDict[\"vpcHostPairs\"][vpcPairkey] = vpcPairDict\n\n                        if deviceSn not in switchListWithSingleVpcSwitch:\n                            switchListWithSingleVpcSwitch.append(deviceSn)\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    if not isExternalFab:\n                        # collect the overlay host port attachment info, so that we know set of overlay vlans etc.\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 50,\n                            (\"%s - Gathering Overlay Network Host Port Attachments\" % (progressPrefix))) \n                        buildSwitchNetworkPortAttachments(FABRIC_NAME, globalOverlayInfo, hostPortResyncSwitches, respObj)\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    # get the current set of interfaces known in DCNM\n                    #Wrapper.print(\"%s: ****** Host Intf DB - vpcHostPairs1 = %s\" % (funcName,\n                    #    json.dumps(hostPortResyncDict[\"vpcHostPairs\"], indent=4, sort_keys=True)))\n                    Wrapper.print(\"%s: switchListWithSingleVpcSwitch %s\" % (funcName, switchListWithSingleVpcSwitch))\n                    for deviceSn in switchListWithSingleVpcSwitch:\n                        dict = switchInfoDict[deviceSn]\n                        gVarDictObj[\"DICTIONARY_OBJ\"] = dict\n                        #duplicate below two as postAdd doesn't pass \"DICTIONARY_OBJ\" as key\n                        gVarDictObj[\"deviceSerial\"] = deviceSn\n                        gVarDictObj[\"globalOverlayInfo\"] = globalOverlayInfo\n                        buildCurrentIntfInfoDb(FABRIC_NAME, gVarDictObj, respObj)\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    \"\"\"\n                    Wrapper.print(\"%s: ****** Host Intf DB - switches = %s\" % (funcName,\n                        json.dumps(hostPortResyncDict[\"switches\"], indent=4, sort_keys=True)))\n                    Wrapper.print(\"%s: ****** Host Intf DB - vpcHostPairs = %s\" % (funcName,\n                        json.dumps(hostPortResyncDict[\"vpcHostPairs\"], indent=4, sort_keys=True)))\n                    \"\"\"\n                    # device underlay progress range is 40% - 60%\n                    progressBase = 50\n                    numProcessed = 0\n                    for deviceSn in hostPortResyncSwitches:\n                        numProcessed += 1\n                        progress = progressBase + int(float(numProcessed)/float(numResync) * 20)\n\n                        dict = switchInfoDict[deviceSn]\n\n                        if not isExternalFab:\n                            utilObj = Util()\n                            allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n                            overlayVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n                            Wrapper.print(\"%s: Switch [%s] ALL_VLANS = [%d][%s] OVERLAY_VLANS = [%d][%s]\" %  (funcName, \n                                    dict[\"fmtName\"],\n                                    len(switchOverlayInfo[\"ALL_VLANS\"]), allVlansOnSwitchStr, \n                                    len(switchOverlayInfo[\"OVERLAY_VLANS\"]), overlayVlansOnSwitchStr))\n\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - %d of %d - Switch [%s] \"\n                            \"Processing Interfaces\" % (progressPrefix, numProcessed, numResync, dict[\"fmtName\"])))\n\n                        gVarDictObj[\"DICTIONARY_OBJ\"] = dict\n                        #duplicate below two as postAdd doesn't pass \"DICTIONARY_OBJ\" as key\n                        gVarDictObj[\"deviceSerial\"] = deviceSn\n                        gVarDictObj[\"globalOverlayInfo\"] = globalOverlayInfo\n\n                        Util.exe(buildHostPortResyncDb(FABRIC_NAME, gVarDictObj))\n\n                        # clear out the match results to avoid holding large data\n                        dict[\"matchResult\"] = dict[\"interfacesRes\"] = None\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    Wrapper.print(\"%s: ****** Host Intf DB - switches = %s\" % (funcName,\n                        json.dumps(hostPortResyncDict[\"switches\"], indent=4, sort_keys=True)))\n                    Wrapper.print(\"%s: ****** Host Intf DB - vpcHostPairs = %s\" % (funcName,\n                        json.dumps(hostPortResyncDict[\"vpcHostPairs\"], indent=4, sort_keys=True)))\n\n                    # validate the changes for unsupported cases\n                    validateOOBChanges(FABRIC_NAME, globalOverlayInfo, respObj)\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    # now that the switch interface DB is built.. do the necessary PTI updates\n                    updateHostPortPolicies(FABRIC_NAME, progressPrefix, 70, 20, globalOverlayInfo, respObj)\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    if not isExternalFab:\n                        # update the overlay port attachments\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 90,\n                                (\"%s - Updating Overlay Network Host Port Attachments\" % (progressPrefix))) \n                        updateSwitchNetworkPortAttachments(FABRIC_NAME, progressPrefix, 90, 10, globalOverlayInfo, respObj)\n\n                    if not respObj.isRetCodeFailure():\n                        # the operation completed successfully... take switches out of the resync mode\n                        for devSerial in hostPortResyncSwitches:\n                            Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.SIM_PTI, \"host_syncup_completed\", {}))\n                            ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"host_port_resync\"))\n                            for pti in ptiList:\n                                PTI.deleteInstance(pti.getPolicyId())\n                elif numChangeIP:\n                    # need to update the following intent:\n                    #   1. mgmt0 policy with int_mgmt\n                    #   2. switch_freeform with description \"management vrf configuration\" - Greenfield case\n                    #   3. the contents of vrf context management inside switch_freeform \n                    #       with description \"Pre Interfaces Configuration\" - Brownfield case\n                    #   4. v4_mgmt_default_gateway\n                    #   5. dns-vrfList PTI processing\n                    #   6. vpc domain update\n                    # progress range is 40% - 80%\n                    progressBase = 40\n                    numProcessed = 0\n                    vPcPairsList = []\n                    for deviceSn in switchList:\n                        numProcessed += 1\n                        progress = progressBase + int(float(numProcessed)/float(numChangeIP) * 40)\n                        swInfo = switchInfoDict[deviceSn]\n\n                        Wrapper.print(\"%s: *********** CHANGE IP - START - %d of %d - Switch [%s]\" % (funcName, \n                            numProcessed, numChangeIP, swInfo[\"fmtName\"]))\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - %d of %d - Switch [%s] \"\n                            \"Processing Switch\" % (progressPrefix, numProcessed, numChangeIP, swInfo[\"fmtName\"])))\n\n                        if isFabricInbandMgmt:\n                            seedIP = Util.exe(Helper.getSeedIp(deviceSn))\n                            # get the current PYTHON policy for the routing loopback intf and update with the seed ip\n                            ptiList = Util.exe(PTIWrapper.getPTIs(deviceSn, \"INTERFACE\", getLbIntfName(\"bgp\"), \"PYTHON\"))\n                            for pti in ptiList:\n                                nvPairs = copy.deepcopy(pti.getNvPairs())\n                                nvPairs[\"IP\"] = Util.exe(Helper.getSeedIp(deviceSn))\n                                Util.exe(PTI.updateInstance(pti.getPolicyId(), nvPairs))\n                                break\n                            continue\n\n                        # relevant for OOB mgmt\n                        # get the match related file names to be used\n                        getMigrationFileNames(swInfo)\n                        # get the matching results\n                        swInfo[\"matchResult\"] = Util.exe(getJSONFileContents(swInfo[\"matchResultsFileName\"]))\n                        swInfo[\"interfacesRes\"] = Util.exe(getJSONFileContents(swInfo[\"interfaceMatchResultsFileName\"]))\n            \n                        matchResults = swInfo[\"matchResult\"]\n                        interfacesRes = swInfo[\"interfacesRes\"]\n\n                        intfName = \"mgmt0\"\n                        intfMatchResult = interfacesRes.get(intfName, None)\n                        if intfMatchResult is not None:\n                            templateNameMatches = intfMatchResult[\"matched_templates\"]\n                            matchingNvPairs = getIntfMatchNvPairs(matchResults, intfName, templateNameMatches)\n\n                            nvPairs = getMgmtIntfNvpairs(swInfo, intfName, matchingNvPairs)\n                            PTIWrapper.createOrUpdate(deviceSn, \"INTERFACE\", intfName, \"\", ConfigPriority.INTF_MGMT,\n                                                \"int_mgmt\", nvPairs)\n\n                        mgmtVrfFF = getVrfCfg(MGMT_VRF_NAME, matchResults, False)\n                        if mgmtVrfFF:\n                            # there is some mgmt vrf config that we may need to update\n                            vrfPti = None\n                            ptiList = Util.exe(PTI.get(deviceSn, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n                            for pti in ptiList:\n                                if pti.isDeleted():\n                                    continue\n                                \n                                desc = pti.getDescription()\n                                if desc == GF_MGMT_VRF_FF_PTI_DESC:\n                                    vrfPti = pti\n                                elif desc == BF_PRE_INTF_FF_PTI_DESC:\n                                    vrfPti = pti\n\n                                if vrfPti:\n                                    newNvPairs = copy.deepcopy(vrfPti.getNvPairs())\n                                    updatedCfgList = updateMgmtVrfFF(newNvPairs[\"CONF\"], mgmtVrfFF, respObj)\n                                    if updatedCfgList:\n                                        newNvPairs[\"CONF\"] = Util.newLine().join(updatedCfgList)\n                                        # Wrapper.print(\"%s: Switch [%s] Change IP - new vrf cfg [%s]\" % (funcName, \n                                        #                                     swInfo[\"fmtName\"], newNvPairs[\"CONF\"]))\n                                        Util.exe(PTI.updateInstance(vrfPti.getPolicyId(), newNvPairs))\n                                    break\n                            \n                            if vrfPti is None:\n                                # we did not find a PTI, but, have some new content.. create new PTI\n                                createMgmtVrfPti(deviceSn, mgmtVrfFF)\n\n                        templateName = \"dns-vrfList\"\n                        srchOpt = CtrlPolicySearch()\n                        srchOpt.setSerialNumber(deviceSn)\n                        srchOpt.setTemplateName(templateName)\n                        ptiList = Util.exe(PTI.getPTIs(srchOpt))\n                        for pti in ptiList:\n                            if pti.isDeleted():\n                                continue\n                            \n                            if pti.getNvPairs().get(\"NAME_SERVER_VRF\") == MGMT_VRF_NAME:\n                                continue\n\n                            # delete this one since we will create new ones as needed\n                            PTI.deleteInstance(pti.getPolicyId())\n\n                        nvPairList = getTemplateMatchResults(matchResults, templateName)\n                        if nvPairList is not None:\n                            for nvPairs in nvPairList:\n                                if nvPairs[\"NAME_SERVER_VRF\"] != MGMT_VRF_NAME:\n                                    continue\n                            \n                                Util.exe(PTIWrapper.create(deviceSn, \"SWITCH\", \"SWITCH\", getSrc(templateName), \n                                            getPrio(templateName), templateName, nvPairs))\n\n                        templateName = \"v4_mgmt_default_gateway\"\n                        srchOpt = CtrlPolicySearch()\n                        srchOpt.setSerialNumber(deviceSn)\n                        srchOpt.setTemplateName(templateName)\n                        ptiList = Util.exe(PTI.getPTIs(srchOpt))\n                        for pti in ptiList:\n                            if pti.isDeleted():\n                                continue\n                            # delete this one since we will create new ones as needed\n                            PTI.deleteInstance(pti.getPolicyId())\n\n                        nvPairList = getTemplateMatchResults(matchResults, templateName)\n                        if nvPairList is not None:\n                            for nvPairs in nvPairList:\n                                Util.exe(PTIWrapper.create(deviceSn, \"SWITCH\", \"SWITCH\", getSrc(templateName), \n                                    getPrio(templateName), templateName, nvPairs))\n\n                        # check if the switch is a vPC pair\n                        newRespObj = VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, deviceSn)\n                        if newRespObj.isRetCodeSuccess():\n                            vpcPairKey = newRespObj.getValue()\n                            if vpcPairKey not in vPcPairsList:\n                                # will do additional checks later\n                                vPcPairsList.append(vpcPairKey)\n                        else:\n                            Wrapper.print(\"%s: Switch [%s] is not set as a vPC pair in DCNM\" % (funcName, swInfo[\"fmtName\"]))\n                        \n                        Wrapper.print(\"%s: *********** CHANGE IP - END - %d of %d - Switch [%s]\" % (funcName, \n                            numProcessed, numChangeIP, swInfo[\"fmtName\"]))\n\n                    # update vpc domain policies\n                    # progress range is 80% - 100%\n                    progressBase = 80\n                    numProcessed = 0\n                    numVpc = len(vPcPairsList)\n                    for vpcKeyPair in vPcPairsList:\n                        numProcessed += 1\n                        progress = progressBase + int(float(numProcessed)/float(numVpc) * 20)\n\n                        Wrapper.print(\"%s: *********** CHANGE IP - START vPC PAIR - %d of %d - VPC [%s]\" % (funcName, \n                            numProcessed, numVpc, vpcKeyPair))\n\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - %d of %d - \"\n                            \"Processing vPC pair\" % (progressPrefix, numProcessed, numVpc)))\n\n                        serials = vpcKeyPair.split(Helper.DELIMITER)\n                        peer1Serial = serials[0]\n                        peer2Serial = serials[1]\n\n                        # get the vpc_domain_mgmt PTI for each switch\n                        templateName = 'vpc_domain_mgmt'\n                        srchOpt = CtrlPolicySearch()\n                        srchOpt.setSerialNumber(peer1Serial)\n                        srchOpt.setTemplateName(templateName)\n                        p1PtiList = Util.exe(PTI.getPTIs(srchOpt))\n                        if len(p1PtiList) == 0:\n                            continue\n                        else:\n                            peer1Pti = p1PtiList[0]\n\n                        srchOpt.setSerialNumber(peer2Serial)\n                        p2PtiList = Util.exe(PTI.getPTIs(srchOpt))\n                        if len(p2PtiList) == 0:\n                            continue\n                        else:\n                            peer2Pti = p2PtiList[0]\n\n                        # get the seed IPs\n                        peer1SeedIp = Util.exe(Helper.getSeedIp(peer1Serial))\n                        peer2SeedIp = Util.exe(Helper.getSeedIp(peer2Serial))\n\n                        peer1NvPairs = copy.deepcopy(peer1Pti.getNvPairs())\n                        peer2NvPairs = copy.deepcopy(peer2Pti.getNvPairs())\n\n                        # Wrapper.print(\"%s: Change Discovery IP - VPC - peer1Serial [%s]: IP [%s] -> [%s],\"\n                        #             \"peer2Serial [%s]: IP [%s] -> [%s]\" % (funcName,\n                        #             switchInfoDict[peer1Serial][\"fmtName\"], nvPairs[\"PEER1_KEEP_ALIVE_LOCAL_IP\"], peer1SeedIp,\n                        #             switchInfoDict[peer2Serial][\"fmtName\"], nvPairs[\"PEER2_KEEP_ALIVE_LOCAL_IP\"], peer2SeedIp))\n\n                        peer1NvPairs[\"KEEP_ALIVE_PEER_IP\"]  = peer2SeedIp\n                        peer1NvPairs[\"KEEP_ALIVE_LOCAL_IP\"]  = peer1SeedIp\n                        peer2NvPairs[\"KEEP_ALIVE_PEER_IP\"]  = peer1SeedIp\n                        peer2NvPairs[\"KEEP_ALIVE_LOCAL_IP\"]  = peer2SeedIp\n\n                        Util.exe(PTI.updateInstance(peer1Pti.getPolicyId(), peer1NvPairs))\n                        Util.exe(PTI.updateInstance(peer2Pti.getPolicyId(), peer2NvPairs))\n\n                        Wrapper.print(\"%s: *********** CHANGE IP - END vPC PAIR - %d of %d - VPC [%s]\" % (funcName, \n                            numProcessed, numVpc, vpcKeyPair))\n\n                    # the operation completed successfully... take switches out of the change IP mode\n                    for deviceSn in switchList:\n                        # get switch out of the migration mode\n                        PTI.delete(deviceSn, \"SWITCH\", \"SWITCH\", \"\", \"switch_migration_state\")\n\n                FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 100, (\"%s - Completed\" % (progressPrefix)))\n\n                if (isExternalFab or respObj.isRetCodeFailure()):\n                    return respObj\n\n                for devSerial in devices:\n                    if Util.isSwitchInMigrationState(devSerial):\n                        Wrapper.print(\"%s: Switch [%s] still in migration mode\" % (funcName, devSerial))\n                        respObj.addErrorReport(getFabErrEntity(funcName),\n                            \"Switches are still in migration mode. Please resolve all errors and retry Recalculate & Deploy.\")\n                        respObj.setFailureRetCode()\n                        return respObj\n\n                Wrapper.print(\"%s: Migration is completed, now execute Save\" % funcName)\n                if ACTIVE_MIGRATION == \"true\":\n                    # take the fabric out of migration mode (upgrade case)\n                    FabricWrapper.update(FABRIC_NAME, \"ACTIVE_MIGRATION\", \"false\")\n            finally:\n                if (progressPrefix == \"Brownfield\"):\n                    # clear the BF import activity\n                    Util.exe(FabricWrapper.clearFabricActivity(FABRIC_NAME))\n    except Exception as e:\n        msg = (\"Unexpected error during Brownfield/Upgrade Processing. Please fix errors and retry Recalculate & Deploy\")\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"BROWNFIELD_UPGRADE\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        return respObj\n\ndef updateMgmtVrfFF(ffCfg, newMgmtVrfCfg, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    # Wrapper.print(\"%s: ffCfg [%s]\" % (funcName, ffCfg))\n    # Wrapper.print(\"%s: newMgmtVrfCfg [%s]\" % (funcName, newMgmtVrfCfg))\n    newCfgList = None\n    newMgmtVrfCfgList = newMgmtVrfCfg.splitlines()\n    try:\n        cfgList = []\n        lines = ffCfg.splitlines()\n        saveBlock = True\n        for line in lines:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                # top level CLI\n                # Wrapper.print(\"%s: Line [%s]\" % (funcName, line))\n                if (line.strip() == \"vrf context management\"):\n                    # add in the new config\n                    # Wrapper.print(\"%s: Found vrf mgmt\" % (funcName))\n                    saveBlock = False\n                    cfgList.extend(newMgmtVrfCfgList)\n                    newCfgList = cfgList\n                else:\n                    saveBlock = True\n                \n            if saveBlock:\n                cfgList.append(line)\n        if newCfgList is None:\n            # we did not find any existing config.. so append the new config\n            cfgList.extend(newMgmtVrfCfgList)\n            newCfgList = cfgList\n    except Exception as e:\n        Util.handleException((\"%s: Error processing Mgmt Vrf Config updates\" % (funcName)), e, respObj)\n        newCfgList = None\n    \n    return newCfgList\n\n# returns the following SVI match results for a given vlan id\n#   - the interface result match entry\n#   - the nvPairs for the corresponding 'vlan_interface' policy\n# None indicates that the matching SVI does not exist\n\ndef getSviTemplateMatch(vlanId, matchResult, interfacesRes):\n    sviNvPair = None\n    sviVlanIntfRes = None\n\n    intfName = \"Vlan\" + vlanId\n    # first check if the intf exists\n    if intfName not in interfacesRes:\n        return sviVlanIntfRes, sviNvPair\n\n    intfRes = interfacesRes[intfName]\n    if UNDERLAY_IS_V6 == \"true\":\n        templateName = \"v6_vlan_interface_link_local\" if USE_LINK_LOCAL == \"true\" else \"v6_vlan_interface\"\n    else:\n        templateName = \"vlan_interface\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            if (nvPair[\"INTF_NAME\"] == intfName):\n                sviVlanIntfRes = intfRes\n                sviNvPair = nvPair\n                break\n \n    return sviVlanIntfRes, sviNvPair\n\ndef getFabricIntefaces(topologyDataObj, sn, switchRole):\n    fabricInterfaces = []\n    allFabricInterfaces = topologyDataObj.get(TopologyInfoType.ALL_FABRIC_INTFS, sn)\n    for fabricIntf in allFabricInterfaces:\n        neighborSn = topologyDataObj.get(TopologyInfoType.NEIGHBOR_SN, sn, fabricIntf)\n        if neighborSn:\n            neighborFabricInterface = topologyDataObj.get(TopologyInfoType.NEIGHBOR_INTF, sn, fabricIntf)\n            if neighborSn and neighborFabricInterface:\n                # ignore physical links between switches of same role (ex: links between vpc pairs)\n                peerRole = topologyDataObj.getSwitchRole(neighborSn)\n                if switchRole != peerRole:\n                   fabricInterfaces.append(fabricIntf)\n    return fabricInterfaces\n\ndef getIntfTemplateNvpair(intfName, templateName, matchResult):\n    nvPair = None\n    #Wrapper.print(\"getIntfTemplateNvpair: intf [%s] template [%s]\" % (intfName, templateName))\n    if templateName in matchResult:\n        nvPairs = matchResult[templateName]\n        for entry in nvPairs:\n            if entry[\"INTF_NAME\"] == intfName:\n                nvPair = entry\n                break\n    return nvPair\n\ndef checkBfd(switchInfoDict, devSerial, fabricInterfaces, matchResult, interfacesRes, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    fmtName = switchInfoDict[\"fmtName\"]\n\n    if BFD_ENABLE == \"false\":\n        # do not check further\n        return\n\n    # check BFD feature\n    nvPairList = getTemplateMatchResults(matchResult, \"feature_bfd\")\n    if (nvPairList == None):\n        if BFD_ENABLE == \"true\":\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BFD_ENABLE\"),\n               \"BFD feature not enabled on switch, but, enabled in fabric settings\", devSerial)\n            respObj.setFailureRetCode()\n        \n    # po member policies\n    poMemberPoliciesSet = set([\"port_channel_mode_on\", \"port_channel_mode\"])\n\n    localFabricInterfaces = copy.deepcopy(fabricInterfaces)\n\n    # add the peer link SVI to the list to check\n    sviIntf, sviNvPair = getSviTemplateMatch(switchInfoDict[\"vpcInfo\"][\"peerLinkVlan\"], matchResult, interfacesRes)\n    if sviNvPair:\n        localFabricInterfaces.append(sviNvPair[\"INTF_NAME\"])\n\n    # validate all the expected configs on the fabric interfaces\n    for fabricIntf in localFabricInterfaces:\n        intfMatchEntry = interfacesRes[fabricIntf]\n\n        # skip PO members\n        if poMemberPoliciesSet.intersection(set(intfMatchEntry[\"matched_templates\"])):\n            Wrapper.print(\"%s: Switch [%s] skipping po member fabric interface [%s]\" % (funcName, fmtName, fabricIntf))\n            continue\n\n        # check for bfd auth\n        templateName = \"bfd_interface_auth\"\n        nvPair = getIntfTemplateNvpair(fabricIntf, templateName, matchResult)\n        if BFD_AUTH_ENABLE == \"true\":\n            isError = False\n            if nvPair:\n                if ((nvPair[\"BFD_AUTH_KEY\"] != BFD_AUTH_KEY) or\n                    (nvPair[\"BFD_AUTH_KEY_ID\"] != BFD_AUTH_KEY_ID)):\n                    isError = True\n\n            if isError:\n                params = {\"INTF_NAME\" : fabricIntf, \"BFD_AUTH_KEY\" : BFD_AUTH_KEY, \"BFD_AUTH_KEY_ID\" : BFD_AUTH_KEY_ID}\n                cfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, params, False, None)\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BFD_AUTH\"),\n                   \"Fabric interface [%s]: Required BFD interface authentication configuration mismatch or missing. \"\n                   \"Please configure the following: %s%s\" % (fabricIntf, Util.newLine(), cfg), devSerial)\n                respObj.setFailureRetCode()\n\ndef getShowRunConfigBlocks(fileName, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    configBlocks = {}\n    # open the test file and read line by line\n    file = None\n    try:\n        file = open(fileName, 'r')\n        lines = file.read().splitlines()\n        for line in lines:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                # top level CLIs\n                saveBlock = False\n                sectionKey = None\n                blockKey = None\n                cfgList = None\n                if (line.startswith(\"router ospf \") or line.startswith(\"router ospfv3 \")):\n                    sectionKey = \"ROUTER_OSPF\"\n                    saveBlock = True\n                elif line.startswith(\"router isis \"):\n                    sectionKey = \"ROUTER_ISIS\"\n                    saveBlock = True\n                elif line.startswith(\"key chain \"):\n                    sectionKey = \"KEY_CHAIN\"\n                    saveBlock = True\n                \n                if saveBlock:\n                    if sectionKey not in configBlocks:\n                        configBlocks[sectionKey] = {}\n                    cfgList = []\n                    configBlocks[sectionKey][line] = cfgList\n\n            if saveBlock:\n                cfgList.append(line)\n    except Exception as e:\n        Util.handleException((\"Error reading from file [%s] trying to extract config blocks\" % fileName), e, respObj)\n    finally:\n        if file:\n            file.close()\n        return configBlocks\n\ndef checkAuthAndFabricIntfs(switchInfoDict, devSerial, switchRole, fabricInterfaces, \n                                vpcPeerLinkVlanFound, matchResult, interfacesRes, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    fmtName = switchInfoDict[\"fmtName\"]\n\n    Wrapper.print(\"%s: Switch [%s] fabricInterfaces %s\" % (funcName, fmtName, fabricInterfaces))\n\n    localFabricInterfaces = copy.deepcopy(fabricInterfaces)\n\n    # add the loopback and vpc peer link svi to the list (if present)\n    loInf = getLbIntfName(\"bgp\")\n    if loInf in interfacesRes:\n        localFabricInterfaces.append(loInf)\n\n    if switchRole != \"spine\":\n        loInf = getLbIntfName(\"nve\")\n        if loInf in interfacesRes:\n            localFabricInterfaces.append(loInf)\n    \n    \"\"\"\n    if vpcPeerLinkVlanFound:\n        localFabricInterfaces.append(\"Vlan\" + VPC_PEER_LINK_VLAN)\n    \"\"\"\n\n    # check some global parameters first\n    isisKeychainAuthNvPair = None\n    isisAuthNvPair = None\n    if LINK_STATE_ROUTING == \"is-is\":\n        nvPairList = getTemplateMatchResults(matchResult, \"base_isis_auth\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if (nvPair[\"ISIS_TAG\"] == LINK_STATE_ROUTING_TAG):\n                    isisAuthNvPair = nvPair\n                    break\n            if isisAuthNvPair:\n                if (ISIS_AUTH_ENABLE != \"true\"):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                       \"ISIS Area Authentication found, but, not enabled in fabric settings\", devSerial)\n                    respObj.setFailureRetCode()\n            else:\n                if (ISIS_AUTH_ENABLE == \"true\"):\n                    nvPairs = {\"ISIS_TAG\" : LINK_STATE_ROUTING_TAG, \"IS_TYPE\" : ISIS_LEVEL,\n                               \"ISIS_AUTH_KEYCHAIN_NAME\" : ISIS_AUTH_KEYCHAIN_NAME}\n                    expectedCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(\"base_isis_auth\", nvPairs, False, None)\n\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                       \"ISIS Area Authentication configuration not found, but, enabled in fabric settings. Expected configuration [%s]\" %\n                       (expectedCfg), devSerial)\n                    respObj.setFailureRetCode()\n        else:\n            if (ISIS_AUTH_ENABLE == \"true\"):\n                # switch does not auth configured, but, fabric has configuration\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                   \"ISIS Area Authentication not configured\", devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n        if (ISIS_AUTH_ENABLE == \"true\"):\n            # check the keychain also if ISIS Auth is enabled\n            nvPairList = getTemplateMatchResults(matchResult, \"keychain\")\n            if (nvPairList != None):\n                for nvPair in nvPairList:\n                    #Wrapper.print(\"Switch [%s] Processing keychain [%s, %s]\" %\n                    #    (devSerial, nvPair[\"KEYCHAIN_NAME\"], nvPair[\"KEYCHAIN_ID\"]))\n                    if ((nvPair[\"KEYCHAIN_NAME\"] == ISIS_AUTH_KEYCHAIN_NAME) and\n                        (nvPair[\"KEYCHAIN_ID\"] == ISIS_AUTH_KEYCHAIN_KEY_ID) and (nvPair[\"AUTH_KEY\"] == ISIS_AUTH_KEY)):\n                        # this keychain is what we are looking for\n                        isisKeychainAuthNvPair = nvPair\n                        break\n            if not isisKeychainAuthNvPair:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                   \"ISIS Authentication keychain for Name, Id, Key [%s, %s, %s] not found\" % \n                    (ISIS_AUTH_KEYCHAIN_NAME, ISIS_AUTH_KEYCHAIN_KEY_ID, ISIS_AUTH_KEY), devSerial)\n                respObj.setFailureRetCode()\n            else:\n                if (isisAuthNvPair and (isisAuthNvPair[\"ISIS_AUTH_KEYCHAIN_NAME\"] != isisKeychainAuthNvPair[\"KEYCHAIN_NAME\"])):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                       \"ISIS Area Authentication keychain name [%s] does not match configured keychain name [%s]\" %\n                       (isisAuthNvPair[\"ISIS_AUTH_KEYCHAIN_NAME\"], isisKeychainAuthNvPair[\"KEYCHAIN_NAME\"]), devSerial)\n                    respObj.setFailureRetCode()\n    else:\n        nvPairList = getTemplateMatchResults(matchResult, \"base_ospf_auth\")\n        ospfAuthInstanceNvpair = None\n        if (nvPairList != None):\n            # there could be multiple OSPF instances.. look for the one matching the fabric setting\n            for nvPair in nvPairList:\n                if nvPair[\"OSPF_TAG\"] == LINK_STATE_ROUTING_TAG:\n                    ospfAuthInstanceNvpair = nvPair\n                    break\n\n        if (OSPF_AUTH_ENABLE == \"true\"):\n            if not ospfAuthInstanceNvpair:\n                # switch does not auth configured, but, fabric has configuration\n                nvPairs = {\"OSPF_TAG\" : LINK_STATE_ROUTING_TAG, \"OSPF_AREA_ID\" : OSPF_AREA_ID}\n                expectedCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(\"base_ospf_auth\", nvPairs, False, None)\n\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                   \"OSPF Message Digest Authentication not configured. Expected configuration [%s]\" % (expectedCfg), devSerial)\n                respObj.setFailureRetCode()\n        else:\n            if ospfAuthInstanceNvpair:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                   \"OSPF Message Digest Authentication found, but, not enabled in fabric settings\", devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n    # po member policies\n    poMemberPoliciesSet = set([\"port_channel_mode_on\", \"port_channel_mode\"])\n\n    fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n    inbandPoapEnabled = isInbandPoapEnabled(fabricSettings)\n\n    # validate all the expected configs on the interfaces\n    for fabricIntf in localFabricInterfaces:\n        intfMatchEntry = interfacesRes[fabricIntf]\n        isLoopbackIntf = False\n        if fabricIntf.startswith(\"loopback\"):\n            isLoopbackIntf = True\n\n        # skip PO members\n        if poMemberPoliciesSet.intersection(set(intfMatchEntry[\"matched_templates\"])):\n            Wrapper.print(\"%s: Switch [%s] skipping po member fabric interface [%s]\" %\n                (funcName, fmtName, fabricIntf))\n            continue\n\n        if not isLoopbackIntf:\n            if FABRIC_INTERFACE_TYPE == \"p2p\":\n                if UNDERLAY_IS_V6 == \"false\":\n                    nvPair = getIntfTemplateNvpair(fabricIntf, \"p2p_routed_interface\", matchResult)\n                    if not nvPair:\n                        # check for inband POAP case\n                        if inbandPoapEnabled == \"true\":\n                            nvPair = getIntfTemplateNvpair(fabricIntf, \"p2p_routed_interface_tag\", matchResult)\n                            if not nvPair:\n                                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":P2P\"),\n                                    \"Underlay is V4. Fabric interface [%s]: Required [%s] interface configuration not found with Inband POAP Enabled\" %\n                                    (fabricIntf, FABRIC_INTERFACE_TYPE), devSerial)\n                                respObj.setFailureRetCode()\n                        else:\n                            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":P2P\"),\n                                \"Underlay is V4. Fabric interface [%s]: Required [%s] interface configuration not found.\" %\n                                (fabricIntf, FABRIC_INTERFACE_TYPE), devSerial)\n                            respObj.setFailureRetCode()\n                elif USE_LINK_LOCAL == \"true\":\n                    nvPair = getIntfTemplateNvpair(fabricIntf, \"interface_ipv6_link_local\", matchResult)\n                    if not nvPair:\n                        nvPair = getIntfTemplateNvpair(fabricIntf, \"interface_ipv6_link_local_bia\", matchResult)\n                    if not nvPair:\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":P2P\"),\n                            \"Underlay is V6 and Link-Local is enabled. Fabric interface [%s]: Required [%s + link-local] interface configuration not found\" %\n                           (fabricIntf, FABRIC_INTERFACE_TYPE), devSerial)\n                        respObj.setFailureRetCode()\n                else:\n                    nvPair = getIntfTemplateNvpair(fabricIntf, \"interface_ipv6_11_1\", matchResult)\n                    if not nvPair:\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":P2P\"),\n                            \"Underlay is V6. Fabric interface [%s]: Required [%s + ipv6] interface configuration not found\" %\n                            (fabricIntf, FABRIC_INTERFACE_TYPE), devSerial)\n                        respObj.setFailureRetCode()\n            else:\n                nvPair = getIntfTemplateNvpair(fabricIntf, \"unnumbered_fabric_interface_nov6\", matchResult)\n                if not nvPair:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":UNUMBERED\"),\n                           \"Fabric interface [%s]: Required [%s] interface configuration not found\" %\n                           (fabricIntf, FABRIC_INTERFACE_TYPE), devSerial)\n                    respObj.setFailureRetCode()\n        \n        # check the routing protocol specific parameters\n        if LINK_STATE_ROUTING == \"is-is\":\n            templateName = \"isis_interface\" if UNDERLAY_IS_V6 == \"false\" else \"v6_isis_interface\"\n            nvPair = getIntfTemplateNvpair(fabricIntf, templateName, matchResult)\n            if nvPair:\n                if (nvPair[\"ISIS_TAG\"] != LINK_STATE_ROUTING_TAG):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS\"),\n                        \"Fabric interface [%s]: ISIS related configuration mismatch. Found Process ID [%s], Expected [%s]\" %\n                        (fabricIntf, nvPair[\"ISIS_TAG\"], LINK_STATE_ROUTING_TAG), devSerial)\n                    respObj.setFailureRetCode()\n            else:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS\"),\n                    \"Fabric interface [%s]: Required ISIS interface configuration not found\" % (fabricIntf), devSerial)\n                respObj.setFailureRetCode()\n\n            # skip auth related checks for the loopback interfaces\n            if isLoopbackIntf:\n                continue\n\n            # check network point-to-point. Allow if ISIS_P2P_ENABLE is enabled on fabric, but missing in switch config, not the reverse\n            if (FABRIC_INTERFACE_TYPE == \"p2p\" or UNDERLAY_IS_V6 == \"true\") and ISIS_P2P_ENABLE != \"true\":\n                templateName = \"isis_p2p_interface\"\n                nvPair = getIntfTemplateNvpair(fabricIntf, templateName, matchResult)\n                if nvPair:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                        \"Fabric interface [%s]: ISIS network point-to-point found on switch configuration, but not enabled on fabric.\" %\n                        (fabricIntf), devSerial)\n                    respObj.setFailureRetCode()\n\n            # check the auth related config\n            if FABRIC_INTERFACE_TYPE == \"p2p\":\n                templateName = \"isis_interface_auth\"\n            else:\n                templateName = \"isis_interface_auth_no_lvl\"\n            nvPair = getIntfTemplateNvpair(fabricIntf, templateName, matchResult)\n            if not nvPair and FABRIC_INTERFACE_TYPE == \"p2p\" and ISIS_P2P_ENABLE == \"true\":\n                # ISIS_P2P_ENABLE case can also use auth_no_lvl, as in 11.5(2), matching this is also ok\n                nvPair = getIntfTemplateNvpair(fabricIntf, \"isis_interface_auth_no_lvl\", matchResult)\n            if not nvPair:\n                if (ISIS_AUTH_ENABLE == \"true\"):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                        \"Fabric interface [%s]: Required ISIS interface authentication related configuration not found\" %\n                        (fabricIntf), devSerial)\n                    respObj.setFailureRetCode()\n                    # proceed to next error check\n            else:\n                if (ISIS_AUTH_ENABLE == \"true\"):\n                    if isisKeychainAuthNvPair:\n                        if (nvPair[\"ISIS_AUTH_KEYCHAIN_NAME\"] != ISIS_AUTH_KEYCHAIN_NAME):\n                            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                               \"Fabric Interface [%s] - ISIS Authentication keychain name [%s] does not match fabric setting [%s]\" %\n                                        (fabricIntf, nvPair[\"ISIS_AUTH_KEYCHAIN_NAME\"], ISIS_AUTH_KEYCHAIN_NAME), devSerial)\n                            respObj.setFailureRetCode()\n                else:\n                    # intf has ISIS interface auth configured, but, not enabled in fabric\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                        \"Fabric interface [%s]: ISIS interface authentication configuration found, but, not enabled in fabric settings\" %\n                        (fabricIntf), devSerial)\n                    respObj.setFailureRetCode()\n                    # proceed to next error check\n        else:\n            templateName = \"ospf_interface_11_1\" if UNDERLAY_IS_V6 == \"false\" else \"v6_ospf_interface\"\n            nvPair = getIntfTemplateNvpair(fabricIntf, templateName, matchResult)\n            if nvPair:\n                if ((nvPair[\"OSPF_TAG\"] != LINK_STATE_ROUTING_TAG) or (nvPair[\"OSPF_AREA_ID\"] != OSPF_AREA_ID)):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF\"),\n                        \"Fabric interface [%s]: OSPF related configuration mismatch. Found Process ID/Area [%s, %s], Expected [%s, %s]\" %\n                           (fabricIntf, nvPair[\"OSPF_TAG\"], nvPair[\"OSPF_AREA_ID\"], LINK_STATE_ROUTING_TAG, OSPF_AREA_ID), devSerial)\n                    respObj.setFailureRetCode()\n            else:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF\"),\n                   \"Fabric interface [%s]: Required OSPF interface configuration not found\" % (fabricIntf), devSerial)\n\n            # check the auth related config\n            nvPair = getIntfTemplateNvpair(fabricIntf, \"ospf_interface_auth\", matchResult)\n            if nvPair:\n                if (OSPF_AUTH_ENABLE != \"true\"):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                        \"Fabric interface [%s]: OSPF interface authentication configuration found, but, not enabled in fabric settings\" %\n                        (fabricIntf), devSerial)\n                    respObj.setFailureRetCode()\n                    # proceed to next error check\n                else:\n                    if ((nvPair[\"OSPF_AUTH_KEY\"] != OSPF_AUTH_KEY) or (nvPair[\"OSPF_AUTH_KEY_ID\"] != OSPF_AUTH_KEY_ID)):\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                           \"Fabric Interface [%s] - OSPF Authentication (Key ID, Key) [%s, %s]. Fabric setting [%s, %s]\" %\n                                (fabricIntf, nvPair[\"OSPF_AUTH_KEY_ID\"], nvPair[\"OSPF_AUTH_KEY\"], OSPF_AUTH_KEY_ID, OSPF_AUTH_KEY), devSerial)\n                        respObj.setFailureRetCode()\n                        # proceed to next error check\n            elif (OSPF_AUTH_ENABLE == \"true\"):\n                # switch does not auth configured, but, fabric has configuration\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                   \"Fabric interface [%s]: Required OSPF interface authentication configuration not found\" %\n                   (fabricIntf), devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n# returns two variables: hasVpcConfig, vpcDomainId\n#   hasVpcConfig - set to true if atleast some vpc domain config is found\n#   vpcDomainId  - the configured vpc domain id, None if not found\ndef getVpcDomainId(devSerial, matchResult):\n    # init to an invalid number\n    vpcDomainId = None\n    hasVpcConfig = False\n    vpcDomainTemplates = [\"vpc_delay_restore\", \"vpc_domain_autorecovery_default\", \"vpc_domain_virtual_peerlink_dscp\",\n            \"vpc_domain_autorecovery\", \"vpc_domain_default\", \"vpc_domain_ipv6_nd_11_1\", \"vpc_domain_l3_pka_vrf_11_1\",\n            \"vpc_domain_l3_vrf\", \"vpc_domain_mgmt_no_src_11_1\", \"vpc_domain_mgmt\"]\n    for template in vpcDomainTemplates:\n        if template in matchResult:\n            matchRes = matchResult[template]\n            if (len(matchRes) > 0):\n                hasVpcConfig = True\n                for nvPairs in matchRes:\n                    if \"DOMAIN_ID\" in nvPairs:\n                        vpcDomainId = nvPairs[\"DOMAIN_ID\"]\n                        break\n\n    Wrapper.print(\"getVpcDomainId: device [%s] hasVpcConfig [%s] vpcDomainId [%s]\" % (devSerial, hasVpcConfig, vpcDomainId))\n    return hasVpcConfig, vpcDomainId\n\ndef fabricUpgrade(gVarDictObj, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    try:\n        dictionaryObj = gVarDictObj[\"DICTIONARY_OBJ\"]\n        devSerial = dictionaryObj[\"deviceSerial\"]\n        topologyDataObj = gVarDictObj[\"topologyObj\"]\n        matchResult = dictionaryObj[\"matchResult\"]\n        interfacesRes = dictionaryObj[\"interfacesRes\"]\n\n        # build a dictionary of the BGP neighbors so that we can validate only BGP related entries that match our AS#.\n        # Note: this will be used in deviceUpgrade\n        bgpNeighborDict = {}\n        dictionaryObj[\"bgpNeighborDict\"] = bgpNeighborDict\n\n        switchRole = dictionaryObj[\"switchRole\"]\n        hostName = dictionaryObj[\"hostName\"]\n        formattedName = dictionaryObj[\"fmtName\"]\n        model = dictionaryObj[\"deviceModel\"]\n\n        isSpine = False\n        if topologyDataObj.check(TopologyInfoType.IS_SPINE, devSerial):\n            isSpine = True\n        Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s: Switch [%s] Model [%s] Role [%s] isSpine [%r] isN9KTahoe [%r]\" %\n                (FABRIC_NAME, funcName, formattedName, model, switchRole, isSpine, (not dictionaryObj[\"n9kIsNotTahoe\"])))\n\n        # port-profiles are not supported... look for them and report error\n        features_info = matchResult[\"FEATURES_INFO\"]\n        global_unaccounted = features_info[\"GLOBAL_UNACCTED\"][\"unaccounted\"]\n        isCdpError = False\n        isPortProfileFound = False\n        for line in global_unaccounted:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                if (line.startswith(\"port-profile\")):\n                    # port-profiles are not supported\n                    isPortProfileFound = True\n                elif ((line == \"no cdp enable\") or (line.startswith(\"cdp format device-id\"))):\n                    # CDP is disabled or system id is not in expected format\n                    isCdpError = True\n\n        if isPortProfileFound:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":PORT_PROFILE\"),\n                \"Port-Profiles are not supported. Please unconfigure all the port-profiles and retry.\",\n                devSerial)\n            respObj.setFailureRetCode()\n\n        if isCdpError:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial + \":CDP\"),\n                \"CDP is disabled and/or system id is in unexpected format. Please check documentation \"\n                \" for CDP requirements to update the switch configuration and retry.\", devSerial)\n            respObj.setFailureRetCode()\n\n        # vni ranges under 'interface nve1' is not supported\n        nveVnis = features_info[\"NVE_BLOCK\"].get(\"interface nve1\", None)\n        if nveVnis:\n            # look into each 'member vni xxx' config and check if it has a range\n            for nveCmd in nveVnis:\n                if not nveCmd.startswith(\"member vni\"):\n                    continue\n                nveVni = nveCmd.split(\" \")[2]\n                if \"-\" in nveVni:\n                    # we found a vni range.. report an error\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":NVE_VNI_RANGE\"),\n                        \"Unsupported VNI range [%s] under \\'interface nve1\\'. Please have individual \"\n                        \"VNIs and retry Recalculate & Deploy\" % (nveCmd), devSerial)\n                    respObj.setFailureRetCode()\n        vPCInfo = {\"virtualVPC\" : False, \"userPeerLinkVlanPtiId\" : None, \"peerLinkVlan\" : VPC_PEER_LINK_VLAN}\n        vPCInfo[\"hasVpcConfig\"], vPCInfo[\"domainId\"] = getVpcDomainId(devSerial, matchResult)\n        dictionaryObj[\"vpcInfo\"] = vPCInfo\n\n        # check if the user has specified a vpc peer link vlan by creating the 'vpc_peer_link_vlan' PTI\n        srchOpt = CtrlPolicySearch()\n        srchOpt.setSerialNumber(devSerial)\n        srchOpt.setSource(\"\")\n        srchOpt.setTemplateName(\"vpc_peer_link_vlan\")\n        ptis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n        for pti in ptis:\n            if pti.isDeleted():\n                continue\n            vPCInfo[\"userPeerLinkVlanPtiId\"] = pti.getPolicyId()\n            vPCInfo[\"peerLinkVlan\"] = pti.getNvPairs()[\"VLAN\"]\n            Wrapper.print(\"%s: Switch [%s] Found user specified vPC Peer Link Vlan [%s] PTI [%s]\" % (funcName, \n                formattedName, vPCInfo[\"peerLinkVlan\"], vPCInfo[\"userPeerLinkVlanPtiId\"]))\n            break\n        vpcPeerLinkVlanFound = False\n\n        if vPCInfo[\"domainId\"]:\n            # Do some sanity check for the vPC case\n            if ENABLE_FABRIC_VPC_DOMAIN_ID == \"true\":\n                # fabric is using same domain ids on all pairs.. it must match what is on the switch\n                if (vPCInfo[\"domainId\"] != FABRIC_VPC_DOMAIN_ID):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC\"),\n                           \"Please ensure the vPC Domain id on switch [%s] matches the fabric setting of [%s]\" %\n                           (vPCInfo[\"domainId\"], FABRIC_VPC_DOMAIN_ID), devSerial)\n                    respObj.setFailureRetCode()\n\n            sviIntf, sviNvPair = getSviTemplateMatch(vPCInfo[\"peerLinkVlan\"], matchResult, interfacesRes)\n            if sviNvPair:\n                vpcPeerLinkVlanFound = True\n            #   - check to make sure we have atleast one match for each of the vPC related templates\n            vpcTemplates = getVpcMandatoryTemplateList(dictionaryObj[\"n9kIsNotTahoe\"])\n            for templateName in vpcTemplates:\n                if (getTemplateMatchResults(matchResult, templateName) == None):\n                    if ((templateName == \"vpc_nve_loopback\") and \n                        getTemplateMatchResults(matchResult, \"vpc_nve_loopback_with_tag_11_1\") != None):\n                        continue\n                    if (templateName == \"vpc_nve_loopback\") and UNDERLAY_IS_V6 == \"true\":\n                        continue\n                    if ((templateName == \"vpc_peer_link_member_interface\") and \n                        getTemplateMatchResults(matchResult, \"vpc_domain_virtual_peerlink_dscp\") != None):\n                        continue\n                    # did not find any matches... vPC config is inconsistent\n                    Wrapper.print(\"%s: Switch [%s] Did not find a match for vPC template [%s]\" % (funcName, formattedName, templateName))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC\"),\n                               \"Did not find expected vPC configuration for [%s] template.\" % (templateName), devSerial)\n                    respObj.setFailureRetCode()\n                    isValidVPC = False\n            vPCInfo[\"virtualVPC\"] = False\n            nvPairList = getTemplateMatchResults(matchResult, \"vpc_domain_virtual_peerlink_dscp\")\n            if nvPairList:\n                vPCInfo[\"virtualVPC\"] = True\n\n            if not vPCInfo[\"virtualVPC\"] and not vpcPeerLinkVlanFound:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VPC_VLAN\"),\n                       \"vPC Peer Link Vlan/SVI is not matching with Fabric setting [%s]\" % (vPCInfo[\"peerLinkVlan\"]), devSerial)\n                respObj.setFailureRetCode()\n\n            if vPCInfo[\"virtualVPC\"] and vpcPeerLinkVlanFound:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC Virtual Peer link\"),\n                       \"vPC Peer Link Vlan/SVI should not be present with Virtual Peer Link Configuration [%s]\" %\n                       (vPCInfo[\"peerLinkVlan\"]), devSerial)\n                respObj.setFailureRetCode()\n\n            swVersionOk = Util.isSwVersionOk(devSerial, \"10.3.2\")\n            if vPCInfo[\"virtualVPC\"] and UNDERLAY_IS_V6 == \"true\" and not swVersionOk: \n                hostName = Util.exe(InventoryWrapper.getHostName(devSerial))\n                nxosImage = Util.exe(ImageManagementWrapper.getNXOSVersion(devSerial))\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":IPv6 Underlay Fabric Peering\"),\n                       \"vPC Virtual Peer Link with IPv6 Underlay is supported from 10.3.2 onwards, switch %s has %s\"%(hostName, nxosImage), devSerial)\n                respObj.setFailureRetCode()\n        else:\n            if vPCInfo[\"hasVpcConfig\"]:\n                # we did not find the vPC domain config match, report an error\n                templateName = \"base_vpc_domain_11_1\"\n                domainId = \"1000\"\n                if ENABLE_FABRIC_VPC_DOMAIN_ID == \"true\":\n                    domainId = FABRIC_VPC_DOMAIN_ID\n                params = {\"DOMAIN_ID\" : domainId}\n                cfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, params, False, None)\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC\"),\n                       \"Please ensure the following vPC domain configuration exists: %s%s\" % (Util.newLine(), cfg), devSerial)\n                respObj.setFailureRetCode()\n\n        Wrapper.print(\"%s: Switch [%s] vPC Info [%s]\" % (funcName, formattedName, vPCInfo))\n\n        if (not isSpine and not (\"border gateway\" in switchRole.lower())):\n            nvPairList = getTemplateMatchResults(matchResult, \"anycast_gateway\")\n            if (nvPairList != None):\n                configGw = Util.normalizeMac(ANYCAST_GW_MAC)\n                gw = nvPairList[0][\"ANYCAST_MAC\"].lower()\n                if (gw != configGw):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":GW\"),\n                           \"Found anycast-gateway [%s]. Fabric setting [%s]\" % (gw, ANYCAST_GW_MAC), devSerial)\n                    respObj.setFailureRetCode()\n                    # proceed to next error check\n            else:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":GW\"),\n                                       \"Anycast-gateway not configured\", devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n        # check if the Fabric Settings doesn't match replication # matches the configured value\n        multicastConfigInSwitch = asmConfigInSwitch = asmRPConfigInSwitch = False\n\n        nvPairList = getTemplateMatchResults(matchResult, \"base_pim_asm_11_1\")\n        if (nvPairList != None):\n            multicastConfigInSwitch = asmConfigInSwitch = True\n            if REPLICATION_MODE != \"Multicast\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Ingress Replication Mode\"),\n                       \"Multicast Config Found. Fabric setting [%s]\" % (REPLICATION_MODE), devSerial)\n                respObj.setFailureRetCode()\n            elif RP_MODE != \"asm\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast RP Mode\"),\n                       \"PIM ASM Config Found. Fabric setting [%s]\" % (RP_MODE), devSerial)\n                respObj.setFailureRetCode()\n            else:\n                # there could be multiple matches for base_pim_asm_11_1 policy.. one must match the\n                # fabric setting, or at least a superset of the fabric setting ... error if not\n                foundMatch = False\n                foundMatchSuperset = False\n                warningMsg = \"\"\n                for pimAsmNvpair in nvPairList:\n                    mcastGroupSubnet = pimAsmNvpair[\"RP_GROUP\"].strip()\n                    if (mcastGroupSubnet == MULTICAST_GROUP_SUBNET):\n                        foundMatch = True\n                        break\n                    else:\n                        Wrapper.print(\"[%s] look for mcast group subnet match, mcastGroupSubnet %s\" % (devSerial, mcastGroupSubnet))\n                        switchIP, switchMask = mcastGroupSubnet.split('/')\n                        fabricIP, fabricMask = MULTICAST_GROUP_SUBNET.split('/')\n                        if int(switchMask) < 16 and int(switchMask) < int(fabricMask):\n                            newSubnet = Util.getSubnetStringWithPrefix(fabricIP, switchMask)\n                            if newSubnet == mcastGroupSubnet:\n                                foundMatchSuperset = True\n                                warningMsg += \"Found switch config of Multicast Group Subnet %s different from %s in fabric setting. Switch config will be overwritten by value in fabric setting. \" % (mcastGroupSubnet, MULTICAST_GROUP_SUBNET)\n                                Wrapper.print(\"[%s]: %s\" % (devSerial, warningMsg))\n\n                if not foundMatch:\n                    if not foundMatchSuperset:\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast Group Subnet\"),\n                           \"Missing Multicast ASM Group configuration on switch for the \\'ip pim rp-address\\' CLI. Expected multicast group [%s]\" %\n                           (MULTICAST_GROUP_SUBNET), devSerial)\n                        respObj.setFailureRetCode()\n                        # proceed to next error check\n                    else:\n                        warningMessage = \"[%s/%s]: %s\" % (hostName, devSerial, warningMsg)\n                        respObj.addWarnReport(getFabErrEntity(funcName, devSerial), warningMessage)\n                        respObj.setWarningRetCode()\n\n        nvPairList = getTemplateMatchResults(matchResult, \"base_pim_bidir_11_1\")\n        if (nvPairList != None):\n            multicastConfigInSwitch = True\n            if REPLICATION_MODE != \"Multicast\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Ingress Replication Mode\"),\n                                       \"Multicast Config Found. Fabric setting [%s]\" % (REPLICATION_MODE), devSerial)\n                respObj.setFailureRetCode()\n            elif RP_MODE != \"bidir\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast RP Mode\"),\n                                       \"PIM Bidir Config Found. Fabric setting [%s]\" % (RP_MODE), devSerial)\n                respObj.setFailureRetCode()\n            elif (len(nvPairList) > 2):\n                # Only 2 RPs are supported for bidir in brownfield migration\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast RP Mode\"),\n                                       \"PIM Bidir Config Found. Config indicates that more than 2 RPs are used. \"\n                                       \"Only 2 or less RPs are supported in brownfield migration for Bidir.\", devSerial)\n                respObj.setFailureRetCode()\n            # No need to check mcastGroupSubnet used in the customer config,\n            # any bidir config change after brownfield migration will require manual config\n\n        if REPLICATION_MODE == \"Multicast\" and multicastConfigInSwitch == False:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast Replication Mode\"),\n                                   \"No Multicast Config Found. Fabric setting [%s]\" % (REPLICATION_MODE), devSerial)\n            respObj.setFailureRetCode()\n\n        nvPairList = getTemplateMatchResults(matchResult, \"evpn_multisite\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if nvPair[\"siteId\"] != SITE_ID:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Miltisite ID\"),\n                       \"Found Site Id [%s]. Fabric setting [%s]\" % (nvPair[\"siteId\"], SITE_ID), devSerial)\n                    respObj.setFailureRetCode()\n                    break\n\n        nvPairList = getTemplateMatchResults(matchResult, \"anycast_rp\")\n        if (nvPairList != None):\n            multicastConfigInSwitch = asmRPConfigInSwitch = True\n            if RP_MODE != \"asm\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast RP Mode\"),\n                                       \"PIM ASM Config Found. Fabric setting [%s]\" % (REPLICATION_MODE), devSerial)\n                respObj.setFailureRetCode()\n\n        nvPairList = getTemplateMatchResults(matchResult, \"pim_interface\")\n        if (nvPairList != None):\n            multicastConfigInSwitch = True\n\n        if multicastConfigInSwitch:\n            if REPLICATION_MODE == \"Ingress\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Ingress Replication Mode\"),\n                           \"Found Replication Mode # [%s]. Fabric setting [%s]\" % (\"Multicast\", REPLICATION_MODE), devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n        # check if the Fabric Settings of LINK_STATE_ROUTING matches the configured value\n        if LINK_STATE_ROUTING == \"ospf\":\n            ospfInstanceNvpair = None\n            templateName = \"base_ospf\" if UNDERLAY_IS_V6 == \"false\" else \"base_ospfv3\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            if (nvPairList != None):\n                # there could be multiple OSPF instances.. look for the one matching the fabric setting\n                for nvPair in nvPairList:\n                    if nvPair[\"OSPF_TAG\"] == LINK_STATE_ROUTING_TAG:\n                        ospfInstanceNvpair = nvPair\n                        break\n\n            if not ospfInstanceNvpair:\n                # we did not find the expected OSPF instance\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF Routing Tag\"),\n                   \"Did not find OSPF instance [%s]. Please ensure device has expected configuration as defined in the base_ospf policy\" %\n                            (LINK_STATE_ROUTING_TAG), devSerial)\n                respObj.setFailureRetCode()\n        else:\n            isisInstanceNvpair = None\n            nvPairList = getTemplateMatchResults(matchResult, \"base_isis_level2_internal\")\n            if (nvPairList != None):\n                # there could be multiple ISIS instances.. look for the one matching the fabric setting\n                for nvPair in nvPairList:\n                    if LINK_STATE_ROUTING_TAG == nvPair[\"ISIS_TAG\"]:\n                        isisInstanceNvpair = nvPair\n                        if nvPair[\"IS_TYPE\"] != ISIS_LEVEL:\n                            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS Level\"),\n                                \"ISIS Level on the device [%s] does not match fabric setting [%s]\" %\n                                (nvPair[\"IS_TYPE\"], ISIS_LEVEL), devSerial)\n                            respObj.setFailureRetCode()\n                            # proceed to next error check\n                        break\n            if not isisInstanceNvpair:\n                # we did not find the expected ISIS instance\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS Routing Tag\"),\n                   \"Did not find ISIS instance [%s]. Please ensure device has expected configuration.\" %\n                            (LINK_STATE_ROUTING_TAG), devSerial)\n                respObj.setFailureRetCode()\n\n        # check if the BGP AS # matches the configured value\n        bgpConfigFound = False\n        nvPairList = getTemplateMatchResults(matchResult, \"base_bgp\")\n        if (nvPairList != None):\n            bgpConfigFound = True\n            # we expect only one\n            switchBgpAs = nvPairList[0][\"BGP_AS\"].strip()\n            if (switchBgpAs != BGP_AS):\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AS\"),\n                               \"Found BGP AS # [%s]. Fabric setting [%s]\" % (switchBgpAs, BGP_AS), devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n        else:\n            # no BGP config... error on a leaf\n            if (topologyDataObj.check(TopologyInfoType.IS_LEAF, devSerial) or\n                topologyDataObj.check(TopologyInfoType.IS_BORDER_LEAF, devSerial) or\n                topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_LEAF, devSerial)):\n                Wrapper.print(\"Switch is Leaf from TD, but no BGP config or no BGP router-id configured\")\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AS\"),\n                                     \"BGP not configured or no BGP router-id configured.\", devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n        # look for both rr and non rr neighbor entries... check for the RR entries first\n        templateName = \"evpn_bgp_rr\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            for matchDict in nvPairList:\n                neighborIp = matchDict[\"BGP_NEIGHBOR_IP\"]\n                if (matchDict[\"BGP_AS\"] == BGP_AS):\n                    isInternal = True\n                else:\n                    isInternal = False\n                    matchDict = None\n\n                if neighborIp not in bgpNeighborDict:\n                    bgpNeighborDict[neighborIp] = {\"neighbor\" : matchDict, \"isInternal\" : isInternal}\n\n        templateName = \"evpn_bgp_rr_neighbor\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr_neighbor\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            for matchDict in nvPairList:\n                neighborIp = matchDict[\"BGP_NEIGHBOR_IP\"]\n                if (matchDict[\"BGP_AS\"] == BGP_AS):\n                    isInternal = True\n                else:\n                    isInternal = False\n                    matchDict = None\n\n                if neighborIp not in bgpNeighborDict:\n                    bgpNeighborDict[neighborIp] = {\"neighbor\" : matchDict, \"isInternal\" : isInternal}\n\n        bgpPwNvPairList = getTemplateMatchResults(matchResult, \"evpn_bgp_neighbor_auth\")\n        v6BgpPwNvPairList = getTemplateMatchResults(matchResult, \"v6_evpn_bgp_neighbor_auth\")\n        if v6BgpPwNvPairList != None:\n            if bgpPwNvPairList != None:\n                # merge the lists and process together\n                bgpPwNvPairList += v6BgpPwNvPairList\n            else:\n                bgpPwNvPairList = v6BgpPwNvPairList\n\n        if (bgpPwNvPairList != None):\n            for matchDict in bgpPwNvPairList:\n                neighborIp = matchDict[\"BGP_NEIGHBOR_IP\"]\n                key = \"bgpAuth\"\n                if neighborIp not in bgpNeighborDict:\n                    # we found a BGP password entry that did not match our BGP neighbor policy.. must be for\n                    # an external neighbor entry.. save it so that we can create the entry\n                    # Note: the actual bgp neighbor config will be in the unaccounted config\n                    bgpNeighborDict[matchDict[\"BGP_NEIGHBOR_IP\"]] = {\"neighbor\" : None, \n                                                    \"isInternal\" : False, key : matchDict}\n                    continue\n\n                # a neighbor we need to check against\n                neighborEntry = bgpNeighborDict[neighborIp]\n                if not neighborEntry[\"isInternal\"]:\n                    # update our neighbor dictionary with this info.. nothing more to check\n                    neighborEntry[key] = matchDict\n                    continue\n\n                # additional checks for internal neighbors\n                isBgpAuthMatchFail = ((matchDict[\"BGP_AUTH_KEY\"] != BGP_AUTH_KEY) or \n                    (matchDict[\"BGP_AUTH_KEY_TYPE\"] != BGP_AUTH_KEY_TYPE))\n                if (BGP_AUTH_ENABLE == \"true\"):\n                    if isBgpAuthMatchFail:\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AUTH\"),\n                           \"Found BGP Auth Key [%s, %s] for neighbor [%s]. Fabric setting [%s, %s]\"\n                                % (matchDict[\"BGP_AUTH_KEY_TYPE\"], matchDict[\"BGP_AUTH_KEY\"],\n                                    neighborIp, BGP_AUTH_KEY_TYPE, BGP_AUTH_KEY), devSerial)\n                        respObj.setFailureRetCode()\n                    else:\n                        # update our neighbor dictionary with this info\n                        neighborEntry[key] = matchDict\n                else:\n                    # BGP Auth configured on switch, but, not enabled in the fabric.. do not report\n                    # error.. will let the config get removed to follow setting\n                    pass\n\n        bfdNvPairList = getTemplateMatchResults(matchResult, \"bfd_bgp_neighbor\")\n        if (bfdNvPairList != None):\n            for matchDict in bfdNvPairList:\n                neighborIp = matchDict[\"BGP_NEIGHBOR_IP\"]\n                key = \"bfd\"\n                if neighborIp not in bgpNeighborDict:\n                    # we found a BGP password entry that did not match our BGP neighbor policy.. must be for\n                    # an external neighbor entry.. save it so that we can create the entry\n                    # Note: the actual bgp neighbor config will be in the unaccounted config\n                    bgpNeighborDict[matchDict[\"BGP_NEIGHBOR_IP\"]] = {\"neighbor\" : None, \n                                                    \"isInternal\" : False, key : matchDict}\n                    continue\n\n                # save info.. nothing to check\n                neighborEntry = bgpNeighborDict[neighborIp]\n                neighborEntry[key] = matchDict\n        \n        isBGW = topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_LEAF, devSerial)\n        if (topologyDataObj.check(TopologyInfoType.IS_LEAF, devSerial) or\n            topologyDataObj.check(TopologyInfoType.IS_BORDER_LEAF, devSerial) or isBGW):\n\n            if not isBGW:\n                # do not enforce for BGP role due to special case for EPL\n                templateName = \"evpn_bgp_rr\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr\"\n                nvPairList = getTemplateMatchResults(matchResult, templateName)\n                if (nvPairList != None):\n                    Wrapper.print(\"Switch is Leaf from TD, can not be BGP RR\")\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_RR\"),\n                                           \"Cannot be BGP RR due to its leaf role.\", devSerial)\n                    respObj.setFailureRetCode()\n\n            # TRM check\n            # TBD: Need to support brownfield for border spine and border gateway spine\n            nvPairList = getTemplateMatchResults(matchResult, \"mvpn_bgp_rr_neighbor\")\n            l3trm_nvPairList = getTemplateMatchResults(matchResult, \"l3_trm\")\n            if ENABLE_TRM == \"true\":\n                if nvPairList == None and not IBGP_PEER_TEMPLATE:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":TRM\"),\n                                       \"mvpn_bgp_rr_neighbor config not found while Tenant Routed Multicast is enabled.\", devSerial)\n                    respObj.setFailureRetCode()\n                if l3trm_nvPairList == None:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":TRM\"),\n                                       \"l3_trm config not found while Tenant Routed Multicast is enabled.\", devSerial)\n                    respObj.setFailureRetCode()\n            else:\n                if nvPairList != None:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":TRM\"),\n                                       \"mvpn_bgp_rr_neighbor config found while Tenant Routed Multicast is not enabled.\", devSerial)\n                    respObj.setFailureRetCode()\n                if l3trm_nvPairList != None:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":TRM\"),\n                                       \"l3_trm config found while Tenant Routed Multicast is not enabled.\", devSerial)\n                    respObj.setFailureRetCode()\n\n        # check BGP peer template consistency\n        global fabric_bgp_tmpl_type, fabric_bgp_tmpl_name\n        if IBGP_PEER_TEMPLATE:\n            if (IBGP_PEER_TEMPLATE_LEAF and\n                (topologyDataObj.check(TopologyInfoType.IS_LEAF, devSerial) or\n                 topologyDataObj.check(TopologyInfoType.IS_BORDER_LEAF, devSerial) or\n                 topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_LEAF, devSerial))):\n                bgp_peer_template = IBGP_PEER_TEMPLATE_LEAF.splitlines()\n            else:\n                bgp_peer_template = IBGP_PEER_TEMPLATE.splitlines()\n            peer_cmd = bgp_peer_template[0].strip().split(\" \")\n            fabric_bgp_tmpl_type = peer_cmd[1]\n            fabric_bgp_tmpl_name = peer_cmd[2]\n            Wrapper.print(\"[%s] IBGP_PEER_TEMPLATE consistency check - peer type: %s, name: %s\" % (devSerial, fabric_bgp_tmpl_type, fabric_bgp_tmpl_name))\n            nvPairList = getTemplateMatchResults(matchResult, \"bgp_peer_template\")\n            matching_peer_template_found = False\n            if nvPairList != None:\n                for nvPair in nvPairList:\n                    if (nvPair[\"BGP_AS\"] == BGP_AS and\n                        nvPair[\"TEMPLATE_TYPE\"] == fabric_bgp_tmpl_type and\n                        nvPair[\"TEMPLATE_NAME\"] == fabric_bgp_tmpl_name):\n                        # can add more check like line by line comparison\n                        matching_peer_template_found = True\n                        break\n                if not matching_peer_template_found:\n                    Wrapper.print(\"matching_peer_template_found NOT found on [%s]\" % devSerial)\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":IBGP PEER TEMPLATE\"),\n                                     \"IBGP Peer [template %s %s] not found on switch config while enabled on fabric setting \" %\n                                     (fabric_bgp_tmpl_type, fabric_bgp_tmpl_name), devSerial)\n                    respObj.setFailureRetCode()\n                    # proceed to next error check\n        else:\n            fabric_bgp_tmpl_type, fabric_bgp_tmpl_name = \"\", \"\"\n            nvPairList = getTemplateMatchResults(matchResult, \"bgp_peer_template\")\n            if nvPairList != None:\n                for nvPair in nvPairList:\n                    peer_template_conf = nvPair[\"CONF\"]\n                    # check template for iBGP evpn\n                    as_check = evpn_check = False\n                    for index, cmd in enumerate(peer_template_conf):\n                        if cmd.strip().startswith('remote-as'):\n                            remote_as = cmd.strip().split(' ')[1]\n                            if remote_as == BGP_AS:\n                                as_check = True\n                        elif cmd.strip().startswith('address-family l2vpn evpn'):\n                            evpn_check = True\n\n                    if as_check and evpn_check:\n                        Wrapper.print(\"%s found iBGP evpn peer-template on device while IBGP_PEER_TEMPLATE not defined in fabric setting\" % devSerial)\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":IBGP PEER TEMPLATE\"),\n                                         \"IBGP EVPN Peer template found on switch config while not defined on fabric setting.\", devSerial)\n                        respObj.setFailureRetCode()\n\n        #check if loopbacks matching with fabric settings are present on the switch\n        bgpLbFound = nveLbFound = anycastLbFound = rpLbFound = False\n\n        templateName = \"loopback_interface\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        templateName = \"loopback_interface_with_tag\"\n        nvPairListTag = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            if (nvPairListTag != None):\n                nvPairList += nvPairListTag\n        elif (nvPairListTag != None):\n            nvPairList = nvPairListTag\n\n        if (nvPairList == None):\n            templateName = \"v6_loopback_interface\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            templateName = \"v6_loopback_interface_with_tag\"\n            nvPairListTag = getTemplateMatchResults(matchResult, templateName)\n            if (nvPairList != None):\n                if (nvPairListTag != None):\n                    nvPairList += nvPairListTag\n            elif (nvPairListTag != None):\n                nvPairList = nvPairListTag\n\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if nvPair.get(\"INTF_NAME\").lower() == getLbIntfName(\"bgp\"):\n                    bgpLbFound = True\n                if nvPair.get(\"INTF_NAME\").lower() == getLbIntfName(\"nve\"): #MANISH revisit after vtep on bspine/bgspine\n                    nveLbFound = True\n                if nvPair.get(\"INTF_NAME\").lower() == getLbIntfName(\"anycast\"):\n                    anycastLbFound = True\n                if nvPair.get(\"INTF_NAME\").lower() == getLbIntfName(\"rp\"):\n                    rpLbFound = True\n \n        isBorderSpine = False\n        if (topologyDataObj.check(TopologyInfoType.IS_BORDER_SPINE, devSerial) or\n            topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_SPINE, devSerial)):\n            Wrapper.print(\"Switch is Border Role from TopologyData\")\n            isBorderSpine = True\n\n        if not bgpLbFound and bgpConfigFound:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Routing loopback\"),\n                                   \"Underlay Routing loopback Interface [%s] not found!!!\" % (getLbIntfName(\"bgp\")), devSerial)\n            respObj.setFailureRetCode()\n        if not nveLbFound and not isSpine:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VTEP loopback\"),\n                                   \"Underlay VTEP loopback Interface [%s] not found!!!\" % (getLbIntfName(\"nve\")), devSerial)\n            respObj.setFailureRetCode()\n        if not anycastLbFound and vPCInfo[\"domainId\"] and UNDERLAY_IS_V6 == \"true\":\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Anycast loopback\"),\n                                   \"Underlay Anycast loopback Interface [%s] not found!!!\" % (getLbIntfName(\"anycast\")), devSerial)\n            respObj.setFailureRetCode()\n        if not rpLbFound and (isSpine or isBorderSpine) and asmRPConfigInSwitch:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":PIM ASM loopback\"),\n                                   \"Underlay RP loopback Interface [%s] not found!!!\" % (getLbIntfName(\"rp\")), devSerial)\n            respObj.setFailureRetCode()\n        \n        fabricInterfaces = getFabricIntefaces(topologyDataObj, devSerial, switchRole)\n        checkAuthAndFabricIntfs(dictionaryObj, devSerial, switchRole, fabricInterfaces,\n                                            vpcPeerLinkVlanFound, matchResult, interfacesRes, respObj)\n        checkBfd(dictionaryObj, devSerial, fabricInterfaces, matchResult, interfacesRes, respObj)\n\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error during configuration consistency check\" % formattedName)\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":CONFIG_CHECK\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Switch [%s]. Success = [%r]\" % (FABRIC_NAME,\n            funcName, formattedName, respObj.isRetCodeSuccess()))\n        return respObj\n\ndef deviceUpgrade(gVarDictObj, respObj, doFullProcessing):\n    funcName = sys._getframe(0).f_code.co_name\n    dictionaryObj = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = dictionaryObj[\"deviceSerial\"]\n    formattedName = getFormattedSwitchName(devSerial)\n    Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s: Switch [%s] doFullProcessing [%r]\" % (FABRIC_NAME,\n        funcName, formattedName, doFullProcessing))\n    try:\n        fabTech = gVarDictObj[\"globalOverlayInfo\"][\"fabricTechnology\"]\n        if fabTech == \"VLANFabric\":\n            ECLdeviceUpgradeExt(gVarDictObj, respObj, doFullProcessing)\n        else:    \n            deviceUpgradeExt(gVarDictObj, respObj, doFullProcessing)\n    except respObjError as e:\n        msg = (\"Switch [%s]: Unexpected error during Underlay migration.\" % formattedName)\n        processUpgradeRespObjWithMsg(devSerial + \":UNDERLAY_MIGRATION\", msg, respObj, e.value)\n    except:\n        exc_type, exc_value, exc_traceback = sys.exc_info()\n        Wrapper.print(\"%s: Unexpected Exception. Message [%s] Exception TB [%s]\" % (funcName, exc_value, traceback.format_tb(exc_traceback, None)))\n        msg = (\"Switch [%s]: Unexpected error during Underlay migration. Detail [%s].\" % (formattedName, exc_value))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial + \":UNDERLAY_MIGRATION\"), msg)\n        respObj.setFailureRetCode()\n    finally:\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Switch [%s]. Success = [%r]\" % (\n            FABRIC_NAME, funcName, formattedName, respObj.isRetCodeSuccess()))\n        return respObj\n\ndef getFileContents(filename, isJson):\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    file = None\n    buf = \"\"\n    try:\n        file = open(filename, 'r')\n        buf = file.read()\n        if isJson:\n            respObj.setValue(json.loads(buf))\n        else:\n            respObj.setValue(buf)\n    except Exception as e:\n        Wrapper.print(\"getFileContents: buf failure %s\"%(buf))\n        Wrapper.print(\"getFileContents: Exception. Filename = [%s], Exception [%s]\" % (filename, traceback.format_exc()))\n        Util.handleException((\"Error reading from file [%s]\" % filename), e, respObj)\n    finally:\n        if file:\n            file.close()\n\n    return respObj\n\ndef getJSONFileContents(filename):\n    return getFileContents(filename, True)\n\ndef manageBgpRelatedBrownfieldPolicies(devSerial, matchResult, gVarDictObj, bgpFF, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    bgpNeighborDict = gVarDictObj[\"DICTIONARY_OBJ\"][\"bgpNeighborDict\"]\n\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"evpn_bgp_neighbor_auth\")\n    ptis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    srchOpt.setTemplateName(\"v6_evpn_bgp_neighbor_auth\")\n    ptis += Util.exe(PTIWrapper.getPTIs(srchOpt))\n    srchOpt.setTemplateName(\"bfd_bgp_neighbor\")\n    ptis += Util.exe(PTIWrapper.getPTIs(srchOpt))\n    for pti in ptis:\n        PTIWrapper.deleteInstance(pti.getPolicyId())\n\n    #Wrapper.print(\"%s: %s bgpNeighborDict %s\" % (funcName, devSerial, bgpNeighborDict))\n\n    # create the BGP Auth and BFD PTIs\n    for neighborIp in bgpNeighborDict:\n        neighborEntry = bgpNeighborDict[neighborIp]\n        if \"bgpAuth\" in neighborEntry:\n            nvPair = neighborEntry[\"bgpAuth\"]\n            \n            templateName = \"v6_evpn_bgp_neighbor_auth\" if isIpv6Addr(nvPair[\"BGP_NEIGHBOR_IP\"]) else \"evpn_bgp_neighbor_auth\"\n            if not neighborEntry[\"isInternal\"]:\n                genCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, nvPair, False, None)\n                bgpFF.append(genCfg)\n            else:\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", getSrc(templateName), getPrio(templateName), \n                    templateName, nvPair))\n\n        if \"bfd\" in neighborEntry:\n            nvPair = neighborEntry[\"bfd\"]\n            \n            templateName = \"v6_bfd_bgp_neighbor\" if isIpv6Addr(nvPair[\"BGP_NEIGHBOR_IP\"]) else \"bfd_bgp_neighbor\"\n            if not neighborEntry[\"isInternal\"]:\n                genCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, nvPair, False, None)\n                bgpFF.append(genCfg)\n            else:\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", getSrc(templateName), getPrio(templateName), \n                    templateName, nvPair))\n\ndef createTcamPTI(sn, matchResult, templateName, tcamName, prio):\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        tcamSize = nvPairList[0][\"TCAM_SIZE\"]\n        ptiList = Util.exe(PTI.get(sn, \"SWITCH\", \"SWITCH\", \"\", \"tcam_config\"))\n        for pti in ptiList:\n            if pti.nvPairs.get(\"TCAM_NAME\") == tcamName:\n                PTI.deleteInstance(pti.getPolicyId())\n                break\n        #show run all should take care of no diff\n        Util.exe(PTIWrapper.create(sn, \"SWITCH\", \"SWITCH\", \"\", prio, \"tcam_config\", {\"TCAM_NAME\":tcamName, \"TCAM_SIZE\":tcamSize}))\n    return\n\ndef createVirtualPeerLinkPTI(sn, matchResult, vpcPairInfo):\n    nvPairList = getTemplateMatchResults(matchResult, \"vpc_domain_virtual_peerlink_dscp\")\n    if (nvPairList != None):\n        domainId  = nvPairList[0].get(\"DOMAIN_ID\")\n        peerIp    = nvPairList[0].get(\"DST_LB_IP\")\n        localIp   = nvPairList[0].get(\"SRC_LB_IP\")\n        dscpValue = nvPairList[0].get(\"DSCP\") if nvPairList[0].get(\"DSCP\") else \"\"\n        nvPairsVirtualVPC = {\"DOMAIN_ID\": domainId, \"DST_LB_IP\":peerIp, \"SRC_LB_IP\":localIp, \"DSCP\":dscpValue}\n        createPTI(sn, nvPairsVirtualVPC, \"vpc_domain_virtual_peerlink\", \"SWITCH\", \"\", -1)\n        vpcPairInfo.update({\"vpcFabricPair\":True})\n        vpcPairInfo.update({\"SRC_LB_IP\":localIp})\n    return\n\ndef manageIsisBrownfieldPolicies(devSerial, matchResult, gVarDictObj, respObj):\n    if LINK_STATE_ROUTING != \"is-is\":\n        return\n\n    # look for all the possible ISIS related policies\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"base_isis_level2\")\n    ptis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    srchOpt.setTemplateName(\"isis_overload\")\n    ptis += Util.exe(PTIWrapper.getPTIs(srchOpt))\n\n    # delete the existing policies.. we will recreate them in case they do not match the earlier ones\n    for pti in ptis:\n        PTIWrapper.deleteInstance(pti.getPolicyId())\n\n    # create this PTI since we need to honor the existing isis net \n    nvPairList = getTemplateMatchResults(matchResult, \"base_isis_level2_internal\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            templateName = \"base_isis_level2\"\n            if LINK_STATE_ROUTING_TAG == nvPair[\"ISIS_TAG\"]:\n                # this is the underlay instance we are interested in\n                source = getSrc(templateName)\n                ptiPrio = template_metadata[templateName][\"prio\"]\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", source, ptiPrio, templateName, nvPair))\n                break\n\n    templateName = \"isis_overload\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        ptiPrio = template_metadata[templateName][\"prio\"]\n        for nvPair in nvPairList:\n            source = \"\"\n            if nvPair[\"ISIS_TAG\"] == LINK_STATE_ROUTING_TAG:\n                source = getSrc(templateName)\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", source, ptiPrio, templateName, nvPair))\n                break\n\ndef getVPCPeerDeviceSN(devSerial, vpcSrcToDstMacMap):\n    funcName = sys._getframe(0).f_code.co_name\n    #Wrapper.print(\" %s(): devSerial = %s, vpcSrcToDstMacMap = [%s]\" %(funcName, devSerial, vpcSrcToDstMacMap)) \n    srcSysMac = peerSerialNumber = \"\"\n    for sysMac in vpcSrcToDstMacMap:\n        if vpcSrcToDstMacMap[sysMac][\"switchSn\"] ==  devSerial:\n            srcSysMac = sysMac\n            break\n    for sysMac in vpcSrcToDstMacMap:\n        if srcSysMac == vpcSrcToDstMacMap[sysMac][\"peerMac\"]:\n            peerSerialNumber = vpcSrcToDstMacMap[sysMac][\"switchSn\"]\n            break\n    Wrapper.print(\" %s(): devSerial = [%s], peerSerial [%s]\" %(funcName, devSerial, peerSerialNumber)) \n    return peerSerialNumber \n\ndef managePimPolicies(devSerial, matchResult, gVarDictObj, respObj):\n    # look for all the possible existing template matches\n    templateName = \"base_pim_asm_11_1\"\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(templateName)\n    ptis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n\n    # delete the existing policies.. we will recreate new ones later\n    for pti in ptis:\n        PTIWrapper.deleteInstance(pti.getPolicyId())\n\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        # there could be multiple matches for base_pim_asm_11_1 policy.. create all non-matching ones\n        # with empty source\n        for pimAsmNvpair in nvPairList:\n            src = \"\"\n            mcastGroupSubnet = pimAsmNvpair[\"RP_GROUP\"].strip()\n            if (mcastGroupSubnet == gVarDictObj[\"MULTICAST_GROUP_SUBNET\"]):\n                src = getSrc(templateName)\n            else:\n                switchIP, switchMask = mcastGroupSubnet.split('/')\n                fabricIP, fabricMask = MULTICAST_GROUP_SUBNET.split('/')\n                if int(switchMask) < 16 and int(switchMask) < int(fabricMask):\n                    newSubnet = Util.getSubnetStringWithPrefix(fabricIP, switchMask)\n                    if newSubnet == mcastGroupSubnet:\n                        # switch mcast group subnet is a superset of fabric setting. Create pti for\n                        # later markDelete so that it will be replaced with config using fabric setting\n                        src = getSrc(templateName)\n            Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", src,\n                                   getPrio(templateName), templateName, pimAsmNvpair))\n\n    createMatchedPtis(devSerial, matchResult, \"base_multicast_11_1\")\n    createMatchedPtis(devSerial, matchResult, \"base_pim_bidir_11_1\", False)\n\ndef manageNxCloudPolicies(devSerial, matchResult, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n    ALLOW_NXC = fabricSettings.get(\"ALLOW_NXC\", \"false\")\n    if ALLOW_NXC != \"true\":\n        return respObj\n\n    destVrf = srcIntf = proxyServer = proxyPort = \"\"\n    showRunVrfMgmt = \"false\"\n    nvPairList = getTemplateMatchResults(matchResult, \"intersight_use_vrf_internal\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            destVrf = nvPair.get(\"DEST_VRF\")\n            if destVrf == \"management\":\n                showRunVrfMgmt = \"true\"\n    nvPairList = getTemplateMatchResults(matchResult, \"intersight_src_intf_internal\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            srcIntf = nvPair.get(\"SRC_INTF\")\n    nvPairList = getTemplateMatchResults(matchResult, \"intersight_proxy_port_internal\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            proxyServer = nvPair.get(\"PROXY_SERVER\")\n            proxyPort = nvPair.get(\"PROXY_PORT\")\n    else:\n        nvPairList = getTemplateMatchResults(matchResult, \"intersight_proxy_internal\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                proxyServer = nvPair.get(\"PROXY_SERVER\")\n\n    if destVrf == \"\" and srcIntf == \"\" and proxyServer == \"\":\n        return respObj\n\n    OVERWRITE_GLOBAL_NXC = fabricSettings.get(\"OVERWRITE_GLOBAL_NXC\", \"false\")\n    if OVERWRITE_GLOBAL_NXC == \"true\":\n        NXC_DEST_VRF         = fabricSettings.get(\"NXC_DEST_VRF\", \"\")\n        NXC_SRC_INTF         = fabricSettings.get(\"NXC_SRC_INTF\", \"\")\n        NXC_PROXY_SERVER     = fabricSettings.get(\"NXC_PROXY_SERVER\", \"\")\n        NXC_PROXY_PORT       = fabricSettings.get(\"NXC_PROXY_PORT\", \"\")\n    else:\n        nxcGlobalSettings = Util.exe(FabricWrapper.getNXCGlobalSettings())\n        Wrapper.print(\"%s: nxcGlobalSettings %s\" % (funcName, nxcGlobalSettings))\n        NXC_DEST_VRF         = nxcGlobalSettings.get(\"sourceVrf\", \"\")\n        NXC_SRC_INTF         = nxcGlobalSettings.get(\"sourceIntf\", \"\")\n        NXC_PROXY_SERVER     = nxcGlobalSettings.get(\"proxyIp\", \"\")\n        NXC_PROXY_PORT       = nxcGlobalSettings.get(\"proxyPort\", \"\")\n\n    nxcDestVrf = nxcSrcIntf = nxcProxyServer = nxcProxyPort = \"\"\n\n    if NXC_DEST_VRF != \"\":\n        nxcDestVrf = \"default\" if NXC_DEST_VRF.strip().lower() == \"default\" else NXC_DEST_VRF.strip()\n        if nxcDestVrf.lower() == \"management\":\n            nxcDestVrf = \"management\"\n\n    if NXC_SRC_INTF != \"\":\n        nxcSrcIntf = Util.getIntfFullName(NXC_SRC_INTF)\n        intfType = Util.getIntfFullType(NXC_SRC_INTF)\n        if intfType == \"Loopback\" or intfType == \"Port-Channel\":\n            nxcSrcIntf = nxcSrcIntf.lower()\n\n    nxcProxyServer = NXC_PROXY_SERVER.strip() if NXC_PROXY_SERVER != \"\" else \"\"\n\n    errorMsg = \"\"\n    if destVrf != \"\" and destVrf != nxcDestVrf:\n        if nxcDestVrf == \"\":\n            errorMsg += Util.newLine()\n            errorMsg += (\"Intersight Destination VRF setting is missing for Brownfield Import, \"\n                         \"please set the Destination VRF in %s\" %\n                         (\"Global NxCloud Settings\" if OVERWRITE_GLOBAL_NXC != \"true\" else \"Fabric Settings\"))\n        else:\n            errorMsg += Util.newLine() + \"'intersight use-vrf %s' does not match Destination VRF setting [%s]\" % (destVrf, nxcDestVrf)\n    if srcIntf != \"\" and srcIntf != nxcSrcIntf:\n        errorMsg += Util.newLine()\n        if nxcSrcIntf == \"\" and nxcDestVrf != \"\" and nxcDestVrf != \"management\":\n            errorMsg += (\"Intersight Source Interface setting is missing for Brownfield Import, \"\n                         \"please set the Source Interface in %s\" %\n                         (\"Global NxCloud Settings\" if OVERWRITE_GLOBAL_NXC != \"true\" else \"Fabric Settings\"))\n        else:\n            errorMsg += (\"'intersight source-interface %s' does not match Source Interface setting [%s]\" %\n                         (srcIntf, \"Null\" if nxcSrcIntf == \"\" else nxcSrcIntf))\n    if proxyServer != \"\" and proxyPort != \"\":\n        if proxyServer != nxcProxyServer or proxyPort != NXC_PROXY_PORT:\n            errorMsg += Util.newLine()\n            errorMsg += (\"'intersight proxy %s port %s' does not match Proxy Server/Port settings [%s/%s]\" %\n                         (proxyServer, proxyPort,\n                          \"Null\" if nxcProxyServer == \"\" else nxcProxyServer,\n                          \"Null\" if NXC_PROXY_PORT == \"\" else NXC_PROXY_PORT))\n    elif proxyServer != \"\" and proxyServer != nxcProxyServer:\n        errorMsg += Util.newLine()\n        errorMsg += (\"'intersight proxy %s' does not match Proxy Server setting [%s]\" %\n                     (proxyServer, \"Null\" if nxcProxyServer == \"\" else nxcProxyServer))\n    if errorMsg != \"\":\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":NxCloud\"),\n            \"Intersight config on the device does not match %s: %s\" %\n            (\"Global NxCloud Settings\" if OVERWRITE_GLOBAL_NXC != \"true\" else \"Fabric Settings\", errorMsg), devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n\n    Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                       ConfigPriority.CONFIG_PRIO_UNDERLAY_MIDDLE,\n                                       \"nexus_cloud\",\n                                       {\"NXC_SRC_INTF\": srcIntf,\n                                        \"NXC_DEST_VRF\": destVrf,\n                                        \"NXC_PROXY_SERVER\": proxyServer,\n                                        \"NXC_PROXY_PORT\": proxyPort,\n                                        \"SHOW_RUN_VRF_MGMT\": showRunVrfMgmt}))\n    return respObj\n\ndef getNativeVlanAndUpdatedUnacctCfgList(cfgList):\n    funcName = sys._getframe(0).f_code.co_name\n    nativeVlan = \"\"\n    updatedCfgList = []\n\n    for cfg in cfgList:\n        strippedCfg = cfg.strip()\n        if strippedCfg.startswith(\"switchport trunk native vlan \"):\n            parts = strippedCfg.split(\"switchport trunk native vlan \")\n            nativeVlan = parts[1]\n        else:\n            updatedCfgList.append(cfg)\n\n    Wrapper.print(\"%s: nativeVlan [%s] updatedCfgList [%s]\" % (funcName, nativeVlan, updatedCfgList)) \n    return nativeVlan, updatedCfgList\n\n# process the service route map entries found on service leaf\ndef processServiceRouteMapEntries(fabricName, devSerial, serviceRMDict, globalOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    isServiceLeaf = switchOverlayInfo[\"isServiceLeaf\"]\n\n    Wrapper.print(\"%s: Fabric [%s] [%s] isServiceLeaf [%r] Start serviceRMDict %s\" % (funcName, fabricName, devSerial,\n        isServiceLeaf, json.dumps(serviceRMDict, indent=4, sort_keys=True)))\n\n    # set the route map sequence #s in RM\n    for rmLine in serviceRMDict:\n        rmEntry = serviceRMDict[rmLine]\n\n        Wrapper.print(\"--- [%s] Setting RM for acl [%s] with seq # [%s]\" % (devSerial, rmEntry[\"aclName\"], rmEntry[\"seqNum\"]))\n        ignore, rm_id = Util.exeRM(RM.set(fabricName, \"ROUTE_MAP_SEQUENCE_NUMBER_POOL\", \n                                            devSerial, rmEntry[\"aclName\"], rmEntry[\"seqNum\"]))\n\n    if not isServiceLeaf:\n        return\n\n    # get list of service nodes associated with this service switch\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n    serviceNodeList = servicesInfo[\"serviceSwMaps\"][devSerial][\"nodes\"]\n\n    # iterate over the known route peer entries on the serivce leaf\n    for serviceNodeName in serviceNodeList:\n        serviceNodeEntry = servicesInfo[\"serviceNodes\"][serviceNodeName]\n\n        peerSn = serviceNodeEntry.get(\"peerSwSerial\", None)\n        if peerSn == devSerial:\n            Wrapper.print(\"%s: SN [%s] - Skipping updates for vPC peer [%s]\" % (funcName, serviceNodeName, devSerial))\n            continue\n\n        Wrapper.print(\"%s: New SN\" % (funcName))\n        Wrapper.print(\"%s: SN [%s]\" % (funcName, serviceNodeName))\n\n        for routePeerName in serviceNodeEntry[\"routePeers\"]:\n            rpEntry = serviceNodeEntry[\"routePeers\"][routePeerName]\n\n            Wrapper.print(\"%s: New RP\" % (funcName))\n            Wrapper.print(\"%s: SN [%s] RP Name [%s] Route Peer Entry [%s]\" % (funcName, serviceNodeName, routePeerName, rpEntry))\n            # iterate over the route-map entries found on service leaf\n            for rmLine in serviceRMDict:\n                rmEntry = serviceRMDict[rmLine]\n                Wrapper.print(\">>> RM line [%s] rmEntry [%s]\" % (rmLine, rmEntry)) \n                if rmEntry[\"isProcessed\"] or (not rmEntry[\"aclName\"].startswith(rpEntry[\"aclPrefix\"]) or\n                    (not rmLine.startswith(rpEntry[\"rmPrefix\"]))):\n                    continue\n                \n                isReverse = False\n                processRM = False\n                for netType in rpEntry[\"nets\"]:\n                    rpNetEntry = rpEntry[\"nets\"][netType]\n                    Wrapper.print(\"------ %s: netType [%s] rpNetEntry [%s]\" % (funcName, netType, rpNetEntry)) \n                    if (\"vni\" in rpNetEntry):\n                        # check if the next hop is of interest to us\n                        netEntry = servicesInfo[\"serviceNets\"][rpNetEntry[\"vni\"]]\n                        nextHopSubnetStr = Util.getSubnetStringWithPrefix(rmEntry[\"nextHop\"], netEntry[\"mask\"])\n                        Wrapper.print(\"********* nextHopSubnetStr [%s] netEntry Subnet [%s]\" % (nextHopSubnetStr, netEntry[\"subnet\"]))\n                        if nextHopSubnetStr == netEntry[\"subnet\"]:\n                            processRM = True\n                            if \"nextHop\" not in rpNetEntry:\n                                Wrapper.print(\"%s: Route Peer [%s] Adding nextHop [%s] for network [%s] [%s]\" % (funcName,\n                                    routePeerName, rmEntry[\"nextHop\"], netType, netEntry[\"ipv4\"])) \n                                rpNetEntry[\"nextHop\"] = rmEntry[\"nextHop\"]\n                                break\n\n                if not processRM:\n                    continue\n\n                isReverse = False\n                # process the service policies\n                if serviceNodeEntry[\"serviceNodeType\"] == \"fw\":\n                    if \"nextHop\" in rpEntry[\"nets\"][\"outside\"]:\n                        isReverse = True\n                else:\n                    if len(rpEntry[\"nets\"]) == 1:\n                        # one armed\n                        if \"nextHop\" in rpEntry[\"nets\"][\"one\"]:\n                            isReverse = True\n                    else:\n                        if \"nextHop\" in rpEntry[\"nets\"][\"two\"]:\n                            isReverse = True\n\n                aclTuple = rmEntry[\"aclName\"].split(rpEntry[\"aclPrefix\"])[1]\n                aclTupleParts = aclTuple.split(\"_\")\n                Wrapper.print(\"%s: isReverse [%s] aclTuple [%s] aclTupleParts Num %d %s\" % (funcName, isReverse, \n                                                            aclTuple, len(aclTupleParts), aclTupleParts)) \n                if len(aclTupleParts) != 5:\n                    # not sure why\n                    continue\n\n                rpServicesDict = rpEntry[\"servicePolicies\"]\n                aclTupleSet = set(aclTuple)\n                entryFound = False\n                for serviceEntry in rpServicesDict.values():\n                    if aclTupleSet == serviceEntry[\"tupleSet\"]:\n                        serviceEntry[\"isReverse\"] = isReverse\n                        #if serviceNodeEntry[\"serviceNodeType\"] == \"fw\":\n                        #    serviceEntry[\"policyTemplateNvPairs\"][\"ROUTE_MAP_MATCH_SEQUENCE_NUMBER_REVERSE\"] = rmEntry[\"seqNum\"]\n                        entryFound = True\n\n                if not entryFound:\n                    # create a service policy entry\n                    if serviceNodeEntry[\"serviceNodeType\"] == \"fw\":\n                        nvPairs = {\"SRC_NETWORK\" : aclTupleParts[0], \"DEST_NETWORK\" : aclTupleParts[1],\n                                   \"PROTOCOL\" : aclTupleParts[2], \"SRC_PORT\" : aclTupleParts[3], \"DEST_PORT\" : aclTupleParts[4]}\n                        #nvPairs[\"ROUTE_MAP_MATCH_SEQUENCE_NUMBER\"] = rmEntry[\"seqNum\"]\n                    else:\n                        nvPairs = {\"SRC_NETWORK\" : aclTupleParts[1], \"DEST_NETWORK\" : aclTupleParts[0],\n                                   \"PROTOCOL\" : aclTupleParts[2], \"SRC_PORT\" : aclTupleParts[4], \"DEST_PORT\" : aclTupleParts[3]}\n                        #nvPairs[\"ROUTE_MAP_MATCH_SEQUENCE_NUMBER_REVERSE\"] = rmEntry[\"seqNum\"]\n\n                    nvPairs[\"ROUTE_MAP_ACTION\"] = rmEntry[\"action\"]\n                    if \"nextHopOption\" in rmEntry:\n                        nvPairs[\"NEXT_HOP_OPTION\"] = rmEntry[\"nextHopOption\"]\n\n                    rpServicesDict[aclTuple] = {\"tupleSet\" : aclTupleSet, \"policyTemplateNvPairs\" : nvPairs, \"isReverse\" : isReverse}\n                    Wrapper.print(\"%s: RP [%s] Added Service Entry Key [%s] -> [%s] \" % (funcName, routePeerName, aclTuple, nvPairs)) \n\n                    rmEntry[\"isProcessed\"] = True\n\n    for serviceNodeName in serviceNodeList:\n        serviceNodeEntry = servicesInfo[\"serviceNodes\"][serviceNodeName]\n        for routePeerName in serviceNodeEntry[\"routePeers\"]:\n            rpEntry = serviceNodeEntry[\"routePeers\"][routePeerName]\n\n            rpServicesDict = rpEntry[\"servicePolicies\"]\n            for serviceEntry in rpServicesDict.values():\n                # clear out data we do not need anymore\n                if \"tupleSet\" in serviceEntry:\n                    del serviceEntry[\"tupleSet\"]\n    Wrapper.print(\"%s: %s End serviceRMDict %s\" % (funcName, devSerial, json.dumps(serviceRMDict, indent=4, sort_keys=True)))\n\ndef deviceUpgradeExt(gVarDictObj, respObj, doFullProcessing):\n    global ISIS_LEVEL\n\n    funcName = sys._getframe(0).f_code.co_name\n\n    dictionaryObj = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = dictionaryObj[\"deviceSerial\"]\n    migrateMode = dictionaryObj[\"migrationMode\"]\n    topologyDataObj = gVarDictObj[\"topologyObj\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    vpcSrcToDstMacMap = gVarDictObj[\"vpcSrcToDstMacMap\"]\n    vVpcSpineQos = gVarDictObj[\"vVpcSpineQos\"]\n    matchResult = dictionaryObj[\"matchResult\"]\n    interfacesRes = dictionaryObj[\"interfacesRes\"]\n    switchRole = dictionaryObj[\"switchRole\"]\n    hostName = dictionaryObj[\"hostName\"]\n    fmtName = dictionaryObj[\"fmtName\"]\n    model = dictionaryObj[\"deviceModel\"]\n\n    isSpine = False\n    if (topologyDataObj.check(TopologyInfoType.IS_SPINE, devSerial) or\n        topologyDataObj.check(TopologyInfoType.IS_BORDER_SPINE, devSerial) or\n        topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_SPINE, devSerial)):\n        isSpine = True\n    Wrapper.print(\"==========%s: Fabric = %s, Serial [%s] Model [%s] Role [%s] isSpine [%r]\" % \n        (funcName, FABRIC_NAME, devSerial, model, switchRole, isSpine))\n\n    vPCInfo = dictionaryObj[\"vpcInfo\"]\n    isValidVPC = (vPCInfo[\"domainId\"] != None)\n\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    switchOverlayInfo[\"isVpc\"] = \"true\" if isValidVPC else \"false\"\n\n    device_overlay_vlans = {}\n    doOverlayMigr = False\n    if migrateMode == \"brownAdd\":\n        doOverlayMigr = True\n        if \"border\" in switchRole.lower():\n            switchOverlayInfo[\"doOverlayExtn\"] = \"true\"\n        # record state that the switch overlay migration is not completed yet\n        putSwitchIntoOverlayMigrMode(FABRIC_NAME, devSerial)\n    elif migrateMode == \"upgrade\":\n        if switchRole.lower() != \"spine\":\n            doOverlayMigr = True\n            # the switch will be in migration mode from the backend code\n            # get the interface specific network vlan info\n            device_overlay_vlans = TopDownMigrationUtils.getOverlayInterfaceInfo(devSerial)\n            Wrapper.print(\"Fabric upgrade %s device_overlay_vlans %s\" % (devSerial, device_overlay_vlans))\n            for x in device_overlay_vlans.entrySet():\n                Wrapper.print(\" intf %s, %s\" % (x.key, x.value.getVlanList()))\n\n    if doOverlayMigr:\n        # collect all the overlay info for the leaf switch\n        gatherOverlayInfo(topologyDataObj, devSerial, matchResult, interfacesRes, globalOverlayInfo,\n                    switchOverlayInfo, migrateMode, device_overlay_vlans, respObj)\n\n    if respObj.isRetCodeFailure() or (not doFullProcessing):\n        return respObj\n\n    if Util.exe(FabricWrapper.isFeatureEnabled(\"nxcloud\")):\n        manageNxCloudPolicies(devSerial, matchResult, respObj)\n\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    # add the special route-map policy template for the leaf\n    if not isSpine:\n        # do a check first\n        templateName = \"route_map\"\n        if (getTemplateMatchResults(matchResult, templateName) == None):\n            # add the match entry\n            matchResult.update({templateName : [{}]})\n\n    # process common configs\n    if isValidVPC:\n        createPTI(devSerial, {}, \"base_feature_vpc\", \"SWITCH\", \"UNDERLAY\", -1)\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"nfm_switch_user\")\n    createMatchedPtis(devSerial, matchResult, \"password_no_strength\")\n    createMatchedPtis(devSerial, matchResult, \"host_11_1\")\n    createMatchedPtis(devSerial, matchResult, \"switchnm_11_1\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"v4_mgmt_default_gateway\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"v6_mgmt_default_gateway_11_1\")\n    createMatchedPtis(devSerial, matchResult, \"feature_bfd\")\n    createMatchedPtis(devSerial, matchResult, \"feature_nxapi\")\n    createMatchedPtis(devSerial, matchResult, \"nxapi_http_port\")\n    createMatchedPtis(devSerial, matchResult, \"nxapi_https_port\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"banner\")\n    nvPairList = getTemplateMatchResults(matchResult, \"ssh_key_rsa\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            bits = nvPair.get(\"BITS\")\n            if bits != \"1024\" and bits != \"\":\n                rsaNvPair = {\"BITS\":bits}\n                Wrapper.print(\"match ssh_key_rsa %s\" % nvPair)\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n                                           \"ssh_key_rsa_force\", rsaNvPair))\n\n    createMatchedPtis(devSerial, matchResult, \"pre_config\")\n    if Util.isN9kT2Vtep(topologyDataObj, devSerial):\n        createMatchedPtis(devSerial, matchResult, \"tcam_pre_config_vxlan\")\n        # Special case for the Nexus 9332PQ as it uses the same default allocation as the Nexus 9500\n        if Util.isModularN9k(model) or \"C9332PQ\" in model:\n            createMatchedPtis(devSerial, matchResult, \"tcam_pre_config_9500\")\n        else:\n            createMatchedPtis(devSerial, matchResult, \"tcam_pre_config_9300\")\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"base_bgp\")\n    if UNDERLAY_IS_V6 == \"true\":\n        nvPairList = getTemplateMatchResults(matchResult, \"base_bgp\")\n        if nvPairList != None:\n            for nvPair in nvPairList:\n                routerId = nvPair[\"LOOPBACK_IP\"]\n                entityName = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Util.exe(RM.set(FABRIC_NAME, \"ROUTER_ID_POOL\", EntityType.DEVICE, entityName, routerId))\n                break\n    \n    manageBgpRelatedBrownfieldPolicies(devSerial, matchResult, gVarDictObj, switchOverlayInfo[\"BGP_FF\"], respObj)\n    manageIsisBrownfieldPolicies(devSerial, matchResult, gVarDictObj, respObj)\n    managePimPolicies(devSerial, matchResult, gVarDictObj, respObj)\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"ntp_server\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"ntp_prefer_server\")\n    createMatchedPtis(devSerial, matchResult, \"clock_protocol\")\n    createMatchedPtis(devSerial, matchResult, \"clock_timezone\")\n    createMatchedPtis(devSerial, matchResult, \"clock_summertime\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"dnsList\")  #cleanup first since we use create,not update to support multiple dns_vrf\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"dns-vrfList\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_sev\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_vrf\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_vrf_no_sev\")\n    createMatchedPtis(devSerial, matchResult, \"evpn_multisite\")\n    createMatchedPtis(devSerial, matchResult, \"bgp_cluster_id\")\n    createMatchedPtis(devSerial, matchResult, \"feature_isis\")\n\n    ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"base_pim_bidir_11_1\"))\n    if ptiList:\n        Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, \"rp_state\", {}))\n\n    # check system jumbomtu\n    jumboMtuVal = \"9216\"\n    templateName = \"system_jumbomtu\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            jumboMtuVal = nvPair[\"MTU\"]\n\n    Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n        templateName, {\"MTU\" : jumboMtuVal}))\n\n    # create the internal PTI to track the switch jumbomtu setting\n    Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n        \"switch_mtu_state\", {\"JUMBO_MTU_VAL\" : jumboMtuVal}))\n\n    #createTcamPTI(devSerial, matchResult, \"tcam_ing_racl\", \"ing-racl\", 10)\n    #createTcamPTI(devSerial, matchResult, \"tcam_ing_flow_redirect\", \"ing-flow-redirect\", 11)\n\n    global fabric_bgp_tmpl_type, fabric_bgp_tmpl_name\n\n    template_has_mvpn = False\n    if IBGP_PEER_TEMPLATE:\n        if (IBGP_PEER_TEMPLATE_LEAF and\n            (topologyDataObj.check(TopologyInfoType.IS_LEAF, devSerial) or\n             topologyDataObj.check(TopologyInfoType.IS_BORDER_LEAF, devSerial) or\n             topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_LEAF, devSerial))):\n            bgp_peer_conf = IBGP_PEER_TEMPLATE_LEAF.strip()\n        else:\n            bgp_peer_conf = IBGP_PEER_TEMPLATE.strip()\n        bgp_peer_template = filter(None, map(lambda x: x.strip(), bgp_peer_conf.splitlines()))\n        peer_cmd = bgp_peer_template[0].split(\" \")\n        fabric_bgp_tmpl_type = peer_cmd[1]\n        fabric_bgp_tmpl_name = peer_cmd[2]\n        if \"address-family ipv4 mvpn\" in bgp_peer_template:\n            template_has_mvpn = True\n    else:\n        fabric_bgp_tmpl_type, fabric_bgp_tmpl_name = \"\", \"\"\n    Wrapper.print(\"fabric peer template type %s, name %s\" % (fabric_bgp_tmpl_type, fabric_bgp_tmpl_name))\n\n    PTIWrapper.delete(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", \"bgp_neighbor_inherit\")\n    PTIWrapper.delete(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", \"v6_bgp_neighbor_inherit\")\n    templateName = \"bgp_neighbor_inherit\"\n    bgpInheritNvPairList = getTemplateMatchResults(matchResult, templateName)\n    if bgpInheritNvPairList != None:\n        for nvPair in bgpInheritNvPairList:\n            if isIpv6Addr(nvPair[\"BGP_NEIGHBOR_IP\"]):\n                templateName = \"v6_bgp_neighbor_inherit\"\n                break\n    Wrapper.print(\"%s %s nvPairList %s\" % (funcName, templateName, bgpInheritNvPairList))\n    if IBGP_PEER_TEMPLATE and bgpInheritNvPairList != None:\n        for nvPair in bgpInheritNvPairList[:]:\n            if (nvPair[\"BGP_AS\"] == BGP_AS and\n                nvPair[\"TEMPLATE_TYPE\"] == fabric_bgp_tmpl_type and\n                nvPair[\"TEMPLATE_NAME\"] == fabric_bgp_tmpl_name):\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1,\n                                   templateName, nvPair))\n                bgpInheritNvPairList.remove(nvPair)\n    Wrapper.print(\"%s: %s remaining nvPairList %s\" % (funcName, templateName, bgpInheritNvPairList))\n\n    bgpTmplNvPairList = getTemplateMatchResults(matchResult, \"bgp_peer_template\")\n    Wrapper.print(\"%s: bgp_peer_template nvPairList %s\" % (funcName, bgpTmplNvPairList))\n    if IBGP_PEER_TEMPLATE and bgpTmplNvPairList != None:\n        for nvPair in bgpTmplNvPairList:\n            if (nvPair[\"BGP_AS\"] == BGP_AS and\n                nvPair[\"TEMPLATE_TYPE\"] == fabric_bgp_tmpl_type and\n                nvPair[\"TEMPLATE_NAME\"] == fabric_bgp_tmpl_name):\n                nvPair[\"CONF\"] = Util.newLine().join(nvPair[\"CONF\"])\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1,\n                                   \"bgp_peer_template\", nvPair))\n                bgpTmplNvPairList.remove(nvPair)\n                break\n        Wrapper.print(\"%s: bgp_peer_template remaining nvPairList %s\" % (funcName, bgpTmplNvPairList))\n\n    nvPairList = getTemplateMatchResults(matchResult, \"aaa_tacacs\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            if nvPair[\"AAA_TACACS\"] == \"tacacs+\":\n                Wrapper.print(\"match aaa_tacacs, %s\" % nvPair)\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2,\n                                           \"aaa_tacacs\", nvPair))\n\n    nvPairList = getTemplateMatchResults(matchResult, \"aaa_tacacs_use_vrf\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            if nvPair[\"AAA_TACACS\"] == \"tacacs+\":\n                Wrapper.print(\"match aaa_tacacs_use_vrf, %s\" % nvPair)\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2,\n                                           \"aaa_tacacs_use_vrf\", nvPair))\n    if (POWER_REDUNDANCY_MODE == \"combined\"):\n        createPTI(devSerial, {}, \"power_redundancy_combined\", \"SWITCH\", \"\", -1)\n    else:\n        createPTI(devSerial, {\"REDUNDANCY_MODE\": POWER_REDUNDANCY_MODE},\n                                 \"power_redundancy\", \"SWITCH\", \"\", -1)\n\n    # handle pre-interface global unaccounted cmds\n    features_info = matchResult[\"FEATURES_INFO\"]\n    global_unaccounted = features_info[\"GLOBAL_UNACCTED\"][\"unaccounted\"]\n\n    if LINK_STATE_ROUTING == \"ospf\":\n        underlayProtocolCfgLine = \"router \" + (\"ospf \" if UNDERLAY_IS_V6 == \"false\" else \"ospfv3 \") + LINK_STATE_ROUTING_TAG\n    else:\n        underlayProtocolCfgLine = \"router isis \" + LINK_STATE_ROUTING_TAG\n    #Wrapper.print(\"%s: underlayProtocolCfgLine: [%s]\" % (funcName, underlayProtocolCfgLine))\n\n    keyChainLine = \"\"\n    isisKeyId = \"\"\n    if LINK_STATE_ROUTING == \"is-is\":\n        if ISIS_AUTH_ENABLE == \"true\":\n            keyChainLine = (\"key chain %s\" % ISIS_AUTH_KEYCHAIN_NAME)\n            isisKeyId = (\"key %s\" % ISIS_AUTH_KEYCHAIN_KEY_ID) if (ISIS_AUTH_ENABLE == \"true\") else \"\"\n\n    isBorder = (\"border\" in switchRole)\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n    hasServices = True if servicesInfo and len(servicesInfo) else False\n    isServiceLeaf = switchOverlayInfo[\"isServiceLeaf\"]\n    serviceRMDict = {}\n\n    filteredUnaccounted = []\n    feature_unaccounted = []\n\n    templateName = \"feature_pbr\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        feature_unaccounted.append(\"feature pbr\")\n\n    tcamUnaccounted = []\n    AAA_Configs = []\n    global_unaccounted_AAA = []\n    skipAcl = False\n    isAAABlock = False\n    skipRm = False\n    skipMmodeProfile = False\n    keyChainLines = []\n    keepKeyChain = False\n    isKeyChain = False\n    serviceAclparams = None\n    serviceRmKey = None\n    for line in global_unaccounted:\n        depth = (len(line) - len(line.lstrip(' '))) / 2\n        if depth == 0:\n            # top level CLIs\n            isKeyChain = False\n            keepKeyChain = False\n            skipRm = False\n            serviceRmKey = None\n\n            if skipAcl:\n                # we are out of the ACL block\n                skipAcl = False\n            elif isAAABlock:\n                # we are out of the AAA block\n                isAAABlock = False\n            elif skipMmodeProfile:\n                # we are out of the current maintenance mode profile block\n                skipMmodeProfile = False\n                \n            if (line.startswith(\"power redundancy-mode\") or line.startswith(\"version\")):\n                # these should not be captured in the accounted configs\n                continue\n\n            if line.startswith(\"feature \"):\n                if \"tacacs\" not in line:\n                    feature_unaccounted.append(line)\n                else:\n                    AAA_Configs.append(line)\n                continue\n\n            if line.startswith(\"aaa\"):\n                global_unaccounted_AAA.append(line)\n                isAAABlock = True\n                continue\n\n            if line.startswith(\"hardware access-list tcam region\"):\n                tcamUnaccounted.append(line)\n                continue\n\n            aclCmdPrefix = \"ip access-list \"\n            if line.startswith(aclCmdPrefix):\n                aclName = line[len(aclCmdPrefix):].strip()\n                if aclName == \"telemetryipv4acl\":\n                    skipAcl = True\n                elif hasServices:\n                    # need to check further\n                    for aclPrefixStr in servicesInfo[\"serviceAclPrefixStr\"]:\n                        if aclName.startswith(aclPrefixStr):\n                            #ip access-list acl_vrf_50000_10.1.10.1/24_10.1.11.1/24_ip_any_any\n                            #  10 permit ip 10.1.10.1/24 10.1.11.1/24\n                            # the acl name will be processed when the route-map is parsed\n                            skipAcl = True\n                            break\n                if skipAcl:\n                    continue\n\n            # look for telemetry specific ACL that we need to skip\n            if (line == \"ipv6 access-list telemetryipv6acl\"):\n                skipAcl = True\n                continue\n\n            # look for either maintenance mode or normal mode profile and skip it\n            if line.startswith(\"configure maintenance profile \"):\n                skipMmodeProfile = True\n                continue\n\n            rmCmdPrefix = \"route-map \"\n            if hasServices and line.startswith(rmCmdPrefix):\n                rmName = line[len(rmCmdPrefix):].strip()\n                #Wrapper.print(\"%s: rmName [%s]\" % (funcName, rmName))\n\n                for rmNamePrefix in servicesInfo[\"serviceRmPrefixStr\"]:\n                    # on service node\n                    #route-map rm_vrf_50000 permit 1\n                    #  match ip address acl_vrf_50000_10.1.10.1/24_10.1.11.1/24_ip_any_any\n                    #  set ip next-hop 200.200.200.200\n                    #\n                    # on other leaf (we will just skip this in freeform.. no processing)\n                    #route-map rm_vrf_50000_src_30000 permit 1\n                    #  match ip address acl_vrf_50000_10.1.10.1/24_10.1.11.1/24_ip_any_any\n                    #  set ip next-hop 200.200.200.200\n                    if not rmName.startswith(rmNamePrefix):\n                        continue\n\n                    #Wrapper.print(\"%s: isServiceLeaf [%r] rmName [%s] rmNamePrefix [%s]\" % (funcName, isServiceLeaf, rmName, rmNamePrefix))\n                    skipRm = True\n                    parts = rmName.split(\" \")\n                    partsLen = len(parts)\n                    if partsLen != 3 or (parts[1] not in [\"permit\", \"deny\"]):\n                        Wrapper.print(\"%s: Skip RM line [%s] Unrecognized parts len %d %s\" % (funcName, line, partsLen, parts))\n                        continue\n                    \n                    #if (isServiceLeaf and (parts[0] == rmNamePrefix)):\n                    if parts[2] != \"65535\":\n                        serviceRmKey = rmName\n                        # add a new entry\n                        serviceRMDict[serviceRmKey] = {\"action\" : parts[1], \"seqNum\" : parts[2], \"isProcessed\" : False}\n                        #Wrapper.print(\"%s: Added RM Entry [%s] Entry %s\" % (funcName, serviceRmKey, serviceRMDict[serviceRmKey]))\n                    break\n                if skipRm:\n                    continue\n\n            if line.startswith(\"key chain \"):\n                isKeyChain = True\n                if (line == keyChainLine):\n                    keepKeyChain = True\n                    keyChainLines.append(line)\n                    continue\n\n        elif depth == 1:\n            if isBorder and (line == \"  match ip address prefix-list host-route-v6\"):\n                # these should not be captured in the accounted configs\n                continue\n            elif serviceRmKey:\n                strippedLine = line.strip()\n                if strippedLine.startswith(\"match ip address \"):\n                    serviceRMDict[serviceRmKey][\"aclName\"] = strippedLine.split(\"match ip address \")[1]\n                elif strippedLine.startswith(\"set ip next-hop \"):\n                    parts = strippedLine.split(\"set ip next-hop \")[1].split(\" \")\n                    partsLen = len(parts)\n                    Wrapper.print(\"%s: NH line [%s] parts %d %s\" % (funcName, strippedLine, partsLen, parts))\n                    serviceRMDict[serviceRmKey][\"nextHop\"] = parts[0]\n                    if partsLen > 1:\n                        serviceRMDict[serviceRmKey][\"nextHopOption\"] = parts[1]\n\n        if isKeyChain:\n            if keepKeyChain:\n                keyChainLines.append(line)\n            continue\n        if isAAABlock:\n            global_unaccounted_AAA.append(line)\n            continue\n        elif skipAcl or skipRm or skipMmodeProfile:\n            continue\n          \n        filteredUnaccounted.append(line)\n\n    # process the service node RMs\n    #if isServiceLeaf and serviceRMDict:\n    if serviceRMDict:\n        #Wrapper.print(\"%s: %s serviceRMDict %s\" % (funcName, fmtName, json.dumps(serviceRMDict, indent=4, sort_keys=True)))\n        processServiceRouteMapEntries(FABRIC_NAME, devSerial, serviceRMDict, globalOverlayInfo)\n\n    # filter out the unaccounted key chain config specific to out ISIS auth key chain and key id\n    keyChainLinesFiltered = []\n    if keyChainLine != \"\":\n        for line in keyChainLines:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                ourBlock = False\n                if line == keyChainLine:\n                    ourBlock = True\n            elif depth == 1:\n                strippedLine = line.strip()\n                ourBlock = False\n                if strippedLine == isisKeyId:\n                    ourBlock = True\n\n            if ourBlock:\n                keyChainLinesFiltered.append(line)\n\n        if len(keyChainLinesFiltered) == 1:\n            keyChainLinesFiltered.clear()\n\n    Wrapper.print(\"%s: %s filteredUnaccounted %s\" % (funcName, fmtName, filteredUnaccounted))\n    #Wrapper.print(\"%s: keyChainLine [%s] isisKeyId [%s] keyChainLines %s keyChainLinesFiltered %s\" % (funcName, keyChainLine, isisKeyId, keyChainLines, keyChainLinesFiltered))\n\n    # update the 'global_unaccounted' to the filtered list for subsequent use\n    global_unaccounted = (filteredUnaccounted + keyChainLinesFiltered)\n\n    priority = 5\n    for cmd in tcamUnaccounted:\n        tcamInfoList = cmd.split(\"hardware access-list tcam region \")[1].split(\" \")\n        Wrapper.print(\"%s(): Device %s tcam info list: %s\" % (funcName, devSerial, tcamInfoList))\n        tcamName = tcamInfoList[0] if len(tcamInfoList) > 0 else \"\"\n        tcamSize = tcamInfoList[1] if len(tcamInfoList) > 1 else \"\"\n        tcamType = tcamInfoList[2] if len(tcamInfoList) > 2 else \"\"\n        templateName = \"tcam_config\"\n        ptiPrio = priority\n        if tcamName and tcamSize:\n            Wrapper.print(\"%s(): Device %s created tcam pti with name = [%s], size = [%s], type = [%s]\" % (funcName, devSerial, tcamName, tcamSize, tcamType))\n            #PTIWrapper.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", templateName)\n            Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ptiPrio, templateName, {\"TCAM_NAME\": tcamName, \"TCAM_SIZE\":tcamSize}, \"bf_tcam\"))\n        priority = priority+5\n\n    # look for the vrf references in matches for 'dns_vrf_one' and 'dns_vrf' policies\n    vrfsWithDns = []\n    dnsTemplates = ['dns-vrfList']\n    for templateName in dnsTemplates:\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            getVrfsWithDns(nvPairList, vrfsWithDns)\n\n    vrf_block = features_info[\"VRF_BLOCK\"]\n    for vrfStr in vrf_block.keys():\n        vrfRec = vrf_block[vrfStr]\n        vrfName = vrfStr.split(\" \")[2].strip()\n        Wrapper.print(\"%s: Processing DNS for VRF context [%s]\" % (funcName, vrfName))\n        \n        if vrfName.lower() == MGMT_VRF_NAME:\n            global_unaccounted += vrfRec[\"unaccounted\"]\n        else:\n            if vrfName in vrfsWithDns:\n                continue\n            newCfg = []\n            for line in vrfRec[\"show_run\"]:\n                strippedLine = line.strip()\n                if strippedLine.startswith(\"vrf context\") or strippedLine.startswith(\"ip name-server\"):\n                    newCfg.append(line)\n            if len(newCfg) > 1:\n                Wrapper.print(\"%s: VRF context [%s]. Name server cfg = [%s]\" % (funcName, vrfName, newCfg))\n                global_unaccounted += newCfg\n                #global_unaccounted += Util.newLine().join(newCfg)\n\n    bgp_unaccounted = []\n    routerBgpKey = \"router bgp \" + BGP_AS\n    if routerBgpKey in features_info[\"BGP_BLOCK\"]:\n        bgp_unaccounted = features_info[\"BGP_BLOCK\"][routerBgpKey][\"unaccounted\"]\n\n    # add matched bgp_peer_template and bgp_neighbor_inherit which did not have policy created\n    # may work on the order later\n    if bgpTmplNvPairList == None:\n        bgpTmplNvPairList = []\n    if bgpInheritNvPairList == None:\n        bgpInheritNvPairList = []\n    if len(bgp_unaccounted) == 0 and (len(bgpTmplNvPairList) + len(bgpInheritNvPairList)) != 0:\n        bgp_unaccounted.append(\"router bgp %s\" % BGP_AS)\n\n    for nvPair in bgpTmplNvPairList:\n        bgp_unaccounted.append(\"  template %s %s\" % (nvPair[\"TEMPLATE_TYPE\"],nvPair[\"TEMPLATE_NAME\"]))\n        bgp_unaccounted += nvPair[\"CONF\"]\n\n    for nvPair in bgpInheritNvPairList:\n        bgp_unaccounted.append(\"  neighbor %s\" % nvPair[\"BGP_NEIGHBOR_IP\"])\n        bgp_unaccounted.append(\"    inherit %s %s\" % (nvPair[\"TEMPLATE_TYPE\"], nvPair[\"TEMPLATE_NAME\"]))\n\n    Wrapper.print(\"BGP unaccounted with template: %s\" % bgp_unaccounted)\n\n    cmap = vVpcSpineQos[devSerial].get('classMap') if vVpcSpineQos.has_key(devSerial) else \"\"\n    pmap = vVpcSpineQos[devSerial].get('policyMap') if vVpcSpineQos.has_key(devSerial) else \"\"\n    \n    ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n    for pti in ptiList:\n        Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n\n    if feature_unaccounted:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_TOP,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(feature_unaccounted)}, \"Additional Feature Configuration\"))\n\n    if cmap and pmap:\n        vVpcQosConf = cmap + Util.newLine() + pmap\n        vVpcQosConfList = vVpcQosConf.splitlines()\n        vVpcQosDescription = \"Qos on Spines for fabric vpc peering\"\n        fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n        qosPolicyName = fabricSettings.get(\"FABRIC_VPC_QOS_POLICY_NAME\", \"spine_qos_for_fabric_vpc_peering\")\n        ptiList = Util.getPTIList(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\", \"PYTHON\", vVpcQosDescription)\n        for pti in ptiList:\n            PTI.deleteInstance(pti.getPolicyId())\n        Util.exe(PTI.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                            \"switch_freeform\", {\"CONF\":vVpcQosConf, \"POLICY_NAME\":qosPolicyName}, vVpcQosDescription))\n        Wrapper.print(\"%s(): global_unaccounted [%s] , vVpcQosConfList [%s]\"%(funcName, global_unaccounted, vVpcQosConfList))\n        globalUnaccountedStr = Util.newLine().join(global_unaccounted)\n        globalUnaccountedStr = globalUnaccountedStr.replace(cmap, '')\n        globalUnaccountedStr = globalUnaccountedStr.replace(pmap, '')\n        global_unaccounted = globalUnaccountedStr.splitlines()\n\n    # need to process the config blocks collected from the 'show run'\n    linkProtoCfgLines = []\n    keyChainCfgLines = []\n    cfgBlocksFromShRun = matchResult.get(\".SH_RUN_CFG_BLOCKS\", {})\n    for key in cfgBlocksFromShRun:\n        instances = cfgBlocksFromShRun[key]\n        if (key in [\"ROUTER_ISIS\", \"ROUTER_OSPF\"]):\n            for instance in instances:\n                if underlayProtocolCfgLine == instance:\n                    # we are not interested in this since the policy matches would have captured the intent\n                    continue\n                else:\n                    linkProtoCfgLines += instances[instance]\n        elif key == \"KEY_CHAIN\":\n            for instance in instances:\n                if keyChainLine == instance:\n                    # look further into the key id of interest.. (will not get here is ISIS and auth is not enabled)\n                    isisKeyLines = []\n                    ourBlock = False\n                    for line in instances[instance]:\n                        depth = (len(line) - len(line.lstrip(' '))) / 2\n\n                        if depth == 1:\n                            strippedLine = line.strip()\n                            ourBlock = False\n                            if strippedLine == isisKeyId:\n                                ourBlock = True\n\n                        if not ourBlock:\n                            isisKeyLines.append(line)\n                    if len(isisKeyLines) > 1:\n                        # the first line is the 'key chain <name>'\n                        keyChainCfgLines += isisKeyLines\n                else:\n                    keyChainCfgLines += instances[instance]\n\n    switchOverlayInfo[\"PRE_INTF_FF\"] = (global_unaccounted + keyChainCfgLines + switchOverlayInfo[\"PRE_INTF_FF\"])\n    if switchOverlayInfo[\"PRE_INTF_FF\"]:\n        # this needs to show up before the interfaces\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(switchOverlayInfo[\"PRE_INTF_FF\"])}, BF_PRE_INTF_FF_PTI_DESC))\n    switchOverlayInfo[\"PRE_INTF_FF\"] = None\n\n    # create the post interface unaccounted config block.. this must show up after the interfaces\n    global_unaccounted_AAA_INTF = []\n    filteredUnaccounted = []\n    if 'GLOBAL_POST_INTF_UNACCTED' in features_info:\n        if features_info[\"GLOBAL_POST_INTF_UNACCTED\"]:\n            global_unaccounted = features_info[\"GLOBAL_POST_INTF_UNACCTED\"][\"unaccounted\"]\n            for line in global_unaccounted:\n                depth = (len(line) - len(line.lstrip(' '))) / 2\n\n                if depth == 0:\n                    # top level config\n                    skipBlock = False\n                    if line.startswith(\"boot\"):\n                        # these should not be captured in the accounted configs\n                        continue\n                    if line.startswith(\"router ospf \") or line.startswith(\"router ospfv3 \") or line.startswith(\"router isis \"):\n                        if line != underlayProtocolCfgLine:\n                            # the entire configs for these will be obtained from the 'show run' already.. remove from here\n                            skipBlock = True\n\n                if skipBlock:\n                    Wrapper.print(\"underlayProtocolCfgLine: skipping line [%s]\" % line)\n                    continue\n\n                if (line.startswith(\"radius\") or line.startswith(\"tacacs\") or\n                    line.startswith(\"aaa\") or line.startswith(\"  server\")):\n                    global_unaccounted_AAA_INTF.append(line)\n                    continue\n\n                filteredUnaccounted.append(line)\n\n    postIntfFF = filteredUnaccounted + linkProtoCfgLines + switchOverlayInfo[\"POST_INTF_FF\"]\n    if postIntfFF:\n        # this needs to show up after the interfaces\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.POST_INTF_SWITCH_FF,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(postIntfFF)}, \"Post Interfaces Configuration\"))\n    switchOverlayInfo[\"POST_INTF_FF\"] = None\n\n    AAA_Configs += global_unaccounted_AAA_INTF\n    AAA_Configs += global_unaccounted_AAA\n    if AAA_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.AAA_SWITCH_FF,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(AAA_Configs)}, \"NDFC AAA extra configuration\")) \n\n    bgpFF = bgp_unaccounted + switchOverlayInfo[\"BGP_FF\"]\n    isBGW = True if \"border gateway\" == switchRole else False\n    if isBGW:\n        # capture any rr client configs that were found\n        templateName = \"evpn_bgp_rr\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            respObj.addWarnReport(\"BGP_RR_ON_BORDER_GATEWAY\",\n                   \"Border Gateway role - found BGP Route Reflector (RR) client configuration which is not \"\n                   \"recommended for this role other than for the Endpoint Locator (EPL) use-case.\", devSerial)\n            if respObj.isRetCodeSuccess():\n                # do not overwrite existing error status if any\n                respObj.setWarningRetCode()\n            for nvPairs in nvPairList:\n                genCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, nvPairs, False, None)\n                bgpFF.append(genCfg)\n\n    if bgpFF:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_BOTTOM,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(bgpFF)}, \"BGP Configuration\"))\n    switchOverlayInfo[\"BGP_FF\"] = None\n\n    # process leaf/spine specific global configs\n    vpcPairInfo = {}\n    if not isSpine:\n        # process leaf specific configs\n\n        # create the base features PTI\n        createPTI(devSerial, {}, \"base_feature_leaf_upg\", \"SWITCH\", getSrc(\"base_feature_leaf_upg\"), -1)\n        templateName = \"feature_ospf\" if UNDERLAY_IS_V6 == \"false\" else \"feature_ospfv3\"\n        createMatchedPtis(devSerial, matchResult, templateName)\n        createMatchedPtis(devSerial, matchResult, \"feature_lacp\")\n        createMatchedPtis(devSerial, matchResult, \"feature_pim\")\n        createMatchedPtis(devSerial, matchResult, \"feature_ngoam\")\n        createMatchedPtis(devSerial, matchResult, \"feature_ngmvpn\")\n        createMatchedPtis(devSerial, matchResult, \"trm_multicast_multipath\")\n        createMatchedPtis(devSerial, matchResult, \"feature_dhcp\")\n        createMatchedPtis(devSerial, matchResult, \"eth_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv4_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv6_cfs\")\n\n        createMatchedPtis(devSerial, matchResult, \"enable_ngoam\")\n        createMatchedPtis(devSerial, matchResult, \"route_map\")\n        createMatchedPtis(devSerial, matchResult, \"anycast_gateway\")\n        createMatchedPtis(devSerial, matchResult, \"evpn_bgp_advertise_pip\")\n        createMatchedPtis(devSerial, matchResult, \"nve_advertise_vmac\")\n        templateName = \"evpn_bgp_rr_neighbor\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr_neighbor\"\n        deleteAndCreateMatchedPtis(devSerial, matchResult, templateName)\n        deleteAndCreateMatchedPtis(devSerial, matchResult, \"mvpn_bgp_rr_neighbor\")\n        createMatchedPtis(devSerial, matchResult, \"l3_trm\")\n        createMatchedPtis(devSerial, matchResult, \"base_dhcp\")\n\n        # check system nve infra vlans\n        # what about resource and what about vlan id\n        templateName = \"system_nve_infra_vlan\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            infraVlans = nvPairList[0].get(\"VLAN\")\n            if infraVlans:\n                infraVlanList = getVlanList(infraVlans)\n                if vPCInfo[\"peerLinkVlan\"] in infraVlanList:\n                    infraVlanList.remove(vPCInfo[\"peerLinkVlan\"])\n                infraVlanPTIs = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"system_nve_infra_vlan\"))\n                for pti in infraVlanPTIs:\n                    PTIWrapper.deleteInstance(pti.getPolicyId())\n                for vlan in infraVlanList:\n                    createPTI(devSerial,{\"VLAN\": vlan}, \"system_nve_infra_vlan\", \"SWITCH\",\"\", -1, False)\n\n\n        # create the extra CLIs PTI (we will not match these from the config)\n        if EXTRA_CONF_LEAF != \"\":\n            createPTI(devSerial, {\"CONF\": EXTRA_CONF_LEAF}, \"extra_config_leaf\",\n                                  \"SWITCH\", \"UNDERLAY\", -1)\n\n        if isValidVPC:\n            vpcPairInfo[\"domainId\"] = vPCInfo[\"domainId\"]\n\n            createMatchedPtis(devSerial, matchResult, \"vpc_domain_mgmt\")\n            createMatchedPtis(devSerial, matchResult, \"vpc_domain_ipv6_nd_11_1\")\n\n            createVirtualPeerLinkPTI(devSerial, matchResult, vpcPairInfo)\n            peerSerial = getVPCPeerDeviceSN(devSerial, vpcSrcToDstMacMap)\n            if peerSerial:\n                if vpcPairInfo.get(\"vpcFabricPair\"):\n                    Util.exe(VpcWrapper.create(devSerial, peerSerial, \"true\"))\n                else:\n                    Util.exe(VpcWrapper.create(devSerial, peerSerial))\n\n            \"\"\"\n            no need to create policies below since we will take it from fabric setting. TBD on warning\n            templateName = \"vpc_domain_autorecovery\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            if (nvPairList != None):\n                if nvPairList[0][\"AUTO_RECOVERY\"] != \"240\":\n                    # save the info (we expect a single entry)\n                    vpcPairInfo.update({\"autoRecoveryTime\" : nvPairList[0][\"AUTO_RECOVERY\"]})\n                    createMatchedPtis(devSerial, matchResult, \"vpc_domain_autorecovery\")\n                else:\n                    createMatchedPtis(devSerial, matchResult, \"vpc_domain_autorecovery_default\")\n\n            templateName = \"vpc_delay_restore\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            if (nvPairList != None):\n                if nvPairList[0][\"DELAY_RESTORE\"] != \"30\":\n                    # save the info (we expect a single entry)\n                    vpcPairInfo.update({\"delayRestore\" : nvPairList[0][\"DELAY_RESTORE\"]})\n                    createMatchedPtis(devSerial, matchResult, \"vpc_delay_restore\")\n            \"\"\"\n    \n            templateName = \"vpc_nve_loopback\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            templateName = \"vpc_nve_loopback_with_tag_11_1\"\n            nvPairListWithTag = getTemplateMatchResults(matchResult, templateName)\n\n            if (nvPairList != None):\n                # save the info (we expect a single entry)\n                vpcPairInfo.update({\"nveSecondaryLoopbackIntf\" : nvPairList[0][\"INTF_NAME\"]})\n                vpcPairInfo.update({\"nveSecondaryIp\" : nvPairList[0][\"SECONDARY_IP\"]})\n                #createMatchedPtis(devSerial, matchResult, \"vpc_nve_loopback\")\n            elif nvPairListWithTag != None:\n                vpcPairInfo.update({\"nveSecondaryLoopbackIntf\" : nvPairListWithTag[0][\"INTF_NAME\"]})\n                vpcPairInfo.update({\"nveSecondaryIp\" : nvPairListWithTag[0][\"SECONDARY_IP\"]})\n                vpcPairInfo.update({\"ROUTE_MAP_TAG\" : nvPairListWithTag[0][\"ROUTE_MAP_TAG\"]})\n                #createMatchedPtis(devSerial, matchResult, \"vpc_nve_loopback_with_tag_11_1\")\n\n            # process the vPC peer link SVI\n            sviIntf, nvPair = getSviTemplateMatch(vPCInfo[\"peerLinkVlan\"], matchResult, interfacesRes)\n            if nvPair:\n                intfName = nvPair[\"INTF_NAME\"]\n                vpcPeerLinkSviNvPairs = {\"FABRIC_NAME\" : FABRIC_NAME,\n                                         \"INTF_NAME\" : \"\",\n                                         \"IP\" : \"\",\n                                         \"PREFIX\" : \"\",\n                                         \"V6IP\" : \"\",\n                                         \"V6PREFIX\" : \"\",\n                                         \"LINK_STATE_ROUTING\": LINK_STATE_ROUTING,\n                                         \"LINK_STATE_ROUTING_TAG\": \"\",\n                                         \"OSPF_AREA_ID\": OSPF_AREA_ID,\n                                         \"REPLICATION_MODE\":REPLICATION_MODE,\n                                         \"MTU\":\"\",\n                                         \"DESC\" : \"\",\n                                         \"CONF\" : \"\",\n                                         \"ADMIN_STATE\" : \"true\",\n                                         \"BFD_ENABLE\" : BFD_ENABLE,\n                                         \"BFD_ECHO_DISABLE\" : \"false\"\n                                        }\n\n                if (len(sviIntf[\"unaccounted_cmds\"]) > 0):\n                    vpcPeerLinkSviNvPairs.update({\"CONF\": Util.newLine().join(sviIntf[\"unaccounted_cmds\"])}) \n                if UNDERLAY_IS_V6 == \"false\":\n                    # Underlay is V4, treat ipv6 address config as unaccounted\n                    templateList = [\"interface_ipv6_11_1\"]\n                else:\n                    # Underlay is V6, treat ip address config as unaccounted\n                    templateList = [\"interface_ipv4_11_1\"]\n                configList = unaccCfgFromTemplates(intfName, templateList, sviIntf, matchResult)\n                if vpcPeerLinkSviNvPairs[\"CONF\"] and configList:\n                    vpcPeerLinkSviNvPairs[\"CONF\"] = vpcPeerLinkSviNvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                elif configList:\n                    vpcPeerLinkSviNvPairs[\"CONF\"] = Util.newLine().join(configList)\n                Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"%(devSerial, intfName, vpcPeerLinkSviNvPairs.get(\"CONF\")))\n                \n                # save the vPC peer link vlan id\n                vpcPairInfo.update({\"peerLinkVlanIntf\" : nvPair[\"INTF_NAME\"]})\n                vpcPairInfo.update({\"peerLinkVlan\" : nvPair[\"INTF_NAME\"].lstrip(\"Vlan\")})\n                if UNDERLAY_IS_V6 == \"false\":\n                    vpcPairInfo.update({\"peerLinkVlanIp\" : nvPair[\"IP\"]})\n                    vpcPairInfo.update({\"peerLinkVlanIpPrefix\" : nvPair[\"PREFIX\"]})\n                    vpcPeerLinkSviNvPairs[\"IP\"] = nvPair[\"IP\"]\n                    vpcPeerLinkSviNvPairs[\"PREFIX\"] = nvPair[\"PREFIX\"]\n                elif USE_LINK_LOCAL == \"false\":\n                    vpcPairInfo.update({\"peerLinkVlanIp\" : nvPair[\"IP\"]})\n                    vpcPairInfo.update({\"peerLinkVlanIpPrefix\" : nvPair[\"PREFIX\"]})\n                    vpcPeerLinkSviNvPairs[\"V6IP\"] = nvPair[\"IP\"]\n                    vpcPeerLinkSviNvPairs[\"V6PREFIX\"] = nvPair[\"PREFIX\"]\n                else:\n                    vpcPairInfo.update({\"peerLinkVlanIp\" : \"\"})\n                    vpcPairInfo.update({\"peerLinkVlanIpPrefix\" : \"\"})\n\n                vpcPeerLinkSviNvPairs[\"INTF_NAME\"] = nvPair[\"INTF_NAME\"]\n\n                # mark the interface as being processed\n                sviIntf.update({\"isProcessed\" : True})\n                Wrapper.print(\"%s: Interface [%s] is marked as processed at line [%s]\"%(funcName, intfName, sys._getframe().f_lineno))\n\n                templateNameMatches = sviIntf[\"matched_templates\"]\n                matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n                for templateName in matchingNvPairs:\n                    if (\"interface_desc\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n                    if (\"interface_mtu\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"MTU\"] = matchingNvPairs[templateName][\"MTU\"]\n                    elif (\"ospf_interface_11_1\" == templateName or \"v6_ospf_interface\" == templateName):\n                        vpcPeerLinkSviNvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"OSPF_TAG\"]})\n                        vpcPeerLinkSviNvPairs.update({\"OSPF_AREA_ID\" : matchingNvPairs[templateName][\"OSPF_AREA_ID\"]})\n                    elif (\"isis_interface\" == templateName or \"v6_isis_interface\" == templateName):\n                        vpcPeerLinkSviNvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"ISIS_TAG\"]})\n                    elif (\"shut_interface\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"ADMIN_STATE\"] = \"false\"\n                    elif (\"ospf_interface_auth\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"OSPF_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY_ID\"]\n                        vpcPeerLinkSviNvPairs[\"OSPF_AUTH_KEY\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY\"]\n                    elif (\"pim_interface_hello_auth\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"PIM_HELLO_AUTH_KEY\"] = matchingNvPairs[templateName][\"AUTH_KEY\"]\n                    elif (\"isis_interface_auth\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"ISIS_AUTH_KEYCHAIN_NAME\"] = matchingNvPairs[templateName][\"ISIS_AUTH_KEYCHAIN_NAME\"]\n                        vpcPeerLinkSviNvPairs[\"IS_TYPE\"] = matchingNvPairs[templateName][\"IS_TYPE\"]\n                    elif (\"bfd_interface_auth\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"BFD_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"BFD_AUTH_KEY_ID\"]\n                        vpcPeerLinkSviNvPairs[\"BFD_AUTH_KEY\"] = matchingNvPairs[templateName][\"BFD_AUTH_KEY\"]\n                    elif (\"bfd_no_echo_interface\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"BFD_ECHO_DISABLE\"] = \"true\"\n\n                if \"BFD_AUTH_KEY\" not in vpcPeerLinkSviNvPairs:\n                    vpcPeerLinkSviNvPairs[\"BFD_AUTH_KEY\"] = BFD_AUTH_KEY\n                    vpcPeerLinkSviNvPairs[\"BFD_AUTH_KEY_ID\"] = BFD_AUTH_KEY_ID\n                if \"OSPF_AUTH_KEY\" not in vpcPeerLinkSviNvPairs:\n                    vpcPeerLinkSviNvPairs[\"OSPF_AUTH_KEY\"] = OSPF_AUTH_KEY\n                    vpcPeerLinkSviNvPairs[\"OSPF_AUTH_KEY_ID\"] = OSPF_AUTH_KEY_ID\n                if \"ISIS_AUTH_KEYCHAIN_NAME\" not in vpcPeerLinkSviNvPairs:\n                    vpcPeerLinkSviNvPairs[\"ISIS_AUTH_KEYCHAIN_NAME\"] = ISIS_AUTH_KEYCHAIN_NAME\n                    vpcPeerLinkSviNvPairs[\"IS_TYPE\"] = ISIS_LEVEL\n                vpcPeerLinkSviNvPairs[\"ISIS_P2P_ENABLE\"] = ISIS_P2P_ENABLE\n\n                # create the vPC peer link SVI jython policy\n                Wrapper.print(\"%s: Creating peer link SVI [%s] policy. BFD_ENABLE [%s], nvPairs [%s]\" % \n                    (funcName, intfName, BFD_ENABLE, vpcPeerLinkSviNvPairs))\n                createPTI(devSerial, vpcPeerLinkSviNvPairs, \"int_fabric_vlan_11_1\", intfName, \"UNDERLAY\", -1)\n\n                # create PTI for the peer link vlan also\n                templateName = \"vpc_peer_link_vlan\"\n                asicType = getHwAsicType(topologyDataObj, devSerial)\n                if asicType != \"CLOUDSCALE\":\n                    # this template is good for T2, Fretta, N9kv and white box\n                    templateName = \"vpc_peer_link_vlan_9300PX\"\n                createPTI(devSerial, {\"VLAN\" : vPCInfo[\"peerLinkVlan\"]}, templateName, \"SWITCH\", \"UNDERLAY\", -1)\n\n                # create the PTI for the peer link vlan name if we do find one\n                templateName = \"vlan_name_11_1\"\n                nvPairList = getTemplateMatchResults(matchResult, templateName)\n                if (nvPairList != None):\n                    for nvPair in nvPairList:\n                        if (nvPair[\"VLAN\"] == vPCInfo[\"peerLinkVlan\"]):\n                            # create the PTI with an empty source to allow user to change the name is needed\n                            createPTI(devSerial, nvPair, templateName, \"SWITCH\", \"\", -1)\n\n            vpcPeerLinkPoNvPairs = { \"PO_ID\" : \"\",\n                                     \"NATIVE_VLAN\" : \"\",\n                                     \"DESC\" : \"\",\n                                     \"MEMBER_DESC\":\"\",\n                                     \"ADMIN_STATE\" : \"true\",\n                                     \"MEMBER_INTERFACES\":\"\",\n                                     \"CONF\":\"\"\n                                   }\n\n            # lookup the vpc peer link PO\n            vpcMCTPoId = \"\"\n            pcRmId = -1\n            templateName = \"vpc_peer_link_po_interface\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            if (nvPairList != None):\n                # we expect only one nv pair\n                entityType = getEType(templateName)\n                entityName = getEntityName(devSerial, entityType, nvPairList[0], templateName)\n                intfMatchResult = interfacesRes[entityName]\n\n                vpcPeerLinkPoNvPairs.update({\"PO_ID\" : entityName})\n\n                # mark the interface as being processed\n                intfMatchResult.update({\"isProcessed\" : True})\n                Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(entityName, sys._getframe().f_lineno))\n\n                # set the PO id resource\n                portChannelIntf = entityName.lower()\n                pc, vpcMCTPoId = portChannelIntf.split(\"port-channel\")\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC Peer-Link PO: PORT_CHANNEL_ID [%s]\"%\n                              (FABRIC_NAME, key, vpcMCTPoId))\n                ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, entityName, vpcMCTPoId))\n\n                # get the interface template results to get additional info\n                templateNameMatches = intfMatchResult[\"matched_templates\"]\n                templateList = [\"interface_desc\"]\n                matchingNvPairs = getIntfMatchNvPairs(matchResult, entityName, templateList)\n                if matchingNvPairs:\n                    vpcPeerLinkPoNvPairs.update({\"DESC\" : matchingNvPairs[\"interface_desc\"][\"DESC\"]})\n\n                if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                    Wrapper.print(\"Device [%s] Found unaccounted cfg for portchannel intf [%s]\" % (devSerial, portChannelIntf))\n\n                    # we need to scan and extract the trunk native vlan from the unaccounted config\n                    vpcPeerLinkPoNvPairs[\"NATIVE_VLAN\"], updatedFFCfgList = getNativeVlanAndUpdatedUnacctCfgList(\n                                            intfMatchResult[\"unaccounted_cmds\"])\n\n                    # set the updated extra config\n                    vpcPeerLinkPoNvPairs.update({\"CONF\": Util.newLine().join(updatedFFCfgList)}) \n\n                templateList = [\n                                \"interface_speed\",\n                                \"interface_no_nego_auto\",\n                                \"bpduguard_disable\", \n                                \"bpduguard_enable\", \n                                \"porttype_fast_trunk\",\n                                \"porttype_fast_enable\",\n                                \"access_vlan\",\n                                \"cdp_disable_interface_11_1\"\n                               ]\n\n                configList = unaccCfgFromTemplates(portChannelIntf, templateList, intfMatchResult, matchResult)\n                if vpcPeerLinkPoNvPairs[\"CONF\"] and configList:\n                    vpcPeerLinkPoNvPairs[\"CONF\"] = vpcPeerLinkPoNvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                elif configList:\n                    vpcPeerLinkPoNvPairs[\"CONF\"] = Util.newLine().join(configList)\n                Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"% \n                             (devSerial, portChannelIntf, vpcPeerLinkPoNvPairs.get(\"CONF\")))\n\n             # lookup the vpc peer link peer members\n            templateName = \"vpc_peer_link_member_interface\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            vpcPeerLinkMemberInterfaces = []\n            if (nvPairList != None):\n                for memberNvPair in nvPairList:\n                    if (vpcMCTPoId != memberNvPair[\"PCID\"]):\n                        # this interface does not belong to the MCT\n                        continue\n\n                    entityType = getEType(templateName)\n                    entityName = getEntityName(devSerial, entityType, memberNvPair, templateName)\n                    intfMatchResult = interfacesRes[entityName]\n\n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(entityName, sys._getframe().f_lineno))\n\n                    vpcPeerLinkMemberInterfaces.append(entityName)\n                \n                    # check to see if we need the peer serial\n                    try:\n                        if (vpcPairInfo[\"peerSerialNum\"] != None):\n                            # we have the info already... skip\n                            continue\n                    except:\n                        # the 'peerSerialNum' key does not exist.. \n                        peerSerial = topologyDataObj.getNeighborDeviceSN(devSerial, entityName)\n                        if not (peerSerial == \"\" or peerSerial == 0):\n                            # we have a valid peer... check if it's state is complete\n                            if not isSwitchInUnderlayMigration(peerSerial):\n                                # the expected PTIs should be in place\n                                Wrapper.print(\"vPC: peer serial %s\" % peerSerial)\n                                vpcPairInfo.update({\"peerSerialNum\" : peerSerial})\n                            else:\n                                Wrapper.print(\"vPC: Found peer [%s], but, not migrated\" % peerSerial)\n\n                vpcPeerLinkPoNvPairs.update({\"MEMBER_INTERFACES\" : \",\".join(vpcPeerLinkMemberInterfaces)})\n            if vpcPairInfo.get(\"vpcFabricPair\"):\n                peerSerial = getVPCPeerDeviceSN(devSerial, vpcSrcToDstMacMap)\n                if not (peerSerial == \"\" or peerSerial == 0):\n                    # we have a valid peer... check if it's state is complete\n                    if not isSwitchInUnderlayMigration(peerSerial):\n                        # the expected PTIs should be in place\n                        Wrapper.print(\"vPC: peer serial %s\" % peerSerial)\n                        vpcPairInfo.update({\"peerSerialNum\" : peerSerial})\n                    else:\n                        Wrapper.print(\"vPC: Found peer [%s], but, not migrated\" % peerSerial)\n                vpcPeerLinkPoNvPairs.update({\"MEMBER_INTERFACES\" : \"\"})\n                \n            # we will go ahead and create the vpc peer link PO policy\n            createPTI(devSerial, vpcPeerLinkPoNvPairs, \"int_vpc_peer_link_po\", \n                      vpcPeerLinkPoNvPairs[\"PO_ID\"], \"\", pcRmId)\n            ptiTemplate = \"int_vpc_peer_link_po_member_11_1\"\n            poMemberDescAndFFUpd(devSerial, vpcPeerLinkMemberInterfaces, ptiTemplate, \n                                 vpcMCTPoId, matchResult, interfacesRes, portChannelIntf)\n\n            # take care of setting the vPC related resouces in RM\n            # check if we have the peer serial number\n            peerSerial = \"\"\n            try:\n                peerSerial = vpcPairInfo[\"peerSerialNum\"]\n            except:\n                Wrapper.print(\"vPC: peer serial # does not exist.. skip setting up resources\")\n\n            if (peerSerial != \"\"):\n\n                if not vpcPairInfo.get(\"vpcFabricPair\"):\n                    localIntfIp = vpcPairInfo[\"peerLinkVlanIp\"]\n                \n                # check that the roles of the two peers are consistent before making them a vpcPair\n                peerSwitchRole = topologyDataObj.getSwitchRole(peerSerial)\n                if switchRole != peerSwitchRole:\n                    respObj.addErrorReport(getFabErrEntity(funcName, \"VPC_PAIR_ROLE\"),\n                        \"Inconsistent Role [%s] with vPC Peer switch [%s] Role [%s]. Please set roles correctly and \"\n                        \"retry.\" % (switchRole, getFormattedSwitchName(peerSerial), peerSwitchRole), devSerial)\n                    respObj.setFailureRetCode()\n                else:\n                    # mark the pair as a vPC\n                    Wrapper.print(\"vPC: Marking [%s:%s] a pair\" % (devSerial, peerSerial))\n                    if vpcPairInfo.get(\"vpcFabricPair\"):\n                        Util.exe(VpcWrapper.create(devSerial, peerSerial, \"true\"))\n                    else:\n                        Util.exe(VpcWrapper.create(devSerial, peerSerial))\n\n                    vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n                    serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n                    if ENABLE_FABRIC_VPC_DOMAIN_ID == \"false\":\n                        # Fabric setting is for unique vpc domain ids.. set the vPC domain ID in RM\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: VPC_DOMAIN_ID [%s]\"% \n                                      (FABRIC_NAME, vpcPairSerialKey, vpcPairInfo[\"domainId\"]))\n                        Util.exe(RM.set(FABRIC_NAME, \"VPC_DOMAIN_ID\", vpcPairSerialKey, vpcPairInfo[\"domainId\"]))\n\n                    if not vpcPairInfo.get(\"vpcFabricPair\"):\n                        # set the vPC peer link vlan in RM\n                        ignore, vlanRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_PEER_LINK_VLAN\",\n                                            devSerial, vpcPairSerialKey, vpcPairInfo[\"peerLinkVlan\"]))\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: VPC_PEER_LINK_VLAN [%s], rmId %s - %s\"%\n                                      (FABRIC_NAME, vpcPairSerialKey, vpcPairInfo[\"peerLinkVlan\"], vlanRmId, devSerial))\n\n                        templateName = \"vpc_peer_link_vlan\"\n                        asicType = getHwAsicType(topologyDataObj, devSerial)\n                        if asicType != \"CLOUDSCALE\":\n                            templateName = \"vpc_peer_link_vlan_9300PX\"\n\n                        peerVlanPTIs = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\",\n                                                               \"UNDERLAY\", templateName))\n                        for pti in peerVlanPTIs:\n                            if pti.isDeleted():\n                                continue\n\n                            Wrapper.print(\"Update %s policy %s with rmId %s\" % (templateName, pti.getPolicyId(), vlanRmId))\n                            Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), devSerial, \"SWITCH\", \"SWITCH\",\n                                                        pti.getSource(), pti.getPriority(),\n                                                        vlanRmId, templateName, pti.getNvPairs()))\n                            break\n\n                        ignore, vlanRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_PEER_LINK_VLAN\",\n                                            peerSerial, vpcPairSerialKey, vpcPairInfo[\"peerLinkVlan\"]))\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: VPC_PEER_LINK_VLAN [%s], rmId %s - %s\"%\n                                      (FABRIC_NAME, vpcPairSerialKey, vpcPairInfo[\"peerLinkVlan\"], vlanRmId, peerSerial))\n\n                        templateName = \"vpc_peer_link_vlan\"\n                        asicType = getHwAsicType(topologyDataObj, peerSerial)\n                        if asicType != \"CLOUDSCALE\":\n                            templateName = \"vpc_peer_link_vlan_9300PX\"\n\n                        peerVlanPTIs = Util.exe(PTIWrapper.get(peerSerial, \"SWITCH\", \"SWITCH\",\n                                                               \"UNDERLAY\", templateName))\n                        for pti in peerVlanPTIs:\n                            if pti.isDeleted():\n                                continue\n\n                            Wrapper.print(\"Update %s policy %s with rmId %s\" % (templateName, pti.getPolicyId(), vlanRmId))\n                            Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), peerSerial, \"SWITCH\", \"SWITCH\",\n                                                        pti.getSource(), pti.getPriority(),\n                                                        vlanRmId, templateName, pti.getNvPairs()))\n                            break\n\n                        # generate the key to associate the vPC peer link subnet pool with\n                        peerLinkVlanIntf = vpcPairInfo[\"peerLinkVlanIntf\"]\n                        linkKey = Util.exe(Helper.getKey(\"Link\", serials[0], peerLinkVlanIntf, serials[1], peerLinkVlanIntf))\n\n                        subnetStr = \"\"\n                        if UNDERLAY_IS_V6 == \"false\":\n                            subnetStr = Util.getSubnetStringWithPrefix(localIntfIp, vpcPairInfo[\"peerLinkVlanIpPrefix\"])\n                        elif USE_LINK_LOCAL == \"false\":\n                            subnetStr = Util.getV6SubnetStringWithPrefix(localIntfIp, vpcPairInfo[\"peerLinkVlanIpPrefix\"])\n                        if subnetStr != \"\":\n                            # set the subnet pool in RM\n                            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: Peer Link SUBNET [%s]\" % (FABRIC_NAME, linkKey, subnetStr))\n                            ignore, subnetRmId = Util.exeRM(RM.set(FABRIC_NAME, PoolName.SUBNET, EntityType.LINK, linkKey, subnetStr))\n                            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: Peer Link SUBNET [%s], rmId [%s]\" % (FABRIC_NAME, linkKey, subnetStr, subnetRmId))\n                            #simulated PTI to delete subnet resource along with PTI\n                            Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, subnetRmId, \"link_subnet_simulated\", {}))\n                            Util.exe(PTI.createOrUpdate(peerSerial, \"SWITCH\", \"SWITCH\", \"\", 10, subnetRmId, \"link_subnet_simulated\", {}))\n\n                            # set the local vPC Vlan interface IP in RM\n                            key = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, peerLinkVlanIntf))\n                            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: Peer Link SUBNET [%s] IP [%s]\"%\n                                          (FABRIC_NAME, key, subnetStr, localIntfIp))\n                            ignore, rmId1 = Util.exeRM(RM.set(FABRIC_NAME, subnetStr, EntityType.INTERFACE, key, localIntfIp))\n\n                            peerVlanPTIs = Util.exe(PTIWrapper.get(devSerial, \"INTERFACE\",\n                                                    peerLinkVlanIntf, \"UNDERLAY\", \"int_fabric_vlan_11_1\"))\n                            for pti in peerVlanPTIs:\n                                if pti.isDeleted():\n                                    continue\n\n                                Wrapper.print(\"Update int_fabric_vlan_11_1 policy %s with rmId %s for IP %s\" % (pti.getPolicyId(), rmId1, localIntfIp))\n                                Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), devSerial, \"INTERFACE\", peerLinkVlanIntf,\n                                                            pti.getSource(), pti.getPriority(),\n                                                            rmId1, \"int_fabric_vlan_11_1\", pti.getNvPairs()))\n                                break\n        \n                        # we also need to get the vPC Peer Link Vlan intf IP of the peer\n                        peerIntfPTIs = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\",\n                                                peerLinkVlanIntf, \"UNDERLAY\", \"int_fabric_vlan_11_1\"))\n                        peerIntfIp = \"\"\n                        for pti in peerIntfPTIs:\n                            if UNDERLAY_IS_V6 == \"false\":\n                                peerIntfIp = pti.nvPairs[\"IP\"]\n                            elif USE_LINK_LOCAL == \"false\":\n                                peerIntfIp = pti.nvPairs[\"V6IP\"]\n                            Wrapper.print(\"vPC Peer Link Vlan intf intf [%s]. IP = [%s]\" %\n                                          (peerLinkVlanIntf, peerIntfIp))\n        \n                            if peerIntfIp != \"\":\n                                # set the peer vPC Vlan interface IP in RM\n                                key = Util.exe(Helper.getKey(\"DeviceInterface\", peerSerial, peerLinkVlanIntf))\n                                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: Peer Link SUBNET [%s] IP [%s]\" %\n                                              (FABRIC_NAME, key, subnetStr, peerIntfIp))\n                                ignore, rmId2 = Util.exeRM(RM.set(FABRIC_NAME, subnetStr, EntityType.INTERFACE, key, peerIntfIp))\n                                Wrapper.print(\"update int_fabric_vlan_11_1 peer policy %s with rmId %s for IP %s\" % (pti.getPolicyId(), rmId2, peerIntfIp))\n                                Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), peerSerial, \"INTERFACE\", peerLinkVlanIntf,\n                                                            pti.getSource(), pti.getPriority(),\n                                                            rmId2, \"int_fabric_vlan_11_1\", pti.getNvPairs()))\n                                break\n\n                    if UNDERLAY_IS_V6 == \"false\":\n                        key = Util.exe(Helper.getKey(\"DeviceInterface\",\n                                       devSerial, peerSerial, vpcPairInfo[\"nveSecondaryLoopbackIntf\"]))\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: NVE Secondary IP [%s]\" % \n                                      (FABRIC_NAME, key, vpcPairInfo[\"nveSecondaryIp\"]))\n                        Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK1_IP_POOL\", EntityType.INTERFACE,\n                                        key, vpcPairInfo[\"nveSecondaryIp\"]))\n\n                    \n                    # dummy PTIs to check in easy fabric\n                    createPTI(devSerial, {\"VPC_SERIAL\":vpcPairSerialKey}, \"vpc_serial_simulated\", \"SWITCH\", \"\" , -1)\n                    createPTI(peerSerial, {\"VPC_SERIAL\":vpcPairSerialKey}, \"vpc_serial_simulated\", \"SWITCH\", \"\" , -1)\n    else:\n        # process spine specific policies\n        createPTI(devSerial, {}, \"base_feature_spine_upg\", \"SWITCH\", \"UNDERLAY\", -1)\n\n        templateName = \"feature_ospf\" if UNDERLAY_IS_V6 == \"false\" else \"feature_ospfv3\"\n        createMatchedPtis(devSerial, matchResult, templateName)\n        createMatchedPtis(devSerial, matchResult, \"feature_pim\")\n        createMatchedPtis(devSerial, matchResult, \"feature_ngoam\")\n        createMatchedPtis(devSerial, matchResult, \"feature_nv_overlay\")\n        createMatchedPtis(devSerial, matchResult, \"feature_vlan_based_vnsegment_11_1\")\n        createMatchedPtis(devSerial, matchResult, \"feature_interface_vlan_11_1\")\n\n        templateName = \"evpn_bgp_rr\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr\"\n        deleteAndCreateMatchedPtis(devSerial, matchResult, templateName)\n        deleteAndCreateMatchedPtis(devSerial, matchResult, \"mvpn_bgp_rr_11_1\")\n        createMatchedPtis(devSerial, matchResult, \"mvpn_bgp\")\n\n        createMatchedPtis(devSerial, matchResult, \"anycast_rp\")\n        createMatchedPtis(devSerial, matchResult, \"evpn_bgp_advertise_pip\")\n\n        # create the DHCP related PTIs with empty src so that they can be be removed by user\n        templateName = \"feature_dhcp\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            for nvPairs in nvPairList:\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", getPrio(templateName),\n                        templateName, nvPairs))\n        templateName = \"base_dhcp\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            for nvPairs in nvPairList:\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", getPrio(templateName),\n                        templateName, nvPairs))\n\n        templateName = \"anycast_rp\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            for nvPairs in nvPairList:\n                anycastRPIPAddress = nvPairs.get(\"ANYCAST_RP_IP\")\n                Wrapper.print(\"%s: Device [%s]. Setting ANYCAST_RP to [%s]\" % (funcName, \n                                            getFormattedSwitchName(devSerial), anycastRPIPAddress))\n                Util.exe(RM.set(FABRIC_NAME, \"ANYCAST_RP_IP_POOL\", EntityType.FABRIC, \"ANYCAST_RP\", anycastRPIPAddress))\n                break\n\n        if EXTRA_CONF_SPINE != \"\":\n            createPTI(devSerial, {\"CONF\": EXTRA_CONF_SPINE}, \"extra_config_spine\", \"SWITCH\", \"UNDERLAY\", -1)\n    try:\n        deviceUpgradeIntf(gVarDictObj, matchResult, interfacesRes, isValidVPC, device_overlay_vlans, vpcPairInfo, respObj)\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error during interface migration\" % getFormattedSwitchName(devSerial))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":INTERFACE_MIGRATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n\n    if not respObj.isRetCodeFailure():\n        # create the IFCs\n        createIFCs(dictionaryObj, switchOverlayInfo, interfacesRes, respObj)\n\n    if not respObj.isRetCodeFailure():\n        if (doOverlayMigr and (migrateMode == \"brownAdd\")):\n            # save the switch overlay info to a file\n            writeToFile(dictionaryObj[\"overlayInfoFileName\"], json.dumps(switchOverlayInfo, indent=4, sort_keys=True), respObj)\n\n        takeSwitchOutOfUnderlayMigrMode(FABRIC_NAME, devSerial)\n\n    Wrapper.print(\"%s: Device [%s]. Success = [%r]\" % (funcName, devSerial, respObj.isRetCodeSuccess()))\n    return respObj\n\ndef createIFCs(switchInfo, switchOverlayInfo, interfacesRes, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    fmtName = switchInfo[\"fmtName\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n\n    Wrapper.print(\"%s: [%s] - Number of IFCs [%d]\" % (funcName, fmtName, len(switchOverlayInfo[\"IFCS\"]['VRF_LITE'])))\n\n    if len(switchOverlayInfo[\"IFCS\"]['VRF_LITE']) == 0:\n        return\n\n    for ifName in switchOverlayInfo[\"IFCS\"]['VRF_LITE']:\n        ifcEntry = switchOverlayInfo[\"IFCS\"]['VRF_LITE'][ifName]\n        vrfLiteIFCNvPairs = ifcEntry[\"nvPairs\"]\n\n        # get these from the interface policy associated with the interface\n        srchOpt = CtrlPolicySearch()\n        srchOpt.setSerialNumber(devSerial)\n        srchOpt.setTemplateContentType(\"PYTHON\")\n        srchOpt.setEntityName(ifName)\n        ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n        ifPolicy = None\n        for pti in ptiList:\n            if pti.isDeleted():\n                continue\n            ifPolicy = pti\n\n        if ifPolicy == None:\n            # we did not find any interface policy associated with the interface.. report an error\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRFLITE_IFC\"),\n                \"Could not locate the VRF-Lite parent interface policy for [%s]\" % (ifName), devSerial)\n            respObj.setFailureRetCode()\n            continue\n\n        ifNvPairs = ifPolicy.getNvPairs()\n        ifFreeformList = ifNvPairs.get(\"CONF\", \"\").splitlines(False)\n\n        # pickup the IP address from the parent intf if this is a cfg profile based import\n        if ifName in interfacesRes:\n            intfMatchResult = interfacesRes[ifName]\n\n            # scan the running config and extract the ip address\n            for cmd in intfMatchResult[\"show_run_cmds\"]:\n                if cmd.strip().startswith(\"ip address \"):\n                    ifFreeformList.append(cmd)\n                    break\n\n        ifFreeform = Util.newLine().join(ifFreeformList) \n        Wrapper.print(\"%s: switch [%s], parent VRF-Lite intf [%s] policy [%s/%s] nvPairs = [%s] ifFreeform [%s]\" % (funcName, \n            fmtName, ifName, ifPolicy.getTemplateName(), ifPolicy.getPolicyId(), ifNvPairs, ifFreeform))\n\n        vrfLiteIFCNvPairs['MTU'] = ifNvPairs.get(\"MTU\", \"9216\")\n        if vrfLiteIFCNvPairs[\"SOURCE_SERIAL_NUMBER\"] == devSerial:\n            vrfLiteIFCNvPairs['PEER1_DESC'] = ifNvPairs.get(\"DESC\", \"\")\n            vrfLiteIFCNvPairs['PEER1_CONF'] = ifFreeform\n        else:\n            vrfLiteIFCNvPairs['PEER2_DESC'] = ifNvPairs.get(\"DESC\", \"\")\n            vrfLiteIFCNvPairs['PEER2_CONF'] = ifFreeform\n\n        \"\"\"\n        # how do we get the DESC and CONF for the peer?\n        vrfLiteIFCNvPairs['PEER2_DESC'] = \"\"\n        vrfLiteIFCNvPairs['PEER2_CONF'] = \"\"\n        \"\"\"\n\n        # create the IFC\n        Util.exe(PTIWrapper.createOrUpdate(ifcEntry[\"LINK_UUID\"], \"LINK\",\n            ifcEntry[\"entityName\"], \"\", 500, \"ext_fabric_setup\", vrfLiteIFCNvPairs))\n\ndef deviceUpgradeIntf(gVarDictObj, matchResult, interfacesRes, isValidVPC, device_overlay_vlans, vpcPairInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    topologyDataObj = gVarDictObj[\"topologyObj\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    switchInfo = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n    migrateMode = switchInfo[\"migrationMode\"]\n    fmtName = switchInfo[\"fmtName\"]\n    fabricName = FABRIC_NAME\n\n    allFabricInterfaces = topologyDataObj.get(TopologyInfoType.ALL_FABRIC_INTFS, devSerial)\n    Wrapper.print(\"%s: [%s] all Fabric intf %s\" % (funcName, fmtName, allFabricInterfaces))\n\n    linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, devSerial,  Helper.getNbrTypeInternal()))\n    # collect the FEX IDs info\n    fexList = {}\n    nvPairList = getTemplateMatchResults(matchResult, \"base_fex\")\n    if (nvPairList != None):\n        # build the FEX dictionary\n        for nvPair in nvPairList:\n            fexList[nvPair[\"FEX_ID\"]] = nvPair\n\n\n    vpcLinkMemberInterfaces = []\n    isVPC = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, devSerial))\n    vpcPairSerialKey = \"\"\n    if isVPC:\n        vpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, devSerial))\n        Wrapper.print(\"%s(): vPC: pair [%s]\" % (funcName, vpcPairSerialKey))\n        serials = vpcPairSerialKey.split(Helper.DELIMITER)\n        vpcSn = devSerial\n        vpcPeerSn = serials[1] if vpcSn == serials[0] else serials[0]\n        vpcLinkMemberInterfaces = topologyDataObj.get(TopologyInfoType.VPC_PEER_LINK_MEMBERS, vpcSn, vpcPeerSn)\n    Wrapper.print(\"%s: [%s] - vpc Link members [%s]\" % (funcName, fmtName, vpcLinkMemberInterfaces))\n\n    # special handling for breakout interfaces\n    templateName = \"breakout_interface\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        ptiSource = getSrc(templateName)\n        for nvPair in nvPairList:\n            Wrapper.print(\"Breakout: slot [%s], ports [%s]\" % (nvPair[\"SLOT\"], nvPair[\"PORT\"]))\n\n            # if the PORT is a range, then we need to unroll it into individual PTIs\n            ports = getIntegerRange(nvPair[\"PORT\"])\n\n            # create individual PTIs for each port\n            for port in ports:\n                # update the 'PORT' key value in the policy instance\n                nvPair[\"PORT\"] = str(port)\n                entityName = \"Ethernet\" + nvPair[\"SLOT\"] + \"/\" + nvPair[\"PORT\"]\n                createPTI(devSerial, nvPair, templateName, entityName, ptiSource, -1)\n\n    # process PO and vPC host ports\n    poInterfaces = {}\n\n    # gather the PO and vPC info in two passes\n    # pass 1: the main PO interfaces list\n    # pass 2: the corresponding members\n    for roundNum in range(1,3):\n        for intfName in sorted(interfacesRes.keys()):\n            # get the interface match results\n            intfMatchResult = interfacesRes[intfName]\n\n            # skip interfaces that have been processed\n            if isIntfProcessed(intfMatchResult):\n                continue\n\n            templateNameMatches = intfMatchResult[\"matched_templates\"]\n\n            if roundNum == 1:\n                # Pass 1 - gather the parent PO entries\n                if (intfName.lower().startswith(\"port-channel\")):\n                    isAccessPort = False\n                    isDot1qTunnel = False\n                    isFexPo = False\n                    if (\"fex_port_channel_interface\" in templateNameMatches):\n                        # this is a FEX PO\n                        isFexPo = True\n                    elif((\"access_interface\" in templateNameMatches) or \n                         (\"access_interface_fex\" in templateNameMatches) or \n                         (\"port_channel_access_interface\" in templateNameMatches) or\n                         (\"port_channel_dot1q_tunnel_interface\" in templateNameMatches) or\n                         (\"dot1q_tunnel_interface\" in templateNameMatches)):\n                        # treat dot1q tunnel port as access\n                        isAccessPort = True\n\n                        if ((\"port_channel_dot1q_tunnel_interface\" in templateNameMatches) or\n                            (\"dot1q_tunnel_interface\" in templateNameMatches)):\n                            isDot1qTunnel = True\n                    elif not (\"port_channel_trunk_interface_11_1\" in templateNameMatches):\n                        # not a normal PO we understand\n                        Wrapper.print(\"Incomplete policy match - PO [%s]\" % intfName)\n                        continue\n                    \n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n                    Wrapper.print(\"Switch [%s] : Found PO [%s] isFexPo [%r] isAccessPort [%r] isDot1qTunnel [%r] \" % (devSerial,\n                            intfName, isFexPo, isAccessPort, isDot1qTunnel))\n\n                    # record this PO, with the key as the PO id\n                    # extract the id\n                    portChannelIntf = intfName.lower()\n                    pc, pcid = portChannelIntf.split(\"port-channel\")\n\n                    poMtu = \"1500\"\n                    poSpeed = \"auto\"\n                    poAdminState = \"true\"\n                    poDesc = \"\"\n                    orphanPort = \"false\"\n                    bpduGuardState = \"no\"\n                    porttype_fast_enable = \"false\"\n                    porttype_fast_trunk = \"false\"\n                    vpcId = \"\"\n                    fexId = \"\"\n                    access_vlan = \"\"\n                    native_vlan = \"\"\n\n                    if (\"interface_mtu\" in templateNameMatches):\n                        poMtu = matchingNvPairs[\"interface_mtu\"][\"MTU\"]\n                    if (\"interface_speed\" in templateNameMatches):\n                        poSpeed = matchingNvPairs[\"interface_speed\"][\"SPEED\"]\n                    if isFexPo:\n                        fexId = matchingNvPairs[\"fex_port_channel_interface\"][\"FEX_ID\"]\n                    if (\"shut_interface\" in templateNameMatches):\n                        poAdminState = \"false\"\n                    if (\"interface_desc\" in templateNameMatches):\n                        poDesc = matchingNvPairs[\"interface_desc\"][\"DESC\"]\n                    if (\"interface_orphan_port\" in templateNameMatches):\n                        orphanPort = \"true\"\n                    if (\"bpduguard_enable\" in templateNameMatches):\n                        bpduGuardState = \"true\"\n                    if (\"bpduguard_disable\" in templateNameMatches):\n                        bpduGuardState = \"false\"\n                    if (\"porttype_fast_trunk\" in templateNameMatches):\n                        porttype_fast_trunk = \"true\"\n                    if (\"porttype_fast_enable\" in templateNameMatches):\n                        porttype_fast_enable = \"true\"\n                    if (\"port_channel_vpc_id_11_1\" in templateNameMatches):\n                        vpcId = matchingNvPairs[\"port_channel_vpc_id_11_1\"][\"VPC_ID\"]\n                        Wrapper.print(\"Found vpcId [%s]\" % vpcId)\n                    if (\"access_vlan\" in templateNameMatches and matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"] != 1):\n                        access_vlan = processAccessIntfOverlayInfo(devSerial, migrateMode, \n                            intfName, matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"],\n                            globalOverlayInfo, device_overlay_vlans)\n                    if (\"native_vlan\" in templateNameMatches):\n                        native_vlan = matchingNvPairs[\"native_vlan\"][\"NATIVE_VLAN\"]\n\n                    allowed_vlans = \"none\"\n                    allowed_vlan_orig = \"none\"\n                    if (\"port_channel_trunk_interface_11_1\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"port_channel_trunk_interface_11_1\"][\"ALLOWED_VLANS\"]\n                    elif (\"trunk_interface\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"trunk_interface\"][\"ALLOWED_VLANS\"]\n                    elif (\"trunk_interface_fex\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"trunk_interface_fex\"][\"ALLOWED_VLANS\"]\n\n                    if not isAccessPort:\n                        allowed_vlans = processTrunkIntfOverlayInfo(devSerial, migrateMode, intfName,\n                                    allowed_vlan_orig, globalOverlayInfo, device_overlay_vlans)\n                    unaccCfg = \"\"\n                    if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                        Wrapper.print(\"Device [%s]: Found unaccounted cfg for portchannel intf [%s]\" % (devSerial, intfName))\n                        unaccCfg = Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"]) \n\n                    templateList = [\n                                    \"bfd_interface_auth\",\n                                    \"bfd_no_echo_interface\", \n                                    \"ospf_p2p_interface\",\n                                    \"ospf_interface_auth\",\n                                    \"isis_p2p_inteface\",\n                                    \"isis_interface_auth\",\n                                    \"isis_interface_auth_no_lvl\",\n                                    \"vlan_interface_fwd_mode_11_1\",\n                                    \"interface_ipv6_11_1\",\n                                    \"interface_ipv6_tag_11_1\",\n                                    \"cdp_disable_interface_11_1\"\n                                   ]\n                    if isAccessPort:\n                        templateList.append(\"porttype_fast_trunk\")\n                    else:\n                        templateList.append(\"access_vlan\")\n                        templateList.append(\"porttype_fast_enable\")\n                    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n                    if unaccCfg and configList:\n                        unaccCfg = unaccCfg + Util.newLine() + Util.newLine().join(configList)\n                    elif configList:\n                        unaccCfg = Util.newLine().join(configList)\n\n                    poInterfaces.update({pcid : {\"name\" : intfName,\n                                                 \"mtu\" : poMtu,\n                                                 \"speed\" : poSpeed,\n                                                 \"vpcId\" : vpcId,\n                                                 \"poMode\" : \"active\",\n                                                 \"poDesc\" : poDesc,\n                                                 \"orphanPort\" : orphanPort,\n                                                 \"adminState\" : poAdminState,\n                                                 \"bpduguard\" : bpduGuardState,\n                                                 \"porttype_fast_enable\" : porttype_fast_enable,\n                                                 \"porttype_fast_trunk\" : porttype_fast_trunk,\n                                                 \"fexId\" : fexId,\n                                                 \"allowed_vlans\": allowed_vlans,\n                                                 \"access_vlan\": access_vlan,\n                                                 \"native_vlan\": native_vlan,\n                                                 \"access_port\": isAccessPort,\n                                                 \"dot1q_tunnel\" : isDot1qTunnel,\n                                                 \"members\" : [],\n                                                 \"poConf\" : unaccCfg\n                                                }\n                                            })\n                    Wrapper.print(\"Switch [%s] : Added entry for PO [%s] id [%s]\" % (devSerial, intfName, pcid))\n            else:\n                # Pass 2 - gather the PO/vPC member entries\n                if ((\"port_channel_mode_on\" in templateNameMatches) or\n                    (\"port_channel_mode\" in templateNameMatches)):\n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    # TODO: check if this a host vPC or regular PO based on the 'vpc' config\n                    templatesToCheck = [\"port_channel_mode_on\",\n                                        \"port_channel_mode\"\n                                       ]\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templatesToCheck)\n\n                    pcid = \"\"\n                    mode = \"\"\n                    for templateName in matchingNvPairs:\n                        if (\"port_channel_mode_on\" == templateName):\n                            # record the PO mode\n                            pcid = matchingNvPairs[templateName][\"PCID\"]\n                            mode = \"on\"\n                            break\n                        elif (\"port_channel_mode\" == templateName):\n                            # record the PO mode\n                            pcid = matchingNvPairs[templateName][\"PCID\"]\n                            mode = matchingNvPairs[templateName][\"PC_MODE\"]\n                            break\n\n                    Wrapper.print(\"Switch [%s] - Found PO member intf [%s] mode [%s] parent PO id [%s]\" %\n                        (devSerial, intfName, mode, pcid))\n                    # lookup the main PO dictionary object\n                    try:\n                        parentPo = poInterfaces[pcid]\n                        # update the PO mode\n                        parentPo[\"poMode\"] = mode\n                        # add this interface as a member\n                        parentPo[\"members\"].append(intfName)\n                    except:\n                        intfMatchResult.update({\"isProcessed\" : False})\n                        Wrapper.print(\"ERROR: Switch [%s] Did not find parent PO for intf [%s] id [%s]\" % \n                                                    (devSerial, intfName, pcid))\n                elif (\"fex_po_member_interface\" in templateNameMatches):\n                    Wrapper.print(\"Found FEX member [%s]\" % intfName)\n                    #Wrapper.print(str(templateNameMatches))\n\n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, [\"fex_po_member_interface\"])\n\n                    # lookup the main PO dictionary object\n                    pcid = matchingNvPairs[\"fex_po_member_interface\"][\"PCID\"]\n                    try:\n                        parentPo = poInterfaces[pcid]\n                        Wrapper.print(\"PO: [%s]. adding fex member [%s]\" % (pcid, intfName))\n\n                        # add this interface as a member\n                        parentPo[\"members\"].append(intfName)\n                    except:\n                        intfMatchResult.update({\"isProcessed\" : False})\n                        Wrapper.print(\"ERROR: Did not find parent FEX PO for intf [%s] id [%s]\" % \n                                                (intfName, pcid))\n\n    # create the host PO and VPCs\n    for pcid in poInterfaces:\n        poEntry = poInterfaces[pcid]\n        poName = poEntry[\"name\"]\n        vpcIntfName = \"vPC\" + poEntry[\"vpcId\"]\n\n        intfMatchResult = interfacesRes[poName]\n        if (poEntry[\"fexId\"] != \"\"):\n            if (poEntry[\"vpcId\"] != \"\"):\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: VPC_ID [%s] FEX_ID :[%s]\" % (FABRIC_NAME, key, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n\n                # check if we have the peer serial number\n                peerSerial = \"\"\n                try:\n                    peerSerial = vpcPairInfo[\"peerSerialNum\"]\n                    Wrapper.print(\"AAFEX: peer device [%s] is found for device[%s].\"%(peerSerial, devSerial))\n                except:\n                    Wrapper.print(\"AAFEX: peer serial # is empty. create PTIs to save vpc host info for later use\")\n                    \"\"\"\n                    memberIntfParams = {}\n                    for member in poEntry[\"members\"]:\n                        templatesToCheck = [\"interface_desc\"]\n                        matchingNvPairs = getIntfMatchNvPairs(matchResult, member, templatesToCheck)\n                        if \"interface_desc\" in matchingNvPairs:\n                            desc = matchingNvPairs[\"interface_desc\"][\"DESC\"]\n                        else:\n                            desc = \"\"\n                        if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                            Wrapper.print(\"AAFEX: Device [%s]: Found unaccounted cfg for aa fex po intf [%s]\" % (devSerial, member))\n                            unaccCfgMember = Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"])\n                        else:\n                            unaccCfgMember = \"\"\n                        memberIntfParams.update({member: {\"SN\": devSerial, \"DESC\": desc, \"CONF\": unaccCfgMember}}) \n                    \"\"\"\n\n                    nvPairs = {\"PO_ID\": poName,\n                               \"FEX_ID\" : poEntry[\"fexId\"],\n                               \"MTU\": Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                               \"PO_DESC\": poEntry[\"poDesc\"],\n                               \"ADMIN_STATE\": poEntry[\"adminState\"],\n                               \"DESC\": fexList[poEntry[\"fexId\"]][\"DESC\"],\n                               \"MEMBER_INTERFACES\": \",\".join(poEntry[\"members\"]),\n                               \"INTF_NAME\": vpcIntfName,\n                               \"PO_CONF\":poEntry[\"poConf\"]\n                              }\n                    templateList = [\n                                    \"access_vlan\", \n                                    \"porttype_fast_enable\",\n                                    \"porttype_fast_trunk\",\n                                    \"interface_ipv4_tag_11_1\"\n                                    ]\n                    configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n                    if nvPairs[\"PO_CONF\"] and configList:\n                        nvPairs[\"PO_CONF\"] = nvPairs[\"PO_CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                    elif configList:\n                        nvPairs[\"PO_CONF\"] = Util.newLine().join(configList)\n\n                    # create the vpc host PO trunk jython policy\n                    Wrapper.print(\"Creating standalone fex host PO [%s] vpc [%s] fexid [%s] policy\" % (poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                    createPTI(devSerial, nvPairs, \"int_aa_fex_standalone_11_1\", vpcIntfName, \"temp\", -1)\n                    #need to delete PTI if peer not found in the end\n                    continue\n\n                # vpc host case\n                Wrapper.print(\"AAFEX: Creating AA host PO [%s] vpc [%s] fexid [%s] policy\" %(poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                # we also need to get the vPC trunk host intf info of the peer\n                peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\",\n                                                          vpcIntfName, \"temp\",\n                                                          \"int_aa_fex_standalone_11_1\"))\n\n                peer_member_intfs = \"\"\n                peer_po_desc = \"\"\n                peer_po_conf = \"\"\n                peer_pcid = \"\"\n                peer_fex_desc = \"\"\n                peer_fex_id = \"\"\n                for peervPCpti in peerIntfvPCPTIs:\n                    peer_member_intfs = peervPCpti.getNvPairs()[\"MEMBER_INTERFACES\"]\n                    peer_fex_desc = peervPCpti.getNvPairs()[\"DESC\"]\n                    peer_fex_id =  peervPCpti.getNvPairs()[\"FEX_ID\"]\n                    peer_po_desc = peervPCpti.getNvPairs()[\"PO_DESC\"]\n                    peer_po_conf = peervPCpti.getNvPairs()[\"PO_CONF\"]\n                    discard, peer_pcid = peervPCpti.getNvPairs()[\"PO_ID\"].split(\"port-channel\")\n                    Wrapper.print(\"Deleting peer fex intf [%s] PTIs\" % peer_member_intfs)\n                    Wrapper.print(\"peer fex_desc:[%s], fex_id:[%s], po_desc:[%s], po_id:[%s]\" %\n                                  (peer_fex_desc, peer_fex_id, peer_po_desc, peer_pcid))\n                    Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n                    break\n\n                # get the vPC pair key with the internal serial1:serial2 format\n                vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n                Wrapper.print(\"AA Host PO: pair string [%s]\" % (vpcPairSerialKey))\n                serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n                nvPairs = {\"INTF_NAME\" : vpcIntfName,\n                           \"ADMIN_STATE\": poEntry[\"adminState\"],\n                           \"PEER1_PCID\": \"\",\n                           \"PEER2_PCID\": \"\",\n                           \"PEER1_MEMBER_INTERFACES\": \"\",\n                           \"PEER2_MEMBER_INTERFACES\": \"\",\n                           \"DESC\": \"\",\n                           \"PC_MODE\" : poEntry[\"poMode\"],\n                           \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"PEER1_PO_DESC\": \"\",\n                           \"PEER2_PO_DESC\": \"\",\n                           \"PEER1_PO_CONF\": \"\",\n                           \"PEER2_PO_CONF\": \"\",\n                           \"createVpc\" : \"true\",\n                           \"FEX_ID\" : \"\",\n                           \"FABRIC_NAME\" : FABRIC_NAME\n                          }\n\n                nvPairs[\"FEX_ID\"] = poEntry[\"fexId\"]\n                nvPairs[\"DESC\"] = fexList[poEntry[\"fexId\"]][\"DESC\"]\n                if (serials[0] == devSerial):\n                    nvPairs[\"PEER1_SN\"] = devSerial\n                    nvPairs[\"PEER1_PCID\"] = pcid\n                    nvPairs[\"PEER1_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                    nvPairs[\"PEER1_PO_DESC\"] = poEntry[\"poDesc\"]\n                    nvPairs[\"PEER1_PO_CONF\"] = poEntry[\"poConf\"]\n\n                    nvPairs[\"PEER2_SN\"] = peerSerial\n                    nvPairs[\"PEER2_PCID\"] = peer_pcid\n                    nvPairs[\"PEER2_MEMBER_INTERFACES\"] = peer_member_intfs\n                    nvPairs[\"PEER2_PO_DESC\"] = peer_po_desc\n                    nvPairs[\"PEER2_PO_CONF\"] = peer_po_conf\n\n                else:\n                    nvPairs[\"PEER1_SN\"] = peerSerial\n                    nvPairs[\"PEER1_PCID\"] = peer_pcid\n                    nvPairs[\"PEER1_MEMBER_INTERFACES\"] = peer_member_intfs\n                    nvPairs[\"PEER1_PO_DESC\"] = peer_po_desc\n                    nvPairs[\"PEER1_PO_CONF\"] = peer_po_conf\n\n                    nvPairs[\"PEER2_SN\"] = devSerial\n                    nvPairs[\"PEER2_PCID\"] = pcid\n                    nvPairs[\"PEER2_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                    nvPairs[\"PEER2_PO_DESC\"] = poEntry[\"poDesc\"]\n                    nvPairs[\"PEER2_PO_CONF\"] = poEntry[\"poConf\"]\n\n                Wrapper.print(\"SN:[%s] PEER_SN:[%s] - AA host nvPairs [%s]\"% (devSerial, peerSerial, nvPairs))\n\n                #Sanity to ensure valid AA fex config\n                if (nvPairs[\"PEER1_PCID\"] == \"\" or\n                    nvPairs[\"PEER2_PCID\"] == \"\" or\n                    nvPairs[\"FEX_ID\"] == \"\" ):\n                    Wrapper.print(\"Orphan AA!!! bail out\")\n                    \"\"\"\n                    respObj.setWarningRetCode()\n                    respObj.addWarnReport(getFabErrEntity(unaccountedConfigError.__name__, devSerial+ \":vpc \" +poEntry[\"vpcId\"]),\n                                  \"SN: [%s] FEX with vPC ID [%s] configuration is not correct !!! Either vPC po on Peer or FEX_ID [%s] is missing\"%\n                                  (devSerial, poEntry[\"vpcId\"], nvPairs[\"FEX_ID\"]))\n                    \"\"\"\n                    intfMatchResult.update({\"isProcessed\" : False})\n                    continue\n\n                key = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, peerSerial, vpcIntfName))\n                ignore, vpcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", devSerial, key, poEntry[\"vpcId\"]))\n                ignore, vpcRmId2 = Util.exeRM(RM.findRMDetails(FABRIC_NAME, \"VPC_ID\", key, peerSerial, poEntry[\"vpcId\"]))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s]: VPC_ID [%s] rmId [%s], peer rmId [%s]\" % (FABRIC_NAME, key, poEntry[\"vpcId\"], vpcRmId1, vpcRmId2))\n\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                ignore, pcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+pcid, pcid))\n                ignore, fexRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s] FEX_ID [%s] fexRmId [%s]\"\n                              % (FABRIC_NAME, key, pcid, \"port-channel\"+pcid, pcRmId1, poEntry[\"fexId\"], fexRmId1))\n\n                key = Util.exe(Helper.getKey(\"Device\", peerSerial))\n                ignore, pcRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+peer_pcid, peer_pcid))\n                ignore, fexRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                #Wrapper.print(\"FAB [%s] RM SET: Key [%s]: PORT_CHANNEL_ID [%s] rmId [%s] FEX_ID [%s] fexRmId [%s]\" % (FABRIC_NAME, key, peer_pcid, pcRmId2, poEntry[\"fexId\"], fexRmId2))\n\n                rmIds = [vpcRmId1] + [vpcRmId2] + [fexRmId1] + [fexRmId2]+ [pcRmId1] + [pcRmId2]\n\n                # create the AA fex vpc host PO trunk jython policy\n                Wrapper.print(\"Creating AA FEX vpc host PO [%s] vpc [%s] fexid [%s] policy\" % (poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                createPTI(vpcPairSerialKey, nvPairs, \"int_port_channel_aa_fex\", vpcIntfName,\n                          getSrc(\"int_port_channel_aa_fex\"), rmIds)\n\n                sn1 = sn2 = memberIntfsPeer1 = memberIntfsPeer2 =  poPCIdPeer1 = poPCIdPeer2 = \"\"\n                if nvPairs[\"PEER1_SN\"] == devSerial:\n                    sn1 = devSerial\n                    sn2 = peerSerial\n                    memberIntfsPeer1 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                    memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                    memberIntfsPeer2 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                    memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                    poPCIdPeer1 = nvPairs[\"PEER1_PCID\"]\n                    poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n                elif nvPairs[\"PEER2_SN\"] == devSerial:\n                    sn1 = devSerial\n                    sn2 = peerSerial\n                    memberIntfsPeer1 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                    memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                    memberIntfsPeer2 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                    memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                    poPCIdPeer1 = nvPairs[\"PEER2_PCID\"]\n                    poPCIdPeer2 = nvPairs[\"PEER1_PCID\"]\n                ptiTemplate = \"int_fex_po_member_11_1\"\n                peerMatchResult, peerInterfacesRes = getSwitchMatchResults(peerSerial)\n                poMemberDescAndFFUpd(sn1, memberIntfsPeer1List, ptiTemplate, \n                                     poPCIdPeer1, matchResult, interfacesRes, vpcIntfName)\n                poMemberDescAndFFUpd(sn2, memberIntfsPeer2List, ptiTemplate,\n                                     poPCIdPeer2, peerMatchResult, peerInterfacesRes, vpcIntfName)\n            else:\n                # standalone fex\n                nvPairs = {\"PO_ID\" : poName,\n                           \"FEX_ID\" : poEntry[\"fexId\"],\n                           \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"PO_DESC\" : poEntry[\"poDesc\"],\n                           \"ADMIN_STATE\" : poEntry[\"adminState\"],\n                           \"DESC\" : fexList[poEntry[\"fexId\"]][\"DESC\"],\n                           \"CONF\" : poEntry[\"poConf\"],\n                           \"MEMBER_INTERFACES\" : \",\".join(poEntry[\"members\"]),\n                           \"FABRIC_NAME\" : FABRIC_NAME\n                          }\n\n                templateList = [\n                                \"access_vlan\", \n                                \"porttype_fast_enable\",\n                                \"porttype_fast_trunk\",\n                                \"interface_ipv4_tag_11_1\"\n                               ]\n                configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n                if nvPairs[\"CONF\"] and configList:\n                    nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                elif configList:\n                    nvPairs[\"CONF\"] = Util.newLine().join(configList)\n\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]: FEX_ID [%s]\" % (FABRIC_NAME, key, pcid, poEntry[\"fexId\"]))\n                ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n                ignore, fexRmId = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                rmIds = [pcRmId] + [fexRmId]\n                # create the FEX PO policy\n                Wrapper.print(\"Creating FEX [%s] policy\" % poName)\n                createPTI(devSerial, nvPairs, \"int_port_channel_fex\", poName, \"\", rmIds)\n\n                memberIntfs = nvPairs.get(\"MEMBER_INTERFACES\")\n                memberIntfsList = memberIntfs.split(\",\") if memberIntfs else []\n                ignore, poPCId = poName.split(\"port-channel\")\n                ptiTemplate = \"int_fex_po_member_11_1\"\n                poMemberDescAndFFUpd(devSerial, memberIntfsList, ptiTemplate, \n                                     poPCId, matchResult, interfacesRes, poName)\n        elif (poEntry[\"vpcId\"] != \"\"):\n\n            # check if we have the peer serial number\n            peerSerial = \"\"\n            try:\n                peerSerial = vpcPairInfo[\"peerSerialNum\"]\n            except:\n                Wrapper.print(\"vPC: peer serial # is empty. create PTIs to save vpc host info for later use\")\n                nvPairs = {\"INTF_NAME\": vpcIntfName,\n                           \"ADMIN_STATE\": poEntry[\"adminState\"],\n                           \"PEER1_MEMBER_INTERFACES\": \"\" if (len(poEntry[\"members\"]) == 0) else (\",\".join(poEntry[\"members\"])),\n                           \"PC_MODE\": poEntry[\"poMode\"],\n                           \"BPDUGUARD_ENABLED\": poEntry[\"bpduguard\"],\n                           \"MTU\": Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"SPEED\": Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]),\n                           \"PO_ID\": poName,\n                           \"PO_DESC\": poEntry[\"poDesc\"],\n                           \"PO_CONF\":poEntry[\"poConf\"],\n                           \"ALLOWED_VLANS\" : poEntry[\"allowed_vlans\"],\n                           \"ACCESS_VLAN\" : poEntry[\"access_vlan\"],\n                           \"NATIVE_VLAN\" : poEntry[\"native_vlan\"],\n                           \"createVpc\": \"true\"\n                           }\n                # create the vpc host PO trunk jython policy\n                Wrapper.print(\"Creating standalone vpc host PO [%s] vpc [%s] policy\" % (poName, poEntry[\"vpcId\"]))\n                if poEntry[\"access_port\"]:\n                    templateName = \"int_vpc_access_host_standalone_11_1\"\n                else:\n                    nvPairs[\"NATIVE_VLAN\"] = poEntry[\"native_vlan\"] if poEntry[\"native_vlan\"] != \"\" else \"1\"\n                    templateName = \"int_vpc_trunk_host_standalone_11_1\"\n                createPTI(devSerial, nvPairs, templateName, vpcIntfName, \"temp\", -1)\n                #need to delete PTI if peer not found in the end\n                continue\n\n            # vpc host case\n            Wrapper.print(\"Switch [%s] : vPC: Creating vpc host PO [%s] vpc [%s] policy\" % (devSerial, poName, poEntry[\"vpcId\"]))\n            # we also need to get the vPC host intf info of the peer\n            if poEntry[\"access_port\"]:\n                templateName = \"int_vpc_access_host_standalone_11_1\"\n            else:\n                templateName = \"int_vpc_trunk_host_standalone_11_1\"\n            peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\", vpcIntfName, \"temp\", templateName))\n\n            peer_member_intfs = \"\"\n            peer_po_desc = \"\"\n            peer_po_conf = \"\"\n            peer_pcid = \"\"\n            peer_po_mtu = \"\"\n            peer_po_speed = \"Auto\"\n            peer_allowed_vlan = \"all\"\n            peer_access_vlan = \"\"\n            peer_native_vlan = \"\"\n            po_mode = poEntry[\"poMode\"]\n            for peervPCpti in peerIntfvPCPTIs:\n                peerNvPairs = peervPCpti.getNvPairs()\n                peer_member_intfs = peerNvPairs[\"PEER1_MEMBER_INTERFACES\"]\n                if len(peer_member_intfs) > 0:\n                    # the po mode must be valid on the peer.. use that\n                    po_mode = peerNvPairs[\"PC_MODE\"]\n                peer_po_desc = peerNvPairs[\"PO_DESC\"]\n                peer_po_conf = peerNvPairs[\"PO_CONF\"]\n                peer_po_mtu = peerNvPairs[\"MTU\"]\n                peer_po_speed = peerNvPairs[\"SPEED\"]\n                discard, peer_pcid = peerNvPairs[\"PO_ID\"].split(\"port-channel\")\n                peer_allowed_vlan = peerNvPairs[\"ALLOWED_VLANS\"]\n                peer_access_vlan = peerNvPairs[\"ACCESS_VLAN\"]\n                peer_native_vlan = peerNvPairs[\"NATIVE_VLAN\"]\n                Wrapper.print(\"Deleting peer vpc intf [%s] PTIs\" % peer_member_intfs)\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n                break\n\n            # get the vPC pair key with the internal serial1:serial2 format\n            vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n            Wrapper.print(\"vPC Host PO: pair string [%s]\" % (vpcPairSerialKey))\n            serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n            # Check the vPC port-channel speed config between the vPC peers.\n            # If not the same, add the speed config to the interface freeform and let users fix the config.\n            # Set the SPEED param to \"Auto\" so that no interface_speed policy will be created for the po.\n            addSpeedConfig = []\n            peerAddSpeedConfig = []\n            if Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]) == peer_po_speed:\n                vpcSpeed = peer_po_speed\n            else:\n                vpcSpeed = \"Auto\"\n                if poEntry[\"speed\"] != \"auto\":\n                    addSpeedConfig.append(\"%sspeed %s\" %(INTF_FIRST_LVL_SPACING, poEntry[\"speed\"]))\n                if peer_po_speed != \"Auto\":\n                    peerAddSpeedConfig.append(\"%sspeed %s\" %(INTF_FIRST_LVL_SPACING, Util.mapEnumToSwitchSpeed(peer_po_speed)))\n            \n            nvPairs = {\"INTF_NAME\" : vpcIntfName,\n                       \"ENABLE_MIRROR_CONFIG\": \"false\",\n                       \"ADMIN_STATE\": poEntry[\"adminState\"],\n                       \"PEER1_PCID\": \"\",\n                       \"PEER2_PCID\": \"\",\n                       \"PEER1_MEMBER_INTERFACES\": \"\",\n                       \"PEER2_MEMBER_INTERFACES\": \"\",\n                       \"PEER1_PO_DESC\": \"\",\n                       \"PEER2_PO_DESC\": \"\",\n                       \"PEER1_PO_CONF\": \"\",\n                       \"PEER2_PO_CONF\": \"\",\n                       \"PC_MODE\" : po_mode,\n                       \"BPDUGUARD_ENABLED\": poEntry[\"bpduguard\"],\n                       \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                       \"SPEED\": vpcSpeed,\n                       \"createVpc\" : \"true\"\n                      }\n\n            if (serials[0] == devSerial):\n                nvPairs[\"PEER1_SN\"] = devSerial\n                nvPairs[\"PEER1_PCID\"] = pcid\n                nvPairs[\"PEER1_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                nvPairs[\"PEER1_PO_DESC\"] = poEntry[\"poDesc\"]\n                nvPairs[\"PEER1_ALLOWED_VLANS\"] = poEntry[\"allowed_vlans\"]\n                nvPairs[\"PEER1_ACCESS_VLAN\"] = poEntry[\"access_vlan\"]\n                nvPairs[\"PEER1_NATIVE_VLAN\"] = \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"]\n                nvPairs[\"PEER1_PO_CONF\"] = poEntry[\"poConf\"] \n                if addSpeedConfig:\n                    nvPairs[\"PEER1_PO_CONF\"] = nvPairs[\"PEER1_PO_CONF\"] + Util.newLine() + Util.newLine().join(addSpeedConfig)\n\n                nvPairs[\"PEER2_SN\"] = peerSerial\n                nvPairs[\"PEER2_PCID\"] = peer_pcid\n                nvPairs[\"PEER2_MEMBER_INTERFACES\"] = peer_member_intfs\n                nvPairs[\"PEER2_PO_DESC\"] = peer_po_desc\n                nvPairs[\"PEER2_ALLOWED_VLANS\"] = peer_allowed_vlan\n                nvPairs[\"PEER2_ACCESS_VLAN\"] = peer_access_vlan\n                nvPairs[\"PEER2_NATIVE_VLAN\"] = \"\" if peer_native_vlan == \"1\" else peer_native_vlan\n                nvPairs[\"PEER2_PO_CONF\"] = peer_po_conf\n                if peerAddSpeedConfig:\n                    nvPairs[\"PEER2_PO_CONF\"] = nvPairs[\"PEER2_PO_CONF\"] + Util.newLine() + Util.newLine().join(peerAddSpeedConfig)\n            else:\n                nvPairs[\"PEER1_SN\"] = peerSerial\n                nvPairs[\"PEER1_PCID\"] = peer_pcid\n                nvPairs[\"PEER1_MEMBER_INTERFACES\"] = peer_member_intfs\n                nvPairs[\"PEER1_PO_DESC\"] = peer_po_desc\n                nvPairs[\"PEER1_ALLOWED_VLANS\"] = peer_allowed_vlan\n                nvPairs[\"PEER1_ACCESS_VLAN\"] = peer_access_vlan\n                nvPairs[\"PEER1_NATIVE_VLAN\"] = \"\" if peer_native_vlan == \"1\" else peer_native_vlan\n                nvPairs[\"PEER1_PO_CONF\"] = peer_po_conf\n                if peerAddSpeedConfig:\n                    nvPairs[\"PEER1_PO_CONF\"] = nvPairs[\"PEER1_PO_CONF\"] + Util.newLine() + Util.newLine().join(peerAddSpeedConfig)\n\n                nvPairs[\"PEER2_SN\"] = devSerial\n                nvPairs[\"PEER2_PCID\"] = pcid\n                nvPairs[\"PEER2_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                nvPairs[\"PEER2_PO_DESC\"] = poEntry[\"poDesc\"]\n                nvPairs[\"PEER2_ALLOWED_VLANS\"] = poEntry[\"allowed_vlans\"]\n                nvPairs[\"PEER2_ACCESS_VLAN\"] = poEntry[\"access_vlan\"]\n                nvPairs[\"PEER2_NATIVE_VLAN\"] = \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"]\n                nvPairs[\"PEER2_PO_CONF\"] = poEntry[\"poConf\"] \n                if addSpeedConfig:\n                    nvPairs[\"PEER2_PO_CONF\"] = nvPairs[\"PEER2_PO_CONF\"] + Util.newLine() + Util.newLine().join(addSpeedConfig)\n            Wrapper.print(\"SN:[%s] PEER_SN:[%s] - vPC host nvPairs [%s]\"% (devSerial, peerSerial, nvPairs))\n\n            #Sanity to ensure valid vPC host config\n            if (nvPairs[\"PEER1_PCID\"] == \"\" or\n                nvPairs[\"PEER2_PCID\"] == \"\" ):\n                Wrapper.print(\"Orphan vPC host!!! bail out\")\n                \"\"\"\n                respObj.setWarningRetCode()\n                respObj.addWarnReport(getFabErrEntity(unaccountedConfigError.__name__, devSerial+ \":vpc \" +poEntry[\"vpcId\"]),\n                                      \"SN: [%s] vpc [%s] configuration is not correct !!! peer vpc po is missing\"%\n                                      (devSerial, poEntry[\"vpcId\"]))\n                \"\"\"\n                intfMatchResult.update({\"isProcessed\" : False})\n                continue\n\n            entityName = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, peerSerial, vpcIntfName))\n            ignore, vpcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", devSerial, entityName, poEntry[\"vpcId\"]))\n            ignore, vpcRmId2 = Util.exeRM(RM.findRMDetails(FABRIC_NAME, \"VPC_ID\", entityName, peerSerial, poEntry[\"vpcId\"]))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s]: VPC_ID [%s] rmId [%s] peer rmId [%s]\" % (FABRIC_NAME, entityName, poEntry[\"vpcId\"], vpcRmId1, vpcRmId2))\n\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            ignore, pcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s]\" % (FABRIC_NAME, key, pcid, poName, pcRmId1))\n\n            key = Util.exe(Helper.getKey(\"Device\", peerSerial))\n            ignore, pcRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+peer_pcid, peer_pcid))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s]\" % (FABRIC_NAME, key, pcid, \"port-channel\"+peer_pcid, pcRmId2))\n\n            rmIds = [vpcRmId1] + [vpcRmId2] + [pcRmId1] + [pcRmId2]\n            \n            # create the vpc host PO trunk jython policy\n            #Wrapper.print(\"Creating vpc host PO [%s] vpc [%s] policy\" % (poName, poEntry[\"vpcId\"]))\n            if poEntry[\"access_port\"]:\n                if poEntry[\"dot1q_tunnel\"]:\n                    templateName = \"int_vpc_dot1q_tunnel\"\n                    ptiTemplate = \"int_vpc_dot1q_tunnel_po_member_11_1\"\n                else:\n                    templateName = \"int_vpc_access_host\"\n                    ptiTemplate = \"int_vpc_access_po_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_enable\"]\n            else:\n                templateName = \"int_vpc_trunk_host\"\n                ptiTemplate = \"int_vpc_trunk_po_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_trunk\"]\n            \n            createPTI(vpcPairSerialKey, nvPairs, templateName, vpcIntfName, getSrc(templateName), rmIds)\n\n            sn1 = sn2 = memberIntfsPeer1 = memberIntfsPeer2 =  poPCIdPeer1 = poPCIdPeer2 = \"\"\n            if nvPairs[\"PEER1_SN\"] == devSerial:\n                sn1 = devSerial\n                sn2 = peerSerial\n                memberIntfsPeer1 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                memberIntfsPeer2 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                poPCIdPeer1 = nvPairs[\"PEER1_PCID\"]\n                poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n            elif nvPairs[\"PEER2_SN\"] == devSerial:\n                sn1 = devSerial\n                sn2 = peerSerial\n                memberIntfsPeer1 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                memberIntfsPeer2 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n                poPCIdPeer2 = nvPairs[\"PEER1_PCID\"]\n            \n            peerMatchResult, peerInterfacesRes = getSwitchMatchResults(peerSerial)\n            poMemberDescAndFFUpd(sn1, memberIntfsPeer1List, ptiTemplate, \n                                 poPCIdPeer1, matchResult, interfacesRes, vpcIntfName)\n            poMemberDescAndFFUpd(sn2, memberIntfsPeer2List, ptiTemplate, \n                                 poPCIdPeer2, peerMatchResult, peerInterfacesRes, vpcIntfName)\n        else:\n            # regular PO case\n            nvPairs = {\"PO_ID\" : poName, \"PC_MODE\" : poEntry[\"poMode\"],\n                       \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                       \"SPEED\": Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]),\n                       \"DESC\" : poEntry[\"poDesc\"],\n                       \"ENABLE_ORPHAN_PORT\" : poEntry[\"orphanPort\"],\n                       \"ADMIN_STATE\" : poEntry[\"adminState\"],\n                       \"BPDUGUARD_ENABLED\" : poEntry[\"bpduguard\"],\n                       \"ALLOWED_VLANS\" : poEntry[\"allowed_vlans\"],\n                       \"PORTTYPE_FAST_ENABLED\": poEntry[\"porttype_fast_enable\"],\n                       \"ACCESS_VLAN\" : poEntry[\"access_vlan\"],\n                       \"NATIVE_VLAN\" : \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"],\n                       \"CONF\" : poEntry[\"poConf\"],\n                       \"MEMBER_INTERFACES\" : \",\".join(poEntry[\"members\"])\n                      }\n\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]\" % (FABRIC_NAME, key, pcid))\n            ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]: rmId [%s]\" % (FABRIC_NAME, key, pcid, pcRmId))\n\n            # create the host PO trunk jython policy\n            Wrapper.print(\"Creating PO [%s] policy\" % poName)\n            templateList = [\n                            \"interface_ipv4_tag_11_1\",\n                           ]\n            if poEntry[\"access_port\"]:\n                templateList.append(\"porttype_fast_trunk\")\n                if poEntry[\"dot1q_tunnel\"]:\n                    templateName = \"int_port_channel_dot1q_tunnel_host\"\n                    ptiTemplate = \"int_port_channel_dot1q_tunnel_member_11_1\"\n                else:\n                    templateName = \"int_port_channel_access_host\"\n                    ptiTemplate = \"int_port_channel_access_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_enable\"]\n            else:\n                templateList.append(\"access_vlan\") \n                templateList.append(\"porttype_fast_enable\")\n                templateName = \"int_port_channel_trunk_host\"\n                ptiTemplate = \"int_port_channel_trunk_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_trunk\"]\n                \n            configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n            Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"%(devSerial, poName, nvPairs.get(\"CONF\")))\n            createPTI(devSerial, nvPairs, templateName, poName, getSrc(templateName), pcRmId)\n\n            memberIntfs = nvPairs.get(\"MEMBER_INTERFACES\")\n            memberIntfsList = memberIntfs.split(\",\") if memberIntfs else []\n            ignore, poPCId = poName.split(\"port-channel\")\n            poMemberDescAndFFUpd(devSerial, memberIntfsList, ptiTemplate, \n                                 poPCId, matchResult, interfacesRes, poName)\n    # delete dangling standalone vpc PTI.\n    peerSerial = \"\"\n    try:\n        peerSerial = vpcPairInfo[\"peerSerialNum\"]\n    except:\n        pass\n    if peerSerial:\n        peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"temp\"))\n        for peervPCpti in peerIntfvPCPTIs:\n            vpcIntf = peervPCpti.getEntityName()\n            Wrapper.print(\"Standalone AA/vPC host policy found with %s\"%(vpcIntf))\n            if vpcIntf:\n                ptiListPeer1 = Util.exe(PTIWrapper.get(devSerial, \"INTERFACE\", vpcIntf))\n                ptiListPeer2 = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\", vpcIntf))\n                po1 = ptiListPeer1[0].nvPairs.get(\"PO_ID\") if ptiListPeer1 else \"\"\n                po2 = ptiListPeer2[0].nvPairs.get(\"PO_ID\") if ptiListPeer2 else \"\"\n                Wrapper.print(\"vpc [%s] with po1 [%s] and po2 [%s]\"%(vpcIntf, po1, po2))\n                if not ptiListPeer1 or not ptiListPeer2:\n                    errorEntity = getFabErrEntity(funcName, devSerial+ \":vpc \" + peerSerial)\n                    Wrapper.print(\"vpcPair %s:%s - doesn't have proper vpc id %s or port-channel configuration \"\n                                  \"for interface %s,%s \"%(devSerial, peerSerial, vpcIntf.strip(\"vPC\"), po1, po2))\n                    #respObj.setWarningRetCode()\n                    #respObj.addWarnReport(errorEntity, \"vpcPair %s:%s - doesn't have proper vpc id %s or port-channel configuration \"\n            if peervPCpti.getTemplateName() == \"int_aa_fex_standalone_11_1\":\n                Wrapper.print(\"deleting AA standalone host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n            if peervPCpti.getTemplateName() == \"int_vpc_trunk_host_standalone_11_1\":\n                Wrapper.print(\"deleting vPC standalone trunk host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n            if peervPCpti.getTemplateName() == \"int_vpc_access_host_standalone_11_1\":\n                Wrapper.print(\"deleting vPC standalone access host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n    bidirConfigInSwitch = False\n    nvPairList = getTemplateMatchResults(matchResult, \"base_pim_bidir_11_1\")\n    if (nvPairList != None):\n        bidirConfigInSwitch = True\n\n    # process rest of the interfaces\n    for intfName in sorted(interfacesRes.keys()):\n        lowerIntfName = intfName.lower()\n        intfMatchResult = interfacesRes[intfName]\n        Wrapper.print(\"Processing intf [%s]. Processed = %r\" % \n                      (intfName, isIntfProcessed(intfMatchResult)))\n\n        if isIntfProcessed(intfMatchResult):\n            continue\n\n        templateNameMatches = intfMatchResult[\"matched_templates\"]\n        # remove some mutually exclusive matches\n        if (\"trunk_interface\" in templateNameMatches):\n            if (\"trunk_interface_fex\" in templateNameMatches):\n                # we will delete this since it is redundant\n                templateNameMatches.remove(\"trunk_interface\")\n\n        #Wrapper.print(\"%s(): Matched templates [%s]\"%(funcName, templateNameMatches))\n        matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n        if ((intfName in allFabricInterfaces) and (intfName not in vpcLinkMemberInterfaces)):\n            # processs the fabric interfaces\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is fabric interface, marked as processed at line [%s]\"%(intfName,\n                sys._getframe().f_lineno))\n\n            # check if any of these are PO members, then capture them as int_routed_host\n            if (('port_channel_mode' in templateNameMatches) or \n                ('port_channel_mode_on' in templateNameMatches)):\n                # include the po member inherited configs to avoid CC flagging them as diffs since it does\n                # not find the expected parent PO policy\n                createRoutedIntf(switchInfo, intfName, matchingNvPairs, True)\n                continue\n\n            nvPairs = getFabricIntfNvPairs(FABRIC_NAME, devSerial, intfName, matchingNvPairs, \n                                           LINK_STATE_ROUTING, REPLICATION_MODE, \n                                           intfMatchResult, matchResult, False)\n            nvPairs[\"IS_COMPLETE\"] = \"false\"\n            nvPairs[\"RMID_LIST\"] = \"\"\n            # check to see if the peer device is in the topology and get its details\n            peerIntf, peerSerialNum = getPoPeerDeviceSN(topologyDataObj, devSerial, intfName)\n            dictObj = {}\n            dictObj[\"FABRIC_NAME\"] = FABRIC_NAME\n            dictObj[\"FABRIC_INTERFACE\"] = FABRIC_NAME\n            dictObj[\"localSerialNum\"] = devSerial\n            dictObj[\"localNvPairs\"] = nvPairs\n            dictObj[\"localIntfName\"] = intfName\n            dictObj[\"peerSerialNum\"] = peerSerialNum\n            dictObj[\"peerIntfName\"] = peerIntf\n            dictObj[\"localHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, devSerial)\n            dictObj[\"peerHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, peerSerialNum)\n            dictObj[\"linkNbrList\"] = linkNbrList\n            Util.exe(manageFabricIntf(dictObj))\n            continue\n\n        ptiSource = \"UNDERLAY\"\n        if (lowerIntfName.startswith(\"vlan\")):\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n            # do not process any SVIs.. they are either overlays or local and are already captured in the freeforms\n            continue\n        elif (intfName.startswith(\"mgmt\")):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getMgmtIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n            PTIWrapper.createOrUpdate(devSerial, \"INTERFACE\", intfName, \"\", ConfigPriority.INTF_MGMT,\n                                \"int_mgmt\", nvPairs)\n            continue\n        elif (\"nve_interface\" in templateNameMatches or \"nve_anycast_interface\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getNveIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n            Wrapper.print(\"Creating NVE interface [%s] policy\" % intfName)\n            createPTI(devSerial, nvPairs, \"int_nve\", intfName, getSrc(\"int_nve\"), -1)\n            continue\n        elif ((\"p2p_routed_interface\" in templateNameMatches or \"interface_ipv6_11_1\" in templateNameMatches) and\n              (intfName in vpcLinkMemberInterfaces)):\n            # this is a vpc peer keep alive interface\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is vpc peer keep alive interface, marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getFabricIntfNvPairs(FABRIC_NAME, devSerial, intfName, matchingNvPairs, \n                                           LINK_STATE_ROUTING, REPLICATION_MODE, \n                                           intfMatchResult, matchResult, True)\n            nvPairs[\"IS_COMPLETE\"] = \"false\"\n            nvPairs[\"RMID_LIST\"] = \"\"\n            # check to see if the peer device is in the topology and get its details\n            peerIntf, peerSerialNum = getPoPeerDeviceSN(topologyDataObj, devSerial, intfName)\n            dictObj = {}\n            dictObj[\"FABRIC_NAME\"] = FABRIC_NAME\n            dictObj[\"FABRIC_INTERFACE\"] = FABRIC_NAME\n            dictObj[\"localSerialNum\"] = devSerial\n            dictObj[\"localIntfName\"] = intfName\n            dictObj[\"peerSerialNum\"] = peerSerialNum\n            dictObj[\"peerIntfName\"] = peerIntf\n            dictObj[\"localHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, devSerial)\n            dictObj[\"peerHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, peerSerialNum)\n            dictObj[\"linkNbrList\"] = linkNbrList\n\n            templateList = [\n                        \"bfd_interface_auth\",\n                        \"bfd_no_echo_interface\", \n                        \"ospf_interface_11_1\",\n                        \"v6_ospf_interface\",\n                        \"ospf_p2p_interface\",\n                        \"ospf_interface_auth\",\n                        \"pim_interface_hello_auth\",\n                        \"isis_p2p_interface\",\n                        \"isis_interface_auth\",\n                        \"isis_interface_auth_no_lvl\",\n                        \"pim_interface\",\n                        \"isis_interface\",\n                        \"v6_isis_interface\",\n                        \"bpduguard_disable\", \n                        \"bpduguard_enable\", \n                        \"interface_speed\",\n                        \"interface_no_nego_auto\",\n                        \"porttype_fast_enable\",\n                        \"porttype_fast_trunk\",\n                        \"vlan_interface_fwd_mode_11_1\",\n                        \"interface_ipv4_tag_11_1\",\n                        \"interface_ipv6_tag_11_1\",\n                        \"cdp_disable_interface_11_1\",\n                        \"routed_interface_no_ip_redirects\"\n                        ]\n            configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n\n            dictObj[\"localNvPairs\"] = nvPairs\n            Util.exe(manageVPCPKAIntf(dictObj))\n            continue\n        elif (intfName.startswith(\"loopback\")):\n            # this is a loopback port\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # get the id\n            loopbackId = intfName[8:]\n            #Wrapper.print(\"Found loopback ID: [%s]\" % loopbackId)\n\n            localIp = loopbackIp = \"\"\n            for templateName in matchingNvPairs:\n                if (\"loopback_interface\" == templateName or\n                    \"loopback_interface_with_tag\" == templateName):\n                    loopbackIp = matchingNvPairs[templateName][\"IP\"]\n                    break\n               \n            if vpcPairInfo.get(\"vpcFabricPair\"):\n                localIp = vpcPairInfo.get(\"SRC_LB_IP\")\n\n            if localIp and localIp == loopbackIp:\n                if lowerIntfName == getLbIntfName(\"nve\") or lowerIntfName == getLbIntfName(\"rp\"):\n                    errorMsg = (\"Interface %s, Ip %s should not same vPC virtual peer link source ip !!!. \"\n                                \"RP or NVE loopback should not be used with vpc virtual peer link configuration.\"%\n                                (lowerIntfName, loopbackIp))\n                    respObj.addErrorReport((funcName+lowerIntfName+\":\"+loopbackIp), errorMsg, devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n                if lowerIntfName != getLbIntfName(\"bgp\"):\n                    vpcPairInfo.update({\"virtualVPCLoopback\":loopbackId})\n\n            if (lowerIntfName != getLbIntfName(\"bgp\") and\n                lowerIntfName != getLbIntfName(\"nve\") and\n                lowerIntfName != getLbIntfName(\"anycast\") and\n                lowerIntfName != getLbIntfName(\"rp\") and \n                not vpcPairInfo.get(\"virtualVPCLoopback\")):\n\n                if not handleServiceLoopback(FABRIC_NAME, devSerial, intfName, loopbackId, matchingNvPairs, globalOverlayInfo):\n                    # not a service related loopback\n                    setRmResource = True\n                    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n                    for cfg in intfMatchResult[\"show_run_cmds\"]:\n                        lowerStr = cfg.lower()\n                        if (lowerStr.strip().startswith(\"vrf member \")):\n                            setRmResource = False\n                            Wrapper.print(\"FAB [%s]: Skip setting RM ID for intfName [%s]\" % (FABRIC_NAME, intfName))\n                            break\n\n                    rmId = -1\n                    if setRmResource:\n                        key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                        ignore, rmId = Util.exeRM(RM.set(FABRIC_NAME, \"LOOPBACK_ID\", key, intfName, loopbackId))\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s] rmId [%s]\" %\n                                      (FABRIC_NAME, key, loopbackId, intfName, rmId))\n                    createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME, rmId)\n                continue\n\n            nvPairs = {\"INTF_NAME\" : intfName,\n                       \"IP\" : \"\",\n                       \"SECONDARY_IP\" : \"\",\n                       \"V6IP\" : \"\",\n                       \"DESC\" : \"\",\n                       \"REPLICATION_MODE\" : REPLICATION_MODE,\n                       \"LINK_STATE_ROUTING_TAG\" : LINK_STATE_ROUTING_TAG,\n                       \"ROUTE_MAP_TAG\" : \"\",\n                       \"FABRIC_NAME\" : FABRIC_NAME,\n                       \"ADMIN_STATE\" : \"true\",\n                       \"CONF\" :\"\"\n                      }\n\n            if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                nvPairs.update({\"CONF\": Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"])})\n            templateList = [\n                            \"access_vlan\", \n                            \"bpduguard_disable\", \n                            \"bpduguard_enable\", \n                            \"interface_speed\",\n                            \"ospf_p2p_interface\",\n                            \"ospf_interface_auth\",\n                            \"pim_interface_hello_auth\",\n                            \"isis_p2p_interface\",\n                            \"isis_interface_auth\",\n                            \"isis_interface_auth_no_lvl\",\n                            \"porttype_fast_enable\",\n                            \"porttype_fast_trunk\",\n                            \"vlan_interface_fwd_mode_11_1\",\n                            \"cdp_disable_interface_11_1\"\n                            ]\n\n            if UNDERLAY_IS_V6 == \"false\":\n                # Underlay is V4, treat ipv6 address config as unaccounted\n                templateList.append(\"interface_ipv6_11_1\")\n            else:\n                # Underlay is V6, treat ip address config as unaccounted\n                templateList.append(\"interface_ipv4_11_1\")\n\n            configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n            Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"%(devSerial, intfName, nvPairs.get(\"CONF\")))\n\n            for templateName in matchingNvPairs:\n                if (\"loopback_interface\" == templateName or \n                    \"loopback_interface_with_tag\" == templateName):\n                    nvPairs.update({\"IP\" : matchingNvPairs[templateName][\"IP\"]})\n\n                    nvPair = matchingNvPairs[templateName]\n\n                    # record resources in RM\n                    key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s]\" %\n                                  (FABRIC_NAME, key, loopbackId, intfName))\n                    #Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK_ID\", key, intfName, loopbackId))\n\n                    # set the loopback IP resource\n                    loopbackIP = nvPair[\"IP\"]\n                    Wrapper.print(\"loopback IP [%s] from nvPair and loopback IP [%s] from matchnvPair\"%\n                                  (loopbackIP, matchingNvPairs[templateName][\"IP\"]))\n                    key = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, intfName))\n\n                    # get the PTI for the anycast RP IP\n                    anycastRPIP = \"\"\n                    ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", \"anycast_rp\"))\n                    for pti in ptiList:\n                        anycastRPIP = pti.getNvPairs()[\"ANYCAST_RP_IP\"]\n                        Wrapper.print(\"SN [%s]. ANYCAST_RP_IP = [%s]\" % (devSerial, anycastRPIP))\n                        break\n\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK IP: [%s] ANYCAST_RP_IP: [%s]\" %\n                                  (FABRIC_NAME, key, loopbackIP, anycastRPIP))\n                    if loopbackIP != anycastRPIP:\n                        poolName = \"\"\n                        if (lowerIntfName == getLbIntfName(\"bgp\")):\n                            poolName = \"LOOPBACK0_IP_POOL\"\n                        elif (lowerIntfName == getLbIntfName(\"nve\")):\n                            poolName = \"LOOPBACK1_IP_POOL\"\n                        elif (lowerIntfName == getLbIntfName(\"rp\")): # revisit\n                            poolName = \"ANYCAST_RP_IP_POOL\"\n                        elif vpcPairInfo.get(\"virtualVPCLoopback\"):\n                            poolName = \"LOOPBACK0_IP_POOL\"\n                        else:\n                            #user loopback case\n                            Wrapper.print(\"No fabric loopback\")\n                            continue\n                        Util.exe(RM.set(FABRIC_NAME, poolName, EntityType.INTERFACE, key, loopbackIP))\n                elif (\"v6_loopback_interface\" == templateName or \n                      \"v6_loopback_interface_with_tag\" == templateName):\n                    nvPairs.update({\"V6IP\" : matchingNvPairs[templateName][\"IP\"]})\n\n                    nvPair = matchingNvPairs[templateName]\n\n                    # record resources in RM\n                    key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s]\" %\n                                  (FABRIC_NAME, key, loopbackId, intfName))\n                    #Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK_ID\", key, intfName, loopbackId))\n\n                    # set the loopback IP resource\n                    loopbackIP = nvPair[\"IP\"]\n                    Wrapper.print(\"loopback IP [%s] from nvPair and loopback IP [%s] from matchnvPair\"%\n                                  (loopbackIP, matchingNvPairs[templateName][\"IP\"]))\n                    key = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, intfName))\n\n                    poolName = \"\"\n                    if (lowerIntfName == getLbIntfName(\"bgp\")):\n                        poolName = \"LOOPBACK0_IP_POOL\"\n                    elif (lowerIntfName == getLbIntfName(\"nve\")):\n                        poolName = \"LOOPBACK1_IP_POOL\"\n                    elif (lowerIntfName == getLbIntfName(\"anycast\")):\n                        poolName = \"LOOPBACK1_IP_POOL\"\n                    else:\n                        # user loopback case\n                        Wrapper.print(\"No fabric loopback for V6\")\n                        continue\n\n                    if isVPC and (lowerIntfName == getLbIntfName(\"anycast\")):\n                        key = Util.exe(Helper.getKey(\"DeviceInterface\", vpcSn, vpcPeerSn, intfName))\n                        Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK1_IP_POOL\", EntityType.INTERFACE, key, loopbackIP))\n                        continue\n                        \n                    Util.exe(RM.set(FABRIC_NAME, poolName, EntityType.INTERFACE, key, loopbackIP))\n                elif (\"ospf_interface_11_1\" == templateName or \"v6_ospf_interface\" == templateName):\n                    nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"OSPF_TAG\"]})\n                    nvPairs.update({\"OSPF_AREA_ID\" : matchingNvPairs[templateName][\"OSPF_AREA_ID\"]})\n                elif (\"ospf_interface_auth\" == templateName):\n                    nvPairs[\"OSPF_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY_ID\"]\n                    nvPairs[\"OSPF_AUTH_KEY\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY\"]\n                elif (\"isis_interface\" == templateName or \"v6_isis_interface\" == templateName):\n                    nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"ISIS_TAG\"]})\n                elif (\"shut_interface\" == templateName):\n                    nvPairs[\"ADMIN_STATE\"] = \"false\"\n                elif (\"interface_desc\" == templateName):\n                    nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n            if isValidVPC:\n                # check for the vPC NVE secondary IP\n                templateName = \"vpc_nve_loopback\"\n                secIp = \"\"\n                nvPairList = getTemplateMatchResults(matchResult, templateName)\n                if (nvPairList != None):\n                    if (nvPairList[0][\"INTF_NAME\"] == intfName):\n                        nvPairs[\"SECONDARY_IP\"] = \"0.0.0.0\"#matchingNvPairs[templateName][\"SECONDARY_IP\"]\n                        secIp = matchingNvPairs[templateName][\"SECONDARY_IP\"]\n                templateName = \"vpc_nve_loopback_with_tag_11_1\"\n                nvPairList = getTemplateMatchResults(matchResult, templateName)\n                if (nvPairList != None):\n                    if (nvPairList[0][\"INTF_NAME\"] == intfName):\n                        nvPairs[\"SECONDARY_IP\"] = \"0.0.0.0\"#matchingNvPairs[templateName][\"SECONDARY_IP\"]\n                        secIp = matchingNvPairs[templateName][\"SECONDARY_IP\"]\n                Wrapper.print(\"%s: RM Set# Secondary IP %s\"%(devSerial, secIp))\n                if secIp and vpcPairSerialKey and lowerIntfName == getLbIntfName(\"nve\"):\n                    tmpSerials = vpcPairSerialKey.split(Helper.DELIMITER)\n                    tmpVpcSn = devSerial\n                    tmpVpcPeerSn = tmpSerials[1] if tmpVpcSn == tmpSerials[0] else tmpSerials[0]\n                    key = Util.exe(Helper.getKey(\"DeviceInterface\", tmpVpcSn, tmpVpcPeerSn, lowerIntfName))\n                    Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK1_IP_POOL\", EntityType.INTERFACE, key, secIp))\n\n            if \"OSPF_AUTH_KEY\" not in nvPairs:\n                nvPairs[\"OSPF_AUTH_KEY\"] = OSPF_AUTH_KEY\n                nvPairs[\"OSPF_AUTH_KEY_ID\"] = OSPF_AUTH_KEY_ID\n\n            # create the loopback port jython policy\n            # need to handle it properly\n            nvPairs[\"ROUTE_MAP_TAG\"] = \"\"\n            if UNDERLAY_IS_V6 == \"false\":\n                srcTemplateName = \"loopback_interface\"\n                for templateName in matchingNvPairs:\n                    if \"loopback_interface_with_tag\" == templateName:\n                        nvPairs.update({\"ROUTE_MAP_TAG\" : matchingNvPairs[templateName][\"ROUTE_MAP_TAG\"]})\n                        srcTemplateName = \"loopback_interface_with_tag\"\n                        break\n            else:\n                srcTemplateName = \"v6_loopback_interface\"\n                for templateName in matchingNvPairs:\n                    if \"v6_loopback_interface_with_tag\" == templateName:\n                        nvPairs.update({\"ROUTE_MAP_TAG\" : matchingNvPairs[templateName][\"ROUTE_MAP_TAG\"]})\n                        srcTemplateName = \"v6_loopback_interface_with_tag\"\n                        break\n\n            if lowerIntfName == getLbIntfName(\"rp\"):\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   10, \"rp_lb_id\", {\"id\": loopbackId}))\n\n            if vpcPairInfo.get(\"virtualVPCLoopback\"):\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   10, \"vpc_fabric_pair_lb_id\", {\"id\": loopbackId}))\n            \n            src = getSrc(srcTemplateName)\n            if bidirConfigInSwitch:\n                # Customer config of bidir is used in the fabric,\n                # create the RP loopback using empty source\n                src = \"\"\n            createPTI(devSerial, nvPairs, \"int_fabric_loopback_11_1\", intfName, src, -1)\n            continue\n        elif (\"phantom_loopback_interface_11_1\" in templateNameMatches):\n            # this is a loopback port for phantom RP\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # get the id\n            loopbackId = intfName[8:]\n            Wrapper.print(\"Found phantom RP loopback ID: [%s]\" % loopbackId)\n\n            # Do not create phantom RP loopback if the switch is not using bidir nor a spine\n            if not bidirConfigInSwitch or not isSpine:\n                createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME)\n                continue\n\n            # Only 2 RPs are supported for bidir in brownfield migration\n            if (lowerIntfName != getLbIntfName(\"phantom_rp1\") and\n                lowerIntfName != getLbIntfName(\"phantom_rp2\")):\n                createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME)\n                continue\n\n            nvPairs = {\"INTF_NAME\": intfName,\n                       \"IP\": \"\",\n                       \"PREFIX\": \"\",\n                       \"LINK_STATE_ROUTING\": LINK_STATE_ROUTING,\n                       \"LINK_STATE_ROUTING_TAG\": \"\",\n                       \"OSPF_AREA_ID\": OSPF_AREA_ID,\n                       \"DESC\": \"\",\n                       \"CONF\" :\"\",\n                       \"ADMIN_STATE\" : \"true\"\n                      }\n\n            if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                Wrapper.print(\"Device [%s]: Found unaccounted cfg for loopback intf [%s]\" % (devSerial, intfName))\n                nvPairs.update({\"CONF\": Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"])})\n\n            for templateName in matchingNvPairs:\n                if (\"phantom_loopback_interface_11_1\" == templateName):\n                    nvPairs.update({\"IP\" : matchingNvPairs[templateName][\"IP\"]})\n                    nvPairs.update({\"PREFIX\" : matchingNvPairs[templateName][\"PREFIX\"]})\n\n                    nvPair = matchingNvPairs[templateName]\n\n                    # record resources in RM\n                    key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s]\" %\n                                  (FABRIC_NAME, key, loopbackId, intfName))\n                    #Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK_ID\", key, intfName, loopbackId))\n\n                    # TBD: set the loopback IP resource when RM supports management of subnets\n                elif (\"ospf_interface_11_1\" == templateName):\n                    nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"OSPF_TAG\"]})\n                    nvPairs.update({\"OSPF_AREA_ID\" : matchingNvPairs[templateName][\"OSPF_AREA_ID\"]})\n                elif (\"isis_interface\" == templateName):\n                    nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"ISIS_TAG\"]})\n                elif (\"shut_interface\" == templateName):\n                    nvPairs[\"ADMIN_STATE\"] = \"false\"\n                elif (\"interface_desc\" == templateName):\n                    nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n                elif (\"ospf_interface_auth\" == templateName):\n                    nvPairs[\"OSPF_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY_ID\"]\n                    nvPairs[\"OSPF_AUTH_KEY\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY\"]\n\n            if \"OSPF_AUTH_KEY\" not in nvPairs:\n                nvPairs[\"OSPF_AUTH_KEY\"] = OSPF_AUTH_KEY\n                nvPairs[\"OSPF_AUTH_KEY_ID\"] = OSPF_AUTH_KEY_ID\n\n            # create the loopback port jython policy\n            Wrapper.print(\"Creating phantom RP loopback port [%s] policy\" % intfName)\n            createPTI(devSerial, nvPairs, \"int_fabric_phantom_rp_loopback_11_1\", intfName, \"\", -1)\n            if loopbackId == PHANTOM_RP_LB_ID1:\n                templateName = \"phantom_rp_lb_id1\"\n            elif loopbackId == PHANTOM_RP_LB_ID2:\n                templateName = \"phantom_rp_lb_id2\"\n            Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, templateName, {\"id\": loopbackId}))\n            continue\n        elif (\"access_interface\" in templateNameMatches or \n              \"access_interface_fex\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the host port jython policy\n            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            templateName = \"int_access_host\"\n            createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n            continue\n        elif (\"dot1q_tunnel_interface\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the host port jython policy\n            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            templateName = \"int_dot1q_tunnel_host\"\n            createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n            continue\n        elif ((\"trunk_interface\" in templateNameMatches) or\n              (\"trunk_interface_fex\" in templateNameMatches)):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getTrunkIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            createPTI(devSerial, nvPairs, \"int_trunk_host\", intfName, getSrc(\"int_trunk_host\"), -1)\n            continue\n        elif (\"routed_interface\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Routed Intf: [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n            createRoutedIntf(switchInfo, intfName, matchingNvPairs, True)\n            continue\n        elif ((\"eth_sub_interface\" in templateNameMatches) or\n              (\"eth_sub_interface_tag\" in templateNameMatches)):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the sub-interface jython policy\n            Wrapper.print(\"Creating Sub-interface policy for [%s]\" % intfName)\n            dot1qID, nvPairs = getSubIntfNvPairs(switchInfo, intfName, matchingNvPairs)\n            createPTI(devSerial, nvPairs, \"int_subif\", intfName, getSrc(\"int_subif\"), -1)\n            continue\n        else:\n            createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME)\n\n        # mark the interface as being processed\n        intfMatchResult.update({\"isProcessed\" : True})\n        Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n    Wrapper.print(\"%s: [%s] Success = [%r]\" % (funcName, fmtName, respObj.isRetCodeSuccess()))\n    return respObj\n\n# API to process the provided freeform for a po member port\n# if includeMemberInheritedCfg is true, all the CLIs that are inherited from the parent PO are removed from the FF\ndef getPoMemberFF(currentFF, intfName, includeMemberInheritedCfg=False):\n    funcName = sys._getframe(0).f_code.co_name\n\n    if includeMemberInheritedCfg:\n        return False, currentFF\n    \n    filteredFF = []\n    # filter out inherited CLIs\n    for line in currentFF:\n        strippedLine = line.strip().lower()\n\n        #Wrapper.print(\"%s: Intf [%s] strippedLine [%s] Line [%s]\" % (funcName, intfName, strippedLine, line))\n\n        # set of commands that are configurable on the member interfaces\n        filterCmdList = ['beacon', 'cdp', 'channel-group', 'description', 'dfe-tuning-delay', 'fec',\n                         'ip', 'ipv6','link', 'lacp', 'lldp', 'logging', 'mdix', 'no', 'power', 'ptp', 'rate-limit',\n                         'service-policy', 'snmp', 'spanning-tree', 'speed-group', 'switchport host', 'unidirectional']\n        intfCmdList = filter(lambda x: strippedLine.startswith(x), filterCmdList)\n\n        if intfCmdList:\n            filteredFF.append(line)\n\n    isUpdated = False\n    if len(currentFF) != len(filteredFF):\n        isUpdated = True\n\n    return isUpdated, filteredFF\n\ndef createLoopbackIntf(fabricName, switchInfo, intfName, matchingNvPairs):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = switchInfo[\"deviceSerial\"]\n\n    # create the host port jython policy\n    templateName = \"int_loopback\"\n    nvPairs = getLoopbackIntfNvpairs(fabricName, switchInfo, intfName, matchingNvPairs)\n    createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n\ndef createRoutedIntf(switchInfo, intfName, matchingNvPairs, includeMemberInheritedCfg):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = switchInfo[\"deviceSerial\"]\n\n    # create the host port jython policy\n    templateName = \"int_routed_host\"\n    nvPairs = getRoutedIntfNvpairs(switchInfo, intfName, matchingNvPairs, includeMemberInheritedCfg)\n    createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n\ndef getLinkInfo(sn1, sn2, intf1, intf2, linkNbrList):\n    uuid = linkType = entityName = \"\"\n    Wrapper.print(\"===Upgrade: getLinkInfo-Start===\")\n    Wrapper.print(\"===Upgrade: getLinkInfo-for [%s/%s/%s/%s]\"%(sn1,sn2,intf1,intf2))\n    for linkNbr in linkNbrList:\n        sw1Info = json.loads(linkNbr.get(\"sw2-info\"))\n        sw2Info = json.loads(linkNbr.get(\"sw1-info\"))\n        Wrapper.print(\"==SWITCH1 INFO==[%s]\"%(sw1Info))\n        Wrapper.print(\"==SWITCH2 INFO==[%s]\"%(sw2Info))\n        Wrapper.print (\"SN1/SN2/IFNAME1/IFNAME2 [%s:%s-%s:%s]\" %\n                       (sw1Info.get(\"sw-serial-number\"), sw2Info.get(\"sw-serial-number\"),\n                        sw1Info.get(\"if-name\"), sw2Info.get(\"if-name\")))\n        if (((sw1Info.get(\"sw-serial-number\") == sn1 and sw2Info.get(\"sw-serial-number\") == sn2) or\n             (sw1Info.get(\"sw-serial-number\") == sn2 and sw2Info.get(\"sw-serial-number\") == sn1)) and\n            ((sw1Info.get(\"if-name\") == intf1 and sw2Info.get(\"if-name\") == intf2) or\n             (sw1Info.get(\"if-name\") == intf2 and sw2Info.get(\"if-name\") == intf1))):\n            uuid = linkNbr.get(\"link-uuid\")\n            linkType = linkNbr.get(\"link-type\")\n            pairSerial = Util.exe(Helper.getLinkOrderByLinkUUid(uuid)) if uuid else \"\"\n            if pairSerial[\"sw1-serial-number\"] == sw2Info.get(\"sw-serial-number\"):\n                entityName = (sw2Info.get(\"sw-serial-number\") + \"~\" + sw2Info.get(\"if-name\") + \"~\" +\n                              sw1Info.get(\"sw-serial-number\") + \"~\" + sw1Info.get(\"if-name\"))\n            else:\n                entityName = (sw1Info.get(\"sw-serial-number\") + \"~\" + sw1Info.get(\"if-name\") + \"~\" +\n                              sw2Info.get(\"sw-serial-number\") + \"~\" + sw2Info.get(\"if-name\"))\n            break\n    Wrapper.print(\"===Upgrade: LINK_UUID [%s] linkType [%s] entityName [%s]===\"%(uuid, linkType, entityName))\n    Wrapper.print(\"===Upgrade: getLinkInfo-End===\")\n    return (uuid, linkType, entityName)\n\ndef manageVPCPKAIntf(dictObj):\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    funcName = sys._getframe(0).f_code.co_name\n    try:\n        FABRIC_NAME = dictObj[\"FABRIC_NAME\"]\n        localSerialNum = dictObj[\"localSerialNum\"]\n        localNvPairs = dictObj[\"localNvPairs\"]\n        localIntfName = dictObj[\"localIntfName\"]\n        peerSerialNum = dictObj[\"peerSerialNum\"]\n        peerIntfName = dictObj[\"peerIntfName\"]\n        localHostName = dictObj[\"localHostName\"]\n        peerHostName = dictObj[\"peerHostName\"]\n        linkNbrList = dictObj[\"linkNbrList\"]\n        templateName = \"int_vpc_peer_keep_alive_11_1\"\n\n        Wrapper.print(\"%s(): Local [%s/%s] <-> Peer [%s/%s]\" %\n                        (funcName, localSerialNum, localIntfName, peerSerialNum, peerIntfName))\n        if (peerIntfName != \"\"):\n            # get the PTI for the peer fabric interface (we need the IP addr on peer intf)\n            srchOpt = CtrlPolicySearch()\n            srchOpt.setSerialNumber(peerSerialNum)\n            srchOpt.setTemplateName(templateName)\n            srchOpt.setEntityName(peerIntfName)\n\n            peerIntfPTIs = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            peerIntfPti = None\n            for pti in peerIntfPTIs:\n                peerIntfPti = pti\n                break\n            \n            localIntfIp4 = localIntfIp6 = \"\"\n            peerIntfIp4 = peerIntfIp6 = \"\"\n            prefix4 = prefix6 = \"\"\n            subnetStr4 = subnetStr6 = \"\" \n\n            if (peerIntfPti != None):\n                isIp4Present = False\n                isIp6Present = False\n                # generate the key to associate the subnet pool with\n                linkKey = Util.exe(Helper.getKey(\"Link\", localSerialNum, localIntfName, peerSerialNum, peerIntfName))\n    \n                peerIntfNvPairs = copy.deepcopy(peerIntfPti.getNvPairs())\n\n                peerIntfIp4 = peerIntfNvPairs[\"IP\"]\n                isIp4Present = True if peerIntfIp4 else False\n                peerIntfIp6 = peerIntfNvPairs[\"V6IP\"]\n                isIp6Present = True if peerIntfIp6 else False\n \n                if isIp4Present:\n                    peerIntfIp4 = peerIntfNvPairs[\"IP\"]\n                    Wrapper.print(\"%s(): Peer intf [%s]. IP = [%s]\" % (funcName, peerIntfName, peerIntfIp4))\n    \n                    # save local intf IP\n                    localIntfIp4 = localNvPairs[\"IP\"]\n    \n                    subnetStr1 = Util.getSubnetStringWithPrefix(localNvPairs[\"IP\"], localNvPairs[\"PREFIX\"])\n                    subnetStr2 = Util.getSubnetStringWithPrefix(peerIntfNvPairs[\"IP\"], peerIntfNvPairs[\"PREFIX\"])\n                    if subnetStr1 != subnetStr2:\n                        errorMsg = (\"SN1:SN2 %s:%s link %s:%s IPs %s:%s are not in same subnet %s:%s. \"\n                                    \"Please correct [%s] Interface [%s] IP [%s/%s] \"%\n                                    (localSerialNum, peerSerialNum, localIntfName, peerIntfName, \n                                     localIntfIp4, peerIntfIp4, subnetStr1, subnetStr2, \n                                     localSerialNum, localIntfName, localIntfIp4, localNvPairs[\"PREFIX\"]))\n                        respObj.addErrorReport((funcName+localIntfName+\":\"+peerIntfName), errorMsg)\n                        respObj.setFailureRetCode()\n                        return respObj\n    \n                    prefix4 = localNvPairs[\"PREFIX\"] if localNvPairs[\"PREFIX\"] < peerIntfNvPairs[\"PREFIX\"] else peerIntfNvPairs[\"PREFIX\"]\n    \n                    # set the subnet pool in RM\n                    subnetStr4 = Util.getSubnetStringWithPrefix(localIntfIp4, localNvPairs[\"PREFIX\"])\n                    Wrapper.print(\"%s(): RM OPER: FAB [%s]: SET:[%s] Key [%s]: Link SUBNET [%s]\" %\n                                  (funcName, FABRIC_NAME, funcName, linkKey, subnetStr4))\n                if isIp6Present:\n                    peerIntfIp6 = peerIntfNvPairs[\"V6IP\"]\n                    Wrapper.print(\"%s(): Peer intf [%s]. V6IP = [%s]\" % (funcName, peerIntfName, peerIntfIp6))\n    \n                    # save local intf IP\n                    localIntfIp6 = localNvPairs[\"V6IP\"]\n    \n                    subnetStr1 = Util.getV6SubnetStringWithPrefix(localNvPairs[\"V6IP\"], localNvPairs[\"V6PREFIX\"])\n                    subnetStr2 = Util.getV6SubnetStringWithPrefix(peerIntfNvPairs[\"V6IP\"], peerIntfNvPairs[\"V6PREFIX\"])\n                    if subnetStr1 != subnetStr2:\n                        errorMsg = (\"SN1:SN2 %s:%s link %s:%s IPs %s:%s are not in same subnet %s:%s. \"\n                                    \"Please correct [%s] Interface [%s] IP [%s/%s] \"%\n                                    (localSerialNum, peerSerialNum, localIntfName, peerIntfName, \n                                     localIntfIp6, peerIntfIp6, subnetStr1, subnetStr2, \n                                     localSerialNum, localIntfName, localIntfIp6, localNvPairs[\"V6PREFIX\"]))\n                        respObj.addErrorReport((funcName+localIntfName+\":\"+peerIntfName), errorMsg)\n                        respObj.setFailureRetCode()\n                        return respObj\n    \n                    prefix6 = localNvPairs[\"V6PREFIX\"] if localNvPairs[\"V6PREFIX\"] < peerIntfNvPairs[\"V6PREFIX\"] else peerIntfNvPairs[\"V6PREFIX\"]\n    \n                    # set the subnet pool in RM\n                    subnetStr6 = Util.getV6SubnetStringWithPrefix(localIntfIp6, localNvPairs[\"V6PREFIX\"])\n                    Wrapper.print(\"%s(): RM OPER: FAB [%s]: SET:[%s] Key [%s]: Link SUBNET [%s]\" %\n                                  (funcName, FABRIC_NAME, funcName, linkKey, subnetStr6))\n\n                # set the local interface IP in RM\n                key = Util.exe(Helper.getKey(\"DeviceInterface\", localSerialNum, localIntfName))\n                Wrapper.print(\"%s(): RM OPER: FAB [%s]: SET:[%s] Key [%s]: Link local (SUBNET4 [%s], IP4 [%s]) (SUBNET6 [%s], IP6 [%s])\" %\n                              (funcName, FABRIC_NAME, funcName, key, subnetStr4, localIntfIp4, subnetStr6, localIntfIp6))\n\n                # set the peer interface IP in RM\n                key = Util.exe(Helper.getKey(\"DeviceInterface\", peerSerialNum, peerIntfName))\n                Wrapper.print(\"%s(): RM OPER: FAB [%s]: SET:[%s] Key [%s]: Link peer (SUBNET4 [%s], IP4 [%s]) (SUBNET6 [%s], IP6 [%s])\" %\n                              (funcName, FABRIC_NAME, funcName, key, subnetStr4, peerIntfIp4, subnetStr6, peerIntfIp6))\n\n                #don't delete before responding about error\n                PTIWrapper.delete(peerSerialNum, \"INTERFACE\", peerIntfName)\n                \n                intfVRF = \"\"\n                if localNvPairs.get(\"INTF_VRF\"):\n                    intfVRF = localNvPairs[\"INTF_VRF\"]\n                nvPairs = {\n                           \"FABRIC1\":FABRIC_NAME, \n                           \"FABRIC2\":FABRIC_NAME,\n                           \"INTF_VRF\":intfVRF,\n                           \"MTU\": localNvPairs[\"MTU\"],\n                           \"ADMIN_STATE\": \"true\",\n                           \"GUI_EDIT\":\"\"\n                          }\n                \n                linkUUID, ignore, entityName = getLinkInfo(localSerialNum, peerSerialNum, localIntfName, peerIntfName, linkNbrList)\n                peer1Sn = entityName.split(\"~\")[0]\n                peer2Sn = entityName.split(\"~\")[2]\n                if peer1Sn == localSerialNum:\n                    nvPairs.update({\"HOSTNAME1\":localHostName, \"HOSTNAME2\":peerHostName,\n                                    \"PEER1_SN\":localSerialNum, \"PEER2_SN\":peerSerialNum, \n                                    \"PEER1_INTF\":localIntfName, \"PEER2_INTF\":peerIntfName,\n                                    \"PEER1_DESC\": localNvPairs[\"DESC\"], \"PEER2_DESC\":peerIntfNvPairs[\"DESC\"], \n                                    \"PEER1_CONF\":localNvPairs[\"CONF\"], \"PEER2_CONF\":peerIntfNvPairs[\"CONF\"]})\n                else:\n                    nvPairs.update({\"HOSTNAME1\":peerHostName, \"HOSTNAME2\":localHostName,\n                                    \"PEER1_SN\":peerSerialNum, \"PEER2_SN\":localSerialNum,\n                                    \"PEER1_INTF\":peerIntfName, \"PEER2_INTF\":localIntfName,\n                                    \"PEER1_DESC\": peerIntfNvPairs[\"DESC\"], \"PEER2_DESC\":localNvPairs[\"DESC\"],\n                                    \"PEER1_CONF\":peerIntfNvPairs[\"CONF\"], \"PEER2_CONF\":localNvPairs[\"CONF\"]})\n\n                ptiTemplateName = \"int_intra_vpc_peer_keep_alive_link\"\n                nvPairs.update({\"PEER1_IP\":\"\", \"PEER2_IP\":\"\", \"PREFIX\":prefix4})\n                nvPairs.update({\"PEER1_V6IP\":\"\", \"PEER2_V6IP\":\"\", \"V6PREFIX\":prefix6})\n                if peer1Sn == localSerialNum:\n                    if isIp4Present:\n                        nvPairs.update({\"PEER1_IP\":localIntfIp4, \"PEER2_IP\":peerIntfIp4})\n                    if isIp6Present:\n                        nvPairs.update({\"PEER1_V6IP\":localIntfIp6, \"PEER2_V6IP\":peerIntfIp6})\n                else:\n                    if isIp4Present:\n                        nvPairs.update({\"PEER1_IP\":peerIntfIp4, \"PEER2_IP\":localIntfIp4})\n                    if isIp6Present:\n                        nvPairs.update({\"PEER1_V6IP\":peerIntfIp6, \"PEER2_V6IP\":localIntfIp6})\n                Util.exe(PTIWrapper.createOrUpdate(linkUUID, \"LINK\", entityName, \"\", 500, ptiTemplateName, nvPairs))\n            else:\n                Wrapper.print(\"%s(): vpc peer keep alive [%s] PTI not found\" % (funcName, peerIntfName))\n        else:\n            Wrapper.print(\"manageVPCPKAIntf: Peer not found. Creating incomplete VPCPKA interface [%s] policy\" % localIntfName)\n            localNvPairs[\"GUI_EDIT\"] = \"\"\n            localNvPairs[\"FABRIC_NAME\"] = FABRIC_NAME\n            localNvPairs[\"IP_RM_ID\"] = \"-1\"\n            localNvPairs[\"SUBNET_RM_ID\"] = \"-1\"\n            createPTI(localSerialNum, localNvPairs, templateName, localIntfName, \"LINK\", -1)\n        Wrapper.print(\"==========%s done==========\"%(funcName))\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef isVirtualVPCSwitch(FABRIC_NAME, sn):\n    isSwitchVPC = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, sn))\n    if isSwitchVPC:\n        try:\n            vpcType = Util.exe(VpcWrapper.get(VPCMetaDataType.PEERLINK_TYPE, \"\", sn))\n            if vpcType == VPCMetaDataType.VIRTUAL_PEERLINK:\n                return True\n        except:\n            Wrapper.print(\"%s() template [%s] Seems Upgrade path :\"%(funcName, \"Easy_Fabric_Extn\"))\n    return False\n\ndef manageFabricIntf(dictObj):\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        FABRIC_NAME = dictObj[\"FABRIC_NAME\"]\n        localSerialNum = dictObj[\"localSerialNum\"]\n        localNvPairs = dictObj[\"localNvPairs\"]\n        localIntfName = dictObj[\"localIntfName\"]\n        peerSerialNum = dictObj[\"peerSerialNum\"]\n        peerIntfName = dictObj[\"peerIntfName\"]\n        localHostName = dictObj[\"localHostName\"]\n        peerHostName = dictObj[\"peerHostName\"]\n        linkNbrList = dictObj[\"linkNbrList\"]\n        templateName = \"int_fabric_unnum_11_1\" if FABRIC_INTERFACE_TYPE == \"unnumbered\" else \"int_fabric_num_11_1\"\n        if UNDERLAY_IS_V6 == \"true\" and USE_LINK_LOCAL == \"true\":\n            templateName = \"int_fabric_ipv6_link_local\"\n\n        Wrapper.print(\"manageFabricIntf: Local [%s/%s] <-> Peer [%s/%s]\" %\n                        (localSerialNum, localIntfName, peerSerialNum, peerIntfName))\n        if (peerIntfName != \"\"):\n            # get the PTI for the peer fabric interface (we need the IP addr on peer intf)\n            srchOpt = CtrlPolicySearch()\n            srchOpt.setSerialNumber(peerSerialNum)\n            srchOpt.setTemplateName(templateName)\n            srchOpt.setEntityName(peerIntfName)\n\n            peerIntfPTIs = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            peerIntfPti = None\n            for pti in peerIntfPTIs:\n                peerIntfPti = pti\n                break\n            \n            localIntfIp = peerIntfIp = \"\"\n            if (peerIntfPti != None):\n                peerIntfNvPairs = copy.deepcopy(peerIntfPti.getNvPairs())\n                prefix = \"\"\n                if FABRIC_INTERFACE_TYPE == \"p2p\" and templateName != \"int_fabric_ipv6_link_local\":\n                    if UNDERLAY_IS_V6 == \"false\":\n                        localIntfIp = localNvPairs[\"IP\"]\n                        localIntfPrefix = localNvPairs[\"PREFIX\"]\n                        peerIntfIp = peerIntfNvPairs[\"IP\"]\n                        peerIntfPrefix = peerIntfNvPairs[\"PREFIX\"]\n                    else:\n                        localIntfIp = localNvPairs[\"V6IP\"]\n                        localIntfPrefix = localNvPairs[\"V6PREFIX\"]\n                        peerIntfIp = peerIntfNvPairs[\"V6IP\"]\n                        peerIntfPrefix = peerIntfNvPairs[\"V6PREFIX\"]\n                     \n                    if localIntfIp == \"\" or peerIntfIp == \"\":\n                        errorMsg = (\"SN1:SN2 %s:%s link %s:%s IPs %s:%s are not configured. \"%\n                                    (localSerialNum, peerSerialNum, localIntfName, peerIntfName, \n                                     localIntfIp, peerIntfIp))\n                        respObj.addErrorReport((\"manageFabricIntf\"+localIntfName+\":\"+peerIntfName), errorMsg)\n                        respObj.setFailureRetCode()\n                    else:\n                        if UNDERLAY_IS_V6 == \"false\":\n                            subnetStr1 = Util.getSubnetStringWithPrefix(localIntfIp, localIntfPrefix)\n                            subnetStr2 = Util.getSubnetStringWithPrefix(peerIntfIp, peerIntfPrefix)\n                        else:\n                            subnetStr1 = Util.getV6SubnetStringWithPrefix(localIntfIp, localIntfPrefix)\n                            subnetStr2 = Util.getV6SubnetStringWithPrefix(peerIntfIp, peerIntfPrefix)\n                        if subnetStr1 != subnetStr2:\n                            errorMsg = (\"SN1:SN2 %s:%s link %s:%s IPs %s:%s are not in same subnet %s:%s. \"\n                                        \"Please correct [%s] Interface [%s] IP [%s]/[%s] \"%\n                                        (localSerialNum, peerSerialNum, localIntfName, peerIntfName, \n                                         localIntfIp, peerIntfIp, subnetStr1, subnetStr2, \n                                         localSerialNum, localIntfName, localIntfIp, localIntfPrefix))\n                            respObj.addErrorReport((\"manageFabricIntf\"+localIntfName+\":\"+peerIntfName), errorMsg)\n                            respObj.setFailureRetCode()\n\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    prefix = localIntfPrefix if localIntfPrefix < peerIntfPrefix else peerIntfPrefix\n\n                    # generate the key to associate the subnet pool with\n                    linkKey = Util.exe(Helper.getKey(\"Link\", localSerialNum, localIntfName, peerSerialNum, peerIntfName))\n\n                    # set the subnet pool in RM\n                    Wrapper.print(\"RM OPER: FAB [%s]: SET:[manageFabricIntf] Key [%s]: Link SUBNET [%s]\" %\n                                  (FABRIC_NAME, linkKey, subnetStr1))\n                    #ignore, subnetPoolRmId = Util.exeRM(RM.set(FABRIC_NAME, PoolName.SUBNET, EntityType.LINK, linkKey, subnetStr1))\n\n                    # set the local interface IP in RM\n                    key = Util.exe(Helper.getKey(\"DeviceInterface\", localSerialNum, localIntfName))\n                    Wrapper.print(\"RM OPER: FAB [%s]: SET:[manageFabricIntf] Key [%s]: Link SUBNET [%s] IP [%s]\" %\n                                  (FABRIC_NAME, key, subnetStr1, localIntfIp))\n                    #ignore, localIpRmId = Util.exeRM(RM.set(FABRIC_NAME, subnetStr1, EntityType.INTERFACE, key, localIntfIp))\n\n                    # set the peer interface IP in RM\n                    key = Util.exe(Helper.getKey(\"DeviceInterface\", peerSerialNum, peerIntfName))\n                    Wrapper.print(\"RM OPER: FAB [%s]: SET:[manageFabricIntf] Key [%s]: Link SUBNET [%s] IP [%s]\" %\n                                  (FABRIC_NAME, key, subnetStr2, peerIntfIp))\n                    #ignore, peerIpRmId = Util.exeRM(RM.set(FABRIC_NAME, subnetStr2, EntityType.INTERFACE, key, peerIntfIp))\n\n                    #don't delete before responding about error\n                    PTIWrapper.delete(peerSerialNum, \"INTERFACE\", peerIntfName)\n\n                nvPairs = {\n                           \"FABRIC1\":FABRIC_NAME, \n                           \"FABRIC2\":FABRIC_NAME,\n                           \"MTU\": localNvPairs[\"MTU\"],\n                           \"SPEED\": localNvPairs[\"SPEED\"],\n                           \"ADMIN_STATE\": \"true\",\n                           \"OSPF_AREA_ID\":OSPF_AREA_ID,\n                           \"REPLICATION_MODE\":REPLICATION_MODE,\n                           \"GUI_EDIT\":\"\",\n                           \"EXTRA_CONF_INTRA_LINKS\" : EXTRA_CONF_INTRA_LINKS,\n                           \"LINK_STATE_ROUTING_TAG\" : LINK_STATE_ROUTING_TAG\n                          }\n                \n                linkUUID, ignore, entityName = getLinkInfo(localSerialNum, peerSerialNum, localIntfName, peerIntfName, linkNbrList)\n                peer1Sn = entityName.split(\"~\")[0]\n                peer2Sn = entityName.split(\"~\")[2]\n\n                localPTFabric = localNvPairs.get(\"PORTTYPE_FABRIC\", \"false\") \n                peerPTFabric = peerIntfNvPairs.get(\"PORTTYPE_FABRIC\", \"false\")\n                \n                nvPairs[\"FABRIC_VPC_QOS\"] = \"false\"\n                fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n                if fabricSettings.get(\"FABRIC_VPC_QOS\") == \"true\":\n                    qosPolicyName = fabricSettings.get(\"FABRIC_VPC_QOS_POLICY_NAME\", \"spine_qos_for_fabric_vpc_peering\")\n                    if qosPolicyName in localNvPairs[\"CONF\"]:  \n                        nvPairs[\"FABRIC_VPC_QOS\"] = \"true\"\n                        localNvPairs[\"CONF\"] = Util.newLine().join(line for line in localNvPairs[\"CONF\"].split(Util.newLine()) if qosPolicyName not in line)\n                    if qosPolicyName in peerIntfNvPairs[\"CONF\"]:\n                        nvPairs[\"FABRIC_VPC_QOS\"] = \"true\"\n                        peerIntfNvPairs[\"CONF\"] = Util.newLine().join(line for line in peerIntfNvPairs[\"CONF\"].split(Util.newLine()) if qosPolicyName not in line)\n\n                if peer1Sn == localSerialNum:\n                    nvPairs.update({\"HOSTNAME1\":localHostName, \"HOSTNAME2\":peerHostName,\n                                    \"PEER1_SN\":localSerialNum, \"PEER2_SN\":peerSerialNum, \n                                    \"PEER1_INTF\":localIntfName, \"PEER2_INTF\":peerIntfName,\n                                    \"PEER1_DESC\": localNvPairs[\"DESC\"], \"PEER2_DESC\":peerIntfNvPairs[\"DESC\"], \n                                    \"PEER1_CONF\":localNvPairs[\"CONF\"], \"PEER2_CONF\":peerIntfNvPairs[\"CONF\"],\n                                    \"PEER1_PORTTYPE_FABRIC\":localPTFabric, \"PEER2_PORTTYPE_FABRIC\":peerPTFabric})\n                else:\n                    nvPairs.update({\"HOSTNAME1\":peerHostName, \"HOSTNAME2\":localHostName,\n                                    \"PEER1_SN\":peerSerialNum, \"PEER2_SN\":localSerialNum,\n                                    \"PEER1_INTF\":peerIntfName, \"PEER2_INTF\":localIntfName,\n                                    \"PEER1_DESC\": peerIntfNvPairs[\"DESC\"], \"PEER2_DESC\":localNvPairs[\"DESC\"],\n                                    \"PEER1_CONF\":peerIntfNvPairs[\"CONF\"], \"PEER2_CONF\":localNvPairs[\"CONF\"],\n                                    \"PEER1_PORTTYPE_FABRIC\":peerPTFabric, \"PEER2_PORTTYPE_FABRIC\":localPTFabric})\n\n                ptiTemplateName = \"int_intra_fabric_unnum_link\" if FABRIC_INTERFACE_TYPE == \"unnumbered\" else \"int_intra_fabric_num_link\"\n                if UNDERLAY_IS_V6 == \"true\" and USE_LINK_LOCAL == \"true\":\n                    ptiTemplateName = \"int_intra_fabric_ipv6_link_local\"\n                if FABRIC_INTERFACE_TYPE == \"p2p\" and ptiTemplateName != \"int_intra_fabric_ipv6_link_local\":\n                    ptiTemplateName = \"int_intra_fabric_num_link\"\n                    localBfdEchoDisable = localNvPairs.get(\"BFD_ECHO_DISABLE\", \"false\")\n                    peerBfdEchoDisable = peerIntfNvPairs.get(\"BFD_ECHO_DISABLE\", \"false\")\n                    nvPairs[\"BFD_ENABLE\"] = BFD_ENABLE\n                    nvPairs[\"BFD_AUTH_KEY_ID\"] = BFD_AUTH_KEY_ID\n                    nvPairs[\"BFD_AUTH_KEY\"] = BFD_AUTH_KEY\n                    nvPairs.update({\"PEER1_IP\":\"\", \"PEER2_IP\":\"\", \"PREFIX\":prefix})\n                    nvPairs.update({\"PEER1_V6IP\":\"\", \"PEER2_V6IP\":\"\", \"V6PREFIX\":prefix})\n                    if peer1Sn == localSerialNum:\n                        if UNDERLAY_IS_V6 == \"false\":\n                            nvPairs.update({\"PEER1_IP\":localIntfIp, \"PEER2_IP\":peerIntfIp})\n                        else:\n                            nvPairs.update({\"PEER1_V6IP\":localIntfIp, \"PEER2_V6IP\":peerIntfIp})\n                        nvPairs[\"PEER1_BFD_ECHO_DISABLE\"] = localBfdEchoDisable\n                        nvPairs[\"PEER2_BFD_ECHO_DISABLE\"] = peerBfdEchoDisable\n                    else:\n                        if UNDERLAY_IS_V6 == \"false\":\n                            nvPairs.update({\"PEER1_IP\":peerIntfIp, \"PEER2_IP\":localIntfIp})\n                        else:\n                            nvPairs.update({\"PEER1_V6IP\":peerIntfIp, \"PEER2_V6IP\":localIntfIp})\n                        nvPairs[\"PEER1_BFD_ECHO_DISABLE\"] = peerBfdEchoDisable\n                        nvPairs[\"PEER2_BFD_ECHO_DISABLE\"] = localBfdEchoDisable\n                nvPairs[\"ENABLE_MACSEC\"] = \"false\"\n                nvPairs[\"ISIS_P2P_ENABLE\"] = ISIS_P2P_ENABLE\n\n                processInbandPOAPLinkFF(fabricSettings, nvPairs)\n\n                PTIWrapper.createOrUpdate(linkUUID, \"LINK\", entityName, \"\", 500, ptiTemplateName, nvPairs)\n                #createPTI(localSerialNum, localNvPairs, templateName, localIntfName, getSrc(templateName), -1)\n            else:\n                Wrapper.print(\"Peer Fabric intf [%s] PTI not found\" % peerIntfName)\n        else:\n            Wrapper.print(\"manageFabricIntf: Peer not found. Creating incomplete fabric interface [%s] policy\" % localIntfName)\n            localNvPairs[\"GUI_EDIT\"] = \"\"\n            localNvPairs[\"FABRIC_NAME\"] = FABRIC_NAME\n            localNvPairs[\"IP_RM_ID\"] = \"-1\"\n            localNvPairs[\"SUBNET_RM_ID\"] = \"-1\"\n            createPTI(localSerialNum, localNvPairs, templateName, localIntfName, \"LINK\", -1)\n        Wrapper.print(\"==========manageFabricIntf done==========\")\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef removeInbandPOAPDhcpConfigs(isUnnum, freeform):\n    ffLines = freeform.split(Util.newLine())\n    newFF = []\n    for line in ffLines:\n        stripLine = line.strip()\n        if stripLine == \"ip proxy-arp\":\n            if not isUnnum:\n                newFF.append(line)\n        elif stripLine.startswith(\"ip dhcp relay address \"):\n            continue\n        elif stripLine.startswith(\"ip dhcp relay source-interface \"):\n            continue\n        else:\n            newFF.append(line)\n\n    return Util.newLine().join(newFF)\n\ndef isInbandPoapEnabled(dictObj):\n    inbandMgmt = dictObj.get(\"INBAND_MGMT\", \"false\")\n    bootstrapPOAPEnable = dictObj.get(\"BOOTSTRAP_ENABLE\", \"false\")\n    return (\"true\" if (inbandMgmt == \"true\" and bootstrapPOAPEnable == \"true\") else \"false\")\n\ndef processInbandPOAPLinkFF(fabricSettings, nvPairs):\n    if isInbandPoapEnabled(fabricSettings) != \"true\":\n        # no changes\n        return\n\n    # additional processing for Inband POAP cases\n    #   - remove the DHCP relay related configs. The correct ones will get added from the regular configSave\n    isUnnum = True if fabricSettings.get(\"FABRIC_INTERFACE_TYPE\", \"unnumbered\") == \"unnumbered\" else False\n    if len(nvPairs[\"PEER1_CONF\"]):\n        nvPairs[\"PEER1_CONF\"] = removeInbandPOAPDhcpConfigs(isUnnum, nvPairs[\"PEER1_CONF\"])\n    if len(nvPairs[\"PEER2_CONF\"]):\n        nvPairs[\"PEER2_CONF\"] = removeInbandPOAPDhcpConfigs(isUnnum, nvPairs[\"PEER2_CONF\"])\n\ndef getMigrationFileNames(dictObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    devSerial = dictObj[\"deviceSerial\"]\n    switchBaseDir = getSwitchBaseDir(devSerial, FABRIC_NAME, Util.getBrownfieldDir())\n\n    # get the cuurent file index to use\n    importMetadataFileName = switchBaseDir + IMPORT_METADATA_FILENAME\n    importMetaData = Util.exe(getJSONFileContents(importMetadataFileName))\n    fileIndexToUse = importMetaData[\"cfgfile_ext_index\"]\n    Wrapper.print(\"%s: [%s] importMetaData fileIndexToUse [%d]\" % (funcName, devSerial, fileIndexToUse))\n\n    dictObj[\"matchResultsFileName\"] = getFilenameWithIndex(switchBaseDir, MATCH_RESULT_FILENAME, fileIndexToUse)\n    dictObj[\"interfaceMatchResultsFileName\"] = getFilenameWithIndex(switchBaseDir, INTF_MATCH_RESULT_FILENAME, fileIndexToUse)\n    dictObj[\"overlayInfoFileName\"] = getFilenameWithIndex(switchBaseDir, OVERLAY_INFO_FILENAME, fileIndexToUse)\n    Wrapper.print(\"%s: [%s] matchResultsFileName [%s] interfaceMatchResultsFileName [%s] overlayInfoFileName[%s]\" % (funcName,\n        devSerial, dictObj[\"matchResultsFileName\"], dictObj[\"interfaceMatchResultsFileName\"], dictObj[\"overlayInfoFileName\"]))\n\ndef getSwitchMatchResults(sn):\n    funcName = sys._getframe(0).f_code.co_name\n    switchBaseDir = getSwitchBaseDir(sn, FABRIC_NAME, Util.getBrownfieldDir())\n\n    # get the cuurent file index to use\n    importMetadataFileName = switchBaseDir + IMPORT_METADATA_FILENAME\n    importMetaData = Util.exe(getJSONFileContents(importMetadataFileName))\n    fileIndexToUse = importMetaData[\"cfgfile_ext_index\"]\n\n    matchResultsFileName = getFilenameWithIndex(switchBaseDir, MATCH_RESULT_FILENAME, fileIndexToUse)\n    interfaceMatchResultsFileName = getFilenameWithIndex(switchBaseDir, INTF_MATCH_RESULT_FILENAME, fileIndexToUse)\n\n    Wrapper.print(\"%s: [%s] fileIndexToUse [%d] matchResultsFileName [%s] interfaceMatchResultsFileName [%s]\" % (funcName,\n        sn, fileIndexToUse, matchResultsFileName, interfaceMatchResultsFileName))\n\n    Wrapper.print(\"%s: [%s] Retrieving match results\" % (funcName, sn))\n    matchResult = Util.exe(getJSONFileContents(matchResultsFileName))\n    interfacesRes = Util.exe(getJSONFileContents(interfaceMatchResultsFileName))\n\n    return (matchResult, interfacesRes)\n\ndef unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult):\n    unaccountedConfigList = []\n    templateNameMatches = intfMatchResult[\"matched_templates\"]\n    #Wrapper.print(\"unaccCfgFromTemplates: interface [%s] with template list %s\"%(intfName, \",\".join(templateList)))\n    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateList)\n    for templateName in matchingNvPairs:\n        if (\"interface_vrf\" == templateName):\n            param = matchingNvPairs[templateName].get(\"INTF_VRF\")\n            if param:\n                unaccountedConfigList.append(\"%svrf member %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"interface_mtu\" == templateName):\n            param = matchingNvPairs[templateName].get(\"MTU\")\n            if param:\n                unaccountedConfigList.append(\"%smtu %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"port_channel_mode\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"PCID\")\n            param2 = matchingNvPairs[templateName].get(\"PC_MODE\")\n            if param1 and param2:\n                unaccountedConfigList.append(\"%schannel-group %s force mode %s\"%(INTF_FIRST_LVL_SPACING, param1,param2))\n        elif (\"port_channel_mode_on\" == templateName):\n            param = matchingNvPairs[templateName].get(\"PCID\")\n            if param:\n                unaccountedConfigList.append(\"%schannel-group %s force\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"cdp_disable_interface_11_1\" == templateName):\n            unaccountedConfigList.append(\"%sno cdp enable\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"access_vlan\" == templateName):\n            param = matchingNvPairs[templateName].get(\"ACCESS_VLAN\")\n            if param and param != \"1\":\n                unaccountedConfigList.append(\"%sswitchport access vlan %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"native_vlan\" == templateName):\n            param = matchingNvPairs[templateName].get(\"NATIVE_VLAN\")\n            if param and param != \"1\":\n                unaccountedConfigList.append(\"%sswitchport trunk native vlan %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"bfd_no_echo_interface\" == templateName):\n            unaccountedConfigList.append(\"%sno bfd echo\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"bpduguard_disable\" == templateName):\n            unaccountedConfigList.append(\"%sspanning-tree bpduguard disable\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"bpduguard_enable\" == templateName):\n            unaccountedConfigList.append(\"%sspanning-tree bpduguard enable\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"interface_speed\" == templateName):\n            swSpeed = matchingNvPairs[templateName].get(\"SPEED\")\n            if swSpeed and swSpeed != \"auto\":\n                #param = Util.mapSwitchSpeedToEnum(swSpeed)\n                unaccountedConfigList.append(\"%sspeed %s\"%(INTF_FIRST_LVL_SPACING, swSpeed))\n        elif (\"interface_no_nego_auto\" == templateName):\n            unaccountedConfigList.append(\"%sno negotiate auto\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"isis_interface\" == templateName):\n            param = matchingNvPairs[templateName].get(\"ISIS_TAG\")\n            if param:\n                unaccountedConfigList.append(\"%sip router isis %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"v6_isis_interface\" == templateName):\n            param = matchingNvPairs[templateName].get(\"ISIS_TAG\")\n            if param:\n                unaccountedConfigList.append(\"%sipv6 router isis %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"ospf_interface_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"OSPF_TAG\")\n            param2 = matchingNvPairs[templateName].get(\"OSPF_AREA_ID\")\n            if param1 and param2:\n                unaccountedConfigList.append(\"%sip router ospf %s area %s\"%(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"v6_ospf_interface\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"OSPF_TAG\")\n            param2 = matchingNvPairs[templateName].get(\"OSPF_AREA_ID\")\n            if param1 and param2:\n                unaccountedConfigList.append(\"%sipv6 router ospfv3 %s area %s\"%(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"ospf_p2p_interface\" == templateName):\n            unaccountedConfigList.append(\"%sip ospf network point-to-point\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"isis_p2p_interface\" == templateName):\n            unaccountedConfigList.append(\"%sisis network point-to-point\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"pim_interface\" == templateName):\n            unaccountedConfigList.append(\"%sip pim sparse-mode\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"porttype_fast_enable\" == templateName):\n            unaccountedConfigList.append(\"%sspanning-tree port type edge\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"porttype_fast_trunk\" == templateName):\n            unaccountedConfigList.append(\"%sspanning-tree port type edge trunk\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"interface_ipv4_tag_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"IP\")\n            param2 = matchingNvPairs[templateName].get(\"PREFIX\")\n            param3 = matchingNvPairs[templateName].get(\"TAG\")\n            unaccountedConfigList.append(\"%sip address %s/%s tag %s\"%(INTF_FIRST_LVL_SPACING, param1, param2, param3))\n        elif (\"interface_ipv4_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"IP\")\n            param2 = matchingNvPairs[templateName].get(\"PREFIX\")\n            unaccountedConfigList.append(\"%sip address %s/%s\"%(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"interface_ipv6_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"IP\")\n            param2 = matchingNvPairs[templateName].get(\"PREFIX\")\n            unaccountedConfigList.append(\"%sipv6 address %s/%s\"%(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"interface_ipv6_tag_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"IP\")\n            param2 = matchingNvPairs[templateName].get(\"PREFIX\")\n            param3 = matchingNvPairs[templateName].get(\"TAG\")\n            unaccountedConfigList.append(\"%sipv6 address %s/%s tag %s\"%(INTF_FIRST_LVL_SPACING, param1, param2, param3))\n        elif (\"vlan_interface_fwd_mode_11_1\" == templateName):\n            param = matchingNvPairs[templateName].get(\"MODE\")\n            unaccountedConfigList.append(\"%sfabric forwarding mode %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"ospf_interface_auth\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"OSPF_AUTH_KEY_ID\")\n            param2 = matchingNvPairs[templateName].get(\"OSPF_AUTH_KEY\")\n            unaccountedConfigList.append(\"%sip ospf message-digest-key %s md5 3 %s\" %(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"pim_interface_hello_auth\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"AUTH_KEY\")\n            unaccountedConfigList.append(\"%sip pim hello-authentication ah-md5 3 %s\" %(INTF_FIRST_LVL_SPACING, param1))\n        elif (\"isis_interface_auth\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"IS_TYPE\")\n            param2 = matchingNvPairs[templateName].get(\"ISIS_AUTH_KEYCHAIN_NAME\")\n            unaccountedConfigList.append(\"%sisis authentication-type md5 %s\" %(INTF_FIRST_LVL_SPACING, param1))\n            unaccountedConfigList.append(\"%sisis authentication key-chain %s %s\" %(INTF_FIRST_LVL_SPACING, param2, param1))\n        elif (\"isis_interface_auth_no_lvl\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"ISIS_AUTH_KEYCHAIN_NAME\")\n            unaccountedConfigList.append(\"%sisis authentication-type md5\" %(INTF_FIRST_LVL_SPACING))\n            unaccountedConfigList.append(\"%sisis authentication key-chain %s\" %(INTF_FIRST_LVL_SPACING, param1))\n        elif (\"routed_interface_no_ip_redirects\" == templateName):\n            unaccountedConfigList.append(\"%sno ip redirects%s%sno ipv6 redirects\" %\n                (INTF_FIRST_LVL_SPACING, Util.newLine(), INTF_FIRST_LVL_SPACING))\n        elif (\"bfd_interface_auth\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"BFD_AUTH_KEY_ID\")\n            param2 = matchingNvPairs[templateName].get(\"BFD_AUTH_KEY\")\n            unaccountedConfigList.append(\"%sbfd authentication Keyed-SHA1 key-id %s hex-key %s\" %(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"port_channel_vpc_id_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"VPC_ID\")\n            unaccountedConfigList.append(\"%svpc %s\" %(INTF_FIRST_LVL_SPACING, param1))\n\n    #Wrapper.print(\"unaccCfgFromTemplates: interface [%s] with unaccounted commands [%s]\"%(intfName, \",\".join(unaccountedConfigList)))\n    return unaccountedConfigList\n\ndef getPoMemberIntfNvpairs(sn, intfName, isTrunk, poPCId, matchResult, interfacesRes, getPTINvpairs):\n    funcName = sys._getframe(0).f_code.co_name\n    #Wrapper.print(\"%s: SN [%s], PO [%s] intfName [%s] getPTINvpairs [%r]\"% (funcName, sn, poPCId, intfName, getPTINvpairs))\n\n    entityName = intfName\n    nvPairs = None\n    update = False\n\n    if getPTINvpairs:\n        ptiList = Util.exe(PTI.getPTIs(sn, \"INTERFACE\", entityName, \"PYTHON\"))\n        #only one PTI so access it\n        if ptiList:\n            nvPairs = copy.deepcopy(ptiList[0].getNvPairs())\n        else:\n            Wrapper.print(\"Something wrong with intfName [%s] of [%s]\"%(intfName, poPCId))\n            return\n    else:\n        nvPairs = {}\n    Wrapper.print(\"%s: SN [%s], PO [%s] intfName [%s] nvPairs [%r]\"% (funcName, sn, poPCId, intfName, nvPairs))\n\n    intfMatchResult = interfacesRes[intfName]\n    templateNameMatches = intfMatchResult[\"matched_templates\"]\n    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n    for templateName in matchingNvPairs:\n        if (templateName == \"shut_interface\"):\n            currVal = nvPairs.get(\"ADMIN_STATE\", \"true\")\n            newVal = \"false\"\n            if currVal != newVal:\n                nvPairs[\"ADMIN_STATE\"] = newVal\n                update = True\n        elif (templateName == \"interface_desc\"):\n            currVal = nvPairs.get(\"DESC\", \"\")\n            newVal = matchingNvPairs[templateName][\"DESC\"]\n            if currVal != newVal:\n                nvPairs[\"DESC\"] = newVal\n                update = True\n\n    poMemberFF = intfMatchResult[\"unaccounted_cmds\"]\n\n    templateList = [\n                \"porttype_fast_trunk\",\n                \"vlan_interface_fwd_mode_11_1\",\n                \"interface_ipv4_tag_11_1\",\n                \"interface_ipv6_11_1\",\n                \"interface_ipv6_tag_11_1\",\n                \"bpduguard_disable\",\n                \"bpduguard_enable\",\n                \"cdp_disable_interface_11_1\"\n                ]\n    if isTrunk:\n        templateList.append(\"access_vlan\")\n        if not Util.isFexHIF(intfName):\n            templateList.append(\"porttype_fast_enable\")\n\n    combinedFF = poMemberFF + unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n\n    # get the final FF\n    if combinedFF:\n        isUpdated, newFF = getPoMemberFF(combinedFF, intfName)\n        #Wrapper.print(\"%s: PO [%s] Member Intf [%s]. isUpdated [%r] Original FF %s Filtered FF %s\" % (funcName,\n        #    poPCId, intfName, isUpdated, combinedFF, newFF))\n        if newFF:\n            currVal = nvPairs.get(\"CONF\", \"\")\n            newVal = Util.newLine().join(newFF)\n            if currVal != newVal:\n                nvPairs[\"CONF\"] = newVal\n                update = True\n\n    Wrapper.print(\"%s: SN [%s] PO [%s] intfName [%s] update [%r] nvPairs [%s]\"% (funcName, sn, poPCId, intfName, update, nvPairs))\n    return update, nvPairs\n\ndef poMemberDescAndFFUpd(sn, memberIntfList, ptiTemplate, poPCId, matchResult, interfacesRes, source):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: SN [%s], PO [%s] Member interfaces [%s]\"% (funcName, sn, poPCId, \",\".join(memberIntfList)))\n    for intfName in memberIntfList:\n        Wrapper.print(\"%s: Sn [%s] processing [%s] of [%s] for template [%s] and source [%s]\"%\n                      (funcName, sn, intfName, poPCId, ptiTemplate, source))\n\n        update, poMemberNvPairs = getPoMemberIntfNvpairs(sn, intfName, True if \"trunk\" in ptiTemplate else False, poPCId,\n            matchResult, interfacesRes, True)\n        if update:\n            createPTI(sn, poMemberNvPairs, ptiTemplate, intfName, source, -1)\n    Wrapper.print(\"%s: SN [%s] Exiting with intfName interfaces [%s]\"% (funcName, sn, \",\".join(memberIntfList)))\n\ndef getPoPeerDeviceSN(topologyDataObj, devSerial, intfName):\n    switchName = topologyDataObj.getHostName(devSerial)\n    Wrapper.print(\"getPoPeerDeviceSN: Input: [%s(%s)/%s]\" % (devSerial, switchName, intfName))\n    peerSerial = \"\"\n    peerName = \"\"\n    peerIntf = topologyDataObj.getNeighborIntf(devSerial, intfName)\n    if (peerIntf != \"\"):\n        peerSerial = topologyDataObj.getNeighborDeviceSN(devSerial, intfName)\n        Wrapper.print(\"getPoPeerDeviceSN: [%s/%s] peer -> [%s/%s]\" % (devSerial, intfName, peerSerial, peerIntf))\n        if (peerSerial != \"\"):\n            # we have a valid peer... check if it's migration state\n            if not isSwitchInUnderlayMigration(peerSerial):\n                # the expected PTIs should be in place\n                peerName = topologyDataObj.getHostName(peerSerial)\n                Wrapper.print(\"getPoPeerDeviceSN: peer serial [%s] is MIGRATED\" % peerSerial)\n            else:\n                peerIntf = \"\"\n                peerSerial = \"\"\n    Wrapper.print(\"getPoPeerDeviceSN: Returning [%s(%s)/%s]\" % (peerSerial, peerName, peerIntf))\n    return peerIntf, peerSerial\n\ndef getFabricIntfNvPairs(fabricName, devSerial, intfName, matchingNvPairs, \n                         LINK_STATE_ROUTING, REPLICATION_MODE, \n                         intfMatchResult, matchResult, vpcPKALink):\n    unnumberedIntf = False\n    Wrapper.print(\"getFabricIntfNvPairs: [%s/%s/%s]\" % (fabricName, devSerial, intfName))\n    nvPairs = {\"INTF_NAME\" : intfName,\n               \"IP\" : \"\",\n               \"PREFIX\" : \"\",\n               \"V6IP\" : \"\",\n               \"V6PREFIX\" : \"\",\n               \"LINK_STATE_ROUTING\":LINK_STATE_ROUTING,\n               \"OSPF_AREA_ID\" : OSPF_AREA_ID,\n               \"REPLICATION_MODE\":REPLICATION_MODE,\n               \"MTU\":\"\",\n               \"SPEED\":\"Auto\",\n               \"DESC\" : \"\",\n               \"ADMIN_STATE\" : \"true\",\n               \"PORTTYPE_FABRIC\" : \"false\",\n               \"CLASS_MAP\": \"\",\n               \"CONF\" : \"\"\n              }\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n            nvPairs[\"MTU\"] = matchingNvPairs[templateName][\"MTU\"]\n        elif (\"interface_speed\" == templateName):\n            nvPairs[\"SPEED\"] = Util.mapSwitchSpeedToEnum(matchingNvPairs[templateName][\"SPEED\"])\n        elif ((\"p2p_routed_interface\" == templateName) or (\"p2p_routed_interface_tag\" == templateName)):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n        elif (\"interface_ipv6_11_1\" == templateName):\n            nvPairs[\"V6IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"V6PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n        elif (\"ospf_interface_11_1\" == templateName or \"v6_ospf_interface\" == templateName):\n            nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"OSPF_TAG\"]})\n            nvPairs.update({\"OSPF_AREA_ID\" : matchingNvPairs[templateName][\"OSPF_AREA_ID\"]})\n        elif (\"isis_interface\" == templateName or \"v6_isis_interface\" == templateName):\n            nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"ISIS_TAG\"]})\n        elif (\"shut_interface\" == templateName):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (templateName == \"interface_desc\"):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"unnumbered_fabric_interface\" == templateName or \"unnumbered_fabric_interface_nov6\" == templateName):\n            unnumberedIntf = True\n            nvPairs.update({\"LOOPBACK_NAME\" : matchingNvPairs[templateName][\"LOOPBACK_NAME\"]})\n        elif (\"interface_vrf\" == templateName and vpcPKALink):\n            nvPairs[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n        elif (\"ospf_interface_auth\" == templateName):\n            nvPairs[\"OSPF_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY_ID\"]\n            nvPairs[\"OSPF_AUTH_KEY\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY\"]\n        elif (\"pim_interface_hello_auth\" == templateName):\n            nvPairs[\"PIM_HELLO_AUTH_KEY\"] = matchingNvPairs[templateName][\"AUTH_KEY\"]\n        elif (\"isis_interface_auth\" == templateName):\n            nvPairs[\"ISIS_AUTH_KEYCHAIN_NAME\"] = matchingNvPairs[templateName][\"ISIS_AUTH_KEYCHAIN_NAME\"]\n            nvPairs[\"IS_TYPE\"] = matchingNvPairs[templateName][\"IS_TYPE\"]\n        elif (\"isis_interface_auth_no_lvl\" == templateName):\n            nvPairs[\"ISIS_AUTH_KEYCHAIN_NAME\"] = matchingNvPairs[templateName][\"ISIS_AUTH_KEYCHAIN_NAME\"]\n            nvPairs[\"IS_TYPE\"] = ISIS_LEVEL\n        elif (\"bfd_no_echo_interface\" == templateName):\n            nvPairs[\"BFD_ECHO_DISABLE\"] = \"true\"\n        elif (\"interface_port_type_fabric\" == templateName):\n            nvPairs[\"PORTTYPE_FABRIC\"] = \"true\"\n        elif (\"bfd_interface_auth\" == templateName):\n            nvPairs[\"BFD_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"BFD_AUTH_KEY_ID\"]\n            nvPairs[\"BFD_AUTH_KEY\"] = matchingNvPairs[templateName][\"BFD_AUTH_KEY\"]\n\n    if \"BFD_AUTH_KEY\" not in nvPairs:\n        nvPairs[\"BFD_AUTH_KEY\"] = BFD_AUTH_KEY\n        nvPairs[\"BFD_AUTH_KEY_ID\"] = BFD_AUTH_KEY_ID\n    if \"OSPF_AUTH_KEY\" not in nvPairs:\n        nvPairs[\"OSPF_AUTH_KEY\"] = OSPF_AUTH_KEY\n        nvPairs[\"OSPF_AUTH_KEY_ID\"] = OSPF_AUTH_KEY_ID\n    if \"ISIS_AUTH_KEYCHAIN_NAME\" not in nvPairs:\n        nvPairs[\"ISIS_AUTH_KEYCHAIN_NAME\"] = ISIS_AUTH_KEYCHAIN_NAME\n        nvPairs[\"IS_TYPE\"] = ISIS_LEVEL\n\n    if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n        Wrapper.print(\"Device [%s]: Found unaccounted cfg for numbered intf [%s]\" % (devSerial, intfName))\n        nvPairs.update({\"CONF\": Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"])})\n\n    templateList = [\n                    \"access_vlan\", \n                    \"bpduguard_disable\", \n                    \"bpduguard_enable\", \n                    \"interface_no_nego_auto\",\n                    \"porttype_fast_enable\",\n                    \"porttype_fast_trunk\",\n                    \"vlan_interface_fwd_mode_11_1\",\n                    \"interface_ipv4_tag_11_1\",\n                    \"interface_ipv6_tag_11_1\",\n                    \"cdp_disable_interface_11_1\"\n                    ]\n    if unnumberedIntf:\n        templateList.append(\"ospf_p2p_interface\")\n    if not vpcPKALink:\n        templateList.append(\"interface_vrf\")\n    if not vpcPKALink:\n        if UNDERLAY_IS_V6 == \"false\":\n            # Underlay is V4, treat ipv6 address config as unaccounted\n            templateList.append(\"interface_ipv6_11_1\")\n        else:\n            # Underlay is V6, treat ip address config as unaccounted\n            templateList.append(\"interface_ipv4_11_1\")\n\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    if nvPairs[\"CONF\"] and configList:\n        nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n    elif configList:\n        nvPairs[\"CONF\"] = Util.newLine().join(configList)\n    Wrapper.print(\"getFabricIntfNvPairs: nvPairs [%s]\" % str(nvPairs))\n    return nvPairs\n\ndef setDot1qRMResource(fabricName, devSerial, intfName, dot1qID):\n    normalizedIntfName = intfName.capitalize() if intfName.lower().startswith(\"port-channel\") else intfName\n    key = Util.exe(Helper.getKey(\"Device\", devSerial))\n    ignore, rmId = Util.exeRM(RM.set(fabricName, \"TOP_DOWN_L3_DOT1Q\", key, normalizedIntfName, normalizedIntfName, dot1qID))\n    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: TOP_DOWN_L3_DOT1Q for [%s(%s)], dot1q [%s]: rmId [%s]\"%\n                  (fabricName, key, normalizedIntfName, intfName, dot1qID, rmId))\n    return rmId\n\ndef createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, fabricName, rmId = -1):\n    devSerial = switchInfo[\"deviceSerial\"]\n    dot1qID, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n    if dot1qID:\n        rmId = setDot1qRMResource(fabricName, devSerial, intfName, dot1qID)\n\n    # the \"catch all\" interface template\n    templateName = \"int_freeform\"\n    createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), rmId)\n\ndef get_user_allowed_vlan(intfName, allowed_vlan_orig, device_overlay_vlans):\n    if allowed_vlan_orig == \"none\":\n        return \"none\"\n\n    if allowed_vlan_orig == \"all\" or allowed_vlan_orig == \"1-4094\":\n        Wrapper.print(\"get_user_allowed_vlan %s: allowed vlan (all) %s\" % (intfName, allowed_vlan_orig))\n        return allowed_vlan_orig\n\n    top_down_vlan_list = []\n    allowed_vlan_str = allowed_vlan_orig\n\n    try:\n        interface_name = intfName.capitalize()\n        top_down_vlans = device_overlay_vlans[interface_name].getVlanList()\n        Wrapper.print(\"%s top_down_vlans %s\" % (interface_name, top_down_vlans))\n        for vlan in top_down_vlans:\n            top_down_vlan_list.append(vlan)\n        utilObj = Util()\n        allowed_vlan_orig_list = utilObj.getIntegerRange(allowed_vlan_orig)\n        allowed_vlans = set(allowed_vlan_orig_list) - set(top_down_vlan_list)\n        if not allowed_vlans:\n            Wrapper.print(\"get_user_allowed_vlan %s all topdown vlans: allowed_vlan_orig %s, top_down_vlan_list %s\" % (intfName, allowed_vlan_orig, top_down_vlan_list))\n            return \"none\"\n\n        allowed_vlan_str = utilObj.vlanStrFromList(allowed_vlans)\n    except Exception as e:\n        Wrapper.print(\"get_user_allowed_vlan exception %s on access device_overlay_vlans[%s]\" % (e, interface_name))\n\n    Wrapper.print(\"get_user_allowed_vlan %s, allowed_vlan_orig %s - top_down_vlan_list %s => allowed_vlan_str %s\" % (intfName, allowed_vlan_orig, top_down_vlan_list, allowed_vlan_str))\n    return allowed_vlan_str\n\ndef is_top_down_vlan(intfName, vlan_str, device_overlay_vlans):\n    try:\n        interface_name = intfName.capitalize()\n        top_down_vlans = device_overlay_vlans[interface_name].getVlanList()\n        Wrapper.print(\"%s config vlan %s top_down_vlans %s\" % (interface_name, vlan_str, top_down_vlans))\n        top_down_vlan_list = []\n        for vlan in top_down_vlans:\n            top_down_vlan_list.append(vlan)\n        if int(vlan_str) in top_down_vlan_list:\n            return True\n    except Exception as e:\n        Wrapper.print(\"is_vlan_top_down exception %s on access device_overlay_vlans[%s]\" % (e, interface_name))\n\n    return False\n\n# returns the access vlan if not an overlay vlan, else return \"\"\ndef processAccessIntfOverlayInfo(devSerial, migrationMode, intfName, accessVlanStr, globalOverlayInfo, device_overlay_vlans):\n    funcName = sys._getframe(0).f_code.co_name\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    reSyncAttachEntries = None\n    Wrapper.print(\"%s: Switch [%s] Mode [%s]. Intf [%s] Skip [%s] accessVlanStr = [%s] overlayVlans = [%s]\" % (funcName, devSerial,\n       migrationMode, intfName, BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS, accessVlanStr,\n       switchOverlayInfo[\"OVERLAY_VLANS\"] if switchOverlayInfo else \"N/A\"))\n    \n    if (accessVlanStr == \"1\"):\n        # default access vlan is 1 which is not an overlay vlan\n        return accessVlanStr;\n\n    if migrationMode == \"upgrade\":\n        # upgrade case\n        return \"\" if is_top_down_vlan(intfName, accessVlanStr, device_overlay_vlans) else accessVlanStr\n    else:\n        # reSync or brownAdd case\n        if ((BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS == \"true\") or (len(switchOverlayInfo[\"NETWORKS_VLAN2VNI\"]) == 0)):\n            # no overlays to process.. return the str as-is\n            return accessVlanStr\n        \n        if migrationMode == \"reSync\":\n            reSyncAttachEntries = globalOverlayInfo[\"HOST_PORT_RESYNC\"][\"networks\"][\"attachEntries\"]\n\n    vlanId = int(accessVlanStr)\n    #Wrapper.print(\"%s [%s]: Vlan [%d] Overlay Vlans [%s]\" % (funcName, intfName, vlanId, switchOverlayInfo[\"OVERLAY_VLANS\"]))\n\n    # get the network entry for this vlan\n    vniStr = switchOverlayInfo[\"NETWORKS_VLAN2VNI\"].get(vlanId, None)\n    if vniStr:\n        adjIntfname = intfName\n        if intfName.lower().startswith(\"port-channel\"):\n            # Topdown code expects the PO name to be capitalized\n            adjIntfname = intfName.capitalize()\n\n        if migrationMode == \"brownAdd\":\n            portList = switchOverlayInfo[\"NETWORKS_BY_ID\"][vniStr][\"attachInfo\"]\n        else:\n            # host port resync case\n            portList = reSyncAttachEntries[vniStr][devSerial][\"portList\"]\n\n        # add the interface to the list\n        #Wrapper.print(\"%s: Switch [%s] Adding intf [%s] to Network [VNI:%s VLAN:%d]\" % (funcName,\n        #                                    devSerial, adjIntfname, vniStr, vlanId))\n        portList.append(adjIntfname)\n        returnStr = \"\"\n    else:\n        returnStr = accessVlanStr\n\n    return returnStr\n\n# returns the trunk allowed vlan string excluding the overlay vlans\ndef processTrunkIntfOverlayInfo(devSerial, migrationMode, intfName, allowed_vlans, globalOverlayInfo, device_overlay_vlans):\n    funcName = sys._getframe(0).f_code.co_name\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n    isServiceLeaf = switchOverlayInfo[\"isServiceLeaf\"]\n\n    reSyncAttachEntries = None\n    Wrapper.print(\"%s: Switch [%s] Mode [%s]. Intf [%s] Skip [%s] allowed_vlans = [%s] overlayVlans = [%s]\" % (funcName, devSerial,\n       migrationMode, intfName, BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS, allowed_vlans,\n       switchOverlayInfo[\"OVERLAY_VLANS\"] if switchOverlayInfo else \"N/A\"))\n    \n    if migrationMode == \"upgrade\":\n        # upgrade case\n        return get_user_allowed_vlan(intfName, allowed_vlans, device_overlay_vlans)\n    else:\n        # reSync or brownAdd case\n        if ((BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS == \"true\") or (len(switchOverlayInfo[\"NETWORKS_VLAN2VNI\"]) == 0)):\n            # no overlays to process.. return the str as-is\n            return allowed_vlans\n        \n        if migrationMode == \"reSync\":\n            reSyncAttachEntries = globalOverlayInfo[\"HOST_PORT_RESYNC\"][\"networks\"][\"attachEntries\"]\n\n    if allowed_vlans in [\"none\", \"all\", \"1-4094\"]:\n        return allowed_vlans\n\n    utilObj = Util()\n    vlanList = utilObj.getIntegerRange(allowed_vlans)\n    #vlansToCheck = list(set(vlanList) & set(switchOverlayInfo[\"OVERLAY_VLANS\"])) \n    localVlans = []\n    for vlanId in vlanList:\n        vniStr = switchOverlayInfo[\"NETWORKS_VLAN2VNI\"].get(vlanId, None)\n        if vniStr:\n            portList = None\n            adjIntfname = intfName\n            if intfName.lower().startswith(\"port-channel\"):\n                # Topdown code expects the PO name to be capitalized\n                adjIntfname = intfName.capitalize()\n\n            if migrationMode == \"brownAdd\":\n                isServiceVlan = False\n                if isServiceLeaf:\n                    # check if the vlan maps to a service vlans... if yes.. do not add the post list\n                    # instead update the attached sw port\n                    if vniStr in servicesInfo[\"serviceSwMaps\"][devSerial][\"vnis\"]:\n                        isServiceVlan = True\n                        for serviceNodeName in servicesInfo[\"serviceSwMaps\"][devSerial][\"nodes\"]:\n                            srvcEntry = servicesInfo[\"serviceNodes\"][serviceNodeName]\n                            if \"swIntf\" in srvcEntry:\n                                continue\n\n                            # check each route peer entry for the matching vni\n                            for routePeerName in srvcEntry[\"routePeers\"]:\n                                rpEntry = srvcEntry[\"routePeers\"][routePeerName]\n                                for netType in rpEntry[\"nets\"]:\n                                    rpNetEntry = rpEntry[\"nets\"][netType]\n                                    if \"vni\" in rpNetEntry and rpNetEntry[\"vni\"] == vniStr:\n                                        Wrapper.print(\"%s: Service Switch [%s] Adding intf [%s] to Network [VNI:%s VLAN:%d]\" % (funcName,\n                                                                            devSerial, adjIntfname, vniStr, vlanId))\n                                        srvcEntry[\"swIntf\"] = intfName\n                if not isServiceVlan:\n                    portList = switchOverlayInfo[\"NETWORKS_BY_ID\"][vniStr][\"attachInfo\"]\n            else:\n                # host port resync case\n                #Wrapper.print(\"%s: Switch [%s] vniStr [%s]\" % (funcName, devSerial, vniStr))\n                portList = reSyncAttachEntries[vniStr][devSerial][\"portList\"]\n\n            if portList != None:\n                # add the interface to the list\n                Wrapper.print(\"%s: Switch [%s] Adding intf [%s] to Network [VNI:%s VLAN:%d]\" % (funcName,\n                                                    devSerial, adjIntfname, vniStr, vlanId))\n                portList.append(adjIntfname)\n        else:\n            # non overlay vlan\n            localVlans.append(vlanId)\n\n    if len(localVlans) > 0:\n        allowed_vlan_str = utilObj.vlanStrFromList(localVlans)\n    else:\n        allowed_vlan_str = \"none\"\n    #Wrapper.print(\"%s: Switch [%s] Intf [%s] Final allowed vlans [%s]\" % (funcName, devSerial, intfName, allowed_vlan_str))\n    return allowed_vlan_str\n\ndef isOverlaySvi(vlanId, switchOverlayInfo):\n    retVal = False\n    if vlanId in switchOverlayInfo[\"OVERLAY_VLANS\"]:\n        # check the network entry to make sure it is not a Layer2Only\n        #Wrapper.print(\"isOverlaySvi: vlan [%d]\" % (vlanId))\n        if vlanId in switchOverlayInfo[\"NETWORKS_VLAN2VNI\"]:\n            vniStr = switchOverlayInfo[\"NETWORKS_VLAN2VNI\"][vlanId]\n            if vniStr in switchOverlayInfo[\"NETWORKS_BY_ID\"]:\n                #Wrapper.print(\"isOverlaySvi: vni = [%s] vlan [%d]\" % (vniStr, vlanId))\n                if switchOverlayInfo[\"NETWORKS_BY_ID\"][vniStr][\"netTemplateParams\"][\"isLayer2Only\"] == \"false\":\n                    # the SVI exists, but, the network itself is a L2 only\n                    retVal = True\n        else:\n            Wrapper.print(\"isOverlaySvi: not a network vlan [%d]\" % (vlanId))\n            retVal = True\n    return retVal\n\ndef getVniTypeAndVlanId(vniTypeStr):\n    #Wrapper.print(\"getVniTypeAndVlanId: type [%s]\" % vniTypeStr)\n    entries = vniTypeStr.split(\"[\")\n    netType = entries[0].strip()\n    vlanOrvrfName = entries[1].split(\"]\")[0].strip()\n    #Wrapper.print(\"getVniTypeAndVlanId: type [%s], vlan or VRF Name [%s]\" % \n    #              (netType, vlanOrvrfName))\n    return netType, vlanOrvrfName\n\ndef getMatchingResultVlan(vlanIdStr, matchResults):\n    vlanKey = 'vlan ' + vlanIdStr\n    if vlanKey in matchResults[\"FEATURES_INFO\"][\"VLAN_BLOCK\"]:\n        return matchResults[\"FEATURES_INFO\"][\"VLAN_BLOCK\"][vlanKey]\n\n    return None\n\n# get a list of all the existing DCNM topdown network and vrf vlan ids (integers)\ndef getAllTopDownVlans(devSerial, device_overlay_vlans):\n    all_overlay_vlan_list = []\n    for x in device_overlay_vlans.entrySet():\n        all_overlay_vlan_list = list(set(all_overlay_vlan_list) | set(x.value.getVlanList()))\n\n    # get the vrf vlans also\n    all_overlay_vlan_list = list(set(all_overlay_vlan_list) | set(TopDownMigrationUtils.getOverlayVrfVlans(devSerial))) \n    Wrapper.print(\"getAllTopDownVlans: Switch [%s] all intf overlay vlans [%d][%s]\" % (devSerial, len(all_overlay_vlan_list), all_overlay_vlan_list))\n    Wrapper.print(\"getAllTopDownVlans: Switch [%s] VRF overlay vlans [%d][%s]\" % (devSerial, len(TopDownMigrationUtils.getOverlayVrfVlans(devSerial)), TopDownMigrationUtils.getOverlayVrfVlans(devSerial)))\n    Wrapper.print(\"getAllTopDownVlans: Switch [%s] Final all intf overlay vlans [%d][%s]\" % (devSerial, len(all_overlay_vlan_list), all_overlay_vlan_list))\n    return all_overlay_vlan_list\n\ndef getVrfsWithDns(nvPairsList, vrfsList):\n    for nvPair in nvPairsList:\n        if \"NAME_SERVER_VRF\" in nvPair:\n            vrfName = nvPair[\"NAME_SERVER_VRF\"]\n            if vrfName not in vrfsList:\n                vrfsList.append(vrfName)\n\ndef getNetworkSviOverlayParams(interfacesRes, sviName, netEntry, switchOverlayInfo, overlayVrfMisconfigList, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = switchOverlayInfo[\"SERIAL\"]\n    switchRole = switchOverlayInfo[\"switchRole\"]\n\n    intfMatchResult = interfacesRes.get(sviName)\n    Wrapper.print(\"%s: Switch [%s] Role [%s] SVI [%s] Exists [%r] doOverlayExtn [%s]\" %\n            (funcName, devSerial, switchRole, sviName, (True if intfMatchResult else False), switchOverlayInfo[\"doOverlayExtn\"]))\n    if intfMatchResult == None:\n        return\n\n    overlayVrfsNameToVni = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n    netTemplateParams = netEntry[\"netTemplateParams\"]\n\n    vrfName = \"\"\n    vrfVniStr = None\n\n    params = {}\n\n    # SVI exists.. need to check further\n    #   - must be in anycast-gw fwd mode\n    #   - must belong to a non-default VRF\n\n    isValidOverlaySvi = False\n    dhcpServerList = []\n    ipAddrSecCount = 1\n    for line in intfMatchResult[\"show_run_cmds\"]:\n        line = line.rstrip()\n        depth = (len(line) - len(line.lstrip(' '))) / 2\n\n        cmd = line.strip()\n        tokens = cmd.split()\n\n        if depth == 1:\n            # look for the expected top level commands\n            if cmd.startswith('vrf member '):\n                vrfName = tokens[2]\n                if vrfName.lower() not in overlayVrfsNameToVni:\n                    # invalid vrf??\n                    Wrapper.print(\"%s: ERROR - SVI [%s] Belongs to non-existent VRF [%s]\" % (funcName, sviName, vrfName))\n                    # check to ensure we report the error for the vrf only once\n                    if vrfName not in overlayVrfMisconfigList:\n                        isValidOverlaySvi = False\n                        overlayVrfMisconfigList.append(vrfName)\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"),\n                           \"Possible missing configuration(s) for Overlay VRF [%s]. Please resolve and retry Recalculate & Deploy\" %\n                           (vrfName), devSerial)\n                        respObj.setFailureRetCode()\n                    return\n                else:\n                    vrfVniStr = overlayVrfsNameToVni[vrfName.lower()][\"vni\"]\n            elif cmd == \"fabric forwarding mode anycast-gateway\":\n                isValidOverlaySvi = True\n            elif cmd.startswith('ip address '):\n                if \"secondary\" in cmd:\n                    if ipAddrSecCount > 4:\n                        # we have accounted for what we can handle.. push this to unaccounted config\n                        intfMatchResult[\"unaccounted_cmds\"].append(line)\n                        continue\n                    secGwParamName = (\"secondaryGW%d\" % ipAddrSecCount)\n                    params[secGwParamName] = tokens[2]\n                    if \"tag\" in cmd:\n                        params['tag'] = tokens[5]\n                    ipAddrSecCount += 1\n                else:\n                    # primary IPv4 address with prefix\n                    params['gatewayIpAddress'] = tokens[2]\n                    if \"tag\" in cmd:\n                        params['tag'] = tokens[4]\n            elif cmd.startswith('ipv6 address '):\n                # primary IPv6 address with prefix\n                if 'gatewayIpV6Address' in params and params['gatewayIpV6Address'] != \"\":\n                    params['gatewayIpV6Address'] = params['gatewayIpV6Address'] + \",\" + tokens[2]\n                else:\n                    params['gatewayIpV6Address'] = tokens[2]\n                if \"tag\" in cmd:\n                    params['tag'] = tokens[4]\n            elif cmd.startswith('ip dhcp relay address '):\n                if len(dhcpServerList) >= NET_PROFILE_DHCP_SERVERS_MAX:\n                    intfMatchResult[\"unaccounted_cmds\"].append(line)\n                    continue\n\n                dhcpServerList.append({\"srvrAddr\" : tokens[4], \"srvrVrf\" : (tokens[6] if (\"use-vrf\" in cmd) else \"\")})\n            elif cmd.startswith('ip dhcp relay source-interface '):\n                if tokens[4].lower().startswith(\"loopback\"):\n                    params['loopbackId'] = tokens[4][8:]\n            elif cmd.startswith('description '):\n                params['intfDescription'] = cmd[len('description '):]\n            elif cmd.startswith('mtu '):\n                params['mtu'] = cmd[len('mtu '):]\n\n    if isValidOverlaySvi:\n        if vrfName == \"\":\n            return\n\n        params[\"vrfName\"] = vrfName\n        params[NET_PROFILE_DHCP_SERVERS_VAR] = buildOverlayNetDhcpStructString(dhcpServerList, vrfName)\n\n        # move the params to the network template params\n        for paramName in params.keys():\n            netTemplateParams[paramName] = params[paramName]\n\n        netEntry[\"vrfName\"] = netTemplateParams[\"vrfName\"]\n        netTemplateParams[\"isLayer2Only\"] = \"false\"\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            netTemplateParams[\"enableL3OnBorder\"] = \"true\"\n\n        # add this network to the VRF network membership list\n        overlayVrfsInfoById[vrfVniStr][\"networks\"].append(str(netEntry[\"vni\"]))\n\ndef gatherCliOverlays(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, switchOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchRole = switchOverlayInfo[\"switchRole\"]\n    vlanNameSupported = (globalOverlayInfo[\"overlayVlanNameSupported\"] == \"true\")\n    includeAllCfg = (globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"] == \"false\")\n    \n    Wrapper.print(\"%s: Switch [%s] Role [%s] vlanNameSupported [%r], includeAllCfg [%r]\" % \n        (funcName, devSerial, switchRole, vlanNameSupported, includeAllCfg))\n\n    switchVxlanInfo = switchOverlayInfo[\"SWITCH_VXLAN_INFO\"]\n    vlanIdInfo = switchVxlanInfo[\"vlanIdInfo\"]\n    vrfVnis = switchVxlanInfo[\"vrfVnis\"]\n    networkVnis = switchVxlanInfo[\"networkVnis\"]\n\n    for vniStr in vlanIdInfo[\"VNIS\"]:\n        vlanIdStr = vlanIdInfo[\"VNIS\"][vniStr]\n        matchingVlanEntry = getMatchingResultVlan(vlanIdStr, matchResults)\n        if not matchingVlanEntry:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRF VLAN\"),\n                \"Overlay VNI [%s]. Did not find vlan configuration for [%s]. Please resolve and retry 'Recalculate & Deploy'\" %\n                (vniStr, vlanIdStr), devSerial)\n            respObj.setFailureRetCode()\n            return\n        else:\n            for vlanCmd in matchingVlanEntry[\"show_run\"]:\n                if \"private-vlan\" in vlanCmd:\n                    Wrapper.print(\"%s: vlan [%s] has unsupported pvlan cmd: %s\" % (funcName, vlanIdStr, vlanCmd))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OVERLAY\"),\n                        \"Cannot have private-vlan config on VNI VLANs.\", devSerial)\n                    respObj.setFailureRetCode()\n                    return\n\n    nvPairList = getTemplateMatchResults(matchResults, \"vlan_name_11_1\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            # check to make sure the name is not the default\n            vlanIdInt = int(nvPair[\"VLAN\"])\n            vlanName = nvPair[\"NAME\"]\n            if vlanName == (\"VLAN%04d\" % vlanIdInt):\n                vlanName = \"\"\n            vlanIdInfo[\"VLANS\"].update({nvPair[\"VLAN\"] : {\"name\" : vlanName}})\n\n    # dictionary of vrf name (key) and its description (value)\n    vrfDescInfo = {}\n    nvPairList = getTemplateMatchResults(matchResults, \"vrf_desc_11_1\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            vrfDescInfo.update({nvPair[\"VRF_NAME\"] : nvPair[\"DESC\"]})\n\n    overlayVrfsNameToVni = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n\n    # process the VRFs first\n    Wrapper.print(\"%s: **** Processing VRFs\" % (funcName))\n    for vniEntry in vrfVnis:\n        # parse the type field\n        vniStr = vniEntry[\"vni\"]\n        Wrapper.print(\"%s: VRF VNI [%s]\" % (funcName, vniStr))\n\n        netType, vrfName = getVniTypeAndVlanId(vniEntry[\"type\"])\n\n        # get the VRF Vlan info from the switch\n        vrfAttachVlan = int(vlanIdInfo[\"VNIS\"][vniStr] if vlanIdInfo[\"VNIS\"].get(vniStr) else 0)\n        if vrfAttachVlan == 0:\n            # could not find the VLAN for the VRF VNI\n            Wrapper.print(\"%s: Switch [%s]. Did not find the Vlan Id for the VRF VNI [%s] [%s]\" % (funcName, devSerial, vniStr, vrfName))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRF VLAN\"),\n                    \"Did not find the Vlan Id for the VRF VNI [%s] [%s]. Please resolve and retry 'Recalculate & Deploy'\" %\n                    (vniStr, vrfName), devSerial)\n            respObj.setFailureRetCode()\n            continue\n        elif vrfAttachVlan == 1:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VLAN 1 VXLAN\"), \"VRF Vlan 1, VNI %s VXLAN overlay is \"\n                \"not supported. Please resolve and retry 'Recalculate & Deploy'\" % (vniStr), devSerial)\n            respObj.setFailureRetCode()\n            continue\n\n        switchOverlayInfo[\"OVERLAY_VLANS\"].append(vrfAttachVlan)\n\n        vrfAttachVlanStr = str(vrfAttachVlan)\n\n        if vlanNameSupported:\n            vrfVlanNameStr = vlanIdInfo[\"VLANS\"][vrfAttachVlanStr][\"name\"] if vlanIdInfo[\"VLANS\"].get(vrfAttachVlanStr) else \"\"\n        else:\n            vrfVlanNameStr = \"\"\n\n        # parameters used during VRF create\n        vrfTemplateParams = {\n            \"vrfVlanId\" : vrfAttachVlanStr,\n            \"vrfName\": vrfName,\n            \"vrfSegmentId\": vniStr,\n            \"nveId\" : \"1\",\n            \"vrfVlanName\" : vrfVlanNameStr,\n            \"vrfIntfDescription\" : \"\",\n            \"vrfDescription\" : vrfDescInfo[vrfName] if vrfDescInfo.get(vrfName) else \"\",\n            \"vrfRouteMap\" : \"\",\n            \"maxBgpPaths\" : \"1\",\n            \"maxIbgpPaths\" : \"1\",\n            \"asn\" : BGP_AS,\n            \"tag\" : \"\",\n            \"isRPExternal\" : \"false\",\n            \"trmBGWMSiteEnabled\" : \"false\",\n            \"trmEnabled\" : \"false\",\n            \"advertiseHostRouteFlag\" : \"true\",\n            \"advertiseDefaultRouteFlag\" : \"true\",\n            \"configureStaticDefaultRouteFlag\" : \"true\",\n            \"ipv6LinkLocalFlag\" : \"false\"\n        }\n\n        vrfEntry = {\n                    'name' : vrfName,\n                    'vni' : vniStr,\n                    # this is the local vlan that the VRF is attached to\n                    'vlanId' : vrfAttachVlan,\n                    'vrfTemplateParams' : vrfTemplateParams,\n                    # list of network VNIs (integer) associated with this VRF\n                    'networks' : [],\n                    # VRF attach extension values\n                    'extensionVals' : \"\",\n                    # VRF attach instance values\n                    'instanceVals' : \"\",\n                    # the additional configuration that could not be accounted for in the config profile\n                    'freeformCfg' : None,\n                   }\n\n        nvPairList = getTemplateMatchResults(matchResults, \"bgp_overlay_vrf_ipv4_redist_rmap_11_1\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if nvPair[\"VRF_NAME\"] == vrfName:\n                    vrfTemplateParams[\"vrfRouteMap\"] = nvPair[\"RMAP\"] \n                    break\n        nvPairList = getTemplateMatchResults(matchResults, \"bgp_overlay_vrf_ipv4_max_bgp_paths_11_1\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if nvPair[\"VRF_NAME\"] == vrfName:\n                    vrfTemplateParams[\"maxBgpPaths\"] = nvPair[\"MAX_PATHS\"]\n                    break\n        nvPairList = getTemplateMatchResults(matchResults, \"bgp_overlay_vrf_ipv4_max_ibgp_paths_11_1\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if nvPair[\"VRF_NAME\"] == vrfName:\n                    vrfTemplateParams[\"maxIbgpPaths\"] = nvPair[\"MAX_PATHS\"]\n                    break\n\n        # need to check if a SVI exists for the locally attached vlan\n        sviName = 'Vlan'+ str(vrfAttachVlan)\n        intfMatchResult = interfacesRes.get(sviName)\n        if intfMatchResult != None:\n            Wrapper.print(\"%s: Found SVI [%s] for VRF [%s]\" % (funcName, sviName, vrfName))\n            templates = [\"interface_desc\", \"vlan_interface_ipv6_link_local_11_1\", \"interface_mtu\"]\n            matchingNvPairs = getIntfMatchNvPairs(matchResults, sviName, templates)\n            for templateName in templates:\n                if templateName in matchingNvPairs:\n                    nvPair = matchingNvPairs[templateName]\n                    if (templateName == \"interface_desc\"):\n                        vrfTemplateParams[\"vrfIntfDescription\"] = nvPair[\"DESC\"]\n                    elif (templateName == \"vlan_interface_ipv6_link_local_11_1\"):\n                        vrfTemplateParams[\"ipv6LinkLocalFlag\"] = \"true\"\n                    elif (templateName == \"interface_mtu\"):\n                        vrfTemplateParams[\"mtu\"] = nvPair[\"MTU\"]\n\n        vrfEntry[\"freeformCfg\"] = getVrfFreeformCfg(devSerial, vrfName, vniStr, vrfAttachVlanStr, \n                                                    matchResults, interfacesRes, includeAllCfg, switchOverlayInfo, None)\n\n        overlayVrfsNameToVni[vrfEntry[\"name\"].lower()] = {\"origName\" : vrfEntry[\"name\"], \"vni\" : vniStr}\n        overlayVrfsInfoById[vrfEntry[\"vni\"]] = vrfEntry\n        Wrapper.print(\"%s: Switch [%s]. VRF VNI [%s] [%s]. Entry %s\" % (funcName, devSerial, vniStr, vrfName, vrfEntry))\n\n    # process the network VNIs\n    Wrapper.print(\"%s: **** Processing Networks\" % (funcName))\n    networksInfo = switchOverlayInfo[\"NETWORKS_BY_ID\"]\n    overlayVrfMisconfigList = []\n    for vniEntry in networkVnis:\n        vniStr = vniEntry[\"vni\"]\n        Wrapper.print(\"%s: Network VNI [%s]\" % (funcName, vniStr))\n        # do some validation checks\n        errMsg = None\n        if vniEntry[\"mcast\"] == \"UnicastBGP\":\n            # not a ingress replication VNI.. check against fabric setting\n            if REPLICATION_MODE != \"Ingress\":\n                errMsg = (\"VXLAN network VNI [%s] setup for Ingress Replication while Fabric Replication Setting is [%s]\" % \n                    (vniStr, REPLICATION_MODE))\n        else:\n            if REPLICATION_MODE == \"Ingress\":\n                errMsg = (\"VXLAN network VNI [%s] setup for Multicast Replication while Fabric Replication Setting is [%s]\" % \n                    (vniStr, REPLICATION_MODE))\n        if errMsg:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"), errMsg, devSerial)\n            respObj.setFailureRetCode()\n            continue\n\n        # parse the type field\n        netType, vlanId = getVniTypeAndVlanId(vniEntry[\"type\"])\n        if vlanId == \"1\":\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VLAN 1 VXLAN\"), \"Network Vlan 1, VNI %s VXLAN overlay is \"\n                \"not supported. Please resolve and retry 'Recalculate & Deploy'\" % (vniStr), devSerial)\n            respObj.setFailureRetCode()\n            continue\n\n        switchOverlayInfo[\"OVERLAY_VLANS\"].append(int(vlanId))\n        if vlanNameSupported:\n            vlanNameStr = vlanIdInfo[\"VLANS\"][vlanId][\"name\"] if vlanIdInfo[\"VLANS\"].get(vlanId) else \"\"\n        else:\n            vlanNameStr = \"\"\n\n        vniFlags = vniEntry[\"flags\"] if \"flags\" in vniEntry else vniEntry[\"vni-flags\"]\n        netTemplateParams = {\n            # mandatory parameters\n            'vlanId' : \"\",\n            'vlanName' : vlanNameStr,\n            'segmentId' : vniStr,\n            'tag' : \"\",\n            'vrfName' : \"NA\",\n\n            # non-mandatory parameters\n            'isLayer2Only' : \"true\",\n            'suppressArp' : \"true\" if (vniFlags and (\"SA\" in vniFlags)) else \"false\",\n            'mcastGroup' : vniEntry[\"mcast\"] if (vniEntry[\"mcast\"] != \"UnicastBGP\") else \"\",\n            'enableIR' : \"true\" if (vniEntry[\"mcast\"] == \"UnicastBGP\") else \"false\",\n            'nveId' : \"1\",\n            'rtBothAuto' : \"false\",\n            # set to 'true' if the border role switches have the svi (for a L3 network)\n            'enableL3OnBorder' : \"false\"\n            }\n\n        netEntry = {\n            # the 'overlayNetName' will be set later \n            'vni': int(vniStr),\n            'vlanId' : int(vlanId),\n            'vlanName' : netTemplateParams[\"vlanName\"],\n            \"netTemplateParams\" : netTemplateParams,\n            'vrfName' : \"NA\",\n            # Network attach extension values\n            'extensionVals' : \"\",\n            # the additional configuration that could not be accounted for in the config profile\n            'freeformCfg' : \"\",\n            # list of interface names. Collected from trunk and access host interfaces where the vlan is enabled explictly,\n            'attachInfo' : []\n        }\n\n        nvPairList = getTemplateMatchResults(matchResults, \"evpn_vni_rt_both_11_1\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if (nvPair[\"VNSEG\"] == vniStr):\n                    netTemplateParams[\"rtBothAuto\"] = \"true\"\n                    break\n\n        # need to check if a SVI exists for this vlan\n        sviName = 'Vlan'+ vlanId\n        intfMatchResult = interfacesRes.get(sviName)\n        getNetworkSviOverlayParams(interfacesRes, sviName, netEntry, switchOverlayInfo, overlayVrfMisconfigList, respObj)\n\n        if (netTemplateParams[\"vlanId\"] == \"\"):\n            # this is the first time we are initializing... set it to the vlan we find. Most likely the same vlan\n            # will be used in all switches. Note that the attach will be for the exact vlan found on the switches\n            netTemplateParams[\"vlanId\"] = netEntry[\"vlanId\"]\n        netEntry[\"freeformCfg\"] = getNetworkFreeformCfg(vniStr, vlanId, matchResults, interfacesRes, includeAllCfg)\n        networksInfo[vniStr] = netEntry\n        switchOverlayInfo[\"NETWORKS_VLAN2VNI\"][netEntry[\"vlanId\"]] = vniStr\n\ndef getAdjustedLinkSerial(nbrSwInfo):\n    serialNum = nbrSwInfo[\"sw-serial-number\"]\n    if ((\"is-vdc\" in nbrSwInfo) and (nbrSwInfo[\"is-vdc\"] == \"true\")):\n        vdc_id = int(nbrSwInfo[\"vdc-id\"])\n        if vdc_id != 1:\n            serialNum = (\"%s:%s\" % (serialNum, nbrSwInfo[\"sw-vdc-name\"]))\n\n    return serialNum\n\ndef getIPAndPrefix(ipAddrWithMask):\n    parts = ipAddrWithMask.split(\"/\")\n    return parts[0], parts[1]\n\ndef buildVrfLiteIFCEntry(ifcEntry, vrfLiteEntry, weAreSrc, srcInfo, dstInfo):\n    funcName = sys._getframe(0).f_code.co_name\n\n    Wrapper.print(\"****%s: SRC: sw-serial-number [%s] if-name [%s] fabric-name [%s]. srcInfo: [%s]\" % (funcName,\n        srcInfo.get(\"sw-serial-number\"), srcInfo.get(\"if-name\"), srcInfo.get(\"fabric-name\"), srcInfo))\n    Wrapper.print(\"****%s: DST: sw-serial-number [%s] if-name [%s] fabric-name [%s]. dstInfo: [%s]\" % (funcName,\n        dstInfo.get(\"sw-serial-number\"), dstInfo.get(\"if-name\"), dstInfo.get(\"fabric-name\"), dstInfo))\n\n    nvPairs = {\"MTU\" : \"\", \"PEER1_DESC\" : \"\", \"PEER2_DESC\": \"\", \"PEER1_CONF\" : \"\", \"PEER2_CONF\" : \"\",\n               \"PEER_VRF_NAME\" : \"\", \"AUTO_VRF_LITE_FLAG\" : \"false\",\n               'VRF_LITE_JYTHON_TEMPLATE' : VRF_LITE_IFC_PYTHON_POLICY\n              }\n\n    # need to extract the IPv4 and IPv6 prefix\n    localV4IP = \"\"\n    localV4Prefix = \"\"\n    if vrfLiteEntry[\"IP_MASK\"] != \"\":\n        localV4IP, localV4Prefix = getIPAndPrefix(vrfLiteEntry[\"IP_MASK\"])\n\n    localV6IP = \"\"\n    localV6Prefix = \"\"\n    if vrfLiteEntry[\"IPV6_MASK\"] != \"\":\n        localV6IP, localV6Prefix = getIPAndPrefix(vrfLiteEntry[\"IPV6_MASK\"])\n\n    # for the IFC, the src and dst must be built depending on whether we are the source or not\n    if weAreSrc:\n        nvPairs[\"asn\"] = BGP_AS\n        nvPairs[\"NEIGHBOR_ASN\"] = vrfLiteEntry['NEIGHBOR_ASN']\n\n        nvPairs[\"IP_MASK\"] = vrfLiteEntry['IP_MASK']\n        nvPairs[\"NEIGHBOR_IP\"] = vrfLiteEntry['NEIGHBOR_IP']\n\n        nvPairs[\"IPV6_MASK\"] = vrfLiteEntry['IPV6_MASK']\n        nvPairs[\"IPV6_NEIGHBOR\"] = vrfLiteEntry['IPV6_NEIGHBOR']\n    else:\n        nvPairs[\"asn\"] = vrfLiteEntry['NEIGHBOR_ASN']\n        nvPairs[\"NEIGHBOR_ASN\"] = BGP_AS\n\n        nvPairs[\"IP_MASK\"] = vrfLiteEntry['NEIGHBOR_IP'] + \"/\" + localV4Prefix\n        nvPairs[\"NEIGHBOR_IP\"] = localV4IP\n\n        if vrfLiteEntry[\"IPV6_MASK\"] != \"\":\n            nvPairs[\"IPV6_MASK\"] = vrfLiteEntry['IPV6_NEIGHBOR'] + \"/\" + localV6Prefix\n            nvPairs[\"IPV6_NEIGHBOR\"] = localV6IP\n        else:\n            nvPairs[\"IPV6_MASK\"] = \"\"\n            nvPairs[\"IPV6_NEIGHBOR\"] = \"\"\n\n    nvPairs['LINK_UUID'] = ifcEntry[\"LINK_UUID\"]\n    nvPairs['SOURCE_FABRIC_NAME'] = srcInfo['fabric-name']\n    nvPairs['SOURCE_SERIAL_NUMBER'] = getAdjustedLinkSerial(srcInfo)\n    nvPairs['SOURCE_SWITCH_NAME'] = srcInfo['sw-sys-name']\n    nvPairs['SOURCE_IF_NAME'] = srcInfo['if-name']\n    nvPairs['DEST_FABRIC_NAME'] = dstInfo['fabric-name']\n    nvPairs['DEST_SERIAL_NUMBER'] = getAdjustedLinkSerial(dstInfo)\n    nvPairs['DEST_SWITCH_NAME'] = dstInfo['sw-sys-name']\n    nvPairs['DEST_IF_NAME'] = dstInfo['if-name']\n\n    ifcEntry[\"nvPairs\"] = nvPairs\n    ifcEntry[\"entityName\"] = (nvPairs['SOURCE_SERIAL_NUMBER'] + Helper.DELIMITER + srcInfo.get(\"if-name\") +\n          Helper.DELIMITER + nvPairs['DEST_SERIAL_NUMBER'] + Helper.DELIMITER + dstInfo.get(\"if-name\"))\n\ndef createVrfLiteIFCEntry(switchInfo, switchOverlayInfo, vrfLiteEntry, linkNbrList, vrfLiteMissingParentIntfs, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    fmtName = switchInfo[\"fmtName\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n\n    # vrfLiteEntry = {\"IF_NAME\" : vrfLiteIntfIfName,\n    #          \"DOT1Q_ID\" : vrfLiteIntfEntry[\"DOT1Q_ID\"],\n    #          \"IP_MASK\" : vrfLiteIntfEntry[\"IP_MASK\"] if \"IP_MASK\" in vrfLiteIntfEntry else \"\",\n    #          \"IPV6_MASK\" : vrfLiteIntfEntry[\"IPV6_MASK\"] if \"IPV6_MASK\" in vrfLiteIntfEntry else \"\",\n    #          \"NEIGHBOR_IP\" : \"\",\n    #          \"IPV6_NEIGHBOR\" : \"\",\n    #          \"NEIGHBOR_ASN\" : \"\",\n    #          \"AUTO_VRF_LITE_FLAG\" : \"false\", \"PEER_VRF_NAME\" : \"\",\n    #          \"VRF_LITE_JYTHON_TEMPLATE\" : \"Ext_VRF_Lite_Jython\"}\n    #\n    # ifcEntry = { \"linkUUID\" : \"\", entityName\" = \"\",\n    #              nvPairs = { \"LINK_UUID\": linkUUID, \"SOURCE_FABRIC_NAME\" : \"\", DEST_FABRIC_NAME': \"\", \"SOURCE_SERIAL_NUMBER\": \"\", \n    #                           \"DEST_SERIAL_NUMBER\" : \"\",\n    #                           \"SOURCE_SWITCH_NAME\"  : \"\", \"DEST_SWITCH_NAME\" : \"\", \"SOURCE_IF_NAME\" : \"\"\n    #                           \"DEST_IF_NAME\", \"\", \"asn\" : \"\", \"IP_MASK\" : \"\", \"NEIGHBOR_IP\" : \"\", 'NEIGHBOR_ASN' : \"\",\n    #                           \"DOT1Q_ID\" : \"\", \"IPV6_MASK\" : \"\", \"IPV6_NEIGHBOR\" : \"\", \"MTU\" : \"\", \"PEER1_DESC\" : \"\"\n    #                           \"PEER2_DESC\",  \"\", \"PEER1_CONF\" : \"\", \"PEER2_CONF\" : \"\", \"AUTO_VRF_LITE_FLAG\" : \"\",\n    #                           \"PEER_VRF_NAME\" : \"\", 'VRF_LITE_JYTHON_TEMPLATE' : \"\"\n    #                        }\n    #            }\n\n    # this is the subif parent interface name. it is assumed to be a routed interface\n    ifName = vrfLiteEntry['IF_NAME']\n\n    Wrapper.print(\"%s: [%s], parent VRF-Lite intf [%s]\" % (funcName, fmtName, ifName))\n    if ifName in switchOverlayInfo[\"IFCS\"][\"VRF_LITE\"]:\n        # parent entry exists.. nothing more to do\n        Wrapper.print(\"****%s: IFC entry exists for [%s] existing entry [%s]\" % (funcName, ifName,\n            switchOverlayInfo[\"IFCS\"][\"VRF_LITE\"][ifName]))\n        return\n\n    # need to create a new IFC entry\n    entryFound = False\n\n    # look for a matching link\n    lowerIntfName = ifName.lower()\n    for linkNbr in linkNbrList:\n        # SWITCH2 INFO==[{u'sw-UUID-ID': 3000, u'sw-model-name': u'N9K-C9396PX', u'ethsw-DBID': 3050, u'fabric-name': u'easy', \n        # u'is-vdc': u'false', u'switch-role': u'leaf', u'if-admin-status': u'Up', u'if-name': u'Ethernet1/1', \n        # u'sw-serial-number': u'SAL1833YM64', u'if-op-reason': u'none', u'if-op-status': u'Up', u'fabric-id': u'3', \n        # u'vdc-id': u'0', u'sw-UUID': u'DCNM-UUID-3000', u'sw-sys-name': u'n9k7_bp2-lfsw04-l001'}]\n\n        sw1Info = json.loads(linkNbr.get(\"sw1-info\"))\n        sw2Info = json.loads(linkNbr.get(\"sw2-info\"))\n\n        if ((sw1Info.get(\"sw-serial-number\") == devSerial) and (sw1Info.get(\"if-name\").lower() == lowerIntfName) and\n            (sw1Info.get(\"fabric-name\") == FABRIC_NAME)):\n            entryFound = True\n        elif ((sw2Info.get(\"sw-serial-number\") == devSerial) and (sw2Info.get(\"if-name\").lower() == lowerIntfName) and\n              (sw2Info.get(\"fabric-name\") == FABRIC_NAME)):\n            entryFound = True\n\n        if not entryFound:\n            continue\n\n        Wrapper.print(\"%s: [%s] VRF-Lite entry [%s]\" % (funcName, fmtName, vrfLiteEntry))\n\n        ifcEntry = {\"LINK_UUID\" : linkNbr.get(\"link-uuid\")}\n\n        pairSerial = Util.exe(Helper.getLinkOrderByLinkUUid(linkNbr.get(\"link-uuid\")))\n        if pairSerial[\"sw1-serial-number\"] == sw1Info.get(\"sw-serial-number\"):\n            # we are the source for the IFC\n            buildVrfLiteIFCEntry(ifcEntry, vrfLiteEntry, True, sw1Info, sw2Info)\n        else:\n            buildVrfLiteIFCEntry(ifcEntry, vrfLiteEntry, False, sw2Info, sw1Info)\n\n        Wrapper.print(\"****%s: pairSerial [%s], ifname [%s] ifcEntry [%s]\" % (funcName, pairSerial, ifName, ifcEntry))\n        switchOverlayInfo[\"IFCS\"][\"VRF_LITE\"][ifName] = ifcEntry\n        break\n    \n    if ((not entryFound) and (ifName not in vrfLiteMissingParentIntfs)):\n        # report error.. our local link must be connected to another fabric\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRFLITE_IFC\"),\n            \"Could not locate the peer interface for VRF-Lite parent interface [%s]. Please ensure that the link \"\n            \"is correctly discovered or add the VRF-Lite IFC for a meta device\" % (ifName), devSerial)\n        respObj.setFailureRetCode()\n\n        vrfLiteMissingParentIntfs.append(ifName)\n\n# parse and return the over network svis only (must have 'fabric forwarding mode anycast-gateway')\ndef getCfgProfileOverlaySviInfo(devSerial, matchResults):\n    funcName = sys._getframe(0).f_code.co_name\n\n    cfgProfiles = matchResults[\"FEATURES_INFO\"][\"CFG_PROFILES\"]\n\n    sviInfo = {}\n\n    # dictionary of valid profiles to process. .key is the actual profile name; ex: MyNetwork_30000\n    profilesToProcess = {}\n\n    # gather all the applied profiles on the switch\n    appliedProfiles = getTemplateMatchResults(matchResults, \"apply_profile\")\n    if appliedProfiles:\n        for profileNvPair in appliedProfiles:\n            # add a dummy dictionary entry\n            profilesToProcess[profileNvPair[\"PROFILE_NAME\"]] = None\n\n    for profileCmd in cfgProfiles:\n        profileName = profileCmd.split()[2]\n\n        if profileName in profilesToProcess:\n            # update the dictionary entry with the match entry\n            profilesToProcess[profileName] = cfgProfiles[profileCmd]\n\n    # process each config profile\n    for profileName in profilesToProcess:\n        profileEntry = profilesToProcess[profileName]\n        if profileEntry == None:\n            # not possible, but, better be safe\n            continue\n\n        context = None\n        vlanId = None\n        sviParams = {}\n        for line in profileEntry['show_run']:\n            line = line.rstrip()\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                # skip the 'configure profile xxxx' line\n                continue\n\n            cmd = line.strip()\n            tokens = cmd.split()\n\n            #Wrapper.print(\"%s: Line [%s], depth [%d], cmd [%s] tokens [%s]\" %  (funcName, line, depth, cmd, tokens))\n\n            if depth == 1:\n                # look for the expected top level commands\n                if cmd.startswith('interface '):\n                    lowerIntfName = tokens[1].lower().strip()\n                    if lowerIntfName.startswith(\"vlan\"):\n                        context = \"svi\"\n                        sviParams[\"vlanId\"] = lowerIntfName[4:]\n            elif depth == 2:\n                if context == \"svi\":\n                    if cmd.startswith('description '):\n                        sviParams[\"desc\"] = cmd[len('description '):]\n                    elif cmd.startswith('vrf member '):\n                        sviParams['vrfName'] = tokens[2]\n                    elif cmd == ('fabric forwarding mode anycast-gateway'):\n                        sviParams['isNetSvi'] = True\n                    elif cmd.startswith('ip address '):\n                        if \"secondary\" not in cmd:\n                            # primary IP address\n                            sviParams['ipv4'] = tokens[2]\n                            if \"tag\" in cmd:\n                                sviParams[\"tag\"] = tokens[4]\n\n        if (('isNetSvi' in sviParams) and (\"vlanId\" in sviParams)):\n            sviParams[\"profileName\"] = profileName\n            sviInfo[sviParams[\"vlanId\"]] = sviParams\n\n    return sviInfo\n\ndef buildOverlayNetDhcpStructString(dhcpServersList, netVrfName):\n    funcName = sys._getframe(0).f_code.co_name\n\n    # normalize the dhcp relay vrf\n    for entry in dhcpServersList:\n        if entry[\"srvrVrf\"] == \"\":\n            entry[\"srvrVrf\"] = netVrfName\n    string = \"\" if (len(dhcpServersList)== 0) else json.dumps({NET_PROFILE_DHCP_SERVERS_VAR : dhcpServersList})\n\n    # Wrapper.print(\"%s: dhcpServersList %s, JSON string %s\" % (funcName, dhcpServersList, string))\n    return string\n\ndef gatherCfgProfileOverlays(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo,\n                            switchOverlayInfo, cfgProfiles):\n    funcName = sys._getframe(0).f_code.co_name\n    switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n    switchRole = switchInfo['switchRole']\n    formattedName = switchInfo[\"fmtName\"]\n\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n    isServiceLeaf = switchOverlayInfo[\"isServiceLeaf\"]\n\n    Wrapper.print(\"%s %s: Start - Fabric [%s] Switch [%s] Role [%s] doOverlayExtn [%s] isServiceLeaf [%r]\" % (OVERLAY_PREFIX, \n        funcName, FABRIC_NAME, formattedName, switchRole, switchOverlayInfo[\"doOverlayExtn\"], isServiceLeaf))\n\n    if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n        multisiteExtnDict = None\n        # check if switch has multisite configs\n        nvPairList = getTemplateMatchResults(matchResults, \"evpn_multisite\")\n        if ((nvPairList != None) and (len(nvPairList) > 0)):\n            # multisite extension values\n            multisiteExtn = {\"MULTISITE_CONN\" : [{\"IF_NAME\" : globalOverlayInfo[\"routingLoName\"]}]}\n            multisiteExtnDict = {\"MULTISITE_CONN\" : json.dumps(multisiteExtn)}\n\n    networksInfo = switchOverlayInfo[\"NETWORKS_BY_ID\"]\n    overlayVrfsNameToVni = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n    freeformCfg = []\n\n    # external links for this switch. Will get fetched on demand\n    linkNbrList = None\n\n    # dictionary of valid profiles to process. .key is the actual profile name; ex: MyNetwork_30000\n    profilesToProcess = {}\n\n    # gather all the applied profiles on the switch\n    appliedProfiles = getTemplateMatchResults(matchResults, \"apply_profile\")\n    if appliedProfiles:\n        for profileNvPair in appliedProfiles:\n            # add a dummy dictionary entry\n            profilesToProcess[profileNvPair[\"PROFILE_NAME\"]] = None\n\n    for profileCmd in cfgProfiles:\n        \"\"\"\n        \"configure profile MyNetwork_30000\": {\n            \"show_run\": [\n                \"configure profile MyNetwork_30000\",\n                \"  vlan 2300\",\n                \"    vn-segment 30000\",\n            [snip]\n        },\n        \"configure profile MyNetwork_30001\": {\n            \"show_run\": [\n                \"configure profile MyNetwork_30001\",\n                \"  vlan 2301\",\n                \"    vn-segment 30001\",\n            [snip]\n        }\n        \"\"\"\n        profileName = profileCmd.split()[2]\n\n        if profileName in profilesToProcess:\n            # update the dictionary entry with the match entry\n            profilesToProcess[profileName] = cfgProfiles[profileCmd]\n        else:\n            # a config profile that exists on the switch, but, not applied??.. add it to the freeform\n            freeformCfg += cfgProfiles[profileCmd][\"show_run\"]\n\n    # track the missing parent vrf-lite interfaces to avoid repeated errors\n    vrfLiteMissingParentIntfs = []\n    # process each config profile\n    for profileName in profilesToProcess:\n        profileEntry = profilesToProcess[profileName]\n        if profileEntry == None:\n            # not possible, but, better be safe\n            continue\n\n        vlanParams = {}\n        sviParams = {}\n        nve1Params = {}\n        vrfParams = {}\n        bgpParams = {}\n        evpnParams = {}\n        loParams = None\n        loIntfs = []\n        trmParams = {}\n        advertiseHostRouteFlagVal = \"true\"\n        advertiseDefaultRouteFlagVal = \"false\"\n        configureStaticDefaultRouteFlagVal = \"false\"\n        tag = \"\"\n\n        # VRF LITE config Tracking data\n        #   {\n        #       # key is the actual subif name\n        #       \"INTFS\" : {\"subif parent intf name\" : {\"DOT1Q_ID\" : \"dot1q\", \n        #                   \"IP_MASK\" : \"intf ip address with prefix\", \"IP_ADDR\" : \"ip address\",\n        #                           IP_PREFIX\" : \"subnet prefix\", \"IP_SUBNET\" : \"ipv4 subnet\",\n        #                   \"IPV6_MASK\" : \"intf v6 ip address with prefix\",\"IPV6_ADDR\" : \"ip v6 address\", \n        #                           IPV6_PREFIX\" : \"v6 subnet prefix\", \"IPV6_SUBNET\" : \"ipv6 subnet\"}\n        #                 }\n        #\n        #       # key is the v4 or v6 neighbor IP\n        #       \"NEIGHBORS\" : {\"v4/v6 neighbor ip\" : {\"isV6\" : True/False, NEIGHBOR_ASN\" : \"asn\", \"IS_PROCESSED\" : True/False}\n        #       \"CURR_INTF\" : intfEntry\n        #       \"CURR_NEIGHBOR\" : v4/v6 neighbor entry\n        #   }\n        vrfLiteParams = {\"INTFS\" : {}, \"NEIGHBORS\" : {},\n                         \"CURR_INTF\" : None, \"CURR_NEIGHBOR\" : None\n                        }\n\n        context = None\n        #Wrapper.print(\"%s: ******************\" % funcName)\n        #Wrapper.print(\"%s: Profile [%s]\" %  (funcName, profileEntry['show_run']))\n        #Wrapper.print(\"%s: ******************\" % funcName)\n        isBgpVrfContext = False\n        isBgpVrfAFContext = False\n        isBgpVrfNeighborContext = False\n        isBgpVrfNeighborAFContext = False\n\n        for line in profileEntry['show_run']:\n            line = line.rstrip()\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                # skip the 'configure profile xxxx' line\n                continue\n\n            cmd = line.strip()\n            tokens = cmd.split()\n\n            #Wrapper.print(\"%s: Line [%s], depth [%d], cmd [%s] tokens [%s]\" %  (funcName, line, depth, cmd, tokens))\n\n            if depth == 1:\n                vrfLiteParams[\"CURR_INTF\"] = None\n                vrfLiteParams[\"CURR_NEIGHBOR\"] = None\n                # look for the expected top level commands\n                if cmd.startswith('vlan '):\n                    context = \"vlan\"\n                    # extract the vlan id (str)\n                    vlanParams['id'] = tokens[1]\n                elif cmd.startswith('interface '):\n                    lowerIntfName = tokens[1].lower().strip()\n                    if lowerIntfName == \"nve1\":\n                        context = \"nve1\"\n                    elif lowerIntfName.startswith(\"vlan\"):\n                        context = \"svi\"\n                    elif lowerIntfName.startswith(\"loopback\"):\n                        context = \"lo\"\n                        loParams = {}\n                        loParams[\"id\"] = tokens[1][8:]\n                        loIntfs.append(loParams)\n                    elif lowerIntfName.startswith(\"ethernet\") or lowerIntfName.startswith(\"port-channel\"):\n                        #Wrapper.print(\"%s: Processing sub interface Line [%s], depth [%d], cmd [%s] tokens [%s]\" % \n                        #            (funcName, line, depth, cmd, tokens))\n                        if '.' in tokens[1]:\n                            # assume it is VRF Lite sub-interface\n                            context = \"subif\"\n\n                            # get the .1q id\n                            parentIntf, dot1qId = tokens[1].split(\".\")\n                            normalizedParentIntfName = parentIntf\n                            if parentIntf.lower().startswith(\"port-channel\"):\n                                normalizedParentIntfName = parentIntf.capitalize()\n                            \n                            if normalizedParentIntfName not in vrfLiteParams[\"INTFS\"]:\n                                # add a new VRF Lite entry\n                                vrfLiteIntfEntry = {\"DOT1Q_ID\" : dot1qId}\n                                #Wrapper.print(\"%s: Adding vrfLiteIntfEntry [%s]\" % (funcName, vrfLiteIntfEntry))\n                                vrfLiteParams[\"INTFS\"][normalizedParentIntfName] = vrfLiteIntfEntry\n                            else:\n                                vrfLiteIntfEntry = vrfLiteParams[\"INTFS\"][normalizedParentIntfName]\n                            vrfLiteParams[\"CURR_INTF\"] = vrfLiteIntfEntry\n                elif cmd.startswith('vrf context '):\n                    context = \"vrf\"\n                    # extract the vrf name\n                    vrfParams['name'] = tokens[2]\n                elif cmd.startswith('router bgp '):\n                    context = \"bgp\"\n                    # extract the bgp asn\n                    bgpParams['asn'] = tokens[2]\n                elif cmd.startswith('evpn'):\n                    context = \"evpn\"\n            elif depth == 2:\n                if context == \"vlan\":\n                    if cmd.startswith('name '):\n                        vlanParams['name'] = tokens[1]\n                    elif cmd.startswith('vn-segment '):\n                        vlanParams['vni'] = tokens[1]\n                    elif cmd.startswith('private-vlan'):\n                        Wrapper.print(\"%s: vlan [%s] has unsupported pvlan cmd: %s\" % (funcName, vlanParams['id'], cmd))\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OVERLAY\"),\n                                \"Cannot have private-vlan config on VNI VLANs.\", devSerial)\n                        respObj.setFailureRetCode()\n                elif context == \"nve1\":\n                    if cmd.startswith('member vni '):\n                        if \"associate-vrf\" in cmd:\n                            nve1Params['isVrfVni'] = \"true\"\n                        else:\n                            nve1Params['isVrfVni'] = \"false\"\n                elif context == \"svi\":\n                    if cmd.startswith('description '):\n                        sviParams['desc'] = cmd[len('description '):]\n                    elif cmd.startswith('vrf member '):\n                        sviParams['vrfName'] = tokens[2]\n                    elif cmd.startswith('ip address '):\n                        if \"secondary\" in cmd:\n                            # secondary GW IP address\n                            if not \"gw1Ipv4\" in sviParams:\n                                sviParams['gw1Ipv4'] = tokens[2]\n                            elif not \"gw2Ipv4\" in sviParams:\n                                sviParams['gw2Ipv4'] = tokens[2]\n                            elif not \"gw3Ipv4\" in sviParams:\n                                sviParams['gw3Ipv4'] = tokens[2]\n                            else:\n                                sviParams['gw4Ipv4'] = tokens[2]\n                            if \"tag\" in cmd:\n                                tag = tokens[5]\n                        else:\n                            # primary IP address\n                            sviParams['ipv4'] = tokens[2]\n                            if \"tag\" in cmd:\n                                tag = tokens[4]\n                    elif cmd.startswith('ipv6 address '):\n                        if cmd == 'ipv6 address use-link-local-only':\n                            sviParams['ipv6LinkLocal'] = \"true\"\n                        else: \n                            # primary IPv6 address\n                            if 'ipv6' in sviParams and sviParams['ipv6'] != \"\":\n                                sviParams['ipv6'] = sviParams['ipv6'] + \",\" + tokens[2]\n                            else:\n                                sviParams['ipv6'] = tokens[2]\n                            if \"tag\" in cmd:\n                                tag = tokens[4]\n                    elif cmd.startswith('mtu '):\n                        sviParams['mtu'] = tokens[1]\n                    elif cmd == 'ip pim sparse-mode':\n                        trmParams['trmEnabled'] = \"true\"\n                    elif cmd.startswith('ip dhcp relay source-interface '):\n                        if tokens[4].lower().startswith(\"loopback\"):\n                            sviParams['dhcpRelayLoId'] = tokens[4]\n                    elif cmd.startswith(\"ip dhcp relay address \"):\n                        if \"dhcpServersList\" not in sviParams:\n                            # add the key for the DHCP Servers\n                            dhcpServerList = []\n                            sviParams[\"dhcpServersList\"] = dhcpServerList\n                        else:\n                            dhcpServerList = sviParams[\"dhcpServersList\"]\n\n                        # ignore any dhcp relay entries more than the max supported.\n                        # this will cause a diff that customer must fix by updating the profile template to accomodate all\n                        if len(dhcpServerList) <= NET_PROFILE_DHCP_SERVERS_MAX:\n                            dhcpServerList.append({\"srvrAddr\" : tokens[4], \n                                \"srvrVrf\" : (tokens[6] if (\"use-vrf\" in cmd) else \"\")})\n                elif context == \"vrf\":\n                    if cmd.startswith('description '):\n                        vrfParams['desc'] = cmd[len('description '):]\n                    elif cmd.startswith('ip pim rp-address '):\n                        trmParams['trmEnabled'] = \"true\"\n                        trmParams['rpAddress'] = tokens[3]\n                        if \"group-list\" in cmd:\n                            trmParams['multicastGroup'] = tokens[5]\n                    elif cmd.lower().startswith('ip route 0.0.0.0/0 ') or cmd.lower().startswith(\"ipv6 route ::/0\"):\n                        configureStaticDefaultRouteFlagVal = \"true\"\n                elif context == \"lo\":\n                    if cmd.startswith('ip address '):\n                        loParams['ipv4'] = tokens[2][:-3]\n                        if \"tag\" in cmd:\n                            tag = tokens[4]\n                    elif cmd.startswith('ipv6 address '):\n                        loParams['ipv6'] = tokens[2][:-4]\n                        if \"tag\" in cmd:\n                            tag = tokens[4]\n                    elif cmd == 'ip pim sparse-mode':\n                        loParams['isTrm'] = \"true\"\n                        trmParams['trmEnabled'] = \"true\"\n                elif context == \"subif\":\n                    vrfLiteIntfEntry = vrfLiteParams[\"CURR_INTF\"]\n                    if (cmd.startswith('ip address ') or cmd.startswith('ipv6 address ')):\n                        # get the prefix string\n                        ipAddr, prefix = tokens[2].split(\"/\")\n                        if Util.isIpv6Addr(ipAddr):\n                            vrfLiteIntfEntry[\"IPV6_MASK\"] = tokens[2]\n                            vrfLiteIntfEntry[\"IPV6_ADDR\"] = ipAddr\n                            vrfLiteIntfEntry[\"IPV6_PREFIX\"] = prefix\n                            vrfLiteIntfEntry[\"IPV6_SUBNET\"] = Util.getV6SubnetStringWithPrefix(ipAddr, prefix)\n                        else:\n                            vrfLiteIntfEntry[\"IP_MASK\"] = tokens[2]\n                            vrfLiteIntfEntry[\"IP_ADDR\"] = ipAddr\n                            vrfLiteIntfEntry[\"IP_PREFIX\"] = prefix\n                            vrfLiteIntfEntry[\"IP_SUBNET\"] = Util.getSubnetStringWithPrefix(ipAddr, prefix)\n                elif context == \"bgp\":\n                    isBgpVrfContext = False\n                    isBgpVrfNeighborContext = False\n                    isBgpVrfNeighborAFContext = False\n                    if cmd.startswith('vrf '):\n                        vrfLiteParams[\"CURR_NEIGHBOR\"] = None\n                        isBgpVrfContext = True\n            elif depth == 3:\n                if context == \"nve1\":\n                    if cmd.startswith('mcast-group '):\n                        if nve1Params['isVrfVni'] == \"true\":\n                            trmParams['trmEnabled'] = \"true\"\n                            trmParams['L3VniMcastGroup'] = tokens[1]\n                        else:\n                            nve1Params['mcastGroup'] = tokens[1]\n                    elif cmd == \"multisite ingress-replication optimized\":\n                        nve1Params['trmBGWMSiteEnabled'] = \"true\"\n                    elif cmd.startswith('ingress-replication '):\n                        nve1Params['isIR'] = \"true\"\n                    elif cmd.startswith('suppress-arp'):\n                        nve1Params['isSuppessArp'] = \"true\"\n                elif context == \"evpn\":\n                    if cmd == \"route-target both auto\":\n                        evpnParams['rtBoth'] = \"true\"\n                elif context == \"bgp\":\n                    if isBgpVrfContext:\n                        if cmd.startswith('neighbor '):\n                            #Wrapper.print(\"%s: bgp neighbor [%s]\" % (funcName, cmd))\n                            # take care of these cases:\n                            # 1. neighbor 20.1.1.2 remote-as 3000\n                            # 2. neighbor 20.1.1.2\n                            #       remote-as 3000\n                            isBgpVrfNeighborContext = True\n                            isBgpVrfNeighborAFContext = False\n                            isBgpVrfAFContext = False\n\n                            asnStr = None\n                            if 'remote-as' in cmd:\n                                asnStr = tokens[3]\n\n                            #Wrapper.print(\"%s: bgp neighbor cmd [%s] asnStr [%s] tokens [%s]\" % (funcName, cmd, asnStr, tokens))\n                            # add a new neighbor\n                            vrfLiteNeighborEntry = {\"isV6\" : \n                                            Util.isIpv6Addr(tokens[1]), \"NEIGHBOR_ASN\" : asnStr, \"IS_PROCESSED\" : False}\n                            vrfLiteParams[\"NEIGHBORS\"][tokens[1]] = vrfLiteNeighborEntry\n                            vrfLiteParams[\"CURR_NEIGHBOR\"] = vrfLiteNeighborEntry\n                        elif cmd.lower() in [\"address-family ipv4 unicast\", \"address-family ipv6 unicast\"]:\n                            isBgpVrfNeighborContext = False\n                            isBgpVrfAFContext = True\n            elif depth == 4:\n                if context == \"bgp\":\n                    if isBgpVrfNeighborContext:\n                        #Wrapper.print(\"%s: bgp neighbor cmd [%s] tokens [%s]\" % (funcName, cmd, tokens))\n                        if cmd.startswith('remote-as '):\n                            vrfLiteParams[\"CURR_NEIGHBOR\"][\"NEIGHBOR_ASN\"] = tokens[1]\n                            #Wrapper.print(\"%s: bgp neighbor cmd [%s] asnStr [%s]\" %\n                            #    (funcName, cmd, vrfLiteParams[\"CURR_NEIGHBOR\"][\"NEIGHBOR_ASN\"]))\n                        elif cmd.lower() in [\"address-family ipv4 unicast\", \"address-family ipv6 unicast\"]:\n                            isBgpVrfNeighborAFContext = True\n                        elif cmd.startswith('password '):\n                            bgpParams['bgpPasswordKeyType'] = tokens[1]\n                            bgpParams['bgpPassword'] = tokens[2]\n                    elif isBgpVrfAFContext:\n                        #Wrapper.print(\"%s: isBgpVrfAFContext cmd [%s]\" % (funcName, cmd))\n                        if cmd.startswith('redistribute direct route-map '):\n                            bgpParams['rmap'] = tokens[3]\n                        elif cmd.startswith('maximum-paths '):\n                            if \"ibgp\" in cmd:\n                                bgpParams['ibgpMaxPaths'] = tokens[2]\n                            else:\n                                bgpParams['bgpMaxPaths'] = tokens[1]\n                        elif cmd.lower() in [\"network 0.0.0.0/0\", \"network ::/0\"]:\n                            advertiseDefaultRouteFlagVal = \"true\"\n            elif depth == 5:\n                if context == \"bgp\":\n                    if isBgpVrfNeighborAFContext:\n                        if cmd.lower() in [\"route-map extcon-rmap-filter out\", \"route-map extcon-rmap-filter-v6 out\"]:\n                            advertiseHostRouteFlagVal = \"false\"\n        \"\"\"\n        Wrapper.print(\"%s: profile [%s]. vlanParams [%s]\" % (funcName, profileName, vlanParams))\n        Wrapper.print(\"%s: profile [%s]. sviParams [%s]\" % (funcName, profileName, sviParams))\n        Wrapper.print(\"%s: profile [%s]. nve1Params [%s]\" % (funcName, profileName, nve1Params))\n        Wrapper.print(\"%s: profile [%s]. vrfParams [%s]\" % (funcName, profileName, vrfParams))\n        Wrapper.print(\"%s: profile [%s]. bgpParams [%s]\" % (funcName, profileName, bgpParams))\n        Wrapper.print(\"%s: profile [%s]. evpnParams [%s]\" % (funcName, profileName, evpnParams))\n        Wrapper.print(\"%s: profile [%s]. trmParams [%s]\" % (funcName, profileName, trmParams))\n        Wrapper.print(\"%s: profile [%s]. loIntfs [%s]\" % (funcName, profileName, loIntfs))\n        Wrapper.print(\"%s: profile [%s]. vrfLiteParams [%s]\" % (funcName, profileName, vrfLiteParams))\n        Wrapper.print(\"%s: profile [%s]. tag [%s]\" % (funcName, profileName, tag))\n        \"\"\"\n\n        # we found a applied config profile.. check some mandatory parameters before assuming these are VXLAN related\n        if (\"vni\" not in vlanParams) or (\"id\" not in vlanParams):\n            # basic vlan/vn-segment info is missing, not an overlay.. add to the freeform\n            freeformCfg += profileEntry['show_run']\n            # add the 'apply profile xxx'\n            freeformCfg += [(\"apply profile %s\" % profileName)]\n            continue\n\n        vniStr = vlanParams['vni']\n        vlanId = vlanParams['id']\n        vlanIdInt = int(vlanParams['id'])\n        switchOverlayInfo[\"OVERLAY_VLANS\"].append(vlanIdInt)\n\n        setCfgProfileName = None\n        if len(vrfParams.keys()) > 0:\n            # this is a VRF profile\n            # Note on config profile naming scheme in DCNM 10.4(2)\n            #   VRF - fabricname-VRFName-vrfprofile-L3VNI\n            #               > the config profile name can be different on different switches because of the following:\n            #                   - the 'vrfprofile' will be different on the borders\n\n            vrfName  = vrfParams[\"name\"]\n            # check if this is a DCNM 10.4(2) style config profile:\n            if (len(profileName) != len(vrfName)):\n                # this is a DCNM 10.4(2) style VRF config profile. Note: DCNM 10.4(2) preserves the vrf name case\n                setCfgProfileName = profileName\n                newProfileName = vrfName\n            else:\n                # we need to manipulate the VRF profile name if the actual vrf name contains ':' because of a\n                # topdown behavior to replace ':' with a '-' in the config profile name\n                #\n                # Note: we must do the below to take care of char case conversions that occur with the profile name\n                # vs the actual vrf name\n                newProfileName = \"\"\n                for i in range(len(vrfName)):\n                    if vrfName[i] == ':':\n                        # there must be a '-' in the profile name.. replace it with ':'\n                        newProfileName += ':'\n                    else:\n                        newProfileName += profileName[i]\n                # make sure the vrfName case is same as the updated profile name\n                vrfName = newProfileName\n\n            Wrapper.print(\"%s: VRF Orig/New Profile Name [%s]/[%s], VRF name [%s], setCfgProfileName [%s]\" %\n                    (funcName, profileName, newProfileName, vrfName, setCfgProfileName))\n            vrfAttachVlanStr = vlanParams['id']\n            vrfTemplateParams = {\n                \"vrfVlanId\" : vrfAttachVlanStr,\n                \"vrfName\": vrfName,\n                \"vrfSegmentId\": vniStr,\n                \"nveId\" : \"1\",\n                \"mtu\" : sviParams.get('mtu', \"\"),\n                \"vrfVlanName\" : vlanParams.get('name', \"\"),\n                \"vrfIntfDescription\" : sviParams.get('desc', \"\"),\n                \"vrfDescription\" : vrfParams.get('desc', \"\"),\n                \"vrfRouteMap\" : bgpParams.get('rmap', \"\"),\n                \"maxBgpPaths\" : bgpParams.get('bgpMaxPaths', \"1\"),\n                \"maxIbgpPaths\" : bgpParams.get('ibgpMaxPaths', \"1\"),\n                \"asn\" : BGP_AS,\n                \"tag\" : tag,\n                \"isRPExternal\" : \"false\",\n                \"trmBGWMSiteEnabled\" : nve1Params.get('trmBGWMSiteEnabled', \"false\"),\n                \"trmEnabled\" : \"false\",\n                \"advertiseHostRouteFlag\" : advertiseHostRouteFlagVal,\n                \"advertiseDefaultRouteFlag\" : advertiseDefaultRouteFlagVal,\n                \"configureStaticDefaultRouteFlag\" : configureStaticDefaultRouteFlagVal,\n                \"ipv6LinkLocalFlag\" : sviParams.get('ipv6LinkLocal', \"false\"),\n            }\n\n            if \"bgpPassword\" in bgpParams:\n                vrfTemplateParams[\"bgpPassword\"] = bgpParams[\"bgpPassword\"]\n                vrfTemplateParams[\"bgpPasswordKeyType\"] = bgpParams[\"bgpPasswordKeyType\"]\n\n            vrfEntry = {\n                        'name' : newProfileName,\n                        'vni' : vrfTemplateParams['vrfSegmentId'],\n                        # this is the local vlan that the VRF is attached to\n                        'vlanId' : vlanIdInt,\n                        'vrfTemplateParams' : vrfTemplateParams,\n                        # list of network VNIs (integer) associated with this VRF\n                        'networks' : [],\n                        # VRF attach instance values\n                        'instanceVals' : \"\",\n                        # VRF attach extension values\n                        'extensionVals' : \"\",\n                        # the additional configuration that could not be accounted for in the config profile\n                        'freeformCfg' : None,\n                       }\n\n            if setCfgProfileName:\n                # save the original profile name so that we can set it during the VRF attach\n                vrfEntry[\"cfgProfileName\"] = profileName\n\n            if len(trmParams.keys()) > 0:\n                vrfTemplateParams.update(trmParams)\n                # assume TRM Lo is not set\n                vrfTemplateParams['isRPExternal'] = \"true\"\n\n            # process loopback interfaces\n            for loParam in loIntfs:\n                if 'isTrm' in loParam:\n                    # TRM loopback\n                    vrfTemplateParams['isRPExternal'] = \"false\"\n                    vrfTemplateParams['loopbackNumber'] = loParam['id']\n                else:\n                    # build the lo instance params\n                    instanceValues = {'loopbackId': loParam['id']}\n                    if 'ipv4' in loParam:\n                        instanceValues['loopbackIpAddress'] = loParam['ipv4']\n                    if 'ipv6' in loParam:\n                        instanceValues['loopbackIpV6Address'] = loParam['ipv6']\n                    vrfEntry['instanceVals'] = json.dumps(instanceValues)\n\n            vrfEntry[\"freeformCfg\"] = getVrfFreeformCfg(devSerial, vrfName, vniStr, vrfAttachVlanStr, \n                                    matchResults, interfacesRes, True, switchOverlayInfo, globalOverlayInfo[\"SERVICES\"])\n\n            # correlate the sub intf and bgp neighbor VRF Lite entries\n            vrfLiteEntries = []\n            if vrfLiteParams[\"NEIGHBORS\"] and vrfLiteParams[\"INTFS\"]:\n                # process the interfaces first\n                for vrfLiteIntfIfName in vrfLiteParams[\"INTFS\"].keys():\n                    vrfLiteIntfEntry = vrfLiteParams[\"INTFS\"][vrfLiteIntfIfName]\n\n                    # this entry is always with us as the source (this is what topdown also expects)\n                    entry = {\"IF_NAME\" : vrfLiteIntfIfName,\n                             \"DOT1Q_ID\" : vrfLiteIntfEntry[\"DOT1Q_ID\"],\n                             \"IP_MASK\" : vrfLiteIntfEntry[\"IP_MASK\"] if \"IP_MASK\" in vrfLiteIntfEntry else \"\",\n                             \"IPV6_MASK\" : vrfLiteIntfEntry[\"IPV6_MASK\"] if \"IPV6_MASK\" in vrfLiteIntfEntry else \"\",\n                             \"NEIGHBOR_IP\" : \"\",\n                             \"IPV6_NEIGHBOR\" : \"\",\n                             \"NEIGHBOR_ASN\" : \"\",\n                             \"AUTO_VRF_LITE_FLAG\" : \"false\", \"PEER_VRF_NAME\" : \"\",\n                             \"VRF_LITE_JYTHON_TEMPLATE\" : VRF_LITE_IFC_PYTHON_POLICY}\n\n                    isValidEntry = False\n\n                    # find the neighbor entries for this interface\n                    for vrfLiteNeighborIP in vrfLiteParams[\"NEIGHBORS\"].keys():\n                        vrfLiteNeighborEntry = vrfLiteParams[\"NEIGHBORS\"][vrfLiteNeighborIP]\n\n                        if vrfLiteNeighborEntry[\"IS_PROCESSED\"]:\n                            continue\n\n                        if vrfLiteNeighborEntry[\"isV6\"]:\n                            if (\"IPV6_MASK\" in vrfLiteIntfEntry):\n                                bgpNeighborSubnetStr = Util.getV6SubnetStringWithPrefix(vrfLiteNeighborIP, \n                                    vrfLiteIntfEntry[\"IPV6_PREFIX\"])\n                                Wrapper.print(\"%s: VRFLITE: V6: Checking neighbor subnet [%s] Intf Subnet [%s]\" %\n                                         (funcName, bgpNeighborSubnetStr, vrfLiteIntfEntry[\"IPV6_SUBNET\"]))\n                                if (bgpNeighborSubnetStr == vrfLiteIntfEntry[\"IPV6_SUBNET\"]):\n                                    # we found what we are looking for\n                                    vrfLiteNeighborEntry[\"IS_PROCESSED\"] = True\n                                    isValidEntry = True\n                                    entry[\"IPV6_NEIGHBOR\"] = vrfLiteNeighborIP\n                                    entry[\"NEIGHBOR_ASN\"] = vrfLiteNeighborEntry[\"NEIGHBOR_ASN\"]\n                        else:\n                            if (\"IP_MASK\" in vrfLiteIntfEntry):\n                                bgpNeighborSubnetStr = Util.getSubnetStringWithPrefix(vrfLiteNeighborIP, \n                                    vrfLiteIntfEntry[\"IP_PREFIX\"])\n                                # Wrapper.print(\"%s: VRFLITE: V4: Checking neighbor subnet [%s] Intf Subnet [%s]\" %\n                                #         (funcName, bgpNeighborSubnetStr, vrfLiteIntfEntry[\"IP_SUBNET\"]))\n                                if (bgpNeighborSubnetStr == vrfLiteIntfEntry[\"IP_SUBNET\"]):\n                                    # we found what we are looking for\n                                    vrfLiteNeighborEntry[\"IS_PROCESSED\"] = True\n                                    isValidEntry = True\n                                    entry[\"NEIGHBOR_IP\"] = vrfLiteNeighborIP\n                                    entry[\"NEIGHBOR_ASN\"] = vrfLiteNeighborEntry[\"NEIGHBOR_ASN\"]\n\n                    if isValidEntry:\n                        if not switchRole.lower().startswith(\"border\"):\n                            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRFLITE_IFC\"),\n                                \"Unexpected VRF-LITE IFC on Interface [%s] with Dot1Q Encap [%s] for a \"\n                                \"Non Border role [%s]. Please set the correct role and retry \"\n                                \"Recalculate & Deploy\" % (entry[\"IF_NAME\"], entry[\"DOT1Q_ID\"], switchRole), devSerial)\n                            respObj.setFailureRetCode()\n                        else:\n                            vrfLiteEntries.append(entry)\n\n                            # create a IFC entry also\n                            if not linkNbrList:\n                                linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, devSerial,  Helper.getNbrTypeExternal()))\n                            createVrfLiteIFCEntry(switchInfo, switchOverlayInfo, entry, linkNbrList, vrfLiteMissingParentIntfs, respObj)\n\n            if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n                overlayExtnDict = {}\n                if multisiteExtnDict:\n                    overlayExtnDict.update(multisiteExtnDict)\n                Wrapper.print(\"%s: vrfTemplateParams [%s]\" % (funcName, vrfTemplateParams))\n                Wrapper.print(\"%s: vrfLiteEntries %d [%s]\" % (funcName, len(vrfLiteEntries), vrfLiteEntries))\n                Wrapper.print(\"%s: VRF-LITE Link Entries [%s]\" % (funcName, switchOverlayInfo[\"IFCS\"][\"VRF_LITE\"]))\n                vrfLiteExtns = {\"VRF_LITE_CONN\" : vrfLiteEntries}\n                vrfLiteExtnsDict = {\"VRF_LITE_CONN\" : json.dumps(vrfLiteExtns)}\n                overlayExtnDict.update(vrfLiteExtnsDict)\n\n                if len(overlayExtnDict) > 0:\n                    vrfEntry['extensionVals'] = json.dumps(overlayExtnDict)\n                    Wrapper.print(\"%s: extensionVals [%s]\" % (funcName, vrfEntry['extensionVals']))\n\n            overlayVrfsNameToVni[vrfEntry[\"name\"].lower()] = {\"origName\" : vrfEntry[\"name\"], \"vni\" : vniStr}\n            Wrapper.print(\"%s: vrfEntry [%s]\" % (funcName, vrfEntry))\n            overlayVrfsInfoById[vrfEntry[\"vni\"]] = vrfEntry\n        else:\n            # this is a network profile\n            if (\"vrfName\" in sviParams):\n                netVrfName = sviParams['vrfName']\n            else:\n                netVrfName = \"NA\"\n            netTemplateParams = {\n                # mandatory parameters\n                'vlanId' : vlanIdInt,\n                'vlanName' : vlanParams['name'] if (\"name\" in vlanParams) else \"\",\n                'segmentId' : vlanParams['vni'],\n                'tag' : tag,\n                'vrfName' : netVrfName,\n                \"gatewayIpAddress\" : sviParams['ipv4'] if (\"ipv4\" in sviParams) else \"\",\n                \"gatewayIpV6Address\" : sviParams['ipv6'] if (\"ipv6\" in sviParams) else \"\",\n\n                # non-mandatory parameters\n                'isLayer2Only' : \"true\",\n                'suppressArp' : nve1Params['isSuppessArp'] if (\"isSuppessArp\" in nve1Params) else \"false\",\n                'mcastGroup' : nve1Params['mcastGroup'] if (\"mcastGroup\" in nve1Params) else \"\",\n                'enableIR' : nve1Params['isIR'] if (\"isIR\" in nve1Params) else \"false\",\n                'nveId' : \"1\",\n                'rtBothAuto' : evpnParams['rtBoth'] if (\"rtBoth\" in evpnParams) else \"false\",\n                # set to 'true' if the border role switches have the svi (for a L3 network)\n                'enableL3OnBorder' : \"false\"\n                }\n\n            netEntry = {\n                # the 'overlayNetName' will be set later \n                'cfgProfileName': profileName,\n                'vni': int(netTemplateParams[\"segmentId\"]),\n                'vlanId' : vlanIdInt,\n                'vlanName' : netTemplateParams[\"vlanName\"],\n                \"netTemplateParams\" : netTemplateParams,\n                'vrfName' : netTemplateParams[\"vrfName\"],\n                # Network attach extension values\n                'extensionVals' : \"\",\n                # the additional configuration that could not be accounted for in the config profile\n                'freeformCfg' : \"\",\n                # list of interface names. Collected from trunk and access host interfaces where the vlan is enabled explictly\n                'attachInfo' : []\n            }\n\n            if \"trmEnabled\" in trmParams:\n                netTemplateParams[\"trmEnabled\"] = trmParams[\"trmEnabled\"]\n\n            for keyName in sviParams:\n                val = sviParams[keyName]\n                if keyName == \"gw1Ipv4\":\n                    netTemplateParams[\"secondaryGW1\"] = val\n                elif keyName == \"gw2Ipv4\":\n                    netTemplateParams[\"secondaryGW2\"] = val\n                elif keyName == \"gw3Ipv4\":\n                    netTemplateParams[\"secondaryGW3\"] = val\n                elif keyName == \"gw4Ipv4\":\n                    netTemplateParams[\"secondaryGW4\"] = val\n                elif keyName == \"desc\":\n                    netTemplateParams[\"intfDescription\"] = val\n                elif keyName == \"mtu\":\n                    netTemplateParams[\"mtu\"] = val\n                elif keyName == \"dhcpRelayLoId\":\n                    netTemplateParams[\"loopbackId\"] = val[len(\"loopback\"):]\n                elif keyName == \"dhcpServersList\":\n                    # store the actual list in a temp key since we need to normalize things later\n                    netTemplateParams[\"dhcpServersTemp\"] = val\n\n            if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n                overlayExtnDict = {}\n                if multisiteExtnDict:\n                    # multisite extension values\n                    overlayExtnDict.update(multisiteExtnDict)\n                if len(overlayExtnDict) > 0:\n                    netEntry['extensionVals'] = json.dumps(overlayExtnDict)\n\n            netEntry[\"freeformCfg\"] = getNetworkFreeformCfg(vniStr, vlanId, matchResults, interfacesRes, True)\n            networksInfo[vlanParams['vni']] = netEntry\n            switchOverlayInfo[\"NETWORKS_VLAN2VNI\"][netEntry[\"vlanId\"]] = vniStr\n\n    # do some post processing...after all the profiles have been parsed\n    for vniStr in networksInfo:\n        netEntry = networksInfo[vniStr]\n        netTemplateParams = netEntry['netTemplateParams']\n        if netTemplateParams['vrfName'] != \"NA\":\n            vrfLookupEntry = overlayVrfsNameToVni[netTemplateParams['vrfName'].lower()]\n            normalizedVrfName = vrfLookupEntry[\"origName\"]\n            netTemplateParams['vrfName'] = normalizedVrfName\n            netEntry['vrfName'] = normalizedVrfName\n            if ('dhcpServersTemp' in netTemplateParams):\n                netTemplateParams[NET_PROFILE_DHCP_SERVERS_VAR] = buildOverlayNetDhcpStructString(netTemplateParams[\"dhcpServersTemp\"], normalizedVrfName)\n                del netTemplateParams[\"dhcpServersTemp\"]\n            netTemplateParams['isLayer2Only'] = \"false\"\n            if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n                Wrapper.print(\"%s: Fabric [%s] Switch [%s] Border Switch Role [%s] Found SVI [%d] - Setting enableL3OnBorder\" % \n                    (funcName, FABRIC_NAME, devSerial, switchRole, netEntry['vlanId']))\n                netTemplateParams[\"enableL3OnBorder\"] = \"true\"\n\n            if isServiceLeaf:\n                if vniStr in servicesInfo[\"serviceNets\"]:\n                    # do not add the service networks to the VRF networks list.. that intent will be from L4-7 services\n                    continue\n            \n            # add the network to the vrf 'networks'\n            overlayVrfsInfoById[vrfLookupEntry[\"vni\"]][\"networks\"].append(str(netEntry[\"vni\"]))\n\n    if isServiceLeaf:\n        for vniStr in servicesInfo[\"serviceNets\"]:\n            if vniStr in networksInfo:\n                srvcNetEntry = servicesInfo[\"serviceNets\"][vniStr]\n                if \"netEntry\" not in srvcNetEntry:\n                    # update the entry\n                    srvcNetEntry[\"netEntry\"] = networksInfo[vniStr]\n                # remove the service networks from the networks list\n                del networksInfo[vniStr]\n\n    # Wrapper.print(\"%s: Switch [%s] **** VRF and Network Entry Summary ****\" % (funcName, devSerial))\n    # for vniStr in overlayVrfsInfoById:\n    #     Wrapper.print(\"%s: VRF VNI [%s]. Entry [%s]\" % (funcName, vniStr, overlayVrfsInfoById[vniStr]))\n\n    # for vniStr in networksInfo:\n    #     Wrapper.print(\"%s: NET VNI [%s]. Entry [%s]\" % (funcName, vniStr, networksInfo[vniStr]))\n\n    switchOverlayInfo[\"POST_INTF_FF\"] += freeformCfg\n    Wrapper.print(\"%s: vrfLiteMissingParentIntfs [%s]\" % (funcName, vrfLiteMissingParentIntfs))\n    Wrapper.print(\"%s %s: End - Fabric [%s] Switch [%s] Role [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME,\n            formattedName, switchRole))\n\ndef getSwitchVxlanInfo(infoDict, switchOverlayInfo, matchResults, sshObj, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    devSerial = switchOverlayInfo[\"SERIAL\"]\n    fmtName = infoDict[\"fmtName\"]\n    migrateMode = infoDict[\"migrationMode\"]\n\n    # init dictionary containing vlan related info\n    # VLANS - dictionary of vlan info. key is vlan id string. value is {\"name\" : vlan_name, \"vni\" : vnseg value string}\n    # VNIS - dictionary of vn-segment info. key is vn-segment id string. value is {\"vni\" : associated vlan id string}\n    vlanIdInfo = {\"VLANS\" : {}, \"VNIS\" : {}}\n\n    # list of VRF VNI entries from the switch (output of 'show nve vni')\n    vrfVnis = []\n\n    # list of Network VNI entries from the switch (output of 'show nve vni')\n    networkVnis = []\n\n    switchOverlayInfo[\"SWITCH_VXLAN_INFO\"] = {\"vlanIdInfo\" : vlanIdInfo, \"vrfVnis\" : vrfVnis,\n                                              \"networkVnis\" : networkVnis}\n\n    # get a list of all vlans on the switch\n    vlanMatchRes = matchResults[\"FEATURES_INFO\"][\"VLAN_BLOCK\"]\n    for vlanStr in vlanMatchRes.keys():\n        vlanListStr = vlanStr[5:]\n        vlanList = Util.getIntegerRange(vlanListStr)\n        isMultiVlans = False\n        if len(vlanMatchRes) == 1:\n            # we have a single entry....this has to be set of all vlans on switch\n            isMultiVlans = True\n        else:\n            if len(vlanList) > 1:\n                # this has to be set of multiple vlans on switch\n                isMultiVlans = True\n        if isMultiVlans:\n            switchOverlayInfo[\"ALL_VLANS\"].extend(vlanList)\n\n    utilObj = Util()\n    allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n\n    hasCfgProfiles = True if matchResults[\"FEATURES_INFO\"][\"CFG_PROFILES\"] else False\n\n    numVlans = len(switchOverlayInfo[\"ALL_VLANS\"])\n    Wrapper.print(\"%s: Switch [%s] Role [%s] migrateMode [%s] hasCfgProfiles [%r] Vlans (%d)[%s]\" % (funcName,\n        fmtName, infoDict[\"switchRole\"], migrateMode, hasCfgProfiles, numVlans, allVlansOnSwitchStr))\n\n    if ((numVlans == 0) or (migrateMode != \"brownAdd\") or (\"spine\" == infoDict[\"switchRole\"].lower())):\n        # we do not need any VXLAN info from the switches\n        Wrapper.print(\"%s: Skip collecting VXLAN info\" % (funcName))\n        return\n\n    # check if there is a discrepancy between the role set by user and actual switch config\n    # 'feature vn-segment-vlan-based' will not be present on 'spine' role switch\n    nvPairList = getTemplateMatchResults(matchResults, \"feature_vlan_based_vnsegment_11_1\")\n    Wrapper.print(\"%s: nvPairList\" % (nvPairList))\n    if (nvPairList is None):\n        # non spine role, but, missing a required feature\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":INCORRECT ROLE\"),\n            \"Required 'feature vn-segment-vlan-based' configuration(s) for role [%s] not found. Please check and \"\n            \"retry 'Recalculate & Deploy'\" % (infoDict[\"switchRole\"]), devSerial)\n        respObj.setFailureRetCode()\n        return\n\n    shNveVniCmdJson = getSwitchCmdJsonOutput(sshObj, devSerial, \"show nve vni | json\", respObj)\n\n    shVlanVnsegCmdJson = getSwitchCmdJsonOutput(sshObj, devSerial, \"show vlan id \" + \n                                    allVlansOnSwitchStr + \" vn-segment | json\", respObj)\n\n    if (((shNveVniCmdJson is None) or (shNveVniCmdJson == \"\")) or \n        (\"TABLE_nve_vni\" not in shNveVniCmdJson)):\n        # something is wrong.. respObj must have the required error\n        Wrapper.print(\"%s: Switch [%s] did not find any VXLAN Overlays on switch\" % (funcName, fmtName))\n        return\n\n    if ((shVlanVnsegCmdJson is None) or (\"TABLE_seginfoid\" not in shVlanVnsegCmdJson)):\n        # we did not find vlans with vn-segments\n        Wrapper.print(\"%s: Switch [%s]. Did not find any vlans with vn-segments\" %  (funcName, fmtName))\n    else:\n        if not isinstance(shVlanVnsegCmdJson[\"TABLE_seginfoid\"][\"ROW_seginfoid\"], list):\n            # this is a single entry.. make a list\n            vlanVnsegRows = [shVlanVnsegCmdJson[\"TABLE_seginfoid\"][\"ROW_seginfoid\"]]\n        else:\n            # this is a list already!\n            vlanVnsegRows = shVlanVnsegCmdJson[\"TABLE_seginfoid\"][\"ROW_seginfoid\"]\n        for vlanVnsegEntry in vlanVnsegRows:\n            vlanStr = vlanVnsegEntry[\"vlanshowinfo-seg-vlanid\"]\n            vnsegStr = vlanVnsegEntry[\"vlanshowinfo-segment-id\"]\n            vlanIdInfo[\"VNIS\"].update({vnsegStr : vlanStr})\n            vlanIdInfo[\"VLANS\"][vlanStr] = {\"vni\" : vnsegStr}\n\n    if not isinstance(shNveVniCmdJson[\"TABLE_nve_vni\"][\"ROW_nve_vni\"], list):\n        # this is a single entry.. make a list\n        nveVniRows = [shNveVniCmdJson[\"TABLE_nve_vni\"][\"ROW_nve_vni\"]]\n    else:\n        # this is a list already!\n        nveVniRows = shNveVniCmdJson[\"TABLE_nve_vni\"][\"ROW_nve_vni\"]\n\n    #Wrapper.print(\"%s: Switch [%s] nveVniRows %s VNIS %s\" % (funcName, fmtName, nveVniRows, vlanIdInfo[\"VNIS\"]))\n    for vniEntry in nveVniRows:\n        # ensure that the VNI state is 'UP'\n        vniStr = vniEntry[\"vni\"]\n        if vniEntry[\"vni-state\"].lower() != \"up\":\n            # flag an error\n            Wrapper.print(\"%s: Switch [%s]. Overlay VNI [%s] non-functional state [%s]\" % \n                (funcName, fmtName, vniStr, vniEntry[\"vni-state\"]))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRF VLAN\"),\n                \"Overlay VNI [%s] in state [%s]. Please resolve and retry 'Recalculate & Deploy'\" % (vniStr, vniEntry[\"vni-state\"]), devSerial)\n            respObj.setFailureRetCode()\n            continue\n\n        netType, vlanOrvrfName = getVniTypeAndVlanId(vniEntry[\"type\"])\n\n        if netType == \"L2\":\n            networkVnis.append(vniEntry)\n        else:\n            vrfVnis.append(vniEntry)\n\ndef gatherOverlayInfo(topologyDataObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, \n                        switchOverlayInfo, migrateMode, device_overlay_vlans, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n    role = switchInfo['switchRole']\n    formattedName = switchInfo[\"fmtName\"]\n    vPCInfo = switchInfo[\"vpcInfo\"]\n\n    Wrapper.print(\"%s %s: Start - FABRIC [%s] Switch [%s] Role [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, formattedName, role))\n\n    cfgProfiles = matchResults[\"FEATURES_INFO\"][\"CFG_PROFILES\"]\n    hasCfgProfiles = True if cfgProfiles else False\n    Wrapper.print(\"%s: Switch [%s] hasCfgProfiles [%r] All Vlans = [%d] [%s]\" % (funcName, formattedName, \n        hasCfgProfiles, len(switchOverlayInfo[\"ALL_VLANS\"]), switchOverlayInfo[\"ALL_VLANS\"]))\n\n    switchHasOverlays = True\n\n    if (role != \"spine\"):\n        if migrateMode == \"upgrade\":\n            switchOverlayInfo[\"OVERLAY_VLANS\"] = getAllTopDownVlans(devSerial, device_overlay_vlans)\n        elif migrateMode == \"brownAdd\":\n            vlanIdInfo = switchOverlayInfo[\"SWITCH_VXLAN_INFO\"][\"vlanIdInfo\"]\n            if not hasCfgProfiles:\n                if len(vlanIdInfo[\"VNIS\"]) == 0:\n                    Wrapper.print(\"%s: Switch [%s] did not find any VXLAN Overlays on switch\" % (funcName, devSerial))\n                    switchHasOverlays = False\n\n            if switchHasOverlays:\n                profInfo = globalOverlayInfo['cfgProfileInfo']\n                if profInfo[\"hasCfgProfile\"] == None:\n                    # set the cfg profile status since this is the first time\n                    profInfo[\"hasCfgProfile\"] = hasCfgProfiles\n                    profInfo[\"refSwitch\"] = devSerial\n\n                Wrapper.print(\"%s: Switch [%s] cfgProfileInfo [%s]\" % (funcName, formattedName, profInfo))\n\n                # check for inconsistency\n                if (hasCfgProfiles != profInfo[\"hasCfgProfile\"]):\n                    # an inconsistency where we are finding a mix of cfg profile and cli based migrations\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OVERLAY\"),\n                       \"Has %s based VXLAN Overlays while Switch [%s] is detected with \"\n                       \"%s based VXLAN Overlays. Inconsistent Overlay Migration with a mix of \"\n                       \"config-profiles and regular CLI based overlays is not supported!\" % (\n                            (\"config-profile\" if hasCfgProfiles else \"CLI\"),\n                            getFormattedSwitchName(profInfo[\"refSwitch\"]),\n                            (\"config-profile\" if profInfo[\"hasCfgProfile\"] else \"CLI\")), devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                if (hasCfgProfiles and OVERLAY_MODE != \"config-profile\"):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OVERLAY\"),\n                        \"Has config-profile based VXLAN Overlays but Overlay Mode is set to [%s] in fabric settings\" %\n                        (OVERLAY_MODE), devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                if hasCfgProfiles:\n                    gatherCfgProfileOverlays(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo,\n                        switchOverlayInfo, cfgProfiles)\n                else:\n                    gatherCliOverlays(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, switchOverlayInfo)\n\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    if not switchHasOverlays:\n        freeformCfg = []\n        # collect all the config profiles and add to freeform\n        for profileCmd in cfgProfiles:\n            # a config profile that exists on the switch, but, not applied??.. add it to the freeform\n            freeformCfg += cfgProfiles[profileCmd][\"show_run\"]\n\n        # gather all the applied profiles on the switch\n        appliedProfiles = getTemplateMatchResults(matchResults, \"apply_profile\")\n        if appliedProfiles:\n            for profileNvPair in appliedProfiles:\n                applyCmd = (\"apply profile %s\" % profileNvPair[\"PROFILE_NAME\"])\n                freeformCfg += [(\"apply profile %s\" % profileNvPair[\"PROFILE_NAME\"])]\n        switchOverlayInfo[\"POST_INTF_FF\"] += freeformCfg\n\n    overlayVrfsNameToVni = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n    utilObj = Util()\n    allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n    overlayVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"OVERLAY_VLANS\"])\n\n    Wrapper.print(\"%s: Switch [%s] ALL_VLANS = [%d][%s] OVERLAY_VLANS = [%d][%s]\" %  (funcName, formattedName,\n            len(switchOverlayInfo[\"ALL_VLANS\"]), allVlansOnSwitchStr, \n            len(switchOverlayInfo[\"OVERLAY_VLANS\"]), overlayVlansOnSwitchStr))\n\n    localVlans = list(set(switchOverlayInfo[\"ALL_VLANS\"]) - set(switchOverlayInfo[\"OVERLAY_VLANS\"]))\n\n    vpcVlanInt = 0\n    if switchOverlayInfo[\"isVpc\"] == \"true\":\n        vpcVlanInt = int(vPCInfo[\"peerLinkVlan\"])\n\n    localVlans.remove(1)\n    if vpcVlanInt in localVlans:\n        # remove the vPC peer link vlan\n        localVlans.remove(vpcVlanInt)\n\n    Wrapper.print(\"%s: Switch [%s] local vlans = [%d][%s]\" % (funcName, formattedName, len(localVlans), localVlans))\n\n    # build the toplevel vlan xxx config\n    freeformCfg = []\n    if len(localVlans):\n        util = Util()\n        freeformCfg.append(\"vlan \" + util.vlanStrFromList(localVlans))\n\n    for vlanId in localVlans:\n        vlanIdStr = str(vlanId)\n        vlanRec = getMatchingResultVlan(vlanIdStr, matchResults)\n        if vlanRec:\n            #Wrapper.print(\"%s: vlan [%s] is not an overlay vlan\" % (funcName, vlanIdStr))\n            isPvlan = False\n            isVNI = False\n            for vlanCmd in vlanRec[\"show_run\"]:\n                if \"private-vlan\" in vlanCmd:\n                    isPvlan = True\n                elif \"vn-segment\" in vlanCmd:\n                    isVNI = True\n            if isPvlan and isVNI:\n                Wrapper.print(\"%s: vlan [%s] has unsupported pvlan cmd: %s\" % (funcName, vlanIdStr, vlanCmd))\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":PVLAN OVERLAY\"),\n                    \"Cannot have private-vlan config on VNI VLANs.\", devSerial)\n                respObj.setFailureRetCode()\n                return\n            freeformCfg += vlanRec[\"show_run\"]\n\n    # put all the non overlay SVI configs into the FF\n    for intfName in sorted(interfacesRes.keys()):\n        intfMatchResult = interfacesRes[intfName]\n        if isIntfProcessed(intfMatchResult):\n            continue\n\n        if not intfName.lower().startswith(\"vlan\"):\n            # not an SVI\n            continue\n\n        # mark the interface as processed\n        intfMatchResult.update({\"isProcessed\" : True})\n        #Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\" % (intfName, sys._getframe().f_lineno))\n\n        vlanIdStr = intfName[4:]\n        vlanId = int(vlanIdStr)\n        if ((vlanId in switchOverlayInfo[\"OVERLAY_VLANS\"]) or (vlanId == vpcVlanInt)):\n            # skip the overlay SVI and the VPC peer link vlan\n            continue\n\n        Wrapper.print(\"%s: Non Overlay SVI [%s]\" % (funcName, intfName))\n        freeformCfg.append(\"interface %s\" % intfName)\n        freeformCfg += intfMatchResult[\"show_run_cmds\"]\n\n    # collect all the non overlay related configs that need to be captured in the switch_config_freeform block\n    vrfMatchRes = matchResults[\"FEATURES_INFO\"][\"VRF_BLOCK\"]\n    for vrfStr in vrfMatchRes.keys():\n        vrfRec = vrfMatchRes[vrfStr]\n        vrfName = vrfStr.split(\" \")[2].strip()\n        #Wrapper.print(\"%s: Processing VRF [%s]\" % (funcName, vrfName))\n        \n        if vrfName.lower() == MGMT_VRF_NAME:\n            # the \"management\" vrf is already taken of earlier\n            continue\n\n        # capture the entire config for a non-overlay vrf\n        # Note: in upgrade case, only the non config profile aware CLIs will be present in 'show run'\n        if vrfName.lower() not in overlayVrfsNameToVni:\n            #Wrapper.print(\"%s: [%s]: show run CLI processing\" % (funcName, vrfName))\n            vrfFF = []\n            vrfKey = 'vrf context ' + vrfName\n            vrfRec = matchResults[\"FEATURES_INFO\"][\"VRF_BLOCK\"].get(vrfKey)\n            if vrfRec != None:\n                for line in vrfRec[\"show_run\"]:\n                    if line.strip().startswith(\"ip name-server\"):\n                        # the DNS config will be processed in another part of the code.. do not add to the VRF cfg\n                        continue\n                    vrfFF.append(line)\n\n            freeformCfg += vrfFF\n\n    switchOverlayInfo[\"PRE_INTF_FF\"] += freeformCfg\n\n    # form the 'router bgp <as>' key to lookup\n    routerBgpKey = \"router bgp \" + BGP_AS\n    if routerBgpKey in matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"]:\n        bgpVrfMatchRes = matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"][routerBgpKey]\n        freeformCfg = switchOverlayInfo[\"BGP_FF\"]\n        for bgpVrfName in bgpVrfMatchRes.keys():\n            if bgpVrfName == \"unaccounted\":\n                continue\n            bgpvrfRec = bgpVrfMatchRes[bgpVrfName]\n            vrfName = bgpVrfName.split(\" \")[1].strip()\n            #Wrapper.print(\"%s: Processing BGP VRF [%s]\" % (funcName, vrfName))\n\n            if vrfName.lower() not in overlayVrfsNameToVni:\n                #Wrapper.print(\"%s: BGP VRF [%s]: show run CLI processing\" % (funcName, vrfName))\n                freeformCfg += bgpvrfRec[\"show_run\"]\n\n    freeformCfg = []\n    if \"evpn\" in matchResults[\"FEATURES_INFO\"][\"EVPN_BLOCK\"]:\n        evpnMatchRes = matchResults[\"FEATURES_INFO\"][\"EVPN_BLOCK\"][\"evpn\"]\n        for evpnStr in evpnMatchRes.keys():\n            vniStr = evpnStr.split(\" \")[1].strip()\n            evpnRec = evpnMatchRes[evpnStr]\n            #Wrapper.print(\"%s: Processing EVPN VNI [%s]\" % (funcName, vniStr))\n\n            isValidOverlay = False\n\n            if (migrateMode == \"brownAdd\"):\n                vlanIdInfo = switchOverlayInfo[\"SWITCH_VXLAN_INFO\"][\"vlanIdInfo\"]\n                # map vni -> vlan id\n                if vniStr in vlanIdInfo[\"VNIS\"]:\n                    #Wrapper.print(\"%s: EVPN Vni [%s] has vlan\" % (funcName, vniStr))\n                    # check if the vlan is an overlay vlan\n                    vlanIdInt = int(vlanIdInfo[\"VNIS\"][vniStr])\n                    if vlanIdInt in switchOverlayInfo[\"OVERLAY_VLANS\"]:\n                        #Wrapper.print(\"%s: EVPN Vni [%s] Vlan [%d] is an overlay vni\" % (funcName, vniStr, vlanIdInt))\n                        isValidOverlay = True\n        \n            if not isValidOverlay:\n                freeformCfg += evpnRec[\"show_run\"]\n    switchOverlayInfo[\"POST_INTF_FF\"] += freeformCfg\n    Wrapper.print(\"%s %s: End - FABRIC [%s] Switch [%s] Role [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, formattedName, role))\n\ndef getVlanCfg(vlanIdStr, matchResults, includeAllCfg):\n    freeformCfg = \"\"\n    vlanKey = 'vlan ' + vlanIdStr\n    vlanRec = matchResults[\"FEATURES_INFO\"][\"VLAN_BLOCK\"].get(vlanKey)\n    if vlanRec != None:\n        if includeAllCfg:\n            freeformCfg += Util.newLine()\n            freeformCfg += Util.newLine().join(vlanRec[\"show_run\"])\n        else:\n            if len(vlanRec[\"unaccounted\"]) > 0:\n                freeformCfg += Util.newLine()\n                freeformCfg += Util.newLine().join(vlanRec[\"unaccounted\"])\n\n    return freeformCfg\n\ndef getSviCfg(vlanIdStr, interfacesRes, includeAllCfg, isVrf, servicesInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    freeformCfg = \"\"\n    sviName = 'Vlan'+ vlanIdStr\n    intfMatchResult = interfacesRes.get(sviName)\n    if intfMatchResult != None:\n        if includeAllCfg:\n            ffList = [\"interface \" + sviName]\n            if isVrf and servicesInfo and len(servicesInfo):\n                for cmd in intfMatchResult[\"show_run_cmds\"]:\n                    addCmd = True\n                    strippedCmd = cmd.strip()\n\n                    # need to filter out some services related config\n                    if strippedCmd.startswith(\"ip policy route-map \"):\n                        rmName = strippedCmd.split(\"ip policy route-map \")[1]\n                        for rmPrefix in servicesInfo[\"serviceRmPrefixStr\"]:\n                            if rmName.startswith(rmPrefix):\n                                addCmd = False\n                                break\n                    if addCmd:\n                        ffList.append(cmd)\n            else:\n                ffList += intfMatchResult[\"show_run_cmds\"]\n            freeformCfg += (Util.newLine() + Util.newLine().join(ffList))\n        else:\n            if len(intfMatchResult[\"unaccounted_cmds\"]) > 0:\n                Wrapper.print(\"%s: sviName [%s]. Unaccounted [%s]\" % (funcName, sviName, intfMatchResult[\"unaccounted_cmds\"]))\n\n                sviUnacctCmds = []\n\n                # - these commands have issues with negation. Ex: to remove 'no ip redirects' CC will issue 'ip redirects'\n                #   which causes the command to actually get removed on switch\n                overlaySpecialSviCmds = [\"no ip redirects\", \"no ipv6 redirects\"]\n                sviHasOtherUnaccCmds = False\n\n                # special case some overlay SVI commands.. the redirect and forward related configs do not\n                # have policies to match\n                overlaySviCmds = [\"ip forward\", \"ipv6 forward\", \"no shutdown\"]\n                for cmd in intfMatchResult[\"unaccounted_cmds\"]:\n                    strippedCmd = cmd.strip()\n                    if strippedCmd in overlaySviCmds:\n                        continue\n                    elif strippedCmd not in overlaySpecialSviCmds:\n                        sviHasOtherUnaccCmds = True\n\n                    sviUnacctCmds.append(cmd)\n\n                if \"vlan_interface\" in intfMatchResult[\"matched_templates\"]:\n                    # this policy being present indicates both the CLI are present.. add them \n                    for cmd in overlaySpecialSviCmds:\n                        sviUnacctCmds.append(INTF_FIRST_LVL_SPACING + cmd)\n                if \"pim_interface\" in intfMatchResult[\"matched_templates\"]:\n                    # this is a match, but, for Brownfield this needs to go to the freeform\n                    sviHasOtherUnaccCmds = True\n                    sviUnacctCmds.append(INTF_FIRST_LVL_SPACING + \"ip pim sparse-mode\")\n\n                Wrapper.print(\"%s: sviName [%s]. sviUnacctCmds [%s]\" % (funcName, sviName, sviUnacctCmds))\n                if len(sviUnacctCmds) > 0:\n                    finalCfgToAddToFreeform = None\n                    if sviHasOtherUnaccCmds:\n                        finalCfgToAddToFreeform = sviUnacctCmds\n\n                    if finalCfgToAddToFreeform:\n                        cfg = Util.newLine().join(finalCfgToAddToFreeform)\n                        freeformCfg += (Util.newLine() + \"interface \" + sviName + Util.newLine() + cfg)\n\n                        # we need to add the 'no shutdown' config to avoid an issue seen with CC trying to\n                        # remove individual config lines.. otherwise CC will generate 'shutdown' to negate 'no shutdown'\n                        if \"no_shut_interface\" in intfMatchResult[\"matched_templates\"]:\n                            freeformCfg += (Util.newLine() + (\"%sno shutdown\" % INTF_FIRST_LVL_SPACING))\n                        Wrapper.print(\"%s: sviName [%s]. freeformCfg [%s]\" % (funcName, sviName, freeformCfg))\n    return freeformCfg\n\ndef getNveCfg(vniStr, matchResults, isVrf, includeAllCfg):\n    freeformCfg = \"\"\n    intNveRec = matchResults[\"FEATURES_INFO\"][\"NVE_BLOCK\"].get(\"interface nve1\")\n    if intNveRec != None:\n        if isVrf:\n            nveVniKey = 'member vni ' + vniStr + ' associate-vrf'\n        else:\n            nveVniKey = 'member vni ' + vniStr\n\n        nveVniRec = intNveRec.get(nveVniKey)\n        if nveVniRec != None:\n            if includeAllCfg:\n                freeformCfg += Util.newLine()\n                freeformCfg += Util.newLine().join(nveVniRec[\"show_run\"])\n            else:\n                if len(nveVniRec[\"unaccounted\"]) > 0:\n                    freeformCfg += Util.newLine()\n                    freeformCfg += Util.newLine().join(nveVniRec[\"unaccounted\"])\n    return freeformCfg\n\ndef getVrfCfg(vrfName, matchResults, includeAllCfg):\n    freeformCfg = \"\"\n    vrfKey = 'vrf context ' + vrfName\n    vrfRec = matchResults[\"FEATURES_INFO\"][\"VRF_BLOCK\"].get(vrfKey)\n    if vrfRec != None:\n        if includeAllCfg:\n            nameServerCfgRemoved = False\n            newCfg = []\n            for line in vrfRec[\"show_run\"]:\n                if line.strip().startswith(\"ip name-server\"):\n                    # the DNS config will be processed in another part of the code.. do not add to the VRF cfg\n                    nameServerCfgRemoved = True\n                    continue\n                newCfg.append(line)\n\n            collectCfg = False\n            lenCfg = len(newCfg)\n            if lenCfg > 1:\n                collectCfg = True\n            else:\n                if not nameServerCfgRemoved:\n                    # there is a case of a dangling 'vrf context xxx' line in the 'show run'.. capture that too\n                    # if the unaccounted has any config\n                    if len(vrfRec[\"unaccounted\"]) == 0:\n                        collectCfg = True\n            if collectCfg:\n                freeformCfg += Util.newLine()\n                freeformCfg += Util.newLine().join(newCfg)\n        else:\n            unaccLen = len(vrfRec[\"unaccounted\"])\n            if unaccLen > 0:\n                # handle a special case for \"simplified\" overlay CLIs where the 'vrf context xxx' is as follows:\n                #   vrf context vrf50000\n                #       vni 50000\n                # \n                # This shows up as 'unaccounted' and gets captured in the vrf freeform\n                # look for this special condition and skip if found\n                collectCfg = True\n                if unaccLen == 2:\n                    if vrfRec[\"unaccounted\"][1].strip().startswith(\"vni \"):\n                        collectCfg = False\n                if collectCfg:\n                    freeformCfg += Util.newLine()\n                    freeformCfg += Util.newLine().join(vrfRec[\"unaccounted\"])\n    return freeformCfg\n\ndef getEvpnCfg(vniStr, matchResults, includeAllCfg):\n    freeformCfg = \"\"\n    evpnKey = \"evpn\"\n    \n    evpnRec = matchResults[\"FEATURES_INFO\"][\"EVPN_BLOCK\"].get(evpnKey)\n    if evpnRec != None:\n        vniKey = 'vni ' + vniStr + \" l2\"\n        vniRec = evpnRec.get(vniKey)\n        if vniRec != None:\n            if includeAllCfg:\n                freeformCfg += Util.newLine()\n                freeformCfg += Util.newLine().join(vniRec[\"show_run\"])\n            else:\n                if len(vniRec[\"unaccounted\"]) > 0:\n                    freeformCfg += Util.newLine()\n                    freeformCfg += Util.newLine().join(vniRec[\"unaccounted\"])\n    return freeformCfg\n\ndef isServiceInterTenanteBGPNeighbor(devSerial, servicesInfo, vrfName, neighborIp):\n    funcName = sys._getframe(0).f_code.co_name\n    # check if neighbor is v4\n\n    Wrapper.print(\"%s: switch [%s] vrfName [%s] neighborIp [%s]\" % (funcName, devSerial, vrfName, neighborIp))\n    # check if this VRF is part of a inter-tenant FW\n    for serviceNodeName in servicesInfo[\"serviceSwMaps\"][devSerial][\"nodes\"]:\n        serviceNodeEntry = servicesInfo[\"serviceNodes\"][serviceNodeName]\n\n        for routePeerName in serviceNodeEntry[\"routePeers\"]:\n            rpEntry = serviceNodeEntry[\"routePeers\"][routePeerName]\n            if rpEntry[\"peerOption\"] == \"none\":\n                continue\n\n            # look through the networks and see if the eBGP neighbor is the same subnet\n            for netTypeEntry in rpEntry[\"nets\"].values():\n                netEntry = servicesInfo[\"serviceNets\"][netTypeEntry[\"vni\"]]\n                if vrfName != netEntry[\"vrfName\"]:\n                    continue\n                neighborSubnet = Util.getSubnetStringWithPrefix(neighborIp, netEntry[\"mask\"])\n                if neighborSubnet == netEntry[\"subnet\"]:\n                    nvPairs = netTypeEntry[\"ptNvPairs\"]\n                    if \"NEIGHBOR_IP\" not in nvPairs:\n                        nvPairs[\"NEIGHBOR_IP\"] = neighborIp\n                    return {\"nvPairs\" : nvPairs, \"snEntry\" : serviceNodeEntry}\n\n    return None\n\ndef handleServiceLoopback(fabricName, devSerial, intfName, loopbackId, matchingNvPairs, globalOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    retVal = False\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n\n    Wrapper.print(\"%s: FAB [%s]: switch [%s] intf [%s] id [%s]\" % (funcName, fabricName, devSerial, intfName, loopbackId))\n    if not (servicesInfo and switchOverlayInfo[\"isServiceLeaf\"] and (intfName in servicesInfo[\"serviceSwMaps\"][devSerial][\"lo\"])):\n        # not a service leaf and/or not a loopback we are interested in\n        return retVal\n\n    # check if the specified loopback is part of a eBGP peering\n    for serviceNodeName in servicesInfo[\"serviceSwMaps\"][devSerial][\"nodes\"]:\n        serviceNodeEntry = servicesInfo[\"serviceNodes\"][serviceNodeName]\n\n        #Wrapper.print(\"%s: SN [%s] serviceNodeEntry %s\" % (funcName, serviceNodeName, serviceNodeEntry))\n        isvPCPeer = False\n        for routePeerName in serviceNodeEntry[\"routePeers\"]:\n            rpEntry = serviceNodeEntry[\"routePeers\"][routePeerName]\n            if rpEntry[\"peerOption\"] == \"none\":\n                continue\n\n            for netTypeEntry in rpEntry[\"nets\"].values():\n                #Wrapper.print(\"%s: SN [%s] netTypeEntry %s\" % (funcName, serviceNodeName, netTypeEntry))\n                nvPairs = netTypeEntry[\"ptNvPairs\"]\n                if devSerial == serviceNodeEntry[\"swSerial\"]:\n                    if nvPairs.get(\".nbrLoIntf\", None) != intfName:\n                        continue\n                else:\n                    if devSerial == serviceNodeEntry.get(\"peerSwSerial\", None):\n                        # vPC peer case\n                        isvPCPeer = True\n                        if nvPairs.get(\".peerNbrLoIntf\", None) != intfName:\n                            continue\n\n                nvPairs[\"ADMIN_STATE\"] = \"true\"\n                loopbackIp = None\n                rmTag = \"12345\"\n                for templateName in matchingNvPairs:\n                    matchEntry = matchingNvPairs[templateName]\n                    if (templateName == \"loopback_interface\"):\n                        loopbackIp = matchEntry[\"IP\"]\n                    elif (templateName == \"loopback_interface_with_tag\"):\n                        loopbackIp = matchEntry[\"IP\"]\n                        rmTag = matchEntry[\"ROUTE_MAP_TAG\"]\n                    elif (templateName == \"shut_interface\"):\n                        nvPairs[\"ADMIN_STATE\"] = \"false\"\n\n                if loopbackIp:\n                    if \"LOOPBACK_IP\" not in nvPairs:\n                        nvPairs[\"LOOPBACK_IP\"] = loopbackIp\n                        nvPairs[\"ROUTE_MAP_TAG\"] = rmTag\n                    else:\n                        # vpc peer case\n                        nvPairs[\"PEER_LOOPBACK_IP\"] = loopbackIp\n\n                # set RM for the loopback id\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                entityName = (\"bgp_%s_%s\" % (servicesInfo[\"serviceNets\"][netTypeEntry[\"vni\"]][\"vrfName\"], nvPairs[\"NEIGHBOR_IP\"]))\n                Wrapper.print(\"%s: FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] entityName [%s]\" %\n                              (funcName, fabricName, key, loopbackId, entityName))\n                Util.exe(RM.set(fabricName, \"LOOPBACK_ID\", key, entityName, loopbackId))\n\n                return True\n\n    return retVal\n\ndef getVrfFreeformCfg(devSerial, vrfName, vrfVniStr, vrfVlanStr, matchResults, interfacesRes,\n                                                        includeAllCfg, switchOverlayInfo, servicesInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: vrfName [%s] vrfVni [%s] vrfVlanStr [%s] includeAllCfg [%r]\" % (funcName, vrfName,\n            vrfVniStr, vrfVlanStr, includeAllCfg))\n    freeformCfg = getVlanCfg(vrfVlanStr, matchResults, includeAllCfg)\n    freeformCfg += getSviCfg(vrfVlanStr, interfacesRes, includeAllCfg, True, servicesInfo)\n    freeformCfg += getVrfCfg(vrfName, matchResults, includeAllCfg)\n    freeformCfg += getNveCfg(vrfVniStr, matchResults, True, includeAllCfg)\n    freeformCfg += getEvpnCfg(vrfVniStr, matchResults, includeAllCfg)\n\n    filteredFF = [\"\"]\n    routerBgpKey = \"router bgp \" + BGP_AS\n    bgpRec = matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"].get(routerBgpKey)\n    if bgpRec != None:\n        vrfKey = 'vrf ' + vrfName\n        vrfRec = bgpRec.get(vrfKey)\n        if vrfRec != None:\n            if includeAllCfg:\n                if (switchOverlayInfo[\"isServiceLeaf\"] and (vrfName in servicesInfo[\"serviceSwMaps\"][devSerial][\"vrfs\"])):\n                    matchDict = None\n                    bgpVrfFF = []\n                    for line in vrfRec[\"show_run\"]:\n                        depth = (len(line) - len(line.lstrip(' '))) / 2\n                        #Wrapper.print(\"%s: line [%s] depth [%d] matchDict [%s]\" % (funcName, line, depth, matchDict))\n                        if depth == 0:\n                            matchDict = None\n                        elif depth == 1:\n                            matchDict = None\n                        elif depth == 2:\n                            matchDict = None\n                            strippedLine = line.strip()\n                            parts = strippedLine.split(\" \")\n                            if len(parts) == 2:\n                                if parts[0] == \"neighbor\":\n                                    matchDict = isServiceInterTenanteBGPNeighbor(devSerial, servicesInfo, vrfName, parts[1])\n                        elif depth == 3:\n                            if matchDict:\n                                ptNvPairs = matchDict[\"nvPairs\"]\n                                strippedLine = line.strip()\n                                parts = strippedLine.split(\" \")\n                                if len(parts) == 2:\n                                    if parts[0] == \"remote-as\":\n                                        if \"NEIGHBOR_ASN\" not in ptNvPairs:\n                                            ptNvPairs[\"NEIGHBOR_ASN\"] = parts[1]\n                                    elif parts[0] == \"update-source\":\n                                        snEntry = matchDict[\"snEntry\"]\n                                        # will be processed further later\n                                        if (snEntry[\"swSerial\"] == devSerial):\n                                            if (\".nbrLoIntf\" not in ptNvPairs):\n                                                ptNvPairs[\".nbrLoIntf\"] = parts[1]\n                                        elif \".peerNbrLoIntf\" not in ptNvPairs:\n                                            # vpc peer case\n                                            ptNvPairs[\".peerNbrLoIntf\"] = parts[1]\n\n                                        loList = servicesInfo[\"serviceSwMaps\"][devSerial][\"lo\"]\n                                        if parts[1] not in loList:\n                                            loList.append(parts[1])\n\n                        if matchDict == None:\n                            #Wrapper.print(\"%s: adding line [%s] to bgpVrfFF\" % (funcName, line))\n                            bgpVrfFF.append(line)\n                    # make sure the freeform has some valid configs\n                    #Wrapper.print(\"%s:  bgpVrfFF %s\" % (funcName, bgpVrfFF))\n                    if len(bgpVrfFF) > 2:\n                        filteredFF.extend(bgpVrfFF)\n                else:\n                    filteredFF.extend(vrfRec[\"show_run\"])\n            else:\n                if len(vrfRec[\"unaccounted\"]) > 0:\n                    filteredFF.extend(vrfRec[\"unaccounted\"])\n\n    if len(filteredFF):\n        freeformCfg += Util.newLine().join(filteredFF)\n\n    return freeformCfg.strip()\n\ndef getNetworkFreeformCfg(netVniStr, netVlanStr, matchResults, interfacesRes, includeAllCfg):\n    Wrapper.print(\"getNetworkFreeformCfg: netVni [%s] netVlanStr [%s]\" % (netVniStr, netVlanStr))\n\n    freeformCfg = getVlanCfg(netVlanStr, matchResults, includeAllCfg)\n    freeformCfg += getSviCfg(netVlanStr, interfacesRes, includeAllCfg, False, None)\n    freeformCfg += getNveCfg(netVniStr, matchResults, False, includeAllCfg)\n    freeformCfg += getEvpnCfg(netVniStr, matchResults, includeAllCfg)\n\n    return freeformCfg.strip()\n\ndef processOverlayAttachments(devSerial, switchOverlayInfo, globalOverlayInfo, allOverlayNets):\n    funcName = sys._getframe(0).f_code.co_name\n    switchDict = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n    Wrapper.print(\"%s: Switch [%s] - Is Extn [%s]\" % (funcName, switchDict[\"fmtName\"], switchOverlayInfo[\"doOverlayExtn\"]))\n\n    # process each of the VRF entries\n    for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n        vrfName = vrfEntry[\"name\"]\n        vrfVniId = vrfEntry[\"vni\"]\n        vrfAttachVlan = vrfEntry[\"vlanId\"]\n        configProfName = vrfEntry[\"cfgProfileName\"] if (\"cfgProfileName\" in vrfEntry) else None\n\n        \"\"\"\n        Wrapper.print(\"%s: Switch [%s] - Attaching for VRF [%s] VNI [%s] Profile Name [%s] Vlan [%d] instanceVals [%s] \"\n            \"Freeform [%s] Extension Vals [%s]\" % (funcName, switchDict[\"fmtName\"], vrfName, vrfVniId, configProfName,\n            vrfAttachVlan, vrfEntry[\"instanceVals\"], vrfEntry[\"freeformCfg\"], vrfEntry[\"extensionVals\"]))\n        \"\"\"\n\n        # check if the vrf entry exists in the global info db\n        if vrfVniId not in globalOverlayInfo[\"VRF_ATTACH\"]:\n            vrfAttachEntry = LanAttachByVRF()\n            vrfAttachEntry.setVrfName(vrfName)\n            vrfAttachEntry.setLanAttachList([])\n\n            globalOverlayInfo[\"VRF_ATTACH\"][vrfVniId] = vrfAttachEntry\n\n        # add an entry for this switch to the list\n        vrfSwitchAttach = LanVRFAttach()\n        vrfSwitchAttach.setFabric(FABRIC_NAME)\n        vrfSwitchAttach.setSerialNumber(devSerial)\n        vrfSwitchAttach.setVlan(vrfAttachVlan)\n        vrfSwitchAttach.setVrfName(vrfName)\n        if configProfName:\n            vrfSwitchAttach.setProfileName(configProfName)\n        vrfSwitchAttach.setExtensionValues(vrfEntry[\"extensionVals\"])\n        vrfSwitchAttach.setDeployment(True)\n        vrfSwitchAttach.setInstanceValues(vrfEntry[\"instanceVals\"])\n        vrfSwitchAttach.setFreeformConfig(vrfEntry[\"freeformCfg\"])\n\n        vrfAttachEntry = globalOverlayInfo[\"VRF_ATTACH\"][vrfVniId]\n        attachList = vrfAttachEntry.getLanAttachList()\n        attachList.append(vrfSwitchAttach)\n        vrfAttachEntry.setLanAttachList(attachList)\n\n    # process each of the network attachment entries\n    for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n\n        refNetEntry = allOverlayNets[netEntry[\"vni\"]][\"netEntry\"]\n        refNetName = refNetEntry[\"overlayNetName\"] if refNetEntry[\"overlayNetName\"] else refNetEntry[\"cfgProfileName\"]\n        configProfName = netEntry[\"cfgProfileName\"] if ((\"cfgProfileName\" in netEntry) and refNetEntry[\"overlayNetName\"]) else None\n\n        \"\"\"\n        Wrapper.print(\"%s: Switch [%s] - Attaching for network [%s/%s] Profile Name [%s] interfaces = [%s] Freeform [%s]\" % \n            (funcName, switchDict[\"fmtName\"], netEntry[\"vni\"], refNetName, configProfName, \n                netEntry[\"attachInfo\"], netEntry[\"freeformCfg\"]))\n        \"\"\"\n\n        # check if the network entry exists in the global info db\n        vniStr = str(netEntry[\"vni\"])\n        if vniStr in globalOverlayInfo[\"NETWORK_ATTACH\"]:\n            netAttach = globalOverlayInfo[\"NETWORK_ATTACH\"][vniStr]\n        else:\n            netAttach = LanAttachByNetwork()\n            netAttach.setNetworkName(refNetName)\n            netAttach.setLanAttachList([])\n\n            globalOverlayInfo[\"NETWORK_ATTACH\"][vniStr] = netAttach\n\n        # add a new attach entry for this switch\n        lanAttach = LanAttach()\n        lanAttach.setFabric(FABRIC_NAME)\n        lanAttach.setNetworkName(refNetName)\n        if configProfName:\n            # we have a network name that is different from the config profile name.. set the config profile name\n            lanAttach.setProfileName(configProfName)\n        lanAttach.setSerialNumber(devSerial)\n        lanAttach.setSwitchPorts(\",\".join(netEntry[\"attachInfo\"]))\n        lanAttach.setDetachSwitchPorts(\"\")\n        lanAttach.setVlan(netEntry[\"vlanId\"])\n        lanAttach.setDot1QVlan(1)\n        lanAttach.setUntagged(False)\n        lanAttach.setDeployment(True)\n        lanAttach.setExtensionValues(netEntry[\"extensionVals\"])\n        lanAttach.setInstanceValues(\"\")\n        lanAttach.setFreeformConfig(netEntry[\"freeformCfg\"])\n\n        attachList = netAttach.getLanAttachList()\n        attachList.append(lanAttach)\n        netAttach.setLanAttachList(attachList)\n\ndef ECLVrfSviLocalInfo(vrfName, vrfSviInfo, localFlag):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s(): vrfName [%s] localFlag [%s] vrfSviInfo[%s]\"%\n                  (funcName, vrfName, localFlag, vrfSviInfo))\n    info = {}\n    if localFlag:\n        try:\n            info = vrfSviInfo[vrfName][\"local\"]\n        except:\n            Wrapper.print(\"failed for info vrf %s\"%(vrfName))\n            pass\n    else:\n         try:\n            info = vrfSviInfo[vrfName][\"peer\"]\n         except:\n            Wrapper.print(\"failed for peerInfo vrf %s\"%(vrfName))\n            pass\n    return info\n     \ndef isSameSubnet(ipAddr1, ipAddr2):\n    sameSnet = False\n    try:\n        sameSnet = Util.exe(FabricWrapper.isSameIp4Or6NwAddr(ipAddr1, ipAddr2))\n    except:\n        pass\n    return sameSnet\n\ndef ECLPrepareVrfInstanceValues(fabricName, devices, globalOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Entering====\"%(funcName))\n\n    #VLP VRF <-> LITE PROTOCOL \n    ospfVLP = True if VRF_LITE_PROTOCOL == \"ospf\" else False\n    bgpVLP = True if VRF_LITE_PROTOCOL == \"ebgp\" else False\n    if not (ospfVLP or bgpVLP):\n        return\n\n    switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"]\n    aggSwitches = []\n    for devSerial in devices:\n        dict = switchInfoDict[devSerial]\n        if \"aggregation\" in dict[\"switchRole\"].lower():\n            aggSwitches.append(devSerial)\n    vrfNghborIpDeviceInfoDict = {}\n    vrfNghborIp4InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp4InfoDict\"] = {} \n    vrfNghborIp6InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp6InfoDict\"] = {}\n    vrfSviInstanceValues = {}\n    ECLGetVrfNeighborIpInfo(fabricName, devices, globalOverlayInfo, vrfNghborIpDeviceInfoDict)\n    vrfSviInfo = ECLGetVrfSviInfo(fabricName, devices, globalOverlayInfo, vrfNghborIpDeviceInfoDict)\n    if not vrfSviInfo:\n        return vrfSviInstanceValues\n\n    ignorePairSwitch = []\n    for devSerial in aggSwitches:\n        if devSerial not in ignorePairSwitch:\n            sn = devSerial\n            peerSn = Util.getVpcPeerSwitch(devSerial, fabricName)\n            ignorePairSwitch.append(peerSn)\n            switchOverlayInfo  = globalOverlayInfo[\"SWITCH_OVERLAYS\"][sn]\n            vrfInfo = switchOverlayInfo[\"VRFS_BY_ID\"]\n            vrfNameList = vrfInfo.keys()\n            for vrfName in vrfSviInfo:\n                if vrfName not in vrfNameList: \n                    Wrapper.print(\"%s(): combined-device [%s~%s] skip non-relavent vrf [%s]\"%(funcName, sn, peerSn, vrfName))\n                    continue\n                \"\"\"\n                if bgpVLP:\n                    vrfNghborIp4Info = vrfNghborIp4InfoDict.get(vrfName)\n                    Wrapper.print(\"%s(): combined-device [%s~%s] vrf [%s] vrfNghborIp4Info [%s]\"%(funcName, sn, peerSn, vrfName, vrfNghborIp4Info))\n                    localSnIp4NbrListInfo = vrfNghborIp4Info.get(sn) if vrfNghborIp4Info else None\n                    peerSnIp4NbrListInfo = vrfNghborIp4Info.get(peerSn) if vrfNghborIp4Info else None\n\n                    vrfNghborIp6Info = vrfNghborIp6InfoDict.get(vrfName)\n                    Wrapper.print(\"%s(): combined-device [%s~%s] vrf [%s] vrfNghborIp6Info [%s]\"%(funcName, sn, peerSn, vrfName, vrfNghborIp6Info))\n                    localSnIp6NbrListInfo = vrfNghborIp6Info.get(sn) if vrfNghborIp6Info else None\n                    peerSnIp6NbrListInfo = vrfNghborIp6Info.get(peerSn) if vrfNghborIp6Info else None\n\n                    if not((localSnIp4NbrListInfo and peerSnIp4NbrListInfo) or\n                           (localSnIp6NbrListInfo and peerSnIp6NbrListInfo)):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] localv4[%s] and peer4[%s] \"\n                                      \"or localv6[%s] and peerv6[%s] should be there\"%\n                                      (funcName, sn, peerSn, localSnIp4NbrListInfo, peerSnIp4NbrListInfo,\n                                      localSnIp6NbrListInfo, peerSnIp6NbrListInfo))\n                        continue\n                \"\"\"\n                sn1VrfInfo = ECLVrfSviLocalInfo(vrfName, vrfSviInfo, True)\n                sn2VrfInfo = ECLVrfSviLocalInfo(vrfName, vrfSviInfo, False)\n                localSnVrfInfo = {}\n                peerSnVrfInfo = {}\n                localSnVrfInfo = sn1VrfInfo.get(sn) if sn1VrfInfo.get(sn) else sn2VrfInfo.get(sn)\n                peerSnVrfInfo =  sn1VrfInfo.get(peerSn) if sn1VrfInfo.get(peerSn) else sn2VrfInfo.get(peerSn)\n\n                Wrapper.print(\"%s(): combined-device [%s~%s] vrf [%s] localSnVrfInfo [%s] peerSnVrfInfo[%s]\"%\n                              (funcName, sn, peerSn, vrfName, localSnVrfInfo, peerSnVrfInfo))\n                if not(localSnVrfInfo and peerSnVrfInfo):\n                    Wrapper.print(\"%s(): combined-device [%s~%s] vrfName [%s] skip if local[%s] and peer [%s] vrfInfo \"\n                                  \"both are not there\"%(funcName, sn, peerSn, vrfName, str(localSnVrfInfo), \n                                  str(peerSnVrfInfo)))\n                    continue\n                ipv4Snet = ipv4SnetPeer = \"\"\n                ip4 = localSnVrfInfo['ip4'] \n                pfx4 = localSnVrfInfo['prefix4']\n                ip4Peer = peerSnVrfInfo['ip4'] \n                pfx4Peer = peerSnVrfInfo['prefix4']\n                if ip4 and pfx4 and ip4Peer and pfx4Peer:\n                    ipv4Snet = ip4 + \"/\" + pfx4\n                    ipv4SnetPeer = ip4Peer + \"/\" + pfx4Peer\n                    if not isSameSubnet(ipv4Snet, ipv4SnetPeer):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip not same subnet Ips \"\n                                      \"ipv4Snet[%s]<-->ipv4SnetPeer[%s]\"%\n                                      (funcName, sn, peerSn, vrfName, ipv4Snet, ipv4SnetPeer))\n                        continue\n\n                ipv6Snet = ipv6SnetPeer = \"\"\n                ip6 = localSnVrfInfo['ip6']\n                pfx6 = localSnVrfInfo['prefix6']\n                ip6Peer = peerSnVrfInfo['ip6']\n                pfx6Peer = peerSnVrfInfo['prefix6']\n                if ip6 and pfx6 and ip6Peer and pfx6Peer:\n                    ipv6Snet = ip6 + \"/\" + pfx6\n                    ipv6SnetPeer = ip6Peer + \"/\" + pfx6Peer\n                    if not isSameSubnet(ipv6Snet, ipv6SnetPeer):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip not same subnet Ips \"\n                                      \"ipv6Snet[%s]<-->ipv6SnetPeer[%s]\"%\n                                     (funcName, sn, peerSn, vrfName, ipv6Snet, ipv6SnetPeer))\n                        continue\n\n                ip4Present = False if not (ipv4Snet and ipv4SnetPeer) else True\n                ip6Present = False if not (ipv6Snet and ipv6SnetPeer) else True\n\n                if not (ip4Present or ip6Present):\n                    continue\n                Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] pfx4 [%s] pfx4Peer [%s] pfx6 [%s] pfx6Peer [%s]\"%\n                                     (funcName, sn, peerSn, vrfName, pfx4, pfx4Peer, pfx6, pfx6Peer))\n                \"\"\"\n                matchingIp4VrfSviLocal = False\n                matchingIp4VrfSviPeer = False\n                matchingIp6VrfSviLocal = False\n                matchingIp6VrfSviPeer = False\n\n                Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] localSnIp4NbrListInfo [%s] peerSnIp4NbrListInfo [%s]\"%\n                                     (funcName, sn, peerSn, vrfName, str(localSnIp4NbrListInfo), str(peerSnIp4NbrListInfo)))\n                Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] localSnIp6NbrListInfo [%s] peerSnIp6NbrListInfo [%s]\"%\n                                     (funcName, sn, peerSn, vrfName, str(localSnIp6NbrListInfo), str(peerSnIp6NbrListInfo)))\n                for peerNghbrIp in peerSnIp4NbrListInfo:\n                    if not (peerNghbrIp and pfx4):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip possible misconfig\"\n                                      \"on svi peerNghbrIp [%s] or pfx4[%s]\"%\n                                      (funcName, sn, peerSn, vrfName, peerNghbrIp, pfx4))\n                        continue\n                    peerNghbrIpSnet = peerNghbrIp + \"/\" + pfx4\n                    if isSameSubnet(ipv4Snet, peerNghbrIpSnet):\n                        matchingVrfSviLocal = True\n\n                for localNghbrIp in localSnIp4NbrListInfo:\n                    if not (localNghbrIp and pfx4Peer):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip possible misconfig \"\n                                      \"on svi localNghbrIp [%s] or pfx4Peer[%s]\"%\n                                      (funcName, sn, peerSn, vrfName, localNghbrIp, pfx4Peer))\n                        continue\n                    localNghbrIpSnet = localNghbrIp + \"/\" + pfx4Peer\n                    if isSameSubnet(ipv4SnetPeer, localNghbrIpSnet):\n                        matchingVrfSviPeer = True\n                for peerNghbrIp6 in peerSnIp6NbrListInfo:\n                    if not (peerNghbrIp6 and pfx6):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip possible misconfig \"\n                                      \"on svi peerNghbrIp6 [%s] or pfx6[%s]\"%\n                                      (funcName, sn, peerSn, vrfName, peerNghbrIp6, pfx6))\n                        continue\n \n                    peerNghbrIp6Snet = peerNghbrIp6 + \"/\" + pfx6\n                    if isSameSubnet(ipv6Snet, peerNghbrIp6Snet):\n                        matchingIp6VrfSviLocal = True\n                for localNghbrIp6 in localSnIp6NbrListInfo:\n                    if not (localNghbrIp6 and pfx6Peer):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip possible misconfig \"\n                                      \"on svi localNghbrIp6 [%s] or pfx6Peer[%s]\"%\n                                      (funcName, sn, peerSn, vrfName, localNghbrIp6, pfx6Peer))\n                        continue\n                    localNghbrIp6Snet = localNghbrIp6 + \"/\" + pfx6Peer\n                    if isSameSubnet(ipv6SnetPeer, localNghbrIp6Snet):\n                        matchingIp6VrfSviPeer = True\n                if not ((matchingVrfSviLocal and matchingVrfSviPeer) or \n                        (matchingIp6VrfSviLocal and matchingIp6VrfSviPeer)):\n                    Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip not matching nbr Ips \"\n                                  \"matchingVrfSviLocal[%s]<-->matchingVrfSviPeer[%s] or \"\n                                  \"matchingIp6VrfSviLocal[%s]<-->matchingIp6VrfSviPeer[%s]\"%\n                                  (funcName, sn, peerSn, vrfName, matchingVrfSviLocal, matchingVrfSviPeer,\n                                   matchingIp6VrfSviLocal, matchingIp6VrfSviPeer))\n                    continue\n                \"\"\"\n                vrfInstanceDict = {}\n                Wrapper.print(\"%s(): sn [%s] <---> peerSn[%s] vrfname=[%s] localSnVrfInfo[%s] peerSnVrfInfo[%s]\"%\n                              (funcName, sn, peerSn, vrfName, localSnVrfInfo, peerSnVrfInfo))\n                snEntry = {}\n                snEntry[\"local\"] = {sn: localSnVrfInfo}\n                peerSnEntry = {}\n                snEntry[\"peer\"] = {peerSn: peerSnVrfInfo}\n                if not vrfSviInstanceValues.get(vrfName):\n                    vrfSviInstanceValues[vrfName] = {}\n                vrfSviInstanceValues[vrfName].update(snEntry)\n                vrfSviInstanceValues[vrfName].update(peerSnEntry)\n    Wrapper.print(\"%s() vrfSviInstanceValues %s\"%(funcName, vrfSviInstanceValues)) \n    Wrapper.print(\"%s():====Exiting====\"%(funcName))\n    return vrfSviInstanceValues\n\ndef ECLGetNbrList(vrfFreeformList, bgpAs, nghbrIp4List, nghbrIp6List):\n    length = len(vrfFreeformList)\n    for i in range (length):\n        remoteAs = \"    remote-as \" + bgpAs\n        if i < length-1:\n            x = vrfFreeformList[i]\n            x1 = vrfFreeformList[i+1]\n            if \"  neighbor\" in x and remoteAs in x1 and \":\" in x:\n                nghbrIp6List.append(x.lstrip(\"  neighbor \"))\n            elif \"  neighbor\" in x and remoteAs in x1 and \":\" not in x:\n                nghbrIp4List.append(x.lstrip(\"  neighbor \"))\n    return\n\ndef ECLGetVrfNeighborIp4OrIp6(devSerial, vrfName, overlayVrfsInfoById, matchResults):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Entering====\"%(funcName))\n    ip4, ip6 = (False, False)\n    if not matchResults:\n        Wrapper.print(\"%s() devSerial[%s] empty matchResults[%s]\"%(funcName, devSerial, matchResults))\n        return (False, False)\n    \n    if overlayVrfsInfoById:\n        swEntryIp4 = {}\n        swEntryIp6 = {}\n        vrfNameList = overlayVrfsInfoById.keys()\n        Wrapper.print(\"%s() devSerial[%s] vrfNameList[%s]\"%(funcName, devSerial, vrfNameList))\n        if vrfName in vrfNameList or vrfName == \"default\":\n            vrfFreeformList = []\n            if vrfName == \"default\":\n                featuresInfo = matchResults[\"FEATURES_INFO\"]\n                bgpBlock = featuresInfo[\"BGP_BLOCK\"]\n                bgpAsKey = \"router bgp \" + BGP_AS\n                defaultVrfUnacc = bgpBlock.get(bgpAsKey)\n                if defaultVrfUnacc:\n                    vrfFreeformList = defaultVrfUnacc.get(\"unaccounted\")\n            else:\n                vrfFreeformInfo = vrfInfo[vrfName][\"freeformCfg\"]\n                vrfFreeformList = vrfFreeformInfo.splitlines()\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] vrfFreeformList[%s]\"%(funcName, devSerial, vrfName, vrfFreeformList))\n            if not vrfFreeformList:\n                return (False, False)\n            nghbrIp4List = []\n            nghbrIp6List = []\n            ECLGetNbrList(vrfFreeformList, BGP_AS, nghbrIp4List, nghbrIp6List)\n            if not (nghbrIp4List or nghbrIp6List):\n                Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] skip without nbrIp4[%s] or nbrIp6[%s] list \"%\n                              (funcName, devSerial, vrfName, nghbrIp4List, nghbrIp6List))\n                return (False, False)\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] nghbrIp4List[%s]\"%(funcName, devSerial, vrfName, nghbrIp4List))\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] nghbrIp6List[%s]\"%(funcName, devSerial, vrfName, nghbrIp6List))\n            if len(nghbrIp4List) > 0:\n                ip4 = True\n            if len(nghbrIp6List) > 0:\n                ip6 = True\n    Wrapper.print(\"%s():====Exiting====\"%(funcName))\n    return (ip4, ip6)\n\ndef ECLGetVrfNeighborIpInfo(fabricName, devices, globalOverlayInfo, vrfNghborIpDeviceInfoDict):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Entering====\"%(funcName))\n    if VRF_LITE_PROTOCOL != \"ebgp\":\n        return\n    switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"]\n    aggSwitches = []\n    for devSerial in devices:\n         dict = switchInfoDict[devSerial]\n         if \"aggregation\" in dict[\"switchRole\"].lower():\n             aggSwitches.append(devSerial)\n    \n    vrfNghborIp4InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp4InfoDict\"]\n    vrfNghborIp6InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp6InfoDict\"]\n    for devSerial in aggSwitches:\n        switchOverlayInfo  = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n        vrfInfo = switchOverlayInfo[\"VRFS_BY_ID\"]\n        vrfNameList = vrfInfo.keys()\n        for vrfName in vrfNameList:\n            swEntryIp4 = {}\n            swEntryIp6 = {}\n            vrfFreeformList = []\n            if vrfName == \"default\":\n                switchDict = switchInfoDict[devSerial]\n                matchResult = Util.exe(getJSONFileContents(switchDict[\"matchResultsFileName\"]))\n                if not matchResult:\n                    continue\n                #Wrapper.print(\"matchResult [%s]\"%(matchResult))\n                featuresInfo = matchResult[\"FEATURES_INFO\"]\n                bgpBlock = featuresInfo[\"BGP_BLOCK\"]\n                bgpAsKey = \"router bgp \" + BGP_AS\n                defaultVrfUnacc = bgpBlock.get(bgpAsKey)\n                if defaultVrfUnacc: \n                    vrfFreeformList = defaultVrfUnacc.get(\"unaccounted\")\n            else:\n                vrfFreeformInfo = vrfInfo[vrfName][\"freeformCfg\"]\n                vrfFreeformList = vrfFreeformInfo.splitlines()\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] vrfFreeformList[%s]\"%(funcName, devSerial, vrfName, vrfFreeformList))\n            if not vrfFreeformList:\n                continue\n            nghbrIp4List = []\n            nghbrIp6List = []\n            ECLGetNbrList(vrfFreeformList, BGP_AS, nghbrIp4List, nghbrIp6List)\n            if not (nghbrIp4List or nghbrIp6List):\n                Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] skip without nbrIp4[%s] or nbrIp6[%s] list \"%\n                              (funcName, devSerial, vrfName, nghbrIp4List, nghbrIp6List))\n                continue\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] nghbrIp4List[%s]\"%(funcName, devSerial, vrfName, nghbrIp4List))\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] nghbrIp6List[%s]\"%(funcName, devSerial, vrfName, nghbrIp6List))\n            swEntryIp4.update({devSerial:nghbrIp4List})\n            swEntryIp6.update({devSerial:nghbrIp6List})\n            if not vrfNghborIp4InfoDict.get(vrfName):\n                vrfNghborIp4InfoDict[vrfName] = {}\n            vrfNghborIp4InfoDict[vrfName].update(swEntryIp4)\n            if not vrfNghborIp6InfoDict.get(vrfName):\n                vrfNghborIp6InfoDict[vrfName] = {}\n            vrfNghborIp6InfoDict[vrfName].update(swEntryIp6)\n    Wrapper.print(\"%s(): devSerial [%s] vrfNghborIp4InfoDict[%s]\"%(funcName, devSerial, vrfNghborIp4InfoDict))\n    Wrapper.print(\"%s(): devSerial [%s] vrfNghborIp6InfoDict[%s]\"%(funcName, devSerial, vrfNghborIp6InfoDict))\n    Wrapper.print(\"%s():====Exiting====\"%(funcName))\n\n\n'''\n#####\n# aggregation vpc pair switches.\n# get s1 int_vlan ptis\n# get s2 int_vlan ptis\n# make combined dictonary which is based on vrf\n# if s1: ipv4 and s2 ipv4 are in same subnet\n# vrf1 = {local: {s1:{vlan:vlanId, ip4:ipv4Val,}}, peer:{s2:{vlan:vlanId, ip4:ip4Val}}}\n# vrf2 = {local: {s1:{vlan:vlanId, ip4:ipv4Val,}}, peer:{s2:{vlan:vlanId, ip4:ip4Val}}}\n#\n####\n'''\n#check if local ip is in peer nbr ip\ndef validInstValBgpNbr(validateInputDict):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Enter====\"%(funcName))\n    vrfName     = validateInputDict.get(\"vrfName\")\n    vlanId      = validateInputDict.get(\"vlanId\")\n    sn          = validateInputDict.get(\"sn\")\n    peerSn      = validateInputDict.get(\"peerSn\")\n    ip4         = validateInputDict.get(\"ip4\")\n    ip6         = validateInputDict.get(\"ip6\")\n    vrfNghborIp4InfoDict = validateInputDict.get(\"vrfNghborIp4InfoDict\")\n    vrfNghborIp6InfoDict = validateInputDict.get(\"vrfNghborIp6InfoDict\")\n\n    peerSwNbrIp4List = []\n    peerSwNbrIp6List = []\n    vrfNghborIp4VrfInfo = vrfNghborIp4InfoDict.get(vrfName)\n    vrfNghborIp6VrfInfo = vrfNghborIp6InfoDict.get(vrfName)\n    if vrfNghborIp4VrfInfo:\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] is my peer here on interest, vrfNghborIp4VrfInfo[%s]\"%\n                      (vlanId, vrfName, peerSn, vrfNghborIp4VrfInfo))\n        peerSwNbrIp4List = vrfNghborIp4VrfInfo.get(peerSn, [])\n    if vrfNghborIp6VrfInfo:\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] is my peer here on interest, vrfNghborIp6VrfInfo[%s]\"%\n                      (vlanId, vrfName, peerSn, vrfNghborIp6VrfInfo))\n        peerSwNbrIp6List = vrfNghborIp6VrfInfo.get(peerSn, [])\n    if not (peerSwNbrIp4List or peerSwNbrIp6List):\n        Wrapper.print(\"%s(): continue without nhbrList local sn [%s] peerSn [%s] vlanId [%s] vrfName [%s]\"%(funcName, sn, peerSn, vlanId, vrfName))\n        return False\n    if (not((ip4 and vrfName and ip4 in peerSwNbrIp4List) or\n            (ip6 and vrfName and ip6 in peerSwNbrIp6List))):\n        Wrapper.print(\"%s(): Skip unwanted vlans sn [%s] vlanId [%s] vrfName [%s] ip4[%s] ip6[%s] peerSwNbrIp4List[%s] peerSwNbrIp6List[%s]\"%\n                  (funcName, sn, vlanId, vrfName, ip4, ip6, peerSwNbrIp4List, peerSwNbrIp6List))\n        return False\n    Wrapper.print(\"%s():====Exit====\"%(funcName))\n    return True\n\n#check if tag and area are matching\ndef validInstValOspfNbr(validateInputDict):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Enter====\"%(funcName))\n    vrfName     = validateInputDict.get(\"vrfName\")\n    vrfName     = validateInputDict.get(\"vrfName\")\n    vlanId      = validateInputDict.get(\"vlanId\")\n    sn          = validateInputDict.get(\"sn\")\n    peerSn      = validateInputDict.get(\"peerSn\")\n    ip4         = validateInputDict.get(\"ip4\")\n    ip6         = validateInputDict.get(\"ip6\")\n    vlanPtiInfoDict     = validateInputDict.get(\"vlanPtiInfoDict\")\n    vlanPtiInfoPeerDict = validateInputDict.get(\"vlanPtiInfoPeerDict\")\n\n\n    sviVlanIdToOspfTagDict          = vlanPtiInfoDict[\"sviVlanIdToOspfTagDict\"]  \n    sviVlanIdToOspfTagPeerDict      = vlanPtiInfoPeerDict[\"sviVlanIdToOspfTagPeerDict\"]\n    sviVlanIdToOspfAreaIdDict       = vlanPtiInfoDict[\"sviVlanIdToOspfAreaIdDict\"]\n    sviVlanIdToOspfAreadIdPeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToOspfAreadIdPeerDict\"]\n\n    sviVlanIdToOspf3TagDict         = vlanPtiInfoDict[\"sviVlanIdToOspf3TagDict\"]\n    sviVlanIdToOspf3TagPeerDict     = vlanPtiInfoPeerDict[\"sviVlanIdToOspf3TagPeerDict\"]\n    sviVlanIdToOspf3AreaIdDict      = vlanPtiInfoDict[\"sviVlanIdToOspf3AreaIdDict\"]\n    sviVlanIdToOspf3AreaIdPeerDict = vlanPtiInfoPeerDict[\"sviVlanIdToOspf3AreaIdPeerDict\"]\n    \n    ospfTag         = sviVlanIdToOspfTagDict.get(vlanId)\n    ospfTagPeer     = sviVlanIdToOspfTagPeerDict.get(vlanId)\n    ospfAreaId      = sviVlanIdToOspfAreaIdDict.get(vlanId) \n    ospfAreaIdPeer  = sviVlanIdToOspfAreadIdPeerDict.get(vlanId)\n\n    ospf3Tag        = sviVlanIdToOspf3TagDict.get(vlanId)\n    ospf3TagPeer    = sviVlanIdToOspf3TagPeerDict.get(vlanId)\n    ospf3AreaId     = sviVlanIdToOspf3AreaIdDict.get(vlanId)\n    ospf3AreaIdPeer = sviVlanIdToOspf3AreaIdPeerDict.get(vlanId)\n\n    if (not ((ospfTag and ospfTagPeer and ospfAreaId and ospfAreaIdPeer) or \n             (ospf3Tag and ospf3AreaId and ospf3TagPeer and ospf3AreaIdPeer))):\n        Wrapper.print(\"vlanId[%s] vrfName [%s] peerSn[%s] ospfTag[%s] ospfTagPeer[%s] \"\n                      \"ospfAreaId[%s] ospfAreaIdPeer[%s] ospf3Tag[%s] ospf3TagPeer[%s] \"\n                      \"ospf3AreaId[%s] ospf3AreaIdPeer[%s]  no ospf or ospf3 config \"\n                      \"looks like misconfig treat it as not interested for instenace values\"%\n                      (vlanId, vrfName, peerSn, ospfTag, ospfTagPeer, ospfAreaId, ospfAreaIdPeer,\n                       ospf3Tag, ospf3AreaId, ospf3TagPeer, ospf3AreaIdPeer))\n        return False\n\n    if not (ospfTag and ospfAreaId):\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] ospfTag[%s] \"\n                      \"ospfAreaId [%s] [%s] not interested\"%\n                      (vlanId, vrfName, peerSn, ospfTag, ospfAreaId))\n        return False\n                 \n    if not (ospfTagPeer and ospfAreaIdPeer):\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] ospfTagPeer[%s] \"\n                      \"ospfAreaIdPeer [%s] not interested\"%\n                      (vlanId, vrfName, peerSn, ospfTagPeer, ospfAreaIdPeer))\n        return False\n\n    if ospfTag != ospfTagPeer or ospfAreaId != ospfAreaIdPeer:\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] ospfTag[%s], ospfTagPeer[%s] \"\n                      \"ospfAreaId [%s] ospfAreaIdPeer [%s] not interested\"%\n                      (vlanId, vrfName, peerSn, ospfTag, ospfTagPeer, ospfAreaId, ospfAreaIdPeer))\n        return False\n\n    if ospf3Tag != ospfTagPeer or ospf3AreaId != ospf3AreaIdPeer:\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] ospf3Tag[%s], ospf3TagPeer[%s] \"\n                      \"ospf3AreaId [%s] ospf3AreaIdPeer [%s] not interested\"%\n                      (vlanId, vrfName, peerSn, ospf3Tag, ospf3TagPeer, ospf3AreaId, ospf3AreaIdPeer))\n        return False\n    Wrapper.print(\"%s():====Exit====\"%(funcName))\n    return True\n\ndef ECLGetVrfSviInfo(fabricName, devices, globalOverlayInfo, vrfNghborIpDeviceInfoDict):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Entering====\"%(funcName))\n    vrfToSviInfoDict = {}\n    #VLP VRF <-> LITE PROTOCOL \n    ospfVLP = True if VRF_LITE_PROTOCOL == \"ospf\" else False\n    bgpVLP = True if VRF_LITE_PROTOCOL == \"ebgp\" else False\n    if not (ospfVLP or bgpVLP):\n        return vrfToSviInfoDict\n\n    switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"]\n    aggSwitches = []\n    for devSerial in devices:\n         dict = switchInfoDict[devSerial]\n         if \"aggregation\" in dict[\"switchRole\"].lower():\n             aggSwitches.append(devSerial)\n\n    vrfNghborIp4InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp4InfoDict\"]\n    vrfNghborIp6InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp6InfoDict\"]\n    vrfSwitchInfoDict = {}\n    ignorePairSwitch = []\n    for devSerial in aggSwitches:\n        if devSerial not in ignorePairSwitch:\n            snMR = {}\n            peerSnMR = {}\n            vlanPtiInfoDict = {}\n            vlanPtiInfoPeerDict = {}\n            sn = devSerial\n            peerSn = Util.getVpcPeerSwitch(devSerial, fabricName)\n            ignorePairSwitch.append(peerSn)\n\n            switchOverlayInfo           = globalOverlayInfo[\"SWITCH_OVERLAYS\"][sn]\n            switchOverlayPeerInfo       = globalOverlayInfo[\"SWITCH_OVERLAYS\"][peerSn]\n\n            if ospfVLP:\n                snMR = getMatchResultObjFromGOI(fabricName, sn, globalOverlayInfo) \n                peerSnMR = getMatchResultObjFromGOI(fabricName, peerSn, globalOverlayInfo)\n\n            vrfNameListSn               = switchOverlayInfo[\"VRFS_BY_ID\"].keys()\n            vrfNameListPeerSn           = switchOverlayPeerInfo[\"VRFS_BY_ID\"].keys()\n\n            sviVrfNameToVlanIdDict      = vlanPtiInfoDict[\"sviVrfNameToVlanIdDict\"]             = {}\n            sviVrfNameToVlanIdPeerDict  = vlanPtiInfoPeerDict[\"sviVrfNameToVlanIdPeerDict\"]     = {}\n\n            sviVlanIdToVrfNameDict      = vlanPtiInfoDict[\"sviVlanIdToVrfNameDict\"]             = {}\n            sviVlanIdToVrfNamePeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToVrfNamePeerDict\"]     = {}\n\n            sviVlanIdToVlanNameDict      = vlanPtiInfoDict[\"sviVlanIdToVlanNameDict\"]           = {}\n            sviVlanIdToVlanNamePeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToVlanNamePeerDict\"]   = {}\n\n            sviVlanIdToIp4Dict          = vlanPtiInfoDict[\"sviVlanIdToIp4Dict\"]                 = {}\n            sviVlanIdToIp4PeerDict      = vlanPtiInfoPeerDict[\"sviVlanIdToIp4PeerDict\"]         = {}\n            sviVlanIdToPrefix4Dict      = vlanPtiInfoDict[\"sviVlanIdToPrefix4Dict\"]             = {}\n            sviVlanIdToPrefix4PeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToPrefix4PeerDict\"]     = {}\n\n            sviVlanIdToIp6Dict          = vlanPtiInfoDict[\"sviVlanIdToIp6Dict\"]                 = {}\n            sviVlanIdToIp6PeerDict      = vlanPtiInfoPeerDict[\"sviVlanIdToIp6PeerDict\"]         = {}\n            sviVlanIdToPrefix6Dict      = vlanPtiInfoDict[\"sviVlanIdToPrefix6Dict\"]             = {}\n            sviVlanIdToPrefix6PeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToPrefix6PeerDict\"]     = {}\n\n            sviVlanIdToPtiDict          = vlanPtiInfoDict[\"sviVlanIdToPtiDict\"]                 = {}\n            sviVlanIdToPtiPeerDict      = vlanPtiInfoPeerDict[\"sviVlanIdToPtiPeerDict\"]         = {}\n            sviVlanIdToDescDict         = vlanPtiInfoDict[\"sviVlanIdToDescDict\"]                = {}  \n            sviVlanIdToDescPeerDict     = vlanPtiInfoPeerDict[\"sviVlanIdToDescPeerDict\"]        = {}  \n\n            sviVlanIdToOspfTagDict          = vlanPtiInfoDict[\"sviVlanIdToOspfTagDict\"]         = {}  \n            sviVlanIdToOspfTagPeerDict      = vlanPtiInfoPeerDict[\"sviVlanIdToOspfTagPeerDict\"]     = {}  \n\n            sviVlanIdToOspfAreaIdDict       = vlanPtiInfoDict[\"sviVlanIdToOspfAreaIdDict\"]      = {}  \n            sviVlanIdToOspfAreadIdPeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToOspfAreadIdPeerDict\"] = {}  \n\n            sviVlanIdToOspf3TagDict         = vlanPtiInfoDict[\"sviVlanIdToOspf3TagDict\"]    = {}  \n            sviVlanIdToOspf3TagPeerDict     = vlanPtiInfoPeerDict[\"sviVlanIdToOspf3TagPeerDict\"]    = {}  \n\n            sviVlanIdToOspf3AreaIdDict      = vlanPtiInfoDict[\"sviVlanIdToOspf3AreaIdDict\"]     = {}  \n            sviVlanIdToOspf3AreaIdPeerDict = vlanPtiInfoPeerDict[\"sviVlanIdToOspf3AreaIdPeerDict\"] = {}  \n            \n            ECLGetVlanInfoFromPti(vlanPtiInfoDict, sn, vrfNameListSn, False, snMR)\n            ECLGetVlanInfoFromPti(vlanPtiInfoPeerDict, peerSn, vrfNameListPeerSn, True, peerSnMR)\n\n            Wrapper.print(\"vlanPtiInfoDict[%s]\"%(vlanPtiInfoDict))\n            Wrapper.print(\"vlanPtiInfoPeerDict[%s]\"%(vlanPtiInfoPeerDict))\n            #for vrfName in sviVrfNameToVlanIdDict:\n            for vlanId in sviVlanIdToVrfNameDict:\n                vrfName = sviVlanIdToVrfNameDict[vlanId]\n                ip4 = sviVlanIdToIp4Dict.get(vlanId)\n                ip6 = sviVlanIdToIp6Dict.get(vlanId)\n                validateInputDict = {}\n                if bgpVLP:\n                    validateInputDict.update({\"vrfName\":vrfName, \"vlanId\":vlanId, \n                                              \"sn\":sn, \"peerSn\":peerSn, \"ip4\":ip4, \"ip6\":ip6,\n                                              \"vrfNghborIp4InfoDict\":vrfNghborIp4InfoDict, \n                                              \"vrfNghborIp6InfoDict\":vrfNghborIp6InfoDict})\n                    if not validInstValBgpNbr(validateInputDict):\n                        continue\n                elif ospfVLP:\n                    validateInputDict.update({\"vrfName\":vrfName, \"vlanId\":vlanId, \"sn\":sn, \"peerSn\":peerSn, \n                                              \"vlanPtiInfoDict\":vlanPtiInfoDict, \"ip4\":ip4, \"ip6\":ip6,\n                                              \"vlanPtiInfoPeerDict\":vlanPtiInfoPeerDict})\n                    if not validInstValOspfNbr(validateInputDict):\n                        continue\n \n                entry    = {}\n                vlanName = sviVlanIdToVlanNameDict.get(vlanId)\n                prefix4  = sviVlanIdToPrefix4Dict.get(vlanId)\n                prefix6  = sviVlanIdToPrefix6Dict.get(vlanId)\n                pti      = sviVlanIdToPtiDict.get(vlanId)\n                desc     = sviVlanIdToDescDict.get(vlanId)\n                sviDict  = {}\n                sviDict.update({\"vlanId\":vlanId,\"vlanName\":vlanName, \"ip4\":ip4, \"ip6\":ip6,\n                                \"prefix4\":prefix4, \"prefix6\":prefix6,\"desc\":desc, \"ptiId\":pti})\n                entry.update({sn:sviDict})\n                local = {\"local\":entry}\n                Wrapper.print(\"%s(): sn [%s] vrfName [%s] entry[%s]\"%(funcName, sn, vrfName, str(entry)))\n                if not vrfToSviInfoDict.get(vrfName):\n                    vrfToSviInfoDict[vrfName] = {}\n                vrfToSviInfoDict[vrfName].update(local)\n                Wrapper.print(\"%s(): sn [%s] vrfToSviInfoDict local [%s]\"%(funcName, sn, str(vrfToSviInfoDict)))\n            for vlanIdPeer in sviVlanIdToVrfNamePeerDict:\n                vrfNamePeer = sviVlanIdToVrfNamePeerDict[vlanIdPeer]\n                ip4Peer = sviVlanIdToIp4PeerDict.get(vlanIdPeer)\n                ip6Peer = sviVlanIdToIp6PeerDict.get(vlanIdPeer)\n                if bgpVLP:\n                    validateInputDict.update({\"vrfName\":vrfNamePeer, \"vlanId\":vlanIdPeer, \n                                              \"sn\":peerSn, \"peerSn\":sn, \"ip4\":ip4Peer, \"ip6\":ip6Peer,\n                                              \"vrfNghborIp4InfoDict\":vrfNghborIp4InfoDict, \n                                              \"vrfNghborIp6InfoDict\":vrfNghborIp6InfoDict})\n                    if not validInstValBgpNbr(validateInputDict):\n                        continue\n                elif ospfVLP:\n                    validateInputDict.update({\"vrfName\":vrfNamePeer, \"vlanId\":vlanIdPeer, \n                                              \"sn\":peerSn, \"peerSn\":sn, \"ip4\":ip4Peer, \"ip6\":ip6Peer,\n                                              \"vlanPtiInfoDict\":vlanPtiInfoDict, \n                                              \"vlanPtiInfoPeerDict\":vlanPtiInfoPeerDict})\n                    if not validInstValOspfNbr(validateInputDict):\n                        continue\n                \n                peerEntry    = {}\n                vlanNamePeer = sviVlanIdToVlanNamePeerDict.get(vlanIdPeer)\n                prefix4Peer  = sviVlanIdToPrefix4PeerDict.get(vlanIdPeer)\n                prefix6Peer  = sviVlanIdToPrefix6PeerDict.get(vlanIdPeer)\n                ptiPeer      = sviVlanIdToPtiPeerDict.get(vlanIdPeer)\n                descPeer     = sviVlanIdToDescPeerDict.get(vlanIdPeer)\n                sviPeerDict  = {}\n                sviPeerDict.update({\"vlanId\":vlanIdPeer,\"vlanName\":vlanNamePeer, \"ip4\":ip4Peer, \"ip6\":ip6Peer,\n                                    \"prefix4\":prefix4Peer, \"prefix6\":prefix6Peer, \"desc\":descPeer, \"ptiId\":ptiPeer})\n                peerEntry.update({peerSn:sviPeerDict})\n                peer = {\"peer\":peerEntry}\n                Wrapper.print(\"%s(): peerSn [%s] vrfNamePeer [%s] peerEntry[%s]\"%(funcName, peerSn, vrfNamePeer, str(peerEntry)))\n                if not vrfToSviInfoDict.get(vrfNamePeer):\n                    vrfToSviInfoDict[vrfNamePeer] = {}\n                vrfToSviInfoDict[vrfNamePeer].update(peer)\n                Wrapper.print(\"%s(): peerSn [%s] vrfToSviInfoDict peer [%s]\"%(funcName, peerSn, str(vrfToSviInfoDict)))\n            Wrapper.print(\"%s(): combinedSn [%s~%s] vrfToSviInfoDict [%s]\"%(funcName, sn, peerSn, str(vrfToSviInfoDict)))\n    Wrapper.print(\"%s():====Exiting====\"%(funcName))\n    return vrfToSviInfoDict\n\n#considers only one agg pair, parent call should ensure other aggpairs\ndef ECLGetVlanInfoFromPti(vlanPtiInfoDict, devSerial, overlayVrfNameList, peer, matchResults):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s(): devSerial [%s] ====Entering====\"%(funcName, devSerial))\n    Wrapper.print(\"%s(): devSerial [%s] overlayVrfNameList [%s]\"%(funcName, devSerial, overlayVrfNameList))\n    sviVlanIdToVrfNameDict = vlanPtiInfoDict[\"sviVlanIdToVrfNameDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToVrfNamePeerDict\"]\n    sviVrfNameToVlanIdDict = vlanPtiInfoDict[\"sviVrfNameToVlanIdDict\"] if not peer else vlanPtiInfoDict[\"sviVrfNameToVlanIdPeerDict\"]\n    sviVlanIdToIp4Dict     = vlanPtiInfoDict[\"sviVlanIdToIp4Dict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToIp4PeerDict\"]\n    sviVlanIdToPrefix4Dict = vlanPtiInfoDict[\"sviVlanIdToPrefix4Dict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToPrefix4PeerDict\"]\n    sviVlanIdToIp6Dict     = vlanPtiInfoDict[\"sviVlanIdToIp6Dict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToIp6PeerDict\"]\n    sviVlanIdToPrefix6Dict = vlanPtiInfoDict[\"sviVlanIdToPrefix6Dict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToPrefix6PeerDict\"]\n    sviVlanIdToPtiDict     = vlanPtiInfoDict[\"sviVlanIdToPtiDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToPtiPeerDict\"]\n    sviVlanIdToDescDict    = vlanPtiInfoDict[\"sviVlanIdToDescDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToDescPeerDict\"]\n    sviVlanIdToOspfTagDict    = vlanPtiInfoDict[\"sviVlanIdToOspfTagDict\"]  if not peer else vlanPtiInfoDict[\"sviVlanIdToOspfTagPeerDict\"]\n    sviVlanIdToOspfAreaIdDict = vlanPtiInfoDict[\"sviVlanIdToOspfAreaIdDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToOspfAreadIdPeerDict\"]  \n    sviVlanIdToOspf3TagDict    = vlanPtiInfoDict[\"sviVlanIdToOspf3TagDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToOspf3TagPeerDict\"] \n    sviVlanIdToOspf3AreaIdDict = vlanPtiInfoDict[\"sviVlanIdToOspf3AreaIdDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToOspf3AreaIdPeerDict\"]  \n \n    vlanIdList = []\n\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"int_vlan\")\n    srchOpt.setEntityType(\"INTERFACE\")\n    srchOpt.setTemplateContentType(\"PYTHON\")\n    srchOpt.setSource(\"\")\n    sviPtis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    ospfVlanIntfList = []\n    ospf3VlanIntfList = []\n    if matchResults:\n        #oil <-> ospfIntfList\n        #o3il <-> ospf3IntfList\n        oil = matchResults[\"ospf_interface_11_1\"]\n        ospfVlanIntfList = list(filter(lambda oil: \"Vlan\" in oil['INTF_NAME'], oil))\n        o3il = matchResults[\"ospf_interface_11_1\"]\n        ospf3VlanIntfList = list(filter(lambda oil: \"Vlan\" in oil['INTF_NAME'], o3il))\n\n    for pti in sviPtis:\n        if not pti.isDeleted():\n            policyId = pti.getPolicyId()\n            ptiNvPairs = pti.getNvPairs()\n            vrfName = ptiNvPairs.get(\"INTF_VRF\")\n            if vrfName == \"\":\n                vrfName = \"default\"\n            #Wrapper.print(\"%s(): devSerial [%s] vrfName [%s]\"%(funcName, devSerial, vrfName))\n            if vrfName not in overlayVrfNameList:\n                Wrapper.print(\"%s(): devSerial [%s] unexpected vrfName [%s]\"%(funcName, devSerial, vrfName))\n                continue\n            \n            #Wrapper.print(\"%s(): devSerial [%s] ptiNvPairs [%s]\"%(funcName, devSerial, ptiNvPairs))\n            intfName = ptiNvPairs.get(\"INTF_NAME\").lower()\n            adminState = ptiNvPairs.get(\"ADMIN_STATE\").lower()\n            if adminState != \"true\":\n                Wrapper.print(\"%s(): devSerial [%s] vrfName [%s] svi [%s] \"\n                              \"skip possible misconfig with shut svi\"%\n                              (funcName, devSerial, vrfName, intfName))\n                continue\n\n            ffConf = ptiNvPairs.get(\"CONF\")\n            ffConfList = ffConf.splitlines()\n            secondaryIpAddPresent = False\n            multipleIp6Count = 0\n            for line in ffConfList:\n                if \"ip address\" in line and \"secondary\" in line:\n                    secondaryIpAddPresent = True\n                if \"ipv6 address\" in line:\n                    multipleIp6Count += 1\n            if secondaryIpAddPresent or multipleIp6Count > 1:\n                Wrapper.print(\"%s(): do not consider svi with secondary ip or multiple v6\"\n                              \" devSerial [%s] vrfName [%s] freeform [%s]\"%(funcName, devSerial, vrfName, ffConf))\n                continue\n\n            vlanId = intfName.lstrip(\"Vlan\")\n            sviDesc = ptiNvPairs.get(\"DESC\").lower()\n            sviVlanIdToDescDict[vlanId] = sviDesc\n            #Wrapper.print(\"%s(): devSerial [%s] vlanId [%s]\"%(funcName, devSerial, vlanId))\n            vlanIdList.append(vlanId)\n            sviVlanIdToVrfNameDict[vlanId] = vrfName\n            sviVrfNameToVlanIdDict[vrfName] = vlanId\n            sviVlanIdToPtiDict[vlanId] =  policyId\n            if ospfVlanIntfList:\n                for ospfIntfRecord in ospfVlanIntfList:\n                    ospfIntf = ospfIntfRecord[\"INTF_NAME\"].lower()\n                    if ospfIntf == intfName:\n                        ospfAreaId = ospfIntfRecord[\"OSPF_AREA_ID\"]\n                        ospfTag = ospfIntfRecord[\"OSPF_TAG\"]\n                        if ospfTag and ospfAreaId:\n                            sviVlanIdToOspfTagDict[vlanId] = ospfTag\n                            sviVlanIdToOspfAreaIdDict[vlanId] = ospfAreaId\n                \n            if ospf3VlanIntfList:\n                for ospf3IntfRecord in ospf3VlanIntfList:\n                    ospf3Intf = ospf3IntfRecord[\"INTF_NAME\"].lower()\n                    if ospf3Intf == intfName:\n                        ospf3AreaId = ospf3IntfRecord[\"OSPF_AREA_ID\"]\n                        ospf3Tag = ospf3IntfRecord[\"OSPF_TAG\"]\n                        if ospf3Tag and ospf3AreaId:\n                            sviVlanIdToOspf3TagDict[vlanId] = ospf3Tag\n                            sviVlanIdToOspf3AreaIdDict[vlanId] = ospf3AreaId\n \n            ip4 = ptiNvPairs.get(\"IP\")\n            prefix4 = ptiNvPairs.get(\"PREFIX\")\n            #Wrapper.print(\"%s(): devSerial [%s] ip4 [%s] prefix4[%s]\"%(funcName, devSerial, ip4,prefix4))\n            if ip4 and prefix4:\n                sviVlanIdToIp4Dict[vlanId] = ip4 \n                sviVlanIdToPrefix4Dict[vlanId] = prefix4 \n            for line in ffConfList:\n                ffConf = line.lstrip()\n                if \"ipv6 address\" in ffConf:\n                    ipPrefix6 = ffConf.lstrip(\"ipv6 address\")\n                    ip6, prefix6 = ipPrefix6.split(\"/\") \n                    if ip6 and prefix6:\n                        sviVlanIdToIp6Dict[vlanId] = ip6\n                        sviVlanIdToPrefix6Dict[vlanId] = prefix6\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToVrfNameDict [%s]\"%(funcName, devSerial, sviVlanIdToVrfNameDict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToPtiDict [%s]\"%(funcName, devSerial, sviVlanIdToPtiDict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToIp4Dict [%s]\"%(funcName, devSerial, sviVlanIdToIp4Dict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToPrefix6Dict [%s]\"%(funcName, devSerial, sviVlanIdToPrefix6Dict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToOspfTagDict [%s]\"%(funcName, devSerial, sviVlanIdToOspfTagDict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToOspfAreaIdDict [%s]\"%(funcName, devSerial, sviVlanIdToOspfAreaIdDict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToOspf3TagDict [%s]\"%(funcName, devSerial, sviVlanIdToOspf3TagDict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToOspf3AreaIdDict [%s]\"%(funcName, devSerial, sviVlanIdToOspf3AreaIdDict))\n\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"switch_freeform\")\n    srchOpt.setEntityType(\"INTERFACE\")\n    srchOpt.setTemplateContentType(\"PYTHON\")\n    srchOpt.setSource(\"\")\n    ffPtis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    for vlanId in vlanIdList:\n        for pti in ffPtis:\n            if not pti.isDeleted():\n                ptiNvPairs = pti.getNvPairs()\n                conf = ptiNvPairs.get(\"CONF\")\n                if (\"vlan \"+vlanId) in conf:\n                     isVlanConfigBlock = False\n                     confList = conf.splitlines()\n                     for line in confList:\n                         Wrapper.print(\"looking for vlanId [%s], found line [%s]\"%(vlanId, line))\n                         depth = (len(line) - len(line.lstrip(' '))) / 2\n                         if depth == 0:\n                            if isVlanConfigBlock:\n                                # we are out of the Vlan configuration block\n                                isVlanConfigBlock = False\n                            if line.startswith(\"vlan \"+vlanId):\n                                isVlanConfigBlock = True\n                                continue\n                         if isVlanConfigBlock:\n                             if \"name\" in line:\n                                vlanName = re.sub(r'. name ', '', line, count=1)\n                                sviVlanIdToVlanNameDict[vlanId] = vlanName\n\n    Wrapper.print(\"%s(): devSerial [%s] ====Exiting====\"%(funcName, devSerial))\n\ndef ECLGetDeviceVrfInstanceValue(vrfName, devSerial, vrfSviInstanceValues):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s(): vrfName [%s] devSerial [%s] ====Enter====\"%(funcName, vrfName, devSerial))\n    localVrfInstanceValues = {}\n    peerVrfInstanceValues = {}\n    localVrfDeviceInstanceValues = {}\n    localVrfDeviceInstanceValues = {}\n    vrfInstValsAndPti = {}\n    imlocal = \"\"\n    try:\n        localVrfInstanceValues = vrfSviInstanceValues[vrfName][\"local\"]\n        peerVrfInstanceValues = vrfSviInstanceValues[vrfName][\"peer\"]\n    except:\n        pass\n    Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] localVrfInstanceValues [%s] \"\n                  \"peerVrfInstanceValues [%s]\"%(funcName, devSerial, vrfName, \n                  localVrfInstanceValues, peerVrfInstanceValues))\n    if localVrfInstanceValues and peerVrfInstanceValues:\n        if devSerial in localVrfInstanceValues.keys():\n            localVrfDeviceInstanceValues =  localVrfInstanceValues[devSerial]\n            peerVrfDeviceInstanceValues = peerVrfInstanceValues.values()[0]\n            Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] got in local order\"%\n                          (funcName, devSerial, vrfName))\n        elif devSerial in peerVrfInstanceValues.keys():\n            localVrfDeviceInstanceValues =  peerVrfInstanceValues[devSerial]\n            peerVrfDeviceInstanceValues = localVrfInstanceValues.values()[0]\n            Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] got in peer order\"%\n                          (funcName, devSerial, vrfName))\n        \n        if localVrfDeviceInstanceValues and peerVrfDeviceInstanceValues:\n            Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] collect instances\"%\n                          (funcName, devSerial, vrfName))\n            ip4L = localVrfDeviceInstanceValues[\"ip4\"]\n            prefix4L = localVrfDeviceInstanceValues[\"prefix4\"]\n            \n            ip4MaskL = (ip4L + \"/\" + prefix4L) if (ip4L and prefix4L) else \"\"\n            nghbrIp4L = peerVrfDeviceInstanceValues[\"ip4\"]\n            nghbrIp4L = nghbrIp4L if nghbrIp4L else \"\" \n\n            ip6L = localVrfDeviceInstanceValues[\"ip6\"]\n            prefix6L = localVrfDeviceInstanceValues[\"prefix6\"]\n\n            ip6MaskL = (ip6L + \"/\" + prefix6L) if (ip6L and prefix6L) else \"\"\n            nghbrIp6L = peerVrfDeviceInstanceValues[\"ip6\"]\n            nghbrIp6L = nghbrIp6L if nghbrIp6L else \"\" \n\n            vlanIdL = localVrfDeviceInstanceValues[\"vlanId\"].lstrip(\"vlan\")\n            vlanIdL = vlanIdL if vlanIdL else \"\" \n            sviDescL = localVrfDeviceInstanceValues[\"desc\"]\n            sviDescL = sviDescL if sviDescL else \"\"\n\n            vlanNameL = localVrfDeviceInstanceValues[\"vlanName\"]\n            vlanNameL = vlanNameL if vlanNameL else \"\"\n                \n            ptiIdL = localVrfDeviceInstanceValues[\"ptiId\"]\n\n            instanceValsDict = {\"vrfVlanName\": vlanNameL,\n                                \"SVI_IP_MASK\": ip4MaskL,\n                                \"SVI_NEIGHBOR_IP\": nghbrIp4L,\n                                \"SVI_IPv6_MASK\": ip6MaskL,\n                                \"SVI_NEIGHBOR_IPv6\": nghbrIp6L,\n                                \"vrfIntfDescription\": sviDescL\n                               }\n            instanceVals = json.dumps(instanceValsDict)\n            vrfInstValsAndPti.update({\"instanceVals\":instanceVals, \"ptiId\":ptiIdL, \"vlanId\":vlanIdL})\n    Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] vrfInstValsAndPti [%s]\"%\n                  (funcName, devSerial, vrfName, vrfInstValsAndPti))\n    Wrapper.print(\"%s(): vrfName [%s] devSerial [%s] ====Exit====\"%(funcName, vrfName, devSerial))\n    return vrfInstValsAndPti\n\n\ndef ECLprocessOverlayAttachments(devSerial, switchOverlayInfo, globalOverlayInfo, allOverlayNets, topologyDataObj, vrfSviInstanceValues):\n    funcName = sys._getframe(0).f_code.co_name\n    switchDict = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n    Wrapper.print(\"%s: Switch [%s] - Is Extn [%s] %s\" % (funcName, switchDict[\"fmtName\"], switchOverlayInfo[\"doOverlayExtn\"], switchDict))\n\n    # process each of the VRF entries\n    for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n        vrfName = vrfEntry[\"name\"]\n        instanceVals = \"\"\n        vrfAttachVlan = 0\n        instanceValsDict = ECLGetDeviceVrfInstanceValue(vrfName, devSerial, vrfSviInstanceValues)\n        if instanceValsDict:\n            instanceVals = instanceValsDict.get(\"instanceVals\")\n            ptiId = instanceValsDict.get(\"ptiId\")\n            vlanId = instanceValsDict.get(\"vlanId\")\n            vrfAttachVlan = int(vlanId) if vlanId else 0\n            Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] vlanId[%s] instanceVals [%s] ptiId [%s]\"%\n                          (funcName, devSerial, vrfName, vlanId, instanceVals,ptiId))\n            if instanceVals and vrfAttachVlan > 0:\n                vrfEntry[\"instanceVals\"] = instanceVals\n \n        configProfName = vrfEntry[\"cfgProfileName\"] if (\"cfgProfileName\" in vrfEntry) else None\n        Wrapper.print(\"%s: Switch [%s] - Attaching for VRF [%s] VNI [%s] Profile Name [%s] Vlan [%s] instanceVals [%s] \"\n            \"Freeform [%s] Extension Vals [%s]\" % (funcName, switchDict[\"fmtName\"], vrfName, vrfName, configProfName,\n            vrfAttachVlan, instanceVals, vrfEntry[\"freeformCfg\"], vrfEntry[\"extensionVals\"]))\n\n        # check if the vrf entry exists in the global info db\n        if vrfName not in globalOverlayInfo[\"VRF_ATTACH\"]:\n            vrfAttachEntry = LanAttachByVRF()\n            vrfAttachEntry.setVrfName(vrfName)\n            vrfAttachEntry.setLanAttachList([])\n            globalOverlayInfo[\"VRF_ATTACH\"][vrfName] = vrfAttachEntry\n\n        # add an entry for this switch to the list\n        vrfSwitchAttach = LanVRFAttach()\n        vrfSwitchAttach.setFabric(FABRIC_NAME)\n        vrfSwitchAttach.setSerialNumber(devSerial)\n        vrfSwitchAttach.setVlan(vrfAttachVlan)\n        vrfSwitchAttach.setVrfName(vrfName)\n        vrfSwitchAttach.setExtensionValues(vrfEntry[\"extensionVals\"])\n        vrfSwitchAttach.setDeployment(True)\n        vrfSwitchAttach.setInstanceValues(vrfEntry[\"instanceVals\"])\n        vrfSwitchAttach.setFreeformConfig(vrfEntry[\"freeformCfg\"])\n\n        vrfAttachEntry = globalOverlayInfo[\"VRF_ATTACH\"][vrfName]\n        attachList = vrfAttachEntry.getLanAttachList()\n        attachList.append(vrfSwitchAttach)\n        vrfAttachEntry.setLanAttachList(attachList)\n        if vrfAttachVlan:\n            #delete vlan pti after this\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            lowerIntfName = \"vlan\"+str(vrfAttachVlan)\n            ignore, rmId = Util.exeRM(RM.get(FABRIC_NAME, \"TOP_DOWN_NETWORK_VLAN\", key, lowerIntfName))\n            Wrapper.print(\"%s() devSerial [%s] vrfName[%s] intfName [%s] ptiId=[%s] delete rmId=[%s]\"%(funcName, devSerial, vrfName, lowerIntfName, ptiId, rmId))\n            PTI.deleteInstance(ptiId)\n            if rmId > 0:\n                RM.deleteResource(rmId)\n        #Wrapper.print(\"%s: Switch [%s] - vrfSwitchAttach for VRF [%s] vrfSwitchAttach[%s] \" % (funcName, switchDict[\"fmtName\"], vrfName, vrfSwitchAttach))\n        #Wrapper.print(\"%s: Switch [%s] - vrfAttachEntry for VRF [%s] attach entryvrfAttachEntry[%s]\" % (funcName, switchDict[\"fmtName\"], vrfName, vrfAttachEntry))\n\n        \n    # process each of the network attachment entries\n    for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n        refEntry = allOverlayNets[netEntry[\"vlanId\"]]\n        refNetEntry = allOverlayNets[netEntry[\"vlanId\"]][\"netEntry\"]\n        refNetName = refNetEntry[\"overlayNetName\"] if refNetEntry[\"overlayNetName\"] else refNetEntry[\"cfgProfileName\"]\n        configProfName = netEntry[\"cfgProfileName\"] if ((\"cfgProfileName\" in netEntry) and refNetEntry[\"overlayNetName\"]) else None\n\n        Wrapper.print(\"%s: Switch [%s] - Attaching for network [%s/%s] Profile Name [%s] interfaces = [%s] Freeform [%s] refEntry [%s]\" % \n            (funcName, switchDict[\"fmtName\"], netEntry[\"vlanId\"], refNetName, configProfName, \n                netEntry[\"attachInfo\"], netEntry[\"freeformCfg\"], refEntry))\n\n        # check if the network entry exists in the global info db\n        vlanIdStr = netEntry[\"vlanId\"]\n        if vlanIdStr in globalOverlayInfo[\"NETWORK_ATTACH\"]:\n            netAttach = globalOverlayInfo[\"NETWORK_ATTACH\"][vlanIdStr]\n        else:\n            netAttach = LanAttachByNetwork()\n            netAttach.setNetworkName(refNetName)\n            netAttach.setLanAttachList([])\n\n            globalOverlayInfo[\"NETWORK_ATTACH\"][vlanIdStr] = netAttach\n\n        #\n        # Aggs will always be a vPC pair.\n        # For each agg vPC pair, determine vPC pair key. That determines Agg1~Agg2\n        # From each Agg switch, various network/vrf specific parameters will be individually learnt\n        # To determine, how to populate this in the network wrt parameters associated with Agg1 vs Agg2, compare the \n        # switch serial number with vPCPairKey. Accordingly, populate pip1 and other variables vs pip2 and other variables\n        # Do this only for non-layer2 only networks\n        #\n        isActive = False\n        isLayer3Net = False\n        if refNetEntry[\"netTemplateParams\"][\"isLayer2Only\"] != \"true\":\n            isLayer3Net = True\n            vpcPairkey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, devSerial))\n            serials = vpcPairkey.split(Helper.DELIMITER)\n            Agg1Sn = serials[0]\n            Agg2Sn = serials[1]\n            Wrapper.print(\"%s: vpcPair[%s], device %s[%s]\" % (funcName, vpcPairkey, switchDict[\"fmtName\"], devSerial))\n            if Agg1Sn == devSerial and devSerial == refEntry[\"refSwitchSerial\"]:\n                Wrapper.print(\"%s: vpcPair[%s], device %s[%s] refSwitchSerial %s setting Agg1Sn isActive true\" % (funcName, vpcPairkey, switchDict[\"fmtName\"], refEntry[\"refSwitchSerial\"], devSerial))\n                isActive = True\n            elif Agg2Sn == devSerial and devSerial == refEntry[\"refSwitchSerial\"]:\n                Wrapper.print(\"%s: vpcPair[%s], device %s[%s] refSwitchSerial %s setting Agg2Sn isActive true\" % (funcName, vpcPairkey, switchDict[\"fmtName\"], refEntry[\"refSwitchSerial\"], devSerial))\n                isActive = True\n        # add a new attach entry for this switch\n        lanAttach = LanAttach()\n        lanAttach.setFabric(FABRIC_NAME)\n        lanAttach.setNetworkName(refNetName)\n        lanAttach.setSerialNumber(devSerial)\n        #Need to filter out agg downlink ports that are part of the uplink_access policies \n        #These are the interfaces connected between access-agg based on the b2b vpc, dual-attached or single attached case\n        #This means that there must be some torPorts also present that in turn will auto-attach the access uplinks & agg downlinks\n        Wrapper.print(\"%s: device %s[%s] attachInfo %s UplinkInts %s\" % \n                    (funcName, switchDict[\"fmtName\"], devSerial, netEntry[\"attachInfo\"], switchDict[\"accessUplinkIntfs\"]))\n        \n        netAttachInfo = set(netEntry[\"attachInfo\"]) - set(switchDict[\"accessUplinkIntfs\"])\n        Wrapper.print(\"%s: device %s[%s] NetattachInfo %s\" % \n                    (funcName, switchDict[\"fmtName\"], devSerial, netAttachInfo))\n        \n        lanAttach.setSwitchPorts(\",\".join(netAttachInfo))\n\n        #To get the torPorts, for this agg device, find out all the access devices that are attached/paired to it. \n        #For each paired access device, get the netEntry[\"attachInfo\"] for that access device and append it to the torPorts\n        newRespObj = WrappersResp.getRespObj()\n        newRespObj.setSuccessRetCode()\n        torPorts = getAggTorPorts(topologyDataObj, devSerial, vlanIdStr, newRespObj, globalOverlayInfo)\n        Wrapper.print(\"%s: device %s[%s] netAttachInfo %s %s torPorts %s %s\" % \n                    (funcName, switchDict[\"fmtName\"], devSerial, netAttachInfo, \",\".join(netAttachInfo), torPorts, \",\".join(torPorts)))        \n        if not newRespObj.isRetCodeSuccess():\n            #TODO:Should we return an error from here or continue?\n            Wrapper.print(\"Switch [%s]: getAggTorPorts call failed\" % switchDict[\"fmtName\"])        \n        lanAttach.setTorPorts(\" \".join(torPorts))\n        lanAttach.setDetachSwitchPorts(\"\")\n        lanAttach.setVlan(netEntry[\"vlanId\"])\n        lanAttach.setDot1QVlan(1)\n        lanAttach.setUntagged(False)\n        lanAttach.setDeployment(True)\n        lanAttach.setExtensionValues(netEntry[\"extensionVals\"])\n        if not isLayer3Net:\n            lanAttach.setInstanceValues(\"\")\n        else:            \n            if isActive:\n                lanAttach.setInstanceValues('{\"isActive\":\"true\"}')\n            else:    \n                lanAttach.setInstanceValues('{\"isActive\":\"false\"}')\n        lanAttach.setFreeformConfig(netEntry[\"freeformCfg\"])\n\n        attachList = netAttach.getLanAttachList()\n        attachList.append(lanAttach)\n        netAttach.setLanAttachList(attachList)\n        \ndef checkOverlayParam(vrfOrNetName, paramName, refSwitchSn, switchSn, refParamVal, paramVal, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    retVal = True\n    if refParamVal != paramVal:\n        respObj.addErrorReport(\"OVERLAY_PARAM\",\n            \"[%s] Overlay parameter [%s] mismatch detected! Value [%s] on switch [%s] does not match \"\n            \"value [%s] on switch [%s]\" % (vrfOrNetName, paramName, refParamVal, getFormattedSwitchName(refSwitchSn), \n                paramVal, getFormattedSwitchName(switchSn)))\n        respObj.setFailureRetCode()\n        retVal = False\n    return retVal\n\ndef resetSwitchMigration(fabricName, devices, globalOverlayInfo, gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: Fabric [%s] - Reset Migration state on failure\" % (funcName, fabricName))\n\n    vpcPairs = {}\n\n    gVarDictObj[\"notDeleteSwitch\"] = True\n    gVarDictObj[\"FABRIC_NAME\"] = fabricName\n    fabTech = gVarDictObj[\"globalOverlayInfo\"][\"fabricTechnology\"]\n    \n    if fabTech == \"VLANFabric\":\n        aggSwitches = []\n        accessSwitches = []\n        switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"]\n        for deviceSn in devices:\n            dict = switchInfoDict[deviceSn]\n            if \"aggregation\" in dict[\"switchRole\"].lower():\n                aggSwitches.append(deviceSn)\n            elif \"access\" in dict[\"switchRole\"].lower():\n                accessSwitches.append(deviceSn)\n        switchList = accessSwitches + list(set(devices) - set(accessSwitches))\n        devices = switchList\n\n    Wrapper.print(\"%s: Fabric [%s] - Reset Migration state for switches %s \" % (funcName, fabricName, devices))\n    for deviceSn in devices:\n        gVarDictObj[\"deviceSerial\"] = deviceSn\n        if fabTech == \"VLANFabric\":\n            PTIWrapper.executePyTemplateMethod(\"Easy_Fabric_Classic\", gVarDictObj, \"preSwitchDelete\")\n        else:\n            PTIWrapper.executePyTemplateMethod(\"Easy_Fabric\", gVarDictObj, \"preSwitchDelete\")\n        # all the PTIs will be deleted as part of the preSwitchDelete() call above\n        # we are here because of overlay migration for the Brownfield case only, so put back the switch in the brownfield migration mode\n        putSwitchIntoBfMigrMode(fabricName, deviceSn)\n\n        switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n\n        # check if the switch was a vpc pair at the start of the import and set the pairing since the previous\n        # cleanup would have removed the paring\n        peerSn = switchInfo[\"vpcPeer\"]\n        if peerSn and (peerSn not in vpcPairs):\n            # check to make sure the peer switch is still in the fabric\n            if peerSn in globalOverlayInfo[\"SWITCH_INFO\"]:\n                # add a new vpc pair info\n                vpcPairs[deviceSn] = peerSn\n\n        # recreate the vpc peer link vlan PTI that user had created earlier since the earlier step would\n        # have cleared all PTIs\n        vPCInfo = switchInfo.get(\"vpcInfo\", None)\n        if vPCInfo and vPCInfo[\"userPeerLinkVlanPtiId\"]:\n            PTI.create(deviceSn, \"SWTICH\", \"SWTICH\", \"\", 500, \"vpc_peer_link_vlan\",\n                {\"VLAN\" : vPCInfo[\"peerLinkVlan\"]})\n\n        # recreate the inband POAP seed switch PTI\n        seedSwNvPairs = switchInfo.get(\"inbandPoapSeedSwitch\", None)\n        if seedSwNvPairs is not None:\n            Util.exe(PTI.create(deviceSn, \"SWITCH\", \"SWITCH\", \"\", 500, \"seed_switch\", seedSwNvPairs))\n\n    # redo the vPC pairings that the user would have done before the import\n    for deviceSn in vpcPairs:\n        switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n        peerSwitchInfo = globalOverlayInfo[\"SWITCH_INFO\"][vpcPairs[deviceSn]]\n\n        # do the vpc paring\n        respObj = VpcWrapper.create(deviceSn, vpcPairs[deviceSn])\n        Wrapper.print(\"%s: Fabric [%s] - Set vPC pair %s <-> %s. Success: [%r]\" % (funcName, \n            fabricName, switchInfo[\"fmtName\"], peerSwitchInfo[\"fmtName\"], not respObj.isRetCodeFailure()))\n\n# process the int_access_host\ndef getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans):\n    devSerial = switchInfo[\"deviceSerial\"]\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"INTF_NAME\" : intfName,\n               \"BPDUGUARD_ENABLED\" : \"no\",\n               \"PORTTYPE_FAST_ENABLED\": \"false\",\n               \"ACCESS_VLAN\" : \"1\",\n               \"SPEED\" : \"Auto\",\n               \"MTU\" : MTU_STR_JUMBO,\n               \"DESC\" : \"\",\n               \"ADMIN_STATE\" : \"true\",\n               \"CONF\": \"\"\n              }\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n            # there is always a match on \"interface_mtu\", even with default mtu\n            nvPairs[\"MTU\"] = Util.getHostIntfMTUStrFromParsedInfo(matchingNvPairs[templateName][\"MTU\"])\n        elif (\"bpduguard_enable\" == templateName):\n            nvPairs[\"BPDUGUARD_ENABLED\"] = \"true\"\n        elif (\"bpduguard_disable\" == templateName):\n            nvPairs[\"BPDUGUARD_ENABLED\"] = \"false\"\n        elif (\"shut_interface\" == templateName):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (\"interface_speed\" == templateName):\n            nvPairs[\"SPEED\"] = Util.mapSwitchSpeedToEnum(matchingNvPairs[templateName][\"SPEED\"])\n        elif (\"porttype_fast_enable\" == templateName):\n            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = \"true\"\n        elif (\"interface_desc\" == templateName):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"interface_orphan_port\" == templateName):\n            nvPairs[\"ENABLE_ORPHAN_PORT\"] = \"true\"\n        elif (\"access_vlan\" == templateName):\n            access_vlan = matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"]\n            nvPairs[\"ACCESS_VLAN\"] = processAccessIntfOverlayInfo(devSerial, switchInfo[\"migrationMode\"], \n                intfName, access_vlan, globalOverlayInfo, device_overlay_vlans)\n\n    templateList = [\n                    \"porttype_fast_trunk\",\n                    \"cdp_disable_interface_11_1\"\n                    ]\n\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = adjustAccessIntfAllowedVlans(intfMatchResult) + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n    #Wrapper.print(\"getAccessIntfNvpairs: device [%s] Interface [%s] nvPairs [%s]\"%(devSerial, intfName, nvPairs))\n\n    return nvPairs\n\ndef adjustAccessIntfAllowedVlans(intfMatchResult):\n    allowedVlans = []\n    unAcctCfg = []\n    utilObj = Util()\n    isDone = False\n\n    # merge all the allowed vlan related config in the unaccounted config into a single line\n    for line in intfMatchResult[\"unaccounted_cmds\"]:\n        addToUnacct = True\n        stripLine = line.strip()\n        if stripLine.startswith(\"switchport trunk allowed vlan \"):\n            addToUnacct = False\n            values = line.strip().split(\"switchport trunk allowed vlan add \")\n            if len(values) == 2:\n                allowedVlans.extend(utilObj.getIntegerRange(values[1]))\n            else:\n                values = line.strip().split(\"switchport trunk allowed vlan \")\n                if len(values) == 2:\n                    vlanListStr = values[1].lower()\n                    if ((vlanListStr == \"none\") or (vlanListStr == \"all\")):\n                        addToUnacct = True\n                        isDone = True\n                    else:\n                        allowedVlans.extend(utilObj.getIntegerRange(vlanListStr))\n\n        if addToUnacct:\n            unAcctCfg.append(line)\n\n    if ((not isDone) and (len(allowedVlans) > 0)):\n        unAcctCfg.append(\"  switchport trunk allowed vlan %s\" % (utilObj.vlanStrFromList(allowedVlans)))\n\n    return unAcctCfg\n\ndef getTrunkIntfAllowedVlanList(intfMatchResult, matchingNvPairs):\n    unAcctCfg = None\n    allowedVlans = None\n    utilObj = Util()\n    isDone = False\n    vlanStr = \"none\"\n\n    for templateName in [\"trunk_interface_fex\", \"port_channel_trunk_interface_11_1\"]:\n        if templateName in matchingNvPairs:\n            vlanListStr = matchingNvPairs[templateName][\"ALLOWED_VLANS\"].lower()\n            if ((vlanListStr == \"none\") or (vlanListStr == \"all\")):\n                vlanStr = vlanListStr\n                isDone = True\n            else:\n                allowedVlans = utilObj.getIntegerRange(vlanListStr)\n            # ignore the other match\n            break\n\n    if not isDone:\n        unAcctCfg = []\n        # need to scan and remove 'switchport trunk allowed vlan add' configs in the unaccounted configs (if any)\n        for line in intfMatchResult[\"unaccounted_cmds\"]:\n            values = line.strip().split(\"switchport trunk allowed vlan add \")\n            if len(values) == 2:\n                allowedVlans.extend(utilObj.getIntegerRange(values[1]))\n            else:\n                unAcctCfg.append(line)\n\n        vlanStr = \"none\" if len(allowedVlans) == 0 else utilObj.vlanStrFromList(allowedVlans)\n    else:\n        unAcctCfg = intfMatchResult[\"unaccounted_cmds\"]\n\n    return vlanStr, unAcctCfg\n\n# process the int_trunk_host\ndef getTrunkIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans):\n    devSerial = switchInfo[\"deviceSerial\"]\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"INTF_NAME\" : intfName,\n               \"BPDUGUARD_ENABLED\" : \"no\",\n               \"PORTTYPE_FAST_ENABLED\": \"false\",\n               \"MTU\" : MTU_STR_JUMBO,\n               \"SPEED\" : \"Auto\",\n               \"ALLOWED_VLANS\" : \"none\",\n               \"DESC\" : \"\",\n               \"CONF\" : \"\",\n               \"ADMIN_STATE\" : \"true\"\n              }\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n            # there is always a match on \"interface_mtu\", even with default mtu\n            nvPairs[\"MTU\"] = Util.getHostIntfMTUStrFromParsedInfo(matchingNvPairs[templateName][\"MTU\"])\n        elif (\"bpduguard_enable\" == templateName):\n            nvPairs[\"BPDUGUARD_ENABLED\"] = \"true\"\n        elif (\"bpduguard_disable\" == templateName):\n            nvPairs[\"BPDUGUARD_ENABLED\"] = \"false\"\n        elif (\"shut_interface\" == templateName):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (\"porttype_fast_trunk\" == templateName):\n            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = \"true\"\n        elif (\"native_vlan\" == templateName):\n            nativeVlan =  matchingNvPairs[templateName][\"NATIVE_VLAN\"]\n            nvPairs[\"NATIVE_VLAN\"] = \"\" if nativeVlan == \"1\" else nativeVlan \n        elif (\"interface_desc\" == templateName):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"interface_orphan_port\" == templateName):\n            nvPairs[\"ENABLE_ORPHAN_PORT\"] = \"true\"\n        elif (\"interface_speed\" == templateName):\n            nvPairs[\"SPEED\"] = Util.mapSwitchSpeedToEnum(matchingNvPairs[templateName][\"SPEED\"])\n\n    currAllowedVlans, unAcctCfg = getTrunkIntfAllowedVlanList(intfMatchResult, matchingNvPairs)\n    if currAllowedVlans != \"none\":\n        if getIsOkToResync(switchInfo, intfName, globalOverlayInfo):\n            nvPairs[\"ALLOWED_VLANS\"] = processTrunkIntfOverlayInfo(devSerial, switchInfo[\"migrationMode\"], intfName,\n                        currAllowedVlans, globalOverlayInfo, device_overlay_vlans)\n\n    templateList = [\n                    \"access_vlan\", \n                    \"cdp_disable_interface_11_1\"\n                    ]\n    if not Util.isFexHIF(intfName):\n        templateList.append(\"porttype_fast_enable\")\n\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = unAcctCfg + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    #Wrapper.print(\"getTrunkIntfNvpairs: device [%s] Interface [%s] nvPairs [%s]\"%(devSerial, intfName, nvPairs))\n\n    return nvPairs\n\ndef getRoutedIntfNvpairs(switchInfo, intfName, matchingNvPairs, includeMemberInheritedCfg=False):\n    funcName = sys._getframe(0).f_code.co_name\n\n    # devSerial = switchInfo[\"deviceSerial\"]\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    isL3PoMember = False\n    templateNameMatches = intfMatchResult[\"matched_templates\"]\n    if (('port_channel_mode' in templateNameMatches) or \n        ('port_channel_mode_on' in templateNameMatches)):\n        isL3PoMember = True\n\n    #Wrapper.print(\"%s. Device [%s] Intf [%s] isL3PoMember [%r]\" % (funcName, devSerial, intfName, isL3PoMember))\n    nvPairs = {\"INTF_NAME\" : intfName, \"INTF_VRF\" : \"\", \"IP\" : \"\", \"PREFIX\" : \"\", \"ROUTING_TAG\" : \"\",\n               \"INTF_VRF\" : \"\", \"ADMIN_STATE\" : \"true\", \"DESC\" : \"\", \"CONF\": \"\", \"MTU\": DEFAULT_MTU, \"SPEED\":\"Auto\"\n              }\n\n    genCfg = [\"  no switchport\"]\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n            if not isL3PoMember:\n                nvPairs.update({\"MTU\" : matchingNvPairs[templateName][\"MTU\"]})\n                genCfg.append(\"  mtu %s\" % nvPairs[\"MTU\"])\n        elif (\"interface_speed\" == templateName):\n            if not isL3PoMember:\n                swSpeed = matchingNvPairs[templateName][\"SPEED\"]\n                nvPairs[\"SPEED\"]  = Util.mapSwitchSpeedToEnum(swSpeed)\n                genCfg.append(\"  speed %s\" % swSpeed)\n        elif (\"interface_no_nego_auto\" == templateName):\n            if not isL3PoMember:\n                genCfg.append(\"  no negotiate auto\")\n        elif (\"interface_desc\" == templateName):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n            genCfg.append(\"  description %s\" % nvPairs[\"DESC\"])\n        elif (\"interface_vrf\" == templateName):\n            nvPairs[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n            genCfg.append(\"  vrf member %s\" % nvPairs[\"INTF_VRF\"])\n        elif (\"shut_interface\" == templateName):\n            nvPairs.update({\"ADMIN_STATE\" : \"false\"})\n        elif (\"p2p_routed_interface\" == templateName):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n            genCfg.append(\"  ip address %s/%s\" % (nvPairs[\"IP\"], nvPairs[\"PREFIX\"]))\n        elif (\"p2p_routed_interface_tag\" == templateName):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n            nvPairs[\"ROUTING_TAG\"] = matchingNvPairs[templateName][\"ROUTING_TAG\"]\n            genCfg.append(\"  ip address %s/%s tag %s\" % (nvPairs[\"IP\"], nvPairs[\"PREFIX\"], nvPairs[\"ROUTING_TAG\"]))\n\n    if nvPairs[\"ADMIN_STATE\"] == \"true\":\n        genCfg.append(\"  no shutdown\")\n    else:\n        genCfg.append(\"  shutdown\")\n\n    # get the configs that do not match our expected generated config\n    unaccCfg = list(OrderedSet(intfMatchResult[\"show_run_cmds\"]) - OrderedSet(genCfg))\n    # Wrapper.print(\"%s: Device [%s] Interface [%s] isL3PoMember [%r] sh_run [%s] genCfg [%s] unaccCfg [%s]\" % (funcName, devSerial, \n    #    intfName, isL3PoMember, intfMatchResult[\"show_run_cmds\"], genCfg, unaccCfg))\n\n    if unaccCfg:\n        if isL3PoMember:\n            isUpdated, newFF = getPoMemberFF(unaccCfg, intfName, includeMemberInheritedCfg)\n            #Wrapper.print(\"%s: Intf [%s]. isUpdated [%r] Original FF [%s] Filtered FF [%s]\" % (funcName, intfName, isUpdated, unaccCfg, newFF))\n        else:\n            newFF = unaccCfg\n\n        if newFF:\n            nvPairs[\"CONF\"] = Util.newLine().join(newFF)\n\n    return nvPairs\n\n# process the int_loopback\ndef getLoopbackIntfNvpairs(fabricName, switchInfo, intfName, matchingNvPairs):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"FABRIC_NAME\" : fabricName, \"INTF_NAME\" : intfName, \"DESC\" : \"\", \"INTF_VRF\" : \"\", \"IP\" : \"\", \"V6IP\" : \"\", \n                \"ROUTE_MAP_TAG\" : \"\", \"LINK_STATE_ROUTING_TAG\" : \"\", \"ADMIN_STATE\" : \"true\", \"CONF\" : \"\"}\n\n    for templateName in matchingNvPairs:\n        if (templateName == \"shut_interface\"):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (templateName == \"interface_desc\"):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (templateName == \"interface_vrf\"):\n            nvPairs[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n        elif (templateName == \"loopback_interface_with_tag\"):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"ROUTE_MAP_TAG\"] = matchingNvPairs[templateName][\"ROUTE_MAP_TAG\"]\n        elif (templateName == \"loopback_interface\"):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n\n    templateList = [\n                    \"bfd_interface_auth\",\n                    \"bfd_no_echo_interface\", \n                    \"bpduguard_disable\", \n                    \"bpduguard_enable\", \n                    \"porttype_fast_enable\",\n                    \"porttype_fast_trunk\",\n                    \"ospf_interface_11_1\",\n                    \"v6_ospf_interface\",\n                    \"isis_interface\",\n                    \"ospf_p2p_interface\",\n                    \"ospf_interface_auth\",\n                    \"pim_interface\",\n                    \"pim_interface_hello_auth\",\n                    \"isis_interface_auth\",\n                    \"isis_interface_auth_no_lvl\",\n                    \"vlan_interface_fwd_mode_11_1\",\n                    \"interface_ipv6_11_1\",\n                    \"interface_ipv6_tag_11_1\",\n                    \"cdp_disable_interface_11_1\",\n                    \"routed_interface_no_ip_redirects\"\n                    ]\n    \n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = intfMatchResult[\"unaccounted_cmds\"] + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    return nvPairs\n\n# process the int_freeform\ndef getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"INTF_NAME\": intfName, \"CONF\" : \"\", \"ADMIN_STATE\" : \"true\"}\n\n    if \"shut_interface\" in matchingNvPairs:\n        nvPairs[\"ADMIN_STATE\"] = \"false\"\n\n    # make a string of all the configs seen (in show run) for the interface except 'shutdown'\n    dot1qID = None\n    cfgList = []\n    for cfg in intfMatchResult[\"show_run_cmds\"]:\n        lowerStr = cfg.lower()\n        if (\"shutdown\" in lowerStr):\n            # skip the shut/no shut config since that is a separate PTI\n            continue\n\n        if (\"encapsulation dot1q\" in lowerStr):\n            dot1qID = lowerStr.strip()[20:]\n\n        cfgList.append(cfg)\n\n    nvPairs[\"CONF\"] = Util.newLine().join(cfgList)\n    return dot1qID, nvPairs\n\n# process the int_mgmt\ndef getMgmtIntfNvpairs(switchInfo, intfName, matchingNvPairs):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n    #Wrapper.print(\"getMgmtIntfNvpairs: Fabric [%s] Serial [%s] intfName [%s] isGreenfield [%r]\" %\n    #        (fabricName, devSerial, intfName, isGreenfield))\n\n    nvPairs = {\"INTF_NAME\" : intfName, \"DESC\" : \"\", \"CDP_ENABLE\" : \"true\", \"ADMIN_STATE\" : \"true\", \"CONF\":\"\" }\n\n    for templateName in matchingNvPairs:\n        if (templateName == \"cdp_disable_interface_11_1\"):\n            nvPairs[\"CDP_ENABLE\"] = \"false\"\n        elif (templateName == \"shut_interface_force\"):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (templateName == \"interface_desc\"):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n    \n    templateList = [\"interface_speed\", \"interface_ipv4_11_1\", \"interface_ipv6_11_1\"]\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = intfMatchResult[\"unaccounted_cmds\"] + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    return nvPairs\n\n# process the int_vlan\ndef getVlanIntfNvpairs(switchInfo, intfName, matchingNvPairs):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"INTF_NAME\": intfName, \"INTF_VRF\": \"\", \"IP\": \"\", \"PREFIX\": \"\", \"MTU\": \"\",\n               \"ROUTING_TAG\": \"\", \"DESC\" : \"\", \"CONF\": \"\", \"ADMIN_STATE\": \"true\",\n               \"DISABLE_IP_REDIRECTS\": \"false\", \"ENABLE_HSRP\": \"false\", \"advSubnetInUnderlay\": \"false\"\n              }\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n           nvPairs[\"MTU\"] = matchingNvPairs[templateName][\"MTU\"]\n        elif (\"interface_desc\" == templateName):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"interface_vrf\" == templateName):\n            nvPairs[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n        elif ((\"interface_ipv4_11_1\" == templateName) or (\"interface_ipv4_tag_11_1\" == templateName)):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n            if (\"interface_ipv4_tag_11_1\" == templateName):\n                nvPairs[\"ROUTING_TAG\"] = matchingNvPairs[templateName][\"TAG\"]\n        elif (\"routed_interface_no_ip_redirects\" == templateName):\n           nvPairs[\"DISABLE_IP_REDIRECTS\"] = \"true\"\n        elif (\"shut_interface\" == templateName):\n           nvPairs[\"ADMIN_STATE\"] = \"false\"\n\n    templateList = [\n                    \"ospf_interface_11_1\",\n                    \"ospf_interface_auth\",\n                    \"v6_ospf_interface\",\n                    \"isis_interface\",\n                    \"pim_interface\",\n                    \"vlan_interface_fwd_mode_11_1\",\n                    \"interface_ipv6_11_1\",\n                    \"interface_ipv6_tag_11_1\",\n                    \"cdp_disable_interface_11_1\",\n                    \"interface_hsrp_vip\",\n                    \"interface_hsrp_version\",\n                    \"interface_hsrp_priority\",\n                    \"interface_hsrp_mac\",\n                    \"interface_hsrp_preempt\",\n                    \"vlan_interface_dhcp_relay_vrf_11_1\",\n                    \"vlan_interface_dhcp_relay_11_1\",\n                    \"interface_ipv4_netflow\"\n                    ]\n    \n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = intfMatchResult[\"unaccounted_cmds\"] + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    return nvPairs\n\n# process the int_subif\ndef getSubIntfNvPairs(switchInfo, intfName, matchingNvPairs):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n    dot1qID = None\n\n    nvPairs = {\"INTF_NAME\" : intfName, \"VLAN\" : \"\", \"INTF_VRF\" : \"\", \"IP\" : \"\", \"PREFIX\" : \"\",\n               \"ROUTING_TAG\": \"\", \"MTU\": \"9216\", \"DESC\" : \"\", \"CONF\": \"\", \"ADMIN_STATE\" : \"true\"\n              }\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n           nvPairs[\"MTU\"] = matchingNvPairs[templateName][\"MTU\"]\n        elif (\"interface_desc\" == templateName):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"interface_vrf\" == templateName):\n            nvPairs[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n        elif (\"eth_sub_interface\" == templateName or \"eth_sub_interface_tag\" == templateName):\n            nvPairs[\"VLAN\"] = matchingNvPairs[templateName][\"VLAN\"]\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n            dot1qID = nvPairs[\"VLAN\"]\n            if (\"eth_sub_interface_tag\" == templateName):\n                nvPairs[\"ROUTING_TAG\"] = matchingNvPairs[templateName][\"TAG\"]\n        elif (\"shut_interface\" == templateName):\n           nvPairs[\"ADMIN_STATE\"] = \"false\"\n\n    templateList = [\n                    \"bfd_interface_auth\",\n                    \"bfd_no_echo_interface\", \n                    \"bpduguard_disable\", \n                    \"bpduguard_enable\", \n                    \"porttype_fast_enable\",\n                    \"porttype_fast_trunk\",\n                    \"ospf_interface_11_1\",\n                    \"v6_ospf_interface\",\n                    \"isis_interface\",\n                    \"ospf_p2p_interface\",\n                    \"ospf_interface_auth\",\n                    \"pim_interface_hello_auth\",\n                    \"isis_interface_auth\",\n                    \"isis_interface_auth_no_lvl\",\n                    \"pim_interface\",\n                    \"vlan_interface_fwd_mode_11_1\",\n                    \"interface_ipv6_11_1\",\n                    \"interface_ipv6_tag_11_1\",\n                    \"cdp_disable_interface_11_1\",\n                    \"routed_interface_no_ip_redirects\"\n                    ]\n    \n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = intfMatchResult[\"unaccounted_cmds\"] + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    return dot1qID, nvPairs\n\n# process the int_nve\ndef getNveIntfNvpairs(switchInfo, intfName, matchingNvPairs, isExternalFab=False):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"INTF_NAME\" : intfName, \"DESC\" : \"\", \"SOURCE_INTF_NAME\" : \"\", \"ANYCAST_INTF_NAME\" : \"\",\n               \"ADMIN_STATE\" : \"true\", \"HD_TIME\": \"180\", \"CONF\":\"\", \"FABRIC_NAME\":FABRIC_NAME,\n              }\n\n    for templateName in matchingNvPairs:\n        if (templateName == \"shut_interface\"):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (templateName == \"nve_interface\"):\n            nvPairs[\"SOURCE_INTF_NAME\"] = matchingNvPairs[templateName][\"SOURCE_INTF_NAME\"]\n        elif (templateName == \"nve_anycast_interface\"):\n            nvPairs[\"SOURCE_INTF_NAME\"] = matchingNvPairs[templateName][\"SOURCE_INTF_NAME\"]\n            nvPairs[\"ANYCAST_INTF_NAME\"] = matchingNvPairs[templateName][\"ANYCAST_INTF_NAME\"]\n        elif (templateName == \"interface_desc\"):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (templateName == \"nve_holddown_time\"):\n            hdTime = matchingNvPairs[templateName][\"HD_TIME\"]\n            if (hdTime != \"\" or hdTime != \"180\"):\n                nvPairs[\"HD_TIME\"] = hdTime\n    \n    # use the 'NVE_BLOCK' unaccounted config\n    #intNveRec = matchResult[\"FEATURES_INFO\"][\"NVE_BLOCK\"].get(\"interface \" + intfName)\n    #ffList = intNveRec[\"unaccounted\"].pop(0) if len(intNveRec[\"unaccounted\"] > 1)\n    ffList = intfMatchResult[\"unaccounted_cmds\"]\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    if isExternalFab:\n        # collect all the 'member vni' configs from the running configs\n        pass\n        \n    return nvPairs\n\ndef getIsOkToResync(switchInfo, intfName, globalOverlayInfo):\n    devSerial = switchInfo[\"deviceSerial\"]\n\n    hostPortResyncDict = globalOverlayInfo.get(\"HOST_PORT_RESYNC\", None)\n    if not hostPortResyncDict:\n        return True\n\n    switchDict = hostPortResyncDict[\"switches\"]\n    dbIfEntry = switchDict[devSerial][intfName.lower()]\n    okToRsync = (dbIfEntry['okToResyn'] and not dbIfEntry['isIGMember'])\n    Wrapper.print(\"getIsOkToResync: switch [%s] Intf [%s] val [%r]\" % (devSerial, intfName, okToRsync))\n    return okToRsync\n\ndef getL3PoIntfParams(switchInfo, intfName, matchingNvPairs):\n    devSerial = switchInfo[\"deviceSerial\"]\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    lowerIntfName = intfName.lower()\n    ignore, pcid = lowerIntfName.split(\"port-channel\")\n\n    templateNameMatches = intfMatchResult[\"matched_templates\"]\n\n    params = {\"PO_ID\" : intfName, \"INTF_VRF\" : \"\", \"IP\" : \"\", \"PREFIX\" : \"\", \"ROUTING_TAG\" : \"\",\n             \"MTU\" : DEFAULT_MTU, \"SPEED\" : \"Auto\", \"DESC\" : \"\", \"CONF\" : \"\", \"ADMIN_STATE\" : \"true\"}\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n            params[\"MTU\"] = matchingNvPairs[templateName][\"MTU\"]\n        elif (\"interface_speed\" == templateName):\n            params[\"SPEED\"]  = Util.mapSwitchSpeedToEnum(matchingNvPairs[templateName][\"SPEED\"])\n        elif (\"interface_desc\" == templateName):\n            params[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"interface_vrf\" == templateName):\n            params[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n        elif (\"shut_interface\" == templateName):\n            params[\"ADMIN_STATE\"] = \"false\"\n        elif (\"p2p_routed_interface\" == templateName):\n            params[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            params[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n        elif (\"p2p_routed_interface_tag\" == templateName):\n            params[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            params[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n            params[\"ROUTING_TAG\"] = matchingNvPairs[templateName][\"ROUTING_TAG\"]\n\n    templateList = [\"cdp_disable_interface_11_1\", \"pim_interface\", \"routed_interface_no_ip_redirects\"]\n\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = intfMatchResult[\"unaccounted_cmds\"] + configList\n    if ffList:\n        params[\"CONF\"] = Util.newLine().join(ffList)\n\n    return params\n\ndef getL2PoIntfParams(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans):\n    devSerial = switchInfo[\"deviceSerial\"]\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    lowerIntfName = intfName.lower()\n    ignore, pcid = lowerIntfName.split(\"port-channel\")\n\n    templateNameMatches = intfMatchResult[\"matched_templates\"]\n    isVpcPeerLinkPo = False\n    ifFexPo = False\n    isAccess = False\n    if (\"fex_port_channel_interface\" in templateNameMatches):\n        ifFexPo = True\n    elif ((\"port_channel_access_interface\" in templateNameMatches) or\n        (\"port_channel_dot1q_tunnel_interface\" in templateNameMatches)):\n        # treat the dot1q tunnell interface as access\n        isAccess = True\n\n    unAcctCfg = intfMatchResult[\"unaccounted_cmds\"]\n    params = {\"pcId\" : pcid, \"fexId\" : \"\", \"vpcId\" : \"\", \"poMtu\" : \"default\", \"poSpeed\" : \"Auto\", \"poAdminState\" : \"true\",\n              \"native_vlan\": \"\", \"poDesc\" : \"\", \"orphanPort\": \"false\", \"bpduGuardState\" : \"no\", \"porttype_fast_enable\" : \"false\",\n              \"porttype_fast_trunk\" : \"false\", \"vpcId\" : \"\", \"fexId\" : \"\", \"poConf\" : \"\"}\n\n    if (\"interface_mtu\" in templateNameMatches):\n        params[\"poMtu\"] = Util.getHostIntfMTUStrFromParsedInfo(matchingNvPairs[\"interface_mtu\"][\"MTU\"])\n    if (\"interface_speed\" in templateNameMatches):\n        params[\"poSpeed\"] = Util.mapSwitchSpeedToEnum(matchingNvPairs[\"interface_speed\"][\"SPEED\"])\n    if (\"fex_port_channel_interface\" in templateNameMatches):\n        params[\"fexId\"] = matchingNvPairs[\"fex_port_channel_interface\"][\"FEX_ID\"]\n    if (\"shut_interface\" in templateNameMatches):\n        params[\"poAdminState\"] = \"false\"\n    if (\"interface_desc\" in templateNameMatches):\n        params[\"poDesc\"] = matchingNvPairs[\"interface_desc\"][\"DESC\"]\n    if (\"interface_orphan_port\" in templateNameMatches):\n        params[\"orphanPort\"] = \"true\"\n    if (\"bpduguard_enable\" in templateNameMatches):\n        params[\"bpduGuardState\"] = \"true\"\n    if (\"bpduguard_disable\" in templateNameMatches):\n        params[\"bpduGuardState\"] = \"false\"\n    if (\"porttype_fast_trunk\" in templateNameMatches):\n        params[\"porttype_fast_trunk\"] = \"true\"\n    if (\"porttype_fast_enable\" in templateNameMatches):\n        params[\"porttype_fast_enable\"] = \"true\"\n    if (\"port_channel_vpc_id_11_1\" in templateNameMatches):\n        vpcId = matchingNvPairs[\"port_channel_vpc_id_11_1\"][\"VPC_ID\"]\n        if vpcId != \"peer-link\":\n            params[\"vpcId\"]  = vpcId\n        else:\n            isVpcPeerLinkPo = True\n    if (\"native_vlan\" in templateNameMatches):\n        params[\"native_vlan\"] = matchingNvPairs[\"native_vlan\"][\"NATIVE_VLAN\"]\n\n    if isAccess:\n        accessVlan = matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"] if \"access_vlan\" in matchingNvPairs else \"1\"\n        params[\"access_vlan\"] = processAccessIntfOverlayInfo(devSerial, switchInfo[\"migrationMode\"], \n            intfName, accessVlan, globalOverlayInfo, device_overlay_vlans)\n        unAcctCfg = adjustAccessIntfAllowedVlans(intfMatchResult)\n    else:\n        if not ifFexPo:\n            currAllowedVlans, unAcctCfg = getTrunkIntfAllowedVlanList(intfMatchResult, matchingNvPairs)\n            if getIsOkToResync(switchInfo, intfName, globalOverlayInfo):\n                params[\"allowed_vlans\"] = processTrunkIntfOverlayInfo(devSerial, switchInfo[\"migrationMode\"], intfName,\n                        currAllowedVlans, globalOverlayInfo, device_overlay_vlans)\n            else:\n                # keep the allowed vlans intact\n                params[\"allowed_vlans\"] = currAllowedVlans\n\n    templateList = [\"cdp_disable_interface_11_1\"]\n    if isAccess:\n        templateList.append(\"native_vlan\")\n        templateList.append(\"porttype_fast_trunk\")\n    else:\n        if not ifFexPo:\n            templateList.append(\"access_vlan\")\n            templateList.append(\"porttype_fast_enable\")\n    \n    if isVpcPeerLinkPo:\n        if \"access_vlan\" not in templateList:\n            templateList.append(\"access_vlan\")\n        if \"porttype_fast_enable\" not in templateList:\n            templateList.append(\"porttype_fast_enable\")\n        if \"porttype_fast_trunk\" not in templateList:\n            templateList.append(\"porttype_fast_trunk\")\n        templateList.append(\"bpduguard_disable\")\n        templateList.append(\"bpduguard_enable\")\n        templateList.append(\"interface_speed\")\n        templateList.append(\"interface_no_nego_auto\")\n\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = unAcctCfg + configList\n    if ffList:\n        params[\"poConf\"] = Util.newLine().join(ffList)\n\n    return params\n\ndef getPoMembersInfo(fabricName, devSerial, poMembersDict, matchResult, interfacesRes):\n    for intfName in poMembersDict:\n        nvPairs = poMembersDict[intfName]\n\n        lowerIntfName = intfName.lower()\n\n        intfMatchResult = interfacesRes[intfName]\n        templateNameMatches = intfMatchResult[\"matched_templates\"]\n        matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n        for templateName in matchingNvPairs:\n            if (\"shut_interface\" == templateName):\n                nvPairs[\"ADMIN_STATE\"] = \"false\"\n            elif (\"interface_desc\" == templateName):\n                nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n\ndef getCurrentIntfPyPtiById(policyId):\n    return Util.exe(PTIWrapper.getInstance(policyId))\n\ndef getCurrentIntfPyPti(devSerial, intfName):\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateContentType(\"PYTHON\")\n    srchOpt.setEntityName(intfName)\n    srchOpt.setEntityType(\"INTERFACE\")\n    ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    return ptiList[0] if ptiList else None\n\nstandaloneSwitchShippingIntfPolicies = [\"breakout_interface\",\n                        \"int_port_channel_fex\", \"int_port_channel_trunk_host\",\n                        \"int_port_channel_access_host\", \"int_port_channel_dot1q_tunnel_host\",\n                        \"int_trunk_host\", \"int_access_host\", \"int_dot1q_tunnel_host\",\n                        \"int_freeform\", \"int_loopback\", \"int_subif\", \"int_routed_host\",\n                        \"int_mgmt\", \"int_nve\", \"int_vlan\"]\n\nvpcSwitchShippingIntfPolicies = [\"int_port_channel_aa_fex\", \"int_vpc_trunk_host\", \"int_vpc_access_host\",\n                                 \"int_vpc_dot1q_tunnel\"]\n\n# the host interface DB\n#   switches - dictionary of interfaces and corresponding info. Key is intf name (vpc key pair for vpcs)\n#              value is a dictionary that holds the following:\n#                   - current information found in IM\n#                   - new info obtained from switch\n#hostPortResyncDict = {\"switches\" : {}, \"vpcHostPairs\" : {}, \"networks\" : {}}\n\n# build a dictionary of interface information that IM is aware of\ndef buildCurrentIntfInfoDb(fabricName, gVarDictObj, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    switchInfo = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    formattedName = switchInfo[\"fmtName\"]\n    hostPortResyncDict = globalOverlayInfo[\"HOST_PORT_RESYNC\"]\n    switchDict = hostPortResyncDict[\"switches\"]\n    vpcIntfDict = hostPortResyncDict[\"vpcHostPairs\"]\n\n    allTemplates = vpcSwitchShippingIntfPolicies + standaloneSwitchShippingIntfPolicies\n\n    # get info from IM\n    intfInfo = json.loads(Util.exe(IM.getInterfaceDetail(devSerial)))\n    Wrapper.print(\"%s: FAB [%s]: Switch [%s] Num Interfaces %s\" % (funcName, fabricName, devSerial, len(intfInfo)))\n\n    for intfEntry in intfInfo:\n        # we expect only one underlay policy (the jython)\n        underlayPolicyEntry = intfEntry[\"underlayPolicies\"][0] if intfEntry[\"underlayPolicies\"] else None\n        nvPairs = None\n        ifType = intfEntry[\"ifType\"]\n        ifName = intfEntry[\"ifName\"]\n        serialNum = intfEntry[\"serialNo\"]\n\n        isIGMember = True if intfEntry[\"interfaceGroup\"] else False\n\n        # ignore interface for resync for the following conditions:\n        #   - is IG member\n        #   - if the source of the policy is non empty\n        #   - if the policy template is not one the feature recognizes\n        okToResyn = False if isIGMember else True\n        if underlayPolicyEntry:\n            if ((underlayPolicyEntry[\"source\"] != \"\") or \n                (underlayPolicyEntry[\"templateName\"] not in allTemplates)):\n                okToResyn = False\n\n        hasOverlays = True if (intfEntry[\"overlayNetwork\"] or isIGMember) else False\n\n        if ifType == \"INTERFACE_VPC\":\n            # isPresent = True indicates interface is still present on switch, False otherwise. Set to False by default\n            dbIfEntry = {\"ifName\" : intfEntry[\"ifName\"], \"current\" : {}, \"new\" : None, \"isPresent\" : False,\n                \"okToResyn\" : okToResyn, \"isIGMember\" : isIGMember}\n            vpcIntfDict[serialNum][ifName] = dbIfEntry\n        else:\n            # non vPC interfaces\n            ifName = ifName.lower()\n\n            dbIfEntry = {\"ifName\" : intfEntry[\"ifName\"], \"current\" : {}, \"new\" : None, \"isPresent\" : False,\n                \"okToResyn\" : okToResyn, \"isIGMember\" : isIGMember}\n            switchDict[serialNum][ifName] = dbIfEntry\n\n        dbIfEntry[\"current\"] = {\"ifType\": ifType, \"policy\" : underlayPolicyEntry, \n                                \"discovered\" : intfEntry[\"discovered\"], \"hasOverlays\" : hasOverlays}\n        #Wrapper.print(\"%s: FAB [%s]: Switch [%s] dbIfEntry %s Entry %s\" % (funcName, fabricName,\n        #    devSerial, dbIfEntry, intfEntry))\n\n    #Wrapper.print(\"%s: FAB [%s]: Switch [%s] hostPortResyncDict %s\" % (funcName, fabricName,\n    #    devSerial, json.dumps(hostPortResyncDict, indent=4, sort_keys=True)))\n\ndef buildHostPortResyncDb(fabricName, gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n\n    switchInfo = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    matchResult = switchInfo[\"matchResult\"]\n    interfacesRes = switchInfo[\"interfacesRes\"]\n    formattedName = switchInfo[\"fmtName\"]\n\n    isExternalFab = globalOverlayInfo[\"isExternalFab\"]\n\n    Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s. Switch [%s]\" % (fabricName, funcName, formattedName))\n\n    hostPortResyncDict = globalOverlayInfo[\"HOST_PORT_RESYNC\"]\n    switchDict = hostPortResyncDict[\"switches\"]\n    vpcIntfDict = hostPortResyncDict[\"vpcHostPairs\"]\n\n    switchGbl = switchDict[devSerial]\n    vpcPairGbl = None\n    isPeer1 = None\n\n    Wrapper.print(\"%s: vpcIntfDict [%s] \" % (funcName, json.dumps(vpcIntfDict, indent=4, sort_keys=True)))\n\n    vpcPeerSw = switchGbl.get(\".vpcPeer\", None)\n    if vpcPeerSw == None:\n        vpcPeerSw = switchInfo[\"vpcPeer\"]\n\n    peerLinkPcId = None\n    if vpcPeerSw:\n        # build the VPC pair key\n        vpcPairkey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, vpcPeerSw))\n        vpcPairGbl = vpcIntfDict[vpcPairkey]\n        if vpcPairGbl[\"peer1Sn\"] == devSerial:\n            isPeer1 = True\n        else:\n            isPeer1 = False\n\n        templateName = \"vpc_peer_link_po_interface\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            # we expect only one\n            ignore, peerLinkPcId = nvPairList[0][\"INTF_NAME\"].lower().split(\"port-channel\")\n\n    Wrapper.print(\"%s: vpcPeerSw [%s] isPeer1 [%r] peerLinkPcId [%s]\" % (funcName, vpcPeerSw, isPeer1, peerLinkPcId))\n    \n    # check to make sure we do not find any vpc configs while the switch is not tagged as such\n    templateName = \"port_channel_vpc_id_11_1\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        if not vpcPairGbl:\n            # the switch is not tagged as a vpc pair\n            respObj.addErrorReport(\"HOST_PORT_RESYNC:VPC-PAIRING\", \"Found vPC configuration on switch that is \"\n                \"not marked as a vPC Pair in the topology. Please make the vPC Pairings and retry\", devSerial)\n            respObj.setFailureRetCode()\n            return respObj\n\n    try:\n        # collect the breakout ports\n        templateName = \"breakout_interface\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            entries = {}\n            switchGbl[\".breakout\"] = {\"templateName\" : templateName, \"entries\" : entries}\n            for nvPair in nvPairList:\n                # if the PORT is a range, then we need to unroll it into individual PTIs\n                ports = getIntegerRange(nvPair[\"PORT\"])\n\n                Wrapper.print(\"Breakout: slot [%s], ports [%s] portList %s\" % (nvPair[\"SLOT\"], nvPair[\"PORT\"], ports))\n\n                for port in ports:\n                    strPort = str(port)\n                    # build the parent intf name\n                    intfName = \"Ethernet\" + nvPair[\"SLOT\"] + \"/\" + strPort\n\n                    nvPairs = {\"SLOT\": nvPair[\"SLOT\"], \"PORT\" : strPort, \"MAP\" : nvPair[\"MAP\"]}\n\n                    intfEntry = {\"ifName\" : intfName, \"nvPairs\" : nvPairs}\n                    entries[intfName.lower()] = intfEntry\n\n        # the N9K host trunk/access interfaces policies depend on the system_jumbomtu policy.. need to process that\n        templateName = \"system_jumbomtu\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        #Wrapper.print(\"%s: Switch [%s] system_jumbomtu nvPairList [%s]\" % (funcName, formattedName, nvPairList))\n        if (nvPairList != None):\n            entries = {}\n            switchGbl[\".jumbomtu\"] = {\"templateName\" : templateName, \"entries\" : entries}\n            for nvPair in nvPairList:\n                # there will be one entry only\n\n                # check the existing value and see if there is any change.. a change will require us to reeval all\n                # trunk/access ports\n                isMtuChanged = False\n                srchOpt = CtrlPolicySearch()\n                srchOpt.setSerialNumber(devSerial)\n                srchOpt.setTemplateName(templateName)\n                ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                for pti in ptiList:\n                    # we expect only one\n                    if pti.isDeleted():\n                        continue\n\n                    existingNvPairs = pti.getNvPairs()\n                    if existingNvPairs[\"MTU\"] != nvPair[\"MTU\"]:\n                        isMtuChanged = True\n\n                entries[\"SWITCH\"] = {\"isMtuChanged\" : isMtuChanged, \"nvPairs\" : {\"MTU\" : nvPair[\"MTU\"]}}\n                break\n\n        # vlan capture for external fabric\n        if isExternalFab:\n            vlanMatchRes = matchResult[\"FEATURES_INFO\"][\"VLAN_BLOCK\"]\n            vlanFreeForm = \"\"\n            for vlanStr in vlanMatchRes.keys():\n                vlanRec = vlanMatchRes[vlanStr]\n                if vlanFreeForm == \"\":\n                    vlanFreeForm = Util.newLine().join(vlanRec[\"show_run\"])\n                else:\n                    vlanFreeForm = vlanFreeForm + Util.newLine() + Util.newLine().join(vlanRec[\"show_run\"])\n            if vlanFreeForm != \"\":\n                entries = {}\n                Wrapper.print(\"%s, vlanFreeForm %s\" % (funcName, vlanFreeForm))\n                switchGbl[\".vlanCfg\"] = {\"templateName\" : \"switch_freeform\", \"entries\" : entries}\n                entries[\"SWITCH_VLANS\"] = {\"nvPairs\" : {\"CONF\" : vlanFreeForm}}\n\n        fexNameDict = {}\n        templateName = \"base_fex\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        #Wrapper.print(\"%s: Switch [%s] base_fex nvPairList [%s]\" % (funcName, formattedName, nvPairList))\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                fexNameDict[nvPair[\"FEX_ID\"]] = nvPair[\"DESC\"]\n\n        sortedIntfNames = sorted(interfacesRes.keys())\n\n        # dictionary for PO. Key is po id. value is a dictionary for the name, members, channel mode\n        poMemberIntfDict = {\"id2Name\" : {}, \"fex\" : {}, \"po\" : {}}\n        for intfName in sortedIntfNames:\n            lowerIntfName = intfName.lower()\n            if lowerIntfName not in switchGbl:\n                \"\"\"\n                # this interface has not been discovered yet? error and instruct user to do a resyn and retry\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:REDISCOVER\", \"Interface [%s] exists on switch, but, \"\n                    \"not discovered in NDFC yet. Please Rediscover the switch and retry Recalculate & Deploy.\" % (intfName), devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n                \"\"\"\n                # add a new entry\n                currentEntry = {\"policy\" : None, \"discovered\" : False, \"hasOverlays\" : False}\n                switchGbl[lowerIntfName] = {\"ifName\" : intfName, \"current\" : currentEntry, \"new\" : None,\n                                                                \"okToResyn\" : True, \"isIGMember\" : False}\n\n            dbIfEntry = switchGbl[lowerIntfName]\n            # update with the name as found on switch\n            dbIfEntry[\"ifName\"] = intfName\n            # mark the intf as pesent\n            dbIfEntry[\"isPresent\"] = True\n\n            \"\"\"\n            if not dbIfEntry[\"okToResyn\"]:\n                # do not consider this\n                Wrapper.print(\"%s: Switch [%s] Skipping Intf [%s]\" % (funcName, formattedName, intfName))\n                intfMatchResult.update({\"isProcessed\" : True})\n                continue\n            \"\"\"\n            Wrapper.print(\"%s: Switch [%s] intfName [%s] Switch Intf [%s]\" % (funcName, formattedName, intfName, dbIfEntry))\n\n            # get the interface match results\n            intfMatchResult = interfacesRes[intfName]\n\n            # skip interfaces that have been processed\n            if isIntfProcessed(intfMatchResult):\n                continue\n\n            templateNameMatches = intfMatchResult[\"matched_templates\"]\n            matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n            newIntfEntry = None\n            if (lowerIntfName.startswith(\"vlan\")):\n                if isExternalFab:\n                    Wrapper.print(\"%s: intfMatchResult %s: matchingNvPairs %s\" % (lowerIntfName, intfMatchResult, matchingNvPairs))\n                    srchOpt = CtrlPolicySearch()\n                    srchOpt.setSerialNumber(devSerial)\n                    srchOpt.setTemplateName(\"int_vlan_internal\")\n                    srchOpt.setEntityName(intfName)\n                    ptiList = Util.exe(PTI.getPTIs(srchOpt))\n                    if ptiList:\n                        Wrapper.print(\"%s skip %s with int_vlan_internal policy\" % (funcName, intfName))\n                        dbIfEntry[\"okToResyn\"] = False\n                        continue\n\n                    templateName = \"int_vlan\"\n                    nvPairs = {\"INTF_NAME\": lowerIntfName,\n                               \"interface\": lowerIntfName,\n                               \"VLANS\": lowerIntfName[4:],\n                               \"INTF_VRF\": \"\",\n                               \"IP\": \"\",\n                               \"PREFIX\": \"\",\n                               \"MTU\" : \"\",\n                               \"ROUTING_TAG\": \"\",\n                               \"DISABLE_IP_REDIRECTS\": \"false\",\n                               \"DESC\": \"\",\n                               \"ADMIN_STATE\": \"true\",\n                               \"CONF\": \"\",\n                               \"ENABLE_HSRP\": \"false\",\n                               \"HSRP_VIP\": \"\",\n                               \"HSRP_VERSION\": \"\",\n                               \"HSRP_PRIORITY\": \"\",\n                               \"HSRP_GROUP\": \"\",\n                               \"MAC\": \"\",\n                               \"PREEMPT\": \"\"\n                              }\n\n                    freeformCfg = []\n                    other_hsrp_subcmds = []\n                    if \"shut_interface\" in templateNameMatches:\n                        nvPairs[\"ADMIN_STATE\"] = \"false\"\n\n                    cur_hsrp_top_cli = \"\"\n                    for cmd in intfMatchResult[\"show_run_cmds\"]:\n                        if not cmd.startswith(\"    \"):\n                            # first level interface cmd\n\n                            if cur_hsrp_top_cli != \"\":\n                                if nvPairs[\"ENABLE_HSRP\"] != \"true\":\n                                    # all goes to freeform\n                                    freeformCfg.append(cur_hsrp_top_cli)\n\n                                    if nvPairs[\"HSRP_PRIORITY\"] != \"\":\n                                        other_hsrp_subcmds.append(\"    priority %s\" % nvPairs[\"HSRP_PRIORITY\"])\n                                        nvPairs[\"HSRP_PRIORITY\"] = \"\"\n                                    if nvPairs[\"PREEMPT\"] == \"true\":\n                                        other_hsrp_subcmds.append(\"    preempt\")\n                                        nvPairs[\"PREEMPT\"] = \"false\"\n                                    if nvPairs[\"MAC\"] != \"\":\n                                        other_hsrp_subcmds.append(\"    mac-address %s\" % nvPairs[\"MAC\"])\n                                        nvPairs[\"MAC\"] = \"\"\n                                else:\n                                    nvPairs[\"HSRP_GROUP\"] = cur_hsrp_top_cli.split()[1]\n\n                                if len(other_hsrp_subcmds) > 0:\n                                    if nvPairs[\"ENABLE_HSRP\"] == \"true\":\n                                        freeformCfg.append(cur_hsrp_top_cli)\n                                    freeformCfg = freeformCfg + other_hsrp_subcmds\n\n                                cur_hsrp_top_cli = \"\"\n                                other_hsrp_subcmds = []\n\n                            if cmd.startswith(\"  ip address \") and (not \"route\" in cmd) and (not \"secondary\" in cmd) and (not \"dhcp\" in cmd):\n                                ip = cmd.split()[2].split(\"/\")\n                                nvPairs[\"IP\"] = ip[0]\n                                nvPairs[\"PREFIX\"] = ip[1]\n                                if \"tag\" in cmd:\n                                    nvPairs[\"ROUTING_TAG\"] = cmd.split()[4]\n                            elif cmd.startswith('  vrf member '):\n                                nvPairs[\"INTF_VRF\"] = cmd.split()[2]\n                            elif cmd.startswith('  description '):\n                                nvPairs[\"DESC\"] = cmd[14:]\n                            elif cmd.startswith('  mtu '):\n                                nvPairs[\"MTU\"] = cmd.split()[1]\n                            elif cmd == '  shutdown':\n                                nvPairs[\"ADMIN_STATE\"] = \"false\"\n                            elif cmd == '  no shutdown':\n                                continue\n                            elif cmd == \"  no ip redirects\":\n                                nvPairs[\"DISABLE_IP_REDIRECTS\"] = \"true\"\n                            elif cmd == \"  no ipv6 redirects\":\n                                nvPairs[\"DISABLE_IP_REDIRECTS\"] = \"true\"\n                            elif cmd.startswith('  hsrp '):\n                                if cmd.startswith(\"  hsrp version\"):\n                                    nvPairs[\"HSRP_VERSION\"] = cmd.split()[2]\n                                else:\n                                    if nvPairs[\"HSRP_GROUP\"] == \"\":\n                                        keys = cmd.split()\n                                        key1 = keys[1]\n                                        if len(keys) == 2 and key1[:1].isdigit():\n                                            cur_hsrp_top_cli = cmd\n                                            other_hsrp_subcmds = []\n                                        else:\n                                            freeformCfg.append(cmd)\n                                    else:\n                                        freeformCfg.append(cmd)\n                            else:\n                                freeformCfg.append(cmd)\n                        else:\n                            if cur_hsrp_top_cli == \"\":\n                                freeformCfg.append(cmd)\n                                continue\n\n                            # hsrp sub-cmd following the v4 group\n                            if cmd.startswith(\"    ip \") and len(cmd.split()) == 2:\n                                nvPairs[\"HSRP_VIP\"] = cmd.split()[1]\n                                nvPairs[\"ENABLE_HSRP\"] = \"true\"\n                            elif cmd.startswith(\"    priority \") and len(cmd.split()) == 2:\n                                nvPairs[\"HSRP_PRIORITY\"] = cmd.split()[1]\n                            elif cmd.strip() == \"preempt\":\n                                nvPairs[\"PREEMPT\"] = \"true\"\n                            elif cmd.startswith(\"    mac-address \"):\n                                nvPairs[\"MAC\"] = cmd.split()[1]\n                            else:\n                                other_hsrp_subcmds.append(cmd)\n\n                    # if hsrp group is the last block\n                    if cur_hsrp_top_cli != \"\":\n                        if nvPairs[\"ENABLE_HSRP\"] != \"true\":\n                            # all goes to freeform\n                            freeformCfg.append(cur_hsrp_top_cli)\n\n                            if nvPairs[\"HSRP_PRIORITY\"] != \"\":\n                                other_hsrp_subcmds.append(\"    priority %s\" % nvPairs[\"HSRP_PRIORITY\"])\n                                nvPairs[\"HSRP_PRIORITY\"] = \"\"\n                            if nvPairs[\"PREEMPT\"] == \"true\":\n                                other_hsrp_subcmds.append(\"    preempt\")\n                                nvPairs[\"PREEMPT\"] = \"false\"\n                            if nvPairs[\"MAC\"] != \"\":\n                                other_hsrp_subcmds.append(\"    mac-address %s\" % nvPairs[\"MAC\"])\n                                nvPairs[\"MAC\"] = \"\"\n                        else:\n                            nvPairs[\"HSRP_GROUP\"] = cur_hsrp_top_cli.split()[1]\n\n                        if len(other_hsrp_subcmds) > 0:\n                            if nvPairs[\"ENABLE_HSRP\"] == \"true\":\n                                freeformCfg.append(cur_hsrp_top_cli)\n                            freeformCfg = freeformCfg + other_hsrp_subcmds\n\n                        Wrapper.print(\"++++ %s: cur_hsrp_top_cli %s, freeform %s\" %(funcName,cur_hsrp_top_cli, freeformCfg))\n\n\n                    if nvPairs[\"ENABLE_HSRP\"] != \"true\":\n                        if nvPairs[\"HSRP_VERSION\"] != \"\":\n                            freeformCfg.append(\"  hsrp version %s\" % nvPairs[\"HSRP_VERSION\"])\n                            nvPairs[\"HSRP_VERSION\"] = \"\"\n                    elif nvPairs[\"IP\"] == \"\":\n                        # all hsrp cli go to freeform\n                        if nvPairs[\"HSRP_VERSION\"] != \"\":\n                            freeformCfg.append(\"  hsrp version %s\" % nvPairs[\"HSRP_VERSION\"])\n                            nvPairs[\"HSRP_VERSION\"] = \"\"\n\n                        hsrp_clis = [\"  hsrp %s\" % nvPairs[\"HSRP_GROUP\"]]\n                        nvPairs[\"HSRP_GROUP\"] = \"\"\n                        nvPairs[\"ENABLE_HSRP\"] = \"false\"\n                        if nvPairs[\"HSRP_VIP\"] != \"\":\n                            hsrp_clis.append(\"    ip %s\" % nvPairs[\"HSRP_VIP\"])\n                            nvPairs[\"HSRP_VIP\"] = \"\"\n                        if nvPairs[\"HSRP_PRIORITY\"] != \"\":\n                            hsrp_clis.append(\"    priority %s\" % nvPairs[\"HSRP_PRIORITY\"])\n                            nvPairs[\"HSRP_PRIORITY\"] = \"\"\n                        if nvPairs[\"PREEMPT\"] == \"true\":\n                            hsrp_clis.append(\"    preempt\")\n                            nvPairs[\"PREEMPT\"] = \"false\"\n                        if nvPairs[\"MAC\"] != \"\":\n                            hsrp_clis.append(\"    mac-address %s\" % nvPairs[\"MAC\"])\n                            nvPairs[\"MAC\"] = \"\"\n\n                        freeformCfg = freeformCfg + hsrp_clis\n\n                    if len(freeformCfg) > 0:\n                        nvPairs[\"CONF\"] = Util.newLine().join(freeformCfg)\n\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                    Wrapper.print(\"%s: %s nvPairs %s\" % (funcName, lowerIntfName, nvPairs))\n\n                    dbIfEntry[\"okToResyn\"] = True\n                else:\n                    # do not do anything for easy fabric\n                    dbIfEntry[\"okToResyn\"] = False\n                    continue\n            else:\n                templateNameMatches = intfMatchResult[\"matched_templates\"]\n                if lowerIntfName.startswith(\"port-channel\"):\n                    ignore, pcId = lowerIntfName.split(\"port-channel\")\n                    usePoFF = False\n                    if ((\"port_channel_trunk_interface_11_1\" in templateNameMatches) or \n                        (\"port_channel_access_interface\" in templateNameMatches) or \n                        (\"port_channel_dot1q_tunnel_interface\" in templateNameMatches) or \n                        (\"fex_port_channel_interface\" in templateNameMatches) or\n                        (\"vpc_peer_link_po_interface\" in templateNameMatches)):\n                        # L2 PO\n                        poMemberIntfDict[\"id2Name\"][pcId] = {\"intfName\" : intfName, \"isL3\" : False}\n                    elif (\"port_channel_routed_interface\" in templateNameMatches):\n                        if not isExternalFab:\n                            usePoFF = True\n                        else:\n                            # support resync for L3 Po in external fabric for the following conditions:\n                            #   - there is no policy associated with the interface\n                            #   - policy is present:\n                            #       > source in empty\n                            #       > current template is \"int_l3_port_channel\"\n                            if \"policy\" in dbIfEntry:\n                                currPolicy = dbIfEntry[\"policy\"]\n                                currTemplate = currPolicy.get(\"templateName\", \"\")\n                                if ((currPolicy.get(\"source\") == \"\") and\n                                    (currTemplate in [\"\", \"int_l3_port_channel\"])):\n                                    # support resync for L3 Po in external fabric if current source in non-empty\n                                    dbIfEntry[\"okToResyn\"] = True\n                            else:\n                                dbIfEntry[\"okToResyn\"] = True\n\n                            # L3 PO - process it as int_l3_port_channel only in External Fabric/LAN_Classic\n                            poMemberIntfDict[\"id2Name\"][pcId] = {\"intfName\" : intfName, \"isL3\" : True}\n                    else:\n                        usePoFF = True\n                    \n                    if usePoFF:\n                        # process as int_freeform\n                        templateName = \"int_freeform\"\n                        dot1qID, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                        newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs, \"dot1qID\" : dot1qID}\n                elif lowerIntfName.startswith(\"mgmt\"):\n                    templateName = \"int_mgmt\"\n                    nvPairs = getMgmtIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                elif lowerIntfName.startswith(\"loopback\"):\n                    # process as int_freeform\n                    loopbackId = intfName[8:]\n                    templateName = \"int_freeform\"\n                    ignore, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs, \"loID\" : loopbackId}\n                elif lowerIntfName.startswith(\"nve\"):\n                    if isExternalFab:\n                        templateName = \"int_freeform\"\n                        ignore, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                    else:\n                        templateName = \"int_nve\"\n                        nvPairs = getNveIntfNvpairs(switchInfo, intfName, matchingNvPairs, isExternalFab)\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                elif (\".\" in lowerIntfName):\n                    if ((\"eth_sub_interface\" in templateNameMatches) or\n                        (\"eth_sub_interface_tag\" in templateNameMatches)):\n                        templateName = \"int_subif\"\n                        dot1qID, nvPairs = getSubIntfNvPairs(switchInfo, intfName, matchingNvPairs)\n                    else:\n                        # process as int_freeform\n                        templateName = \"int_freeform\"\n                        dot1qID, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs, \"dot1qID\" : dot1qID}\n                elif ((\"trunk_interface_fex\" in templateNameMatches) or \n                      (\"access_interface_fex\" in templateNameMatches) or\n                      (\"dot1q_tunnel_interface\" in templateNameMatches) or\n                      (\"fex_po_member_interface\" in templateNameMatches)):\n                    # L2 interfaces\n                    if ((\"port_channel_mode_on\" in templateNameMatches) or\n                        (\"port_channel_mode\" in templateNameMatches)):\n                        # member interfaces\n                        pcid = \"\"\n                        mode = \"\"\n                        fexId = \"\"\n\n                        for templateName in matchingNvPairs:\n                            if (\"port_channel_mode_on\" == templateName):\n                                pcid = matchingNvPairs[templateName][\"PCID\"]\n                                mode = \"on\"\n                            elif (\"port_channel_mode\" == templateName):\n                                pcid = matchingNvPairs[templateName][\"PCID\"]\n                                mode = matchingNvPairs[templateName][\"PC_MODE\"]\n                            elif (\"fex_po_member_interface\" == templateName):\n                                pcid = matchingNvPairs[templateName][\"PCID\"]\n                                fexId = matchingNvPairs[templateName][\"FEX_ID\"]\n\n                        Wrapper.print(\"%s: Switch [%s] pcid [%s] mode [%s] fexId [%s]\" % (funcName, formattedName, pcid, mode, fexId))\n                        poMembersDict = None\n                        if fexId != \"\":\n                            lookupKey = \"fex\"\n                        else:\n                            lookupKey = \"po\"\n                        if pcid not in poMemberIntfDict[lookupKey]:\n                            poMembersDict = {}\n                            poMemberIntfDict[lookupKey][pcid] = {\"MODE\" : mode, \"MEMBERS\" : poMembersDict}\n                        else:\n                            poMembersDict = poMemberIntfDict[lookupKey][pcid][\"MEMBERS\"]\n\n                        Wrapper.print(\"Switch [%s] - Found L2 PO member intf [%s] mode [%s] parent PO id [%s] poMembersDict %s\" %\n                            (devSerial, intfName, mode, pcid, poMembersDict))\n\n                        ignore, poMembersDict[intfName] = getPoMemberIntfNvpairs(devSerial, intfName, True, pcid,\n                                matchResult, interfacesRes, False)\n                        dbIfEntry[\"okToResyn\"] = False\n                    else:\n                        # standalone ports\n                        if (\"access_interface_fex\" in templateNameMatches):\n                            templateName = \"int_access_host\"\n                            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, None)\n                        elif (\"dot1q_tunnel_interface\" in templateNameMatches):\n                            templateName = \"int_dot1q_tunnel_host\"\n                            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, None)\n                        else:\n                            templateName = \"int_trunk_host\"\n                            nvPairs = getTrunkIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, None)\n\n                        newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                elif (\"routed_interface\" in templateNameMatches):\n                    # L3 interfaces\n                    isStandaloneL3Intf = True\n                    includeMemberInheritedCfg = False\n                    if ((\"port_channel_mode_on\" in templateNameMatches) or\n                        (\"port_channel_mode\" in templateNameMatches)):\n                        # L3 po member interfaces\n                        if isExternalFab:\n                            isStandaloneL3Intf = False\n                            pcid = \"\"\n                            mode = \"\"\n\n                            for templateName in matchingNvPairs:\n                                if (\"port_channel_mode_on\" == templateName):\n                                    pcid = matchingNvPairs[templateName][\"PCID\"]\n                                    mode = \"on\"\n                                elif (\"port_channel_mode\" == templateName):\n                                    pcid = matchingNvPairs[templateName][\"PCID\"]\n                                    mode = matchingNvPairs[templateName][\"PC_MODE\"]\n\n                            poMembersDict = None\n                            lookupKey = \"po\"\n                            if pcid not in poMemberIntfDict[lookupKey]:\n                                poMembersDict = {}\n                                poMemberIntfDict[lookupKey][pcid] = {\"MODE\" : mode, \"MEMBERS\" : poMembersDict}\n                            else:\n                                poMembersDict = poMemberIntfDict[lookupKey][pcid][\"MEMBERS\"]\n\n                            Wrapper.print(\"Switch [%s] - Found L3 PO member intf [%s] mode [%s] parent PO id [%s] poMembersDict %s\" %\n                                (devSerial, intfName, mode, pcid, poMembersDict))\n\n                            ignore, poMembersDict[intfName] = getPoMemberIntfNvpairs(devSerial, intfName, True, pcid,\n                                    matchResult, interfacesRes, False)\n                            dbIfEntry[\"okToResyn\"] = False\n                        else:\n                            # non external fab and this will be captured in a routed host port\n                            includeMemberInheritedCfg = True\n                    \n                    if isStandaloneL3Intf:\n                        # standalone L3 interfaces\n                        templateName = \"int_routed_host\"\n                        nvPairs = getRoutedIntfNvpairs(switchInfo, intfName, matchingNvPairs, includeMemberInheritedCfg)\n                        newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                else:\n                    # process as int_freeform\n                    templateName = \"int_freeform\"\n                    dot1qID, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs, \"dot1qID\" : dot1qID}\n\n            #Wrapper.print(\"%s: Switch [%s] newIntfEntry [%s]\" % (funcName, formattedName, newIntfEntry))\n            if newIntfEntry:\n                dbIfEntry[\"new\"] = newIntfEntry\n\n        Wrapper.print(\"%s: poMemberIntfDict %s \" % (funcName, json.dumps(poMemberIntfDict, indent=4, sort_keys=True)))\n\n        # process the port channels\n        for pcid in sorted(poMemberIntfDict[\"id2Name\"]):\n            intfName = poMemberIntfDict[\"id2Name\"][pcid][\"intfName\"]\n            isL3 = poMemberIntfDict[\"id2Name\"][pcid][\"isL3\"]\n            lowerIntfName = intfName.lower()\n\n            Wrapper.print(\"%s: Switch [%s] intfName [%s] pcid [%s] isL3 [%r]\" % (funcName, formattedName, intfName, pcid, isL3))\n            intfMatchResult = interfacesRes[intfName]\n            templateNameMatches = intfMatchResult[\"matched_templates\"]\n\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            #Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\" % (intfName, sys._getframe().f_lineno))\n\n            matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n            dbIfEntry = None\n            poMemberEntry = None\n            if pcid in poMemberIntfDict[\"po\"]:\n                poMemberEntry = poMemberIntfDict[\"po\"][pcid]\n            elif pcid in poMemberIntfDict[\"fex\"]:\n                poMemberEntry = poMemberIntfDict[\"fex\"][pcid]\n\n            Wrapper.print(\"Switch [%s] : Processing PO [%s] pcid [%s] poMemberEntry %s\" % (devSerial,\n                                intfName, pcid, poMemberEntry))\n\n            # Note: poMemberEntry can be empty for port channels that do not have any members\n            if not isL3:\n                poParams = getL2PoIntfParams(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, None)\n                accessPort = False\n                dot1qTunnelPort = False\n                if (\"port_channel_access_interface\" in templateNameMatches):\n                    accessPort = True\n                elif (\"port_channel_dot1q_tunnel_interface\" in templateNameMatches):\n                    dot1qTunnelPort = True\n\n                Wrapper.print(\"Switch [%s] : Found PO [%s] poParams [%s] accessPort [%r] dot1qTunnelPort [%r]\" % (devSerial, \n                    intfName, poParams, accessPort, dot1qTunnelPort))\n            else:\n                poParams = getL3PoIntfParams(switchInfo, intfName, matchingNvPairs)\n\n            newIntfEntry = None\n            if isL3:\n                dbIfEntry = switchGbl[lowerIntfName]\n\n                poMemberInfo = poMemberEntry\n\n                poMembersDict = poMemberInfo[\"MEMBERS\"] if poMemberInfo else {}\n                memberPortsList = poMembersDict.keys()\n\n                nvPairs = poParams\n                nvPairs[\"PC_MODE\"] = poMemberInfo[\"MODE\"] if poMemberInfo else \"on\"\n                nvPairs[\"MEMBER_INTERFACES\"] = \",\".join(memberPortsList)\n\n                newIntfEntry = {\"templateName\" : \"int_l3_port_channel\", \"nvPairs\" : nvPairs, \n                                                                        \"memberPorts\" : poMembersDict}\n            elif (poParams[\"vpcId\"] != \"\"):\n                vpcIntfName = (\"vPC%s\" % poParams[\"vpcId\"])\n\n                if vpcIntfName not in vpcPairGbl:\n                    # this interface has not been discovered yet? ok to add\n                    currentEntry = {\"policy\" : None, \"discovered\" : False, \"hasOverlays\" : False}\n                    vpcPairGbl[vpcIntfName] = {\"ifName\" : vpcIntfName, \"current\" : currentEntry, \"new\" : None,\n                                                            \"okToResyn\" : True, \"isIGMember\" : False}\n\n                dbIfEntry = vpcPairGbl[vpcIntfName]\n                # mark the intf as pesent\n                dbIfEntry[\"isPresent\"] = True\n\n                Wrapper.print(\"%s: Switch [%s] Processing vPC [%s] Intf [%s] dbIfEntry %s\" % (funcName, formattedName, \n                    vpcPairkey, vpcIntfName, dbIfEntry))\n\n                if not dbIfEntry[\"okToResyn\"]:\n                    # do not consider this\n                    Wrapper.print(\"%s: Switch [%s] Skipping Intf [%s]\" % (funcName, formattedName, vpcIntfName))\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    continue\n\n                newIntfEntry = dbIfEntry[\"new\"]\n                currentIntfEntry = dbIfEntry[\"current\"]\n\n                memberLookupKey = \"fex\" if (poParams[\"fexId\"] != \"\") else \"po\"\n                poMemberInfo = poMemberIntfDict[memberLookupKey].get(poParams[\"pcId\"], None)\n                poMembersDict = poMemberInfo[\"MEMBERS\"] if poMemberInfo else {}\n\n                if (poParams[\"fexId\"] != \"\"):\n                    # AA FEX\n                    templateName = \"int_port_channel_aa_fex\"\n                    if not newIntfEntry:\n                        nvPairs = {\"INTF_NAME\" : vpcIntfName, \"FEX_ID\" : poParams[\"fexId\"], \n                                   \"DESC\" : fexNameDict.get(poParams[\"fexId\"], \"\"), \"MTU\" : poParams[\"poMtu\"], \n                                   \"ADMIN_STATE\" : poParams[\"poAdminState\"], \"FABRIC_NAME\" : fabricName}\n                        newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                    else:\n                        nvPairs = newIntfEntry[\"nvPairs\"]\n                else:\n                    pcMode = poMemberInfo[\"MODE\"] if poMemberInfo else \"on\"\n\n                    # vPC PO\n                    templateName = \"int_vpc_access_host\" if accessPort else (\"int_vpc_dot1q_tunnel\" if dot1qTunnelPort else \"int_vpc_trunk_host\")\n                    if not newIntfEntry:\n                        nvPairs = {\"INTF_NAME\" : vpcIntfName, \"ENABLE_MIRROR_CONFIG\" : \"false\",\n                                   \"MTU\" : poParams[\"poMtu\"], \"BPDUGUARD_ENABLED\" : poParams[\"bpduGuardState\"],\n                                   \"PC_MODE\" : pcMode, \"SPEED\" : poParams[\"poSpeed\"], \"ADMIN_STATE\" : poParams[\"poAdminState\"]}\n                        if accessPort or dot1qTunnelPort:\n                            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poParams[\"porttype_fast_enable\"]\n                        else:\n                            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poParams[\"porttype_fast_trunk\"]\n\n                        newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                    else:\n                        nvPairs = newIntfEntry[\"nvPairs\"]\n\n                #Wrapper.print(\"Switch [%s] : PO [%s] poMembersDict %s\" % (devSerial, intfName, poMembersDict))\n                memberPortsList = poMembersDict.keys()\n                if isPeer1:\n                    newIntfEntry[\"peer1MemberPorts\"] = poMembersDict\n                else:\n                    newIntfEntry[\"peer2MemberPorts\"] = poMembersDict\n\n                # set \"peer\" specific keys\n                if isPeer1:\n                    nvPairs[\"PEER1_PCID\"] = poParams[\"pcId\"]\n                    nvPairs[\"PEER1_PO_DESC\"] = poParams[\"poDesc\"]\n                    nvPairs[\"PEER1_PO_CONF\"] = poParams[\"poConf\"]\n                    nvPairs[\"PEER1_MEMBER_INTERFACES\"] = \",\".join(memberPortsList)\n                    if (poParams[\"fexId\"] == \"\"):                    \n                        if accessPort or dot1qTunnelPort:\n                            nvPairs[\"PEER1_ACCESS_VLAN\"] = poParams[\"access_vlan\"]\n                        else:\n                            nvPairs[\"PEER1_ALLOWED_VLANS\"] = poParams[\"allowed_vlans\"]\n                            nvPairs[\"PEER1_NATIVE_VLAN\"] = \"\" if poParams[\"native_vlan\"] == \"1\" else poParams[\"native_vlan\"]\n                else:\n                    nvPairs[\"PEER2_PCID\"] = poParams[\"pcId\"]\n                    nvPairs[\"PEER2_PO_DESC\"] = poParams[\"poDesc\"]\n                    nvPairs[\"PEER2_PO_CONF\"] = poParams[\"poConf\"]\n                    nvPairs[\"PEER2_MEMBER_INTERFACES\"] = \",\".join(memberPortsList)\n                    if (poParams[\"fexId\"] == \"\"):                    \n                        if accessPort or dot1qTunnelPort:\n                            nvPairs[\"PEER2_ACCESS_VLAN\"] = poParams[\"access_vlan\"]\n                        else:\n                            nvPairs[\"PEER2_ALLOWED_VLANS\"] = poParams[\"allowed_vlans\"]\n                            nvPairs[\"PEER2_NATIVE_VLAN\"] = \"\" if poParams[\"native_vlan\"] == \"1\" else poParams[\"native_vlan\"]\n            else:\n                isVpcPeerLinkPo = False\n                # non vpc po\n                dbIfEntry = switchGbl[lowerIntfName]\n                #Wrapper.print(\"%s: Switch [%s] dbIfEntry %s\" % (funcName, formattedName, dbIfEntry))\n                if (poParams[\"fexId\"] != \"\"):\n                    # ST-FEX\n                    templateName = \"int_port_channel_fex\"\n                    poMemberInfo = poMemberIntfDict[\"fex\"].get(poParams[\"pcId\"], None)\n                    nvPairs = {\"PO_ID\" : intfName, \"FEX_ID\" : poParams[\"fexId\"], \n                               \"DESC\" : fexNameDict.get(poParams[\"fexId\"], \"\"), \"PO_DESC\" : poParams[\"poDesc\"],\n                               \"MTU\" : poParams[\"poMtu\"], \"CONF\" : poParams[\"poConf\"], \"ADMIN_STATE\" : poParams[\"poAdminState\"],\n                               \"FABRIC_NAME\" : fabricName}\n                else:\n                    # normal PO\n                    if isExternalFab and (pcid == peerLinkPcId):\n                        isVpcPeerLinkPo = True\n                    \n                    if not isVpcPeerLinkPo:\n                        templateName = \"int_port_channel_access_host\" if accessPort else (\"int_port_channel_dot1q_tunnel_host\" if dot1qTunnelPort else \"int_port_channel_trunk_host\")\n\n                    poMemberInfo = poMemberIntfDict[\"po\"].get(poParams[\"pcId\"], None)\n                    pcMode = poMemberInfo[\"MODE\"] if poMemberInfo else \"on\"\n\n                    if isVpcPeerLinkPo:\n                        nvPairs = {\"PO_ID\" : intfName, \n                                   \"DESC\" : poParams[\"poDesc\"], \"NATIVE_VLAN\" : \"\",\n                                   \"MEMBER_DESC\" : \"\",\n                                   \"CONF\" : poParams[\"poConf\"], \"ADMIN_STATE\" : poParams[\"poAdminState\"]}\n                    else:\n                        nvPairs = {\"PO_ID\" : intfName, \n                                   \"DESC\" : poParams[\"poDesc\"], \"BPDUGUARD_ENABLED\" : poParams[\"bpduGuardState\"],\n                                   \"PC_MODE\" : pcMode, \"SPEED\" : poParams[\"poSpeed\"],\n                                   \"ENABLE_ORPHAN_PORT\": poParams[\"orphanPort\"], \"CONF\" : poParams[\"poConf\"],\n                                   \"MTU\" : poParams[\"poMtu\"], \"ADMIN_STATE\" : poParams[\"poAdminState\"]}\n                        if accessPort or dot1qTunnelPort:\n                            nvPairs[\"ACCESS_VLAN\"] = poParams[\"access_vlan\"]\n                            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poParams[\"porttype_fast_enable\"]\n                        else:\n                            nvPairs[\"ALLOWED_VLANS\"] = poParams[\"allowed_vlans\"]\n                            nvPairs[\"NATIVE_VLAN\"] = \"\" if poParams[\"native_vlan\"] == \"1\" else poParams[\"native_vlan\"]\n                            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poParams[\"porttype_fast_trunk\"]\n\n                Wrapper.print(\"Switch [%s] : Found Non-VPC PO [%s] peerLinkPcId [%s] isVpcPeerLinkPo [%r] isPeer1 [%r] poMemberInfo %s\" % (devSerial,\n                                                                        intfName, peerLinkPcId, isVpcPeerLinkPo, isPeer1, poMemberInfo))\n                poMembersDict = poMemberInfo[\"MEMBERS\"] if poMemberInfo else {}\n                memberPortsList = poMembersDict.keys()\n                nvPairs[\"MEMBER_INTERFACES\"] = \",\".join(memberPortsList)\n\n                if isVpcPeerLinkPo:\n                    vpcPairEntry = vpcPairGbl[\"vpc_pair\"]\n                    vpcPairNvpairs = vpcPairEntry[\"nvPairs\"]\n                    if isPeer1:\n                        vpcPairEntry[\"peer1MemberPorts\"] = poMembersDict\n                        vpcPairNvpairs[\"ADMIN_STATE\"] = nvPairs[\"ADMIN_STATE\"]\n                        vpcPairNvpairs[\"ALLOWED_VLANS\"] = poParams[\"allowed_vlans\"]\n                        vpcPairNvpairs[\"PC_MODE\"] = \"active\"\n                        vpcPairNvpairs[\"PEER1_PCID\"] = pcid\n                        vpcPairNvpairs[\"PEER1_MEMBER_INTERFACES\"] = nvPairs[\"MEMBER_INTERFACES\"]\n                        vpcPairNvpairs[\"PEER1_PO_DESC\"] = nvPairs[\"DESC\"]\n                        vpcPairNvpairs[\"PEER1_PO_CONF\"] = nvPairs[\"CONF\"]\n                    else:\n                        vpcPairEntry[\"peer2MemberPorts\"] = poMembersDict\n                        vpcPairNvpairs[\"PEER2_PCID\"] = pcid\n                        vpcPairNvpairs[\"PEER2_MEMBER_INTERFACES\"] = nvPairs[\"MEMBER_INTERFACES\"]\n                        vpcPairNvpairs[\"PEER2_PO_DESC\"] = nvPairs[\"DESC\"]\n                        vpcPairNvpairs[\"PEER2_PO_CONF\"] = nvPairs[\"CONF\"]\n                else:\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs, \"memberPorts\" : poMembersDict}\n\n            #Wrapper.print(\"%s: Switch [%s] newIntfEntry [%s]\" % (funcName, formattedName, newIntfEntry))\n            if newIntfEntry:\n                dbIfEntry[\"new\"] = newIntfEntry\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error during Host Port Resync. Please review the errors and \"\n            \"retry Recalculate & Deploy after fixing them.\" % (formattedName))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"HOST_PORT_RESYNC\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Switch [%s] Success = [%r]\" % (fabricName, \n                                                        funcName, formattedName, respObj.isRetCodeSuccess()))\n        return respObj\n\n# get the current overlay networks and port attachments for the switches\ndef buildSwitchNetworkPortAttachments(fabricName, globalOverlayInfo, hostPortResyncSwitches, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    networkVniToName = {}\n    networkNameToVni = {}\n    # key is network name, value is a dict of switch serials of type 'LanAttach'\n    netAttachEntries = {}\n    overlayNetDict = {\"vniToName\" : networkVniToName, \"attachEntries\" : netAttachEntries}\n\n    globalOverlayInfo[\"HOST_PORT_RESYNC\"][\"networks\"] = overlayNetDict\n\n    # get a list of all network entries for the fabric to build the vni to name mapping\n    # list of type 'LanNetworkStatus'\n    netEntries = Util.exe(TD.getAllNetworks(fabricName))\n    Wrapper.print(\"%s: Fabric [%s] Num Networks %s\" % (funcName, fabricName, len(netEntries)))\n    if not netEntries:\n        # no overlays defined.. nothing more to do\n        Wrapper.print(\"%s: Fabric [%s] No overlay networks found\" % (funcName, fabricName))\n        return\n\n    for netEntry in netEntries:\n        networkVniToName[netEntry.getNetworkId()] = netEntry.getNetworkName()\n        networkNameToVni[netEntry.getNetworkName()] = netEntry.getNetworkId()\n\n    allNetNames = \",\".join(sorted(networkNameToVni.keys()))\n    allSwitchSerials = \",\".join(hostPortResyncSwitches)\n\n    #Wrapper.print(\"%s: Fabric [%s] allNetNames [%s] allSwitchSerials [%s]\" % (funcName, fabricName, allNetNames, allSwitchSerials))\n\n    # now get the port attachments for the switches we are interested in. list has elements of type 'LanSwitchDetailsByNetwork'\n    netDetailEntries = Util.exe(TD.getSwitchDetailsByNetwork(fabricName, allNetNames, allSwitchSerials))\n\n    #Wrapper.print(\"%s: Fabric [%s] netDetailEntries %s\" % (funcName, fabricName, netDetailEntries))\n\n    # build the existing Net Attach entries\n    for netDetEntry in netDetailEntries:\n        # netDetEntry is of type 'LanSwitchDetailsByNetwork'\n        netName = netDetEntry.getNetworkName()\n        vniStr = networkNameToVni[netName]\n        netAttachEntries[vniStr] = {}\n\n        switchList = netDetEntry.getSwitchDetailsList()\n        # process the 'LanNetworkSwitchStatus' list\n        Wrapper.print(\"%s: Fabric [%s] Network [%s/%s] Num attachments = %d\" % (funcName, fabricName, vniStr, netName, len(switchList)))\n        for switchEntry in switchList:\n            deviceSerial = switchEntry.getSerialNumber()\n\n            if not switchEntry.isIslanAttached():\n                # network is not attached to this switch.. skip\n                Wrapper.print(\"%s: Fabric [%s] Network [%s/%s] Switch [%s] - Skip since unattached\" % (funcName,\n                    fabricName, vniStr, netName, deviceSerial))\n                continue\n\n            vlanId = switchEntry.getVlanId()\n            switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSerial]\n    \n            switchOverlayInfo[\"OVERLAY_VLANS\"].append(vlanId)\n            switchOverlayInfo[\"NETWORKS_VLAN2VNI\"][vlanId] = vniStr\n\n            # build the port list\n            portsList = []\n            for portEntry in switchEntry.getPort():\n                if portEntry.getPortStatus() == \"true\":\n                    portsList.append(portEntry.getPortName())\n\n            # add a new attach entry for this switch\n            lanAttach = LanAttach()\n            # portList will be updated when we process the switch config host port vlan lists later\n            netAttachEntries[vniStr][deviceSerial] = {\"lanAttach\" : lanAttach, \"origPortList\" : portsList, \"portList\" : []}\n\n            Wrapper.print(\"%s: Fabric [%s] Switch [%s] Network [%s/%s] Port List %s\" % (funcName, fabricName,\n                deviceSerial, vniStr, netName, portsList))\n\n            lanAttach.setFabric(fabricName)\n            lanAttach.setNetworkName(netName)\n            lanAttach.setSerialNumber(deviceSerial)\n            lanAttach.setSwitchPorts(\"\")\n            lanAttach.setDetachSwitchPorts(\"\")\n            lanAttach.setVlan(vlanId)\n            lanAttach.setDot1QVlan(1)\n            lanAttach.setUntagged(False)\n            lanAttach.setDeployment(True)\n            lanAttach.setExtensionValues(switchEntry.getExtensionValues())\n            lanAttach.setInstanceValues(switchEntry.getInstanceValues())\n            lanAttach.setFreeformConfig(switchEntry.getFreeformConfig())\n\n            printNetAttachList(fabricName, globalOverlayInfo, [netAttachEntries[vniStr][deviceSerial][\"lanAttach\"]])\n    #Wrapper.print(\"%s: Fabric [%s] Network DB %s\" % (funcName, fabricName,\n    #    json.dumps(globalOverlayInfo[\"HOST_PORT_RESYNC\"][\"networks\"], indent=4, sort_keys=True)))\n\ndef printNetAttachList(fabricName, globalOverlayInfo, attachList):\n    funcName = sys._getframe(0).f_code.co_name\n\n    for attachEntry in attachList:\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][attachEntry.getSerialNumber()]\n        Wrapper.print(\"-----[%s], Name [%s/%s] Vlan [%d] A Ports [%s] D Ports [%s] ExtensionVals [%s] FF [%s]\" % (switchDict[\"fmtName\"],\n            attachEntry.getNetworkName(), attachEntry.getProfileName(), attachEntry.getVlan(), attachEntry.getSwitchPorts(),\n            attachEntry.getDetachSwitchPorts(), attachEntry.getExtensionValues(), attachEntry.getFreeformConfig()))\n\ndef doNetworkAttach(fabricName, globalOverlayInfo, numProcessed, numEntries, vniStr, netAttach):\n    funcName = sys._getframe(0).f_code.co_name\n    netName = netAttach.getNetworkName()\n\n    attachList = netAttach.getLanAttachList()\n    Wrapper.print(\"%s %s: Fabric [%s] Attaching Network [%s,%s] [%d of %d] Attach Count = %d\" % (OVERLAY_PREFIX, funcName,\n        fabricName, vniStr, netName, numProcessed, numEntries, len(attachList)))\n    \n    printNetAttachList(fabricName, globalOverlayInfo, attachList)\n\n    newResp = TD.attachNetwork(fabricName, netAttach, False)\n    if not newResp.isRetCodeSuccess():\n        Wrapper.print(\"%s: Fabric [%s] Attaching network [%s/%s] - Failed\" % (funcName, fabricName, vniStr, netName))\n        return newResp\n\n    # there could still be a failure on a success return\n    respStr = newResp.getValue()\n\n    # check if the response contains \"invalid\" references which indicates some issue occured\n    if (\"invalid\" or \"failed\") in respStr.lower():\n        # we have a failure\n        Wrapper.print(\"%s: Fabric [%s] Attaching network [%s/%s] - Failed with response [%s]\" % \n            (funcName, fabricName, vniStr, netName, respStr))\n        newResp.addErrorReport(funcName,\n            \"Error attaching overlay network [%s]. Response = [%s]\" % (netName, respStr))\n        newResp.setFailureRetCode()\n\n    Wrapper.print(\"%s %s: Fabric [%s] Attaching Network [%s,%s] Resp [%r]\" % (OVERLAY_PREFIX, funcName,\n        fabricName, vniStr, netName, newResp.isRetCodeSuccess()))\n    return newResp\n\ndef doNetworkAttachments(fabricName, progressPrefix, progressStart, progressRange, globalOverlayInfo, netAttachDict, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    numProcessed = 0\n    numEntries = len(netAttachDict)\n    Wrapper.print(\"%s: Fabric [%s] Net Attach Count %d\" % (funcName, fabricName, numEntries))\n    for vniStr in sorted(netAttachDict.keys()):\n        netAttachEntry = netAttachDict[vniStr]\n        numProcessed += 1\n        netName = netAttachEntry.getNetworkName()\n\n        progress = progressStart + int(float(numProcessed)/float(numEntries) * progressRange)\n\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n            (\"%s - %d of %d - Attaching Network [%s/%s]\" % (progressPrefix, numProcessed, numEntries, vniStr, netName)))\n\n        newResp = doNetworkAttach(fabricName, globalOverlayInfo, numProcessed, numEntries, vniStr, netAttachEntry)\n        if not newResp.isRetCodeSuccess():\n            Wrapper.print(\"%s: Fabric [%s] Attaching network [%s/%s] - Failed\" % (funcName, fabricName, vniStr, netName))\n            Util.processRespObj(respObj, newResp)\n            continue\n\ndef setLanAttachPorts(origSet, newSet, lanAttach):\n    lanAttach.setSwitchPorts(\",\".join(list(newSet)))\n    detachPortsList = list(origSet - newSet)\n    lanAttach.setDetachSwitchPorts(\",\".join(detachPortsList))\n\ndef updateSwitchNetworkPortAttachments(fabricName, progressPrefix, progressStart, progressRange, globalOverlayInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    overlayNetDict = globalOverlayInfo[\"HOST_PORT_RESYNC\"][\"networks\"]\n    overlayAttachEntries = overlayNetDict[\"attachEntries\"]\n\n    netAttachDict = {}\n\n    numEntries = len(overlayAttachEntries)\n    Wrapper.print(\"%s: Fabric [%s] Original numEntries %d\" % (funcName, fabricName, numEntries))\n    for vniStr in sorted(overlayAttachEntries.keys()):\n        netName = overlayNetDict[\"vniToName\"][vniStr]\n        lanAttachList = []\n\n        serials = sorted(overlayAttachEntries[vniStr].keys())\n\n        vpcPairs = {}\n        standalone = {}\n        for deviceSerial in serials:\n            switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSerial]\n            swLanAttachDict = overlayAttachEntries[vniStr][deviceSerial]\n\n            portList = swLanAttachDict[\"portList\"]\n            portListSet = set(portList)\n            origPortList = swLanAttachDict[\"origPortList\"]\n            origPortListSet = set(origPortList)\n            skipUpdate = True if portListSet == origPortListSet else False\n\n            swLanAttach = swLanAttachDict[\"lanAttach\"]\n            if switchInfo[\"vpcPeer\"]:\n                vpcPairkey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, deviceSerial))\n                if vpcPairkey not in vpcPairs:\n                    # save the info.. process it later when the peer entry is found\n                    vpcPairs[vpcPairkey] = {deviceSerial : {\"swLanAttachDict\" : swLanAttachDict, \"skipUpdate\" : skipUpdate}}\n                    setLanAttachPorts(origPortListSet, portListSet, swLanAttach)\n                    continue\n                else:\n                    # we found the peer of an existing entry\n                    peerEntry = vpcPairs[vpcPairkey][switchInfo[\"vpcPeer\"]]\n                    if skipUpdate and peerEntry[\"skipUpdate\"]:\n                        # no changes on both the vpc pair switches...\n                        continue\n                    \n                    Wrapper.print(\"%s: Fabric [%s] Network [%s/%s] - Switch [%s] skipUpdate [%r] - Original %s New  %s\" % (funcName,\n                        fabricName, vniStr, netName, deviceSerial, skipUpdate, origPortListSet, portListSet))\n\n                    setLanAttachPorts(origPortListSet, portListSet, swLanAttach)\n                    lanAttachList.append(peerEntry[\"swLanAttachDict\"][\"lanAttach\"])\n                    lanAttachList.append(swLanAttach)\n            else:\n                Wrapper.print(\"%s: Fabric [%s] Network [%s/%s] - Switch [%s] skipUpdate [%r] - Original %s New  %s\" % (funcName,\n                    fabricName, vniStr, netName, deviceSerial, skipUpdate, origPortListSet, portListSet))\n                if not skipUpdate:\n                    setLanAttachPorts(origPortListSet, portListSet, swLanAttach)\n                    lanAttachList.append(swLanAttach)\n\n        Wrapper.print(\"%s: Fabric [%s] Network [%s/%s] Num Attachments - %d\" % (funcName, fabricName, vniStr, netName, len(lanAttachList)))\n        if lanAttachList:\n            netAttach = LanAttachByNetwork()\n            netAttach.setNetworkName(netName)\n            netAttach.setLanAttachList(lanAttachList)\n\n            netAttachDict[vniStr] = netAttach\n\n    # do the attachments\n    doNetworkAttachments(fabricName, progressPrefix, progressStart, progressRange, globalOverlayInfo, netAttachDict, respObj)\n\ndef updatePoMemberPolicy(devSerial, memberIntfDict, ptiTemplate, poPCId, source):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: SN [%s], PO [%s] Member interfaces [%s]\"% (funcName, devSerial, poPCId, \",\".join(memberIntfDict)))\n    for intfName in memberIntfDict:\n        Wrapper.print(\"%s: SN [%s] processing [%s] of [%s] for template [%s] and source [%s]\"%\n                      (funcName, devSerial, intfName, poPCId, ptiTemplate, source))\n\n        # get the current nvPairs\n        ptiList = Util.exe(PTI.getPTIs(devSerial, \"INTERFACE\", intfName, \"PYTHON\"))\n        if ptiList:\n            nvPairs = copy.deepcopy(ptiList[0].getNvPairs())\n\n            newNvPairs = memberIntfDict[intfName]\n            update = False\n            for key in newNvPairs:\n                update = True if (key in nvPairs) and (nvPairs[key] != newNvPairs[key]) else update\n                nvPairs[key] = newNvPairs[key]\n\n            if update:\n                createPTI(devSerial, nvPairs, ptiTemplate, intfName, source, -1)\n\ndef getPOMemberLists(currMembers, newMembers):\n    funcName = sys._getframe(0).f_code.co_name\n\n    currMemberStr = Util.expand_interface_range(currMembers)\n    currentMembers = currMemberStr.split(\",\")\n    newMemberStr = Util.expand_interface_range(newMembers)\n    newMembers = newMemberStr.split(\",\")\n    Wrapper.print(\"%s: currentMembers %d/%s newMembers %d/%s\" % (funcName,\n        len(currentMembers), currentMembers, len(newMembers), newMembers))\n\n    return currMemberStr, currentMembers, newMemberStr, newMembers\n\ndef validateOOBChanges(fabricName, globalOverlayInfo, respObj):\n    # error on the following conditions\n    #   - interface has overlays attached and policy template is changed\n    #   - po membership changes\n    funcName = sys._getframe(0).f_code.co_name\n    hostPortResyncDict = globalOverlayInfo[\"HOST_PORT_RESYNC\"]\n    switchDict = hostPortResyncDict[\"switches\"]\n    vpcIntfDict = hostPortResyncDict[\"vpcHostPairs\"]\n    isExternalFab = globalOverlayInfo[\"isExternalFab\"]\n\n    Wrapper.print(\"FAB [%s]: Start: %s - isExternalFab [%r]\" % (fabricName, funcName, isExternalFab))\n\n    switchList = sorted(switchDict)\n    vpcPairsList = sorted(vpcIntfDict)\n\n    # check the standalone policies\n    for devSerial in switchList:\n        switchGbl = switchDict[devSerial]\n\n        for intfName in switchGbl:\n            if intfName.startswith(\".\"):\n                continue\n\n            intfEntry = switchGbl[intfName]\n\n            #Wrapper.print(\"%s: Processing intf [%s] entry %s\" % (funcName, intfName, intfEntry))\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            currEntry = intfEntry[\"current\"]\n            if not currEntry:\n                # not discovered yet.. nothing special to do\n                continue\n\n            newEntry = intfEntry[\"new\"]\n            if not newEntry:\n                \"\"\"\n                # check to make sure interfaces with overlay attachments are still discovered and also present on switch\n                if currEntry[\"hasOverlays\"] and (currEntry[\"ifType\"] != \"INTERFACE_VLAN\"):\n                    respObj.addErrorReport(\"HOST_PORT_RESYNC:INTF_OVERLAY\", \"Interface [%s] has \"\n                        \"overlay network(s) attached and cannot be deleted from the switch. Please undo the \"\n                        \"out-of-band changes and retry.\" % (intfEntry[\"ifName\"]), devSerial)\n                    respObj.setFailureRetCode()\n                \"\"\"\n                continue\n\n            if not currEntry[\"policy\"]:\n                # no policy attached to this earlier\n                continue\n\n            isSameTemplate = True if currEntry[\"policy\"][\"templateName\"] == newEntry[\"templateName\"] else False\n            \n            if currEntry[\"hasOverlays\"]:\n                # there was an existing policy with overlays\n                if not isSameTemplate:\n                    # error - template type has changed\n                    respObj.addErrorReport(\"HOST_PORT_RESYNC:TEMPLATE_NAME\", \"Interface [%s] policy \"\n                        \"cannot be changed from [%s] to [%s] with Overlays attached or if interface belongs to an \"\n                        \"Interface Group. Please undo the out-of-band changes and retry.\" % (intfEntry[\"ifName\"], \n                            currEntry[\"policy\"][\"templateName\"], newEntry[\"templateName\"]), devSerial)\n                    respObj.setFailureRetCode()\n                    continue\n\n            pti = getCurrentIntfPyPtiById(currEntry[\"policy\"][\"policyId\"])\n            nvPairs = pti.getNvPairs()\n            currMembers = nvPairs.get(\"MEMBER_INTERFACES\", None)\n\n            # check for PO membership changes\n            if ((currMembers != None) and (newEntry[\"templateName\"] in [\"int_port_channel_trunk_host\",\n                \"int_port_channel_access_host\", \"int_port_channel_dot1q_tunnel_host\", \"int_port_channel_fex\"])):\n                # check to make sure the membership is intact\n                currMemberStr, currentMembers, newMemberStr, newMembers = getPOMemberLists(currMembers,\n                                                                    newEntry[\"nvPairs\"][\"MEMBER_INTERFACES\"])\n                if set(currentMembers) != set(newMembers):\n                    # error - membership change detected\n                    respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_MEMBERS\", \"Port Channel Interface [%s] membership \"\n                        \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                        \"changes and retry.\" % (intfEntry[\"ifName\"], currMemberStr, newMemberStr), devSerial)\n                    respObj.setFailureRetCode()\n                    continue\n\n            # update our new nvPairs to avoid unnecessary updates during the PTI updates\n            if isSameTemplate:\n                currNvpairs = copy.deepcopy(nvPairs)\n                for key in currNvpairs:\n                    if key not in newEntry[\"nvPairs\"]:\n                        newEntry[\"nvPairs\"][key]  = currNvpairs[key]\n\n    # check the vPC policies\n    for vpcPairKey in vpcPairsList:\n        vpcPairGbl = vpcIntfDict[vpcPairKey]\n        vpcPairFormattedName = vpcPairGbl[\"fmtName\"]\n\n        for intfName in vpcPairGbl:\n            intfEntry = vpcPairGbl[intfName]\n\n            Wrapper.print(\"%s: Processing vPC intf [%s] entry %s\" % (funcName, intfName, intfEntry))\n\n            if intfName == \"vpc_pair\":\n                if not isExternalFab:\n                    continue               \n                \n                # check the vpc pairing in external fabric\n                #   - do not allow po membership changes\n                vpcPairNvpairs = intfEntry[\"nvPairs\"]\n                if intfEntry[\"ptiID\"]:\n                    # get the current PTI\n                    pti = Util.exe(PTIWrapper.getInstance(intfEntry[\"ptiID\"]))\n                    nvPairs = pti.getNvPairs()\n\n                    # check that the vpc po association is not changed\n                    if nvPairs[\"PEER1_PCID\"] != vpcPairNvpairs[\"PEER1_PCID\"]:\n                        # error - PO association change detected\n                        respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_ASSOCIATION\", \"vPC Pair [%s] Interface [port-channel%s] Peer 1 Port Channel \"\n                            \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                            \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                                nvPairs[\"PEER1_PCID\"], vpcPairNvpairs[\"PEER1_PCID\"]))\n                        respObj.setFailureRetCode()\n                        continue\n\n                    if nvPairs[\"PEER2_PCID\"] != vpcPairNvpairs[\"PEER2_PCID\"]:\n                        # error - PO association change detected\n                        respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_ASSOCIATION\", \"vPC Pair [%s] Interface [port-channel%s] Peer 2 Port Channel \"\n                            \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                            \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                                nvPairs[\"PEER2_PCID\"], vpcPairNvpairs[\"PEER2_PCID\"]))\n                        respObj.setFailureRetCode()\n                        continue\n\n                    currMemberStr, currentMembers, newMemberStr, newMembers = getPOMemberLists(nvPairs[\"PEER1_MEMBER_INTERFACES\"],\n                                                                    vpcPairNvpairs[\"PEER1_MEMBER_INTERFACES\"])\n                    if set(currentMembers) != set(newMembers):\n                        # error - membership change detected\n                        respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_MEMBERS\", \"vPC Pair [%s] Interface [port-channel%s] \"\n                            \"Peer 1 PO Member interface changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                            \"changes and retry.\" % (vpcPairFormattedName, nvPairs[\"PEER1_PCID\"], currMemberStr, newMemberStr))\n                        respObj.setFailureRetCode()\n                        continue\n\n                    currMemberStr, currentMembers, newMemberStr, newMembers = getPOMemberLists(nvPairs[\"PEER2_MEMBER_INTERFACES\"],\n                                                                    vpcPairNvpairs[\"PEER2_MEMBER_INTERFACES\"])\n                    if set(currentMembers) != set(newMembers):\n                        # error - membership change detected\n                        respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_MEMBERS\", \"vPC Pair [%s] Interface [port-channel%s] \"\n                            \"Peer 2 PO Member interface changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                            \"changes and retry.\" % (vpcPairFormattedName, nvPairs[\"PEER1_PCID\"], currMemberStr, newMemberStr))\n                        respObj.setFailureRetCode()\n                        continue\n\n                    currNvpairs = copy.deepcopy(nvPairs)\n                    for key in currNvpairs:\n                        if key not in vpcPairNvpairs:\n                            vpcPairNvpairs[key] = currNvpairs[key]\n\n            if not intfName.startswith(\"vPC\"):\n                continue\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            currEntry = intfEntry[\"current\"]\n            newEntry = intfEntry[\"new\"]\n            if not newEntry:\n                # we did not find this in sh run? we do not care.. leave the intent as is\n                continue\n\n            # check to make sure the vPCs are defined correctly on both peers\n            if (\"PEER1_PCID\" not in newEntry[\"nvPairs\"]):\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:INCORRECT_VPC\", \"vPC Pair [%s] Interface [%s] in missing on \"\n                    \"switch [%s]. Please make configuration consistent and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                        vpcPairGbl[\"peer1Sn\"]))\n                respObj.setFailureRetCode()\n                continue\n\n            if (\"PEER2_PCID\" not in newEntry[\"nvPairs\"]):\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:INCORRECT_VPC\", \"vPC Pair [%s] Interface [%s] in missing on \"\n                    \"switch [%s]. Please make configuration consistent and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                        vpcPairGbl[\"peer2Sn\"]))\n                respObj.setFailureRetCode()\n                continue\n\n            if not currEntry or not currEntry[\"policy\"]:\n                # no policy attached to this earlier\n                continue\n            \n            if currEntry[\"hasOverlays\"]:\n                # there was an existing policy with overlays\n                if currEntry[\"policy\"][\"templateName\"] != newEntry[\"templateName\"]:\n                    # error - template type has changed\n                    respObj.addErrorReport(\"HOST_PORT_RESYNC:TEMPLATE_NAME\", \"vPC Pair  [%s] - Interface [%s] policy \"\n                        \"cannot be changed from [%s] to [%s] with Overlays attached or if interface belongs to an \"\n                        \"Interface Group. Please undo the out-of-band changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                            currEntry[\"policy\"][\"templateName\"], newEntry[\"templateName\"]))\n                    respObj.setFailureRetCode()\n                    continue\n\n            pti = getCurrentIntfPyPtiById(currEntry[\"policy\"][\"policyId\"])\n            nvPairs = pti.getNvPairs()\n\n            # check that the vpc po association is not changed\n            if nvPairs[\"PEER1_PCID\"] != newEntry[\"nvPairs\"][\"PEER1_PCID\"]:\n                # error - PO association change detected\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_ASSOCIATION\", \"vPC Pair [%s] Interface [%s] Peer 1 Port Channel \"\n                    \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                    \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                        nvPairs[\"PEER1_PCID\"], newEntry[\"nvPairs\"][\"PEER1_PCID\"]))\n                respObj.setFailureRetCode()\n                continue\n\n            if nvPairs[\"PEER2_PCID\"] != newEntry[\"nvPairs\"][\"PEER2_PCID\"]:\n                # error - PO association change detected\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_ASSOCIATION\", \"vPC Pair [%s] Interface [%s] Peer 2 Port Channel \"\n                    \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                    \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                        nvPairs[\"PEER2_PCID\"], newEntry[\"nvPairs\"][\"PEER2_PCID\"]))\n                respObj.setFailureRetCode()\n                continue\n\n            # check for PO member interfaces changes\n            currMemberStr, currentMembers, newMemberStr, newMembers = getPOMemberLists(nvPairs[\"PEER1_MEMBER_INTERFACES\"],\n                                                                    newEntry[\"nvPairs\"][\"PEER1_MEMBER_INTERFACES\"])\n            if set(currentMembers) != set(newMembers):\n                # error - membership change detected\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_MEMBERS\", \"vPC Pair [%s] Interface [%s] Peer 1 PO Member interface \"\n                    \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                    \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"], currMemberStr, newMemberStr))\n                respObj.setFailureRetCode()\n                continue\n\n            currMemberStr, currentMembers, newMemberStr, newMembers = getPOMemberLists(nvPairs[\"PEER2_MEMBER_INTERFACES\"],\n                                                                    newEntry[\"nvPairs\"][\"PEER2_MEMBER_INTERFACES\"])\n            if set(currentMembers) != set(newMembers):\n                # error - membership change detected\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_MEMBERS\", \"vPC Pair [%s] Interface [%s] Peer 2 PO Member interface \"\n                    \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                    \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"], currMemberStr, newMemberStr))\n                respObj.setFailureRetCode()\n                continue\n\n            # update our new nvPairs to avoid unnecessary updates during the PTI updates\n            if isSameTemplate:\n                currNvpairs = copy.deepcopy(nvPairs)\n                for key in currNvpairs:\n                    if key not in newEntry[\"nvPairs\"]:\n                        newEntry[\"nvPairs\"][key]  = currNvpairs[key]\n\ndef updateHostPortPolicies(fabricName, progressPrefix, progressStart, progressRange, globalOverlayInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    hostPortResyncDict = globalOverlayInfo[\"HOST_PORT_RESYNC\"]\n    switchDict = hostPortResyncDict[\"switches\"]\n    vpcIntfDict = hostPortResyncDict[\"vpcHostPairs\"]\n    isExternalFab = globalOverlayInfo[\"isExternalFab\"]\n\n    Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s. isExternalFab [%r] \" % (fabricName, funcName, isExternalFab))\n\n    switchList = sorted(switchDict)\n    vpcPairsList = sorted(vpcIntfDict)\n\n    # do the vPC pairing in external fabric first\n    if isExternalFab:\n        for vpcPairKey in vpcPairsList:\n            vpcPairGbl = vpcIntfDict[vpcPairKey]\n\n            vpcPairEntry = vpcPairGbl[\"vpc_pair\"]\n            nvPairs = vpcPairEntry[\"nvPairs\"]\n            if nvPairs == None:\n                continue\n        \n            Wrapper.print(\"%s: Performing vPC pairing for [%s] with nvpairs %s\" % (funcName, vpcPairGbl[\"fmtName\"], nvPairs))\n            Util.exe(VpcWrapper.createOrUpdate(vpcPairGbl[\"peer1Sn\"], vpcPairGbl[\"peer2Sn\"], \"false\", \"vpc_pair\", nvPairs))\n\n            poMemberTemplateName = \"vpc_pair_peer_link_po_member\"\n            src = \"VPC_PAIR\"\n            if \"peer1MemberPorts\" in vpcPairEntry:\n                updatePoMemberPolicy(vpcPairGbl[\"peer1Sn\"], vpcPairEntry[\"peer1MemberPorts\"], poMemberTemplateName, nvPairs[\"PEER1_PCID\"], src)\n            if \"peer2MemberPorts\" in vpcPairEntry:\n                updatePoMemberPolicy(vpcPairGbl[\"peer2Sn\"], vpcPairEntry[\"peer2MemberPorts\"], poMemberTemplateName, nvPairs[\"PEER2_PCID\"], src)\n\n    # delete the host policies for non existant interfaces\n    progress = progressStart\n    FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - Cleaning up Standalone Host Policies\" % (progressPrefix))) \n    Wrapper.print(\"%s: Cleanup Standalone Host Policies\" % (funcName))\n    for devSerial in switchList:\n        switchGbl = switchDict[devSerial]\n\n        for intfName in switchGbl:\n            intfEntry = switchGbl[intfName]\n            if intfName.startswith(\".\"):\n                continue\n\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            Wrapper.print(\"%s: Delete Processing - Switch [%s] intfName [%s]\" % (funcName, devSerial, intfName))\n            currEntry = intfEntry[\"current\"]\n            newEntry = intfEntry[\"new\"]\n            if currEntry and not currEntry[\"policy\"]:\n                continue\n\n            delPti = False\n            if not intfEntry[\"isPresent\"]:\n                # interface had intent already, but, interface has been deleted now\n                delPti = True\n            elif newEntry:\n                # if the templates are different.. delete the current one\n                if newEntry[\"templateName\"] != currEntry[\"policy\"][\"templateName\"]:\n                    delPti = True\n            if delPti:\n                Wrapper.print(\"%s: Deleting intf [%s] entry %s\" % (funcName, intfName, intfEntry))\n                PTI.deleteInstance(currEntry[\"policy\"][\"policyId\"])\n                currEntry[\"policy\"] = None\n\n    # delete the current breakout_interface PTI.. new ones will be created as needed below\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"breakout_interface\")\n    ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    for pti in ptiList:\n        if pti.isDeleted():\n            continue\n        Wrapper.print(\"%s: Deleting breakout PTI for [%s]\" % (funcName, pti.getEntityName()))\n        PTI.deleteInstance(pti.getPolicyId())\n\n    # delete the host policies for non existant vpc interfaces\n    progress += 5\n    FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - Cleaning up vPC Host Policies\" % (progressPrefix))) \n    Wrapper.print(\"%s: Cleanup vPC Host Policies\" % (funcName))\n    for vpcPairKey in vpcPairsList:\n        vpcPairGbl = vpcIntfDict[vpcPairKey]\n\n        for intfName in vpcPairGbl:\n            if not intfName.startswith(\"vPC\"):\n                continue\n\n            Wrapper.print(\"%s: Delete Processing - vPC [%s] intfName [%s]\" % (funcName, vpcPairKey, intfName))\n            intfEntry = vpcPairGbl[intfName]\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            currEntry = intfEntry[\"current\"]\n            newEntry = intfEntry[\"new\"]\n\n            if not currEntry or not currEntry[\"policy\"]:\n                continue\n\n            delPti = False\n            if not intfEntry[\"isPresent\"]:\n                # interface had intent already, but, interface has been deleted now\n                delPti = True\n            elif newEntry:\n                # if the templates are different.. delete the current one\n                if newEntry[\"templateName\"] != currEntry[\"policy\"][\"templateName\"]:\n                    delPti = True\n            if delPti:\n                Wrapper.print(\"%s: Deleting vPC intf [%s] entry %s\" % (funcName, intfName, intfEntry))\n                PTI.deleteInstance(currEntry[\"policy\"][\"policyId\"])\n                currEntry[\"policy\"] = None\n\n    # assume system jumbo mtu chnaged to force all pti updated to be forced.. this will \n    # be updated when system_jumbomtu is processed\n    isMtuChanged = True\n\n    # process the special non intf policies first\n    Wrapper.print(\"%s: Processing Special vPC Policies\" % (funcName))\n    for devSerial in switchList:\n        switchGbl = switchDict[devSerial]\n        for intfName in [\".breakout\", \".jumbomtu\", \".vlanCfg\"]:\n            if intfName not in switchGbl:\n                continue\n\n            intfEntry = switchGbl[intfName]\n            \n            #Wrapper.print(\"%s: Switch [%s] Intf [%s] Entry %s\" % (funcName, devSerial, intfName, intfEntry))\n            if intfName == \".breakout\":\n                templateName = intfEntry[\"templateName\"]\n                for entry in intfEntry[\"entries\"].values():\n                    Util.exe(PTI.createOrUpdate(devSerial, entry[\"ifName\"], \"INTERFACE\", \"\", getPrio(templateName),\n                                                templateName, entry[\"nvPairs\"]))\n            elif intfName == \".jumbomtu\":\n                templateName = intfEntry[\"templateName\"]\n                for entry in intfEntry[\"entries\"].values():\n                    isMtuChanged = entry[\"isMtuChanged\"]\n                    Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", getPrio(templateName),\n                                                templateName, entry[\"nvPairs\"]))\n            elif intfName == \".vlanCfg\":\n                Wrapper.print(\"%s .vlanCfg intfEntry %s\" % (funcName, intfEntry))\n                ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n                for pti in ptiList:\n                    if pti.getDescription() == \"vlan configuration\":\n                        PTI.deleteInstance(pti.getPolicyId())\n                        break\n                for entry in intfEntry[\"entries\"].values():\n                    Util.exe(PTI.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_TOP,\n                                        \"switch_freeform\", entry[\"nvPairs\"],\n                                        \"vlan configuration\"))\n\n    # create the standlaone host port policies\n    progress += 5\n    FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - Create/Update Standalone Host Policies\" % (progressPrefix))) \n    Wrapper.print(\"%s: Create/Update Standalone Host Policies. isMtuChanged [%r]\" % (funcName, isMtuChanged))\n    for devSerial in switchList:\n        switchGbl = switchDict[devSerial]\n        #switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n        #fmtname = switchInfoDict[\"fmtName\"]\n\n        for intfName in switchGbl:\n            intfEntry = switchGbl[intfName]\n            if intfName.startswith(\".\"):\n                continue\n\n            Wrapper.print(\"%s: Switch [%s] Intf [%s] Entry %s\" % (funcName, devSerial, intfName, intfEntry))\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            if not intfEntry[\"new\"]:\n                # interface no longer exists on switch\n                continue\n\n            currEntry = intfEntry[\"current\"]\n            newEntry = intfEntry[\"new\"]\n\n            # key to use for RM allocations\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            templateName = newEntry[\"templateName\"]\n            nvPairs = newEntry[\"nvPairs\"]\n            isNewPTI =  False if (currEntry and currEntry[\"policy\"]) else True\n            rmIds = None\n            poMemberTemplateName = None\n            doForceUpdate = False\n\n            if templateName == \"int_loopback\":\n                if isNewPTI:\n                    # record resources in RM\n                    loopbackId = intfName[8:]\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s]\" %\n                                  (fabricName, key, loopbackId, intfName))\n                    ignore, loRmId = Util.exeRM(RM.set(fabricName, \"LOOPBACK_ID\", key, intfEntry[\"ifName\"], loopbackId))\n                    rmIds = [loRmId]\n            elif templateName in [\"int_port_channel_trunk_host\", \"int_port_channel_access_host\",\n                                  \"int_port_channel_fex\", \"int_port_channel_dot1q_tunnel_host\"]:\n                doForceUpdate = isMtuChanged\n                ignore, pcid = intfName.split(\"port-channel\")\n                if isNewPTI:\n                    normalizedIntfName = intfName.capitalize()\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: Intf [%s] PORT_CHANNEL_ID [%s]\" % (fabricName, key, normalizedIntfName, pcid))\n                    ignore, pcRmId = Util.exeRM(RM.set(fabricName, \"PORT_CHANNEL_ID\", key, normalizedIntfName, pcid))\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: Intf [%s] PORT_CHANNEL_ID [%s]: rmId [%s]\" % (fabricName, key,\n                            normalizedIntfName, pcid, pcRmId))\n                    rmIds = [pcRmId]\n\n                if templateName == \"int_port_channel_fex\":\n                    poMemberTemplateName = \"int_fex_po_member_11_1\"\n                    if isNewPTI:\n                        fexId = nvPairs[\"FEX_ID\"]\n                        # set the FEX related RM\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: FEX_ID [%s]\" % (fabricName, key, fexId))\n                        ignore, fexRmId = Util.exeRM(RM.set(fabricName, \"FEX_ID\", key, \"fex-\"+fexId, fexId))\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: FEX_ID [%s]: rmId [%s]\" % (fabricName, key, fexId, fexRmId))\n                        rmIds.append(fexRmId)\n                elif templateName == \"int_port_channel_access_host\":\n                    poMemberTemplateName = \"int_port_channel_access_member_11_1\"\n                elif templateName == \"int_port_channel_dot1q_tunnel_host\":\n                    poMemberTemplateName = \"int_port_channel_dot1q_tunnel_member_11_1\"\n                else:\n                    poMemberTemplateName = \"int_port_channel_trunk_member_11_1\"\n            elif templateName == \"int_l3_port_channel\":\n                ignore, pcid = intfName.split(\"port-channel\")\n                if isNewPTI:\n                    normalizedIntfName = intfName.capitalize()\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: Intf [%s] PORT_CHANNEL_ID [%s]\" % (fabricName, key, normalizedIntfName, pcid))\n                    ignore, pcRmId = Util.exeRM(RM.set(fabricName, \"PORT_CHANNEL_ID\", key, normalizedIntfName, pcid))\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: Intf [%s] PORT_CHANNEL_ID [%s]: rmId [%s]\" % (fabricName, key,\n                            normalizedIntfName, pcid, pcRmId))\n                    rmIds = [pcRmId]\n\n                poMemberTemplateName = \"int_l3_port_channel_member\"\n            elif templateName in [\"int_trunk_host\", \"int_access_host\", \"int_dot1q_tunnel_host\"]:\n                doForceUpdate = isMtuChanged\n            elif templateName in [\"int_subif\", \"int_freeform\"]:\n                dot1qID = newEntry.get(\"dot1qID\", None)\n                if dot1qID:\n                    Wrapper.print(\"%s: Switch [%s] isNewPTI [%r] dot1qID [%s] Entry %s\" % (funcName, devSerial, isNewPTI, dot1qID, intfEntry))\n                    rmIds = [setDot1qRMResource(fabricName, devSerial, intfEntry[\"ifName\"], dot1qID)]\n                loID = newEntry.get(\"loID\", None)\n                if loID:\n                    Wrapper.print(\"%s: Switch [%s] isNewPTI [%r] loID [%s] Entry %s\" % (funcName, devSerial, isNewPTI, loID, intfEntry))\n                    key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                    ignore, loRmId = Util.exeRM(RM.set(fabricName, \"LOOPBACK_ID\", key, intfEntry[\"ifName\"], loID))\n                    rmIds = [loRmId]\n            elif templateName == \"int_vlan\":\n                Wrapper.print(\"%s: int_vlan %s intfEntry %s\" % (funcName, intfName, intfEntry))\n                vlanId = intfName[4:]\n                if isNewPTI and vlanId !=\"1\":\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: TOP_DOWN_NETWORK_VLAN [%s] intfName [%s]\" %\n                                  (fabricName, key, vlanId, intfName))\n                    ignore, loRmId = Util.exeRM(RM.set(fabricName, \"TOP_DOWN_NETWORK_VLAN\", key, intfEntry[\"ifName\"], vlanId))\n\n            if globalOverlayInfo[\"isExternalFab\"]:\n                src = \"\"\n            else:\n                src = getSrc(templateName)\n            \n            if isNewPTI:\n                Util.exe(PTI.createOrUpdate(devSerial, \"INTERFACE\", intfEntry[\"ifName\"], src, getPrio(templateName),\n                                            rmIds, templateName, nvPairs))\n            else:\n                Util.exe(PTI.updateInstance(currEntry[\"policy\"][\"policyId\"], nvPairs, doForceUpdate))\n\n            if \"memberPorts\" in newEntry:\n                # update the member port configs\n                updatePoMemberPolicy(devSerial, newEntry[\"memberPorts\"], poMemberTemplateName, pcid, intfEntry[\"ifName\"])\n\n    # create the vPC host port policies\n    progress += 5\n    FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - Create/Update vPC Host Policies\" % (progressPrefix))) \n    Wrapper.print(\"%s: Create/Update vPC Host Policies. isMtuChanged [%r]\" % (funcName, isMtuChanged))\n    for vpcPairKey in vpcPairsList:\n        vpcPairGbl = vpcIntfDict[vpcPairKey]\n\n        for intfName in vpcPairGbl:\n            if not intfName.startswith(\"vPC\"):\n                continue\n\n            intfEntry = vpcPairGbl[intfName]\n\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            if not intfEntry[\"new\"]:\n                # interface no longer exists on switch\n                continue\n\n            Wrapper.print(\"%s: Start - Processing vPC Host [%s] Entry [%s]\" % (funcName, intfName,\n                                                    json.dumps(intfEntry, indent=4, sort_keys=True)))\n\n            currEntry = intfEntry[\"current\"]\n            newEntry = intfEntry[\"new\"]\n\n            templateName = newEntry[\"templateName\"]\n            nvPairs = newEntry[\"nvPairs\"]\n            isNewPTI =  False if (currEntry and currEntry[\"policy\"]) else True\n            rmIds = None\n            ignore, vpcId = intfName.split('vPC')\n\n            if isNewPTI:\n                key = Util.exe(Helper.getKey(\"DeviceInterface\", vpcPairGbl[\"peer1Sn\"], vpcPairGbl[\"peer2Sn\"], intfName))\n                ignore, vpcRmId1 = Util.exeRM(RM.set(fabricName, \"VPC_ID\", vpcPairGbl[\"peer1Sn\"], key, vpcId))\n                ignore, vpcRmId2 = Util.exeRM(RM.set(fabricName, \"VPC_ID\", vpcPairGbl[\"peer2Sn\"], key, vpcId))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s]: VPC_ID [%s] Peer 1 rmId [%s], Peer 2 rmId [%s]\" % (fabricName, key, vpcId, vpcRmId1, vpcRmId2))\n\n                peer1key = Util.exe(Helper.getKey(\"Device\", vpcPairGbl[\"peer1Sn\"]))\n                peer2key = Util.exe(Helper.getKey(\"Device\", vpcPairGbl[\"peer2Sn\"]))\n                pcId = nvPairs[\"PEER1_PCID\"]\n                ignore, pcRmId1 = Util.exeRM(RM.set(fabricName, \"PORT_CHANNEL_ID\", peer1key, intfName, pcId))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], intfName [%s] rmId [%s]\"\n                              % (fabricName, peer1key, pcId, intfName, pcRmId1))\n\n                pcId = nvPairs[\"PEER2_PCID\"]\n                ignore, pcRmId2 = Util.exeRM(RM.set(fabricName, \"PORT_CHANNEL_ID\", peer2key, intfName, nvPairs[\"PEER2_PCID\"]))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], intfName [%s] rmId [%s]\"\n                              % (fabricName, peer2key, pcId, intfName, pcRmId2))\n\n                rmIds = [vpcRmId1, vpcRmId2, pcRmId1, pcRmId2]\n\n            if isNewPTI and templateName == \"int_port_channel_aa_fex\":\n                fexId = nvPairs[\"FEX_ID\"]\n                fexKey = Util.exe(Helper.getKey(\"DeviceInterface\", vpcPairGbl[\"peer1Sn\"], vpcPairGbl[\"peer2Sn\"], \"fex-\" + intfName))\n\n                Wrapper.print(\"FAB [%s] RM SET: FEX_ID [%s] peer1key [%s] fexKey [%s] fexId [%s]\"\n                              % (fabricName, fexId, peer1key, fexKey, fexId))\n                ignore, fexRmId1 = Util.exeRM(RM.set(fabricName, \"FEX_ID\", peer1key, fexKey, fexId))\n                Wrapper.print(\"FAB [%s] RM SET: FEX_ID [%s] peer2key [%s] fexKey [%s] fexId [%s]\"\n                              % (fabricName, fexId, peer2key, fexKey, fexId))\n                ignore, fexRmId2 = Util.exeRM(RM.set(fabricName, \"FEX_ID\", peer2key, fexKey, fexId))\n                Wrapper.print(\"FAB [%s] RM SET: FEX_ID [%s] Peer1 Key [%s] fexRmId1 [%s] Peer2 Key [%s] fexRmId2 [%s]\"\n                              % (fabricName, fexId, peer1key, fexRmId1, peer2key, fexRmId2))\n\n                rmIds.extend([fexRmId1, fexRmId2])\n\n            if globalOverlayInfo[\"isExternalFab\"]:\n                src = \"\"\n            else:\n                src = getSrc(templateName)\n\n            if isNewPTI:\n                Util.exe(PTI.createOrUpdate(vpcPairKey, \"INTERFACE\", intfName, src, getPrio(templateName),\n                    rmIds, templateName, nvPairs))\n            else:\n                Util.exe(PTI.updateInstance(currEntry[\"policy\"][\"policyId\"], nvPairs, isMtuChanged))\n\n            if templateName == \"int_port_channel_aa_fex\":\n                poMemberTemplateName = \"int_fex_po_member_11_1\"\n            elif templateName == \"int_vpc_trunk_host\":\n                poMemberTemplateName = \"int_vpc_trunk_po_member_11_1\"\n            elif templateName == \"int_vpc_dot1q_tunnel\":\n                poMemberTemplateName = \"int_vpc_dot1q_tunnel_po_member_11_1\"\n            else:\n                poMemberTemplateName = \"int_vpc_access_po_member_11_1\"\n            \n            if \"peer1MemberPorts\" in newEntry:\n                updatePoMemberPolicy(vpcPairGbl[\"peer1Sn\"], newEntry[\"peer1MemberPorts\"], poMemberTemplateName, nvPairs[\"PEER1_PCID\"], intfName)\n            if \"peer2MemberPorts\" in newEntry:\n                updatePoMemberPolicy(vpcPairGbl[\"peer2Sn\"], newEntry[\"peer2MemberPorts\"], poMemberTemplateName, nvPairs[\"PEER2_PCID\"], intfName)\n            Wrapper.print(\"%s: End - Processing vPC Host [%s]\" % (funcName, intfName))\n\ndef handleOverlayMigration(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s\" % (fabricName, funcName))\n    doErrorHandling = False\n    try:\n        handleOverlayMigrationInt(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj)\n        if respObj.isRetCodeFailure():\n            doErrorHandling = True\n        else:\n            for deviceSn in devices:\n                # delete the user created vpc peer link vlan PTI since we would have already created the required PTI\n                # with \"UNDERLAY\" source\n                vPCInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn][\"vpcInfo\"]\n                if vPCInfo[\"userPeerLinkVlanPtiId\"]:\n                    PTI.deleteInstance(vPCInfo[\"userPeerLinkVlanPtiId\"])\n                # take switch out of migration mode\n                delMigrationState(fabricName, deviceSn)\n    except Exception as e:\n        doErrorHandling = True\n        msg = \"Unexpected error during Overlay Migration\"\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"OVERLAY_MIGRATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        if doErrorHandling:\n            resetSwitchMigration(fabricName, devices, globalOverlayInfo, gVarDictObj)\n\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Success = [%r]\" % (fabricName, funcName, respObj.isRetCodeSuccess()))\n        return respObj\n\ndef ECLhandleOverlayMigration(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj, topologyDataObj):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s\" % (fabricName, funcName))\n    doErrorHandling = False\n    try:\n        vrfSviInstanceValues = ECLPrepareVrfInstanceValues(fabricName, devices, globalOverlayInfo)\n        ECLhandleOverlayMigrationInt(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj, topologyDataObj, vrfSviInstanceValues)\n\n        #respObj.addErrorReport(funcName,\"DUMMY ERROR\")\n        #respObj.setFailureRetCode()\n        #return respObj\n        if respObj.isRetCodeFailure():\n            doErrorHandling = True\n        else:\n            for deviceSn in devices:\n                # delete the user created vpc peer link vlan PTI since we would have already created the required PTI\n                # with \"UNDERLAY\" source\n                vPCInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn][\"vpcInfo\"]\n                if vPCInfo[\"userPeerLinkVlanPtiId\"]:\n                    PTI.deleteInstance(vPCInfo[\"userPeerLinkVlanPtiId\"])\n                # take switch out of migration mode\n                delMigrationState(fabricName, deviceSn)\n    except Exception as e:\n        doErrorHandling = True\n        msg = \"Unexpected error during ECL Network/VRF Migration\"\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"OVERLAY_MIGRATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        if doErrorHandling:\n            resetSwitchMigration(fabricName, devices, globalOverlayInfo, gVarDictObj)\n\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Success = [%r]\" % (fabricName, funcName, respObj.isRetCodeSuccess()))\n        return respObj\n\ndef setOverlayVrfReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayVrfs):\n    funcName = sys._getframe(0).f_code.co_name\n    # process all the VRFs found on this switch\n    for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n        vrfEntryTemplateParams = vrfEntry[\"vrfTemplateParams\"]\n        if vrfEntry[\"vni\"] not in allOverlayVrfs:\n            formattedName = getFormattedSwitchName(deviceSn)\n            Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] is reference for VRF \"\n                \"vni [%s]. Params = [%s]\" % (OVERLAY_PREFIX, funcName, fabricName, switchOverlayInfo[\"switchRole\"], formattedName,\n                vrfEntry[\"vni\"], vrfEntryTemplateParams))\n            refVrfEntry = copy.deepcopy(vrfEntry)\n            refEntry = {\"refSwitchSerial\" : deviceSn, \"vrfEntry\" : refVrfEntry}\n            allOverlayVrfs[vrfEntry[\"vni\"]] = refEntry\n            continue\n\n        refEntry = allOverlayVrfs[vrfEntry[\"vni\"]]\n        refEntryTemplateParams = refEntry[\"vrfEntry\"][\"vrfTemplateParams\"]\n\n        # collect the 'tag' from other entries just in case there is a valid value elsewhere\n        if refEntryTemplateParams[\"tag\"] == \"\":\n            refEntryTemplateParams[\"tag\"] = vrfEntryTemplateParams[\"tag\"]\n\n        # collect other extension specific params from borders\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            if \"bgpPassword\" not in refEntryTemplateParams:\n                if \"bgpPassword\" in vrfEntryTemplateParams:\n                    refEntryTemplateParams[\"bgpPassword\"] = vrfEntryTemplateParams[\"bgpPassword\"]\n                    refEntryTemplateParams[\"bgpPasswordKeyType\"] = vrfEntryTemplateParams[\"bgpPasswordKeyType\"]\n\n            paramNameList = [\"advertiseDefaultRouteFlag\", \"advertiseHostRouteFlag\", \"configureStaticDefaultRouteFlag\",\n                                \"trmBGWMSiteEnabled\"]\n            for paramName in paramNameList:\n                if paramName in vrfEntry[\"vrfTemplateParams\"]:\n                    refEntryTemplateParams[paramName] = vrfEntryTemplateParams[paramName]\n\ndef ECLsetOverlayVrfReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayVrfs):\n    funcName = sys._getframe(0).f_code.co_name\n    # process all the VRFs found on this switch\n    for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n        vrfEntryTemplateParams = vrfEntry[\"vrfTemplateParams\"]\n        if vrfEntry[\"name\"] not in allOverlayVrfs:\n            formattedName = getFormattedSwitchName(deviceSn)\n            Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] is reference for VRF \"\n                \"vrfName [%s]. Params = [%s]\" % (OVERLAY_PREFIX, funcName, fabricName, switchOverlayInfo[\"switchRole\"], formattedName,\n                vrfEntry[\"name\"], vrfEntryTemplateParams))\n            refVrfEntry = copy.deepcopy(vrfEntry)\n            refEntry = {\"refSwitchSerial\" : deviceSn, \"vrfEntry\" : refVrfEntry}\n            allOverlayVrfs[vrfEntry[\"name\"]] = refEntry\n            continue\n\n        refEntry = allOverlayVrfs[vrfEntry[\"name\"]]\n        refEntryTemplateParams = refEntry[\"vrfEntry\"][\"vrfTemplateParams\"]\n\n        # collect the 'tag' from other entries just in case there is a valid value elsewhere\n        if refEntryTemplateParams[\"tag\"] == \"\":\n            refEntryTemplateParams[\"tag\"] = vrfEntryTemplateParams[\"tag\"]\n\n        # collect other extension specific params from borders\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            if \"bgpPassword\" not in refEntryTemplateParams:\n                if \"bgpPassword\" in vrfEntryTemplateParams:\n                    refEntryTemplateParams[\"bgpPassword\"] = vrfEntryTemplateParams[\"bgpPassword\"]\n                    refEntryTemplateParams[\"bgpPasswordKeyType\"] = vrfEntryTemplateParams[\"bgpPasswordKeyType\"]\n\n            paramNameList = [\"configureStaticDefaultRouteFlag\"]\n            for paramName in paramNameList:\n                if paramName in vrfEntry[\"vrfTemplateParams\"]:\n                    refEntryTemplateParams[paramName] = vrfEntryTemplateParams[paramName]\n                    \ndef generateNetworkName(deviceSn, refNetEntry, respObj):\n    refNetEntry[\"overlayNetName\"] = BROWNFIELD_NETWORK_NAME_FORMAT.replace(\"$$VNI$$\", \n        (\"%d\" % refNetEntry[\"vni\"])).replace(\"$$VLAN_ID$$\", (\"%d\" % refNetEntry[\"vlanId\"]))\n    lenName = len(refNetEntry[\"overlayNetName\"])\n    if lenName > MAX_TOPDOWN_NETWORK_NAME_LENGTH:\n        respObj.addErrorReport(\"Overlay Network Name\", \"Auto generated network name [%s] for VNI [%d] \"\n            \"is %d characters and exceeds the maximum %d characters limit. Please update the \"\n            \"\\'Overlay Network Name Format\\' fabric setting and retry \"\n            \"Recalculate & Deploy.\" % (refNetEntry[\"overlayNetName\"], lenName, MAX_TOPDOWN_NETWORK_NAME_LENGTH, \n                refNetEntry[\"vni\"]), deviceSn)\n        respObj.setFailureRetCode()\n    else:\n        Wrapper.print(\"generateNetworkName: Switch [%s] Network VNI [%s] Name [%s]\" % (deviceSn, refNetEntry[\"vni\"], refNetEntry[\"overlayNetName\"]))\n\ndef setOverlayNetReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayNets, globalOverlayInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    formattedName = getFormattedSwitchName(deviceSn)\n    \n    fabNamePrefix = (\"%s-\" % (fabricName))\n\n    # process all the networks found on this switch\n    for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n        netEntryTemplateParams = netEntry[\"netTemplateParams\"]\n        if netEntry[\"vni\"] not in allOverlayNets:\n            Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] is reference for Network \"\n                \"vni [%s]. Params = [%s]\" % (OVERLAY_PREFIX, funcName, fabricName, formattedName, switchOverlayInfo[\"switchRole\"],\n                netEntry[\"vni\"], netEntryTemplateParams))\n            refNetEntry = copy.deepcopy(netEntry)\n            refEntry = {\"refSwitchSerial\" : deviceSn, \"netEntry\" : refNetEntry}\n            allOverlayNets[netEntry[\"vni\"]] = refEntry\n\n            if \"cfgProfileName\" in refNetEntry:\n                # this is a config profile based BF import.. set the network name to be None (meaning it is same as the\n                # config profile name)\n                # the overlay name can change if the config profile names are different on different switches.. in which\n                # case we will auto generate the network name. This will be done later\n                refNetEntry[\"overlayNetName\"] = None\n\n                # check for a few patterns typical of DCNM 10.4(2) naming conventions and extract the correct network name\n                profileName = refNetEntry[\"cfgProfileName\"]\n                netNameSuffix = (\"-%s-%d\" % (\n                    (globalOverlayInfo[\"networkExtProfileName\"] if switchOverlayInfo[\"doOverlayExtn\"] == \"true\" else \n                        globalOverlayInfo[\"networkProfileName\"]), refNetEntry[\"vlanId\"]))\n                if profileName.startswith(fabNamePrefix) and profileName.endswith(netNameSuffix):\n                    refNetEntry[\"overlayNetName\"] = profileName[len(fabNamePrefix) : -len(netNameSuffix)]\n                else:\n                    if len(profileName) > MAX_TOPDOWN_NETWORK_NAME_LENGTH:\n                        generateNetworkName(deviceSn, refNetEntry, respObj)\n                    else:\n                        refNetEntry[\"overlayNetName\"] = profileName\n\n                Wrapper.print(\"%s %s: Fabric [%s] profileName [%s][%d] fabNamePrefix [%s] \"\n                    \"netNameSuffix [%s] overlayNetName [%s]\" % (OVERLAY_PREFIX, funcName, fabricName,\n                        profileName, len(profileName), fabNamePrefix, netNameSuffix, refNetEntry[\"overlayNetName\"]))\n            else:\n                # regular CLI based import.. need to auto generate the network name\n                generateNetworkName(deviceSn, refNetEntry, respObj)\n        \n        refEntry = allOverlayNets[netEntry[\"vni\"]]\n        refNetEntry = refEntry[\"netEntry\"]\n        refEntryTemplateParams = refNetEntry[\"netTemplateParams\"]\n\n        # process the 'enableL3OnBorder' setting. Set it to 'true' if atleast one switch has it \"true\"\n        if netEntryTemplateParams[\"enableL3OnBorder\"] == \"true\":\n            if refEntryTemplateParams[\"enableL3OnBorder\"] != \"true\":\n                Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] vni [%s] \"\n                    \"Setting enableL3OnBorder to true\" % (OVERLAY_PREFIX, funcName, fabricName, formattedName,\n                        switchOverlayInfo[\"switchRole\"], netEntry[\"vni\"]))\n                refEntryTemplateParams[\"enableL3OnBorder\"] = \"true\"\n\ndef ECLgenerateNetworkName(deviceSn, refNetEntry, respObj):\n    refNetEntry[\"overlayNetName\"] = BROWNFIELD_NETWORK_NAME_FORMAT.replace(\"$$VLAN_ID$$\", (\"%d\" % refNetEntry[\"vlanId\"]))\n    lenName = len(refNetEntry[\"overlayNetName\"])\n    if lenName > MAX_TOPDOWN_NETWORK_NAME_LENGTH:\n        respObj.addErrorReport(\"Network Name\", \"Auto generated network name [%s] for vlanId [%d] \"\n            \"is %d characters and exceeds the maximum %d characters limit. Please update the \"\n            \"\\' Network Name Format\\' fabric setting and retry \"\n            \"Recalculate & Deploy.\" % (refNetEntry[\"overlayNetName\"], lenName, MAX_TOPDOWN_NETWORK_NAME_LENGTH, \n                refNetEntry[\"vlanId\"]), deviceSn)\n        respObj.setFailureRetCode()\n    else:\n        Wrapper.print(\"generateNetworkName: Switch [%s] Network vlanId [%s] Name [%s]\" % (deviceSn, refNetEntry[\"vlanId\"], refNetEntry[\"overlayNetName\"]))\n\ndef get_fhrp_cmd_str(fhrp_proto, fhrp_group, protocol):\n    return_str = \"\"\n    if fhrp_proto == \"hsrp\" or fhrp_proto == \"vrrp\":\n        return_str = fhrp_proto + ' ' + fhrp_group\n        if protocol == \"IPv6\":\n            return_str += ' ipv6'\n    else:\n        #vrrpv3\n        return_str = fhrp_proto + ' ' + fhrp_group\n        if protocol == \"IPv4\":\n            return_str += ' address-family ipv4'\n        else:    \n            return_str += ' address-family ipv6'\n    return return_str\n    \ndef ECLsetOverlayNetReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayNets, globalOverlayInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    formattedName = getFormattedSwitchName(deviceSn)\n    \n    fabNamePrefix = (\"%s-\" % (fabricName))\n\n    # process all the networks found on this switch\n    for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n        netEntryTemplateParams = netEntry[\"netTemplateParams\"]\n        replaceRefEntry = False\n\n        if netEntry[\"vlanId\"] not in allOverlayNets:\n            Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] is reference for Network \"\n                \"vlanId [%s]. Params = [%s]\" % (OVERLAY_PREFIX, funcName, fabricName, formattedName, switchOverlayInfo[\"switchRole\"],\n                netEntry[\"vlanId\"], netEntryTemplateParams))\n            refNetEntry = copy.deepcopy(netEntry)\n            refEntry = {\"refSwitchSerial\" : deviceSn, \"netEntry\" : refNetEntry}\n            allOverlayNets[netEntry[\"vlanId\"]] = refEntry\n\n            # regular CLI based import.. need to auto generate the network name\n            ECLgenerateNetworkName(deviceSn, refNetEntry, respObj)\n        else:\n            refEntry = allOverlayNets[netEntry[\"vlanId\"]]\n            refNetEntry = refEntry[\"netEntry\"]\n            refEntryTemplateParams = refNetEntry[\"netTemplateParams\"]\n        \n            forceIgnorePriority = False\n            if (refNetEntry and refEntryTemplateParams[\"activePriority\"] and  \n                refEntryTemplateParams[\"activePriority\"] == netEntry[\"netTemplateParams\"][\"activePriority\"]):\n                Wrapper.print(\"%s %s: netEntry[%s] refNetEntry[%s]\" % (funcName, deviceSn, netEntry, refNetEntry))\n                forceIgnorePriority = True\n            #for an agg vPC pair check if ignorePriority mismatch is present \n            if (forceIgnorePriority or \n                (refEntryTemplateParams[\"ignorePriority\"] == \"true\" and \n                (netEntryTemplateParams[\"ignorePriority\"] == \"false\" and \n                 netEntryTemplateParams[\"activePriority\"]))):\n                netEntryTemplateParams[\"ignorePriority\"] = \"true\"\n                #this means that for netEntryParams, v4/v6 fhrp priority cmds need to go to freeform\n                curr_netEntry_freeform = netEntry[\"freeformCfg\"]\n                #Construct svi, fhrp parent cmds before inserting priority cmd\n                svi_cmd = Util.newLine() + 'interface ' + 'Vlan' + str(netEntry[\"vlanId\"])\n                v4_cfg = None\n                v6_cfg = None\n                if netEntryTemplateParams['GROUP']:\n                    fhrp_cmd = Util.newLine() + '  ' + get_fhrp_cmd_str(FHRP_PROTOCOL, netEntryTemplateParams['GROUP'], \"IPv4\")\n                    fhrp_priority_cmd = Util.newLine() + '    priority ' + netEntryTemplateParams[\"activePriority\"]\n                    v4_cfg = svi_cmd + fhrp_cmd + fhrp_priority_cmd\n                if netEntryTemplateParams['GROUP_V6']:\n                    fhrp_cmd = Util.newLine() + '  ' + get_fhrp_cmd_str(FHRP_PROTOCOL, netEntryTemplateParams['GROUP_V6'], \"IPv6\")\n                    fhrp_priority_cmd = Util.newLine() + '    priority ' + netEntryTemplateParams[\"activePriority\"]\n                    if v4_cfg:\n                        v6_cfg = fhrp_cmd + fhrp_priority_cmd\n                    else:\n                        v6_cfg = svi_cmd + fhrp_cmd + fhrp_priority_cmd\n                if v4_cfg:   \n                    netEntry[\"freeformCfg\"] = netEntry[\"freeformCfg\"] + v4_cfg\n                if v6_cfg:   \n                    netEntry[\"freeformCfg\"] = netEntry[\"freeformCfg\"] + v6_cfg\n\n            if (forceIgnorePriority or \n                (netEntryTemplateParams[\"ignorePriority\"] == \"true\" and \n                (refEntryTemplateParams[\"ignorePriority\"] == \"false\" and \n                 refEntryTemplateParams[\"activePriority\"]))):\n                refEntryTemplateParams[\"ignorePriority\"] = \"true\"\n                #this means that for netEntryParams, v4/v6 fhrp priority cmds need to go to freeform\n                curr_refNetEntry_freeform = refNetEntry[\"freeformCfg\"]\n                #Construct svi, fhrp parent cmds before inserting priority cmd\n                svi_cmd = Util.newLine() + 'interface ' + 'Vlan' + str(refNetEntry[\"vlanId\"])\n                v4_cfg = None\n                v6_cfg = None\n                if refEntryTemplateParams['GROUP']:\n                    fhrp_cmd = Util.newLine() + '  ' + get_fhrp_cmd_str(FHRP_PROTOCOL, refEntryTemplateParams['GROUP'], \"IPv4\")\n                    fhrp_priority_cmd = Util.newLine() + '    priority ' + refEntryTemplateParams[\"activePriority\"]\n                    v4_cfg = svi_cmd + fhrp_cmd + fhrp_priority_cmd\n                if refEntryTemplateParams['GROUP_V6']:\n                    fhrp_cmd = Util.newLine() + '  ' + get_fhrp_cmd_str(FHRP_PROTOCOL, refEntryTemplateParams['GROUP_V6'], \"IPv6\")\n                    fhrp_priority_cmd = Util.newLine() + '    priority ' + refEntryTemplateParams[\"activePriority\"]\n                    if v4_cfg:\n                        v6_cfg = fhrp_cmd + fhrp_priority_cmd\n                    else:\n                        v6_cfg = svi_cmd + fhrp_cmd + fhrp_priority_cmd\n                if v4_cfg:   \n                    refNetEntry[\"freeformCfg\"] = refNetEntry[\"freeformCfg\"] + v4_cfg\n                if v6_cfg:   \n                    refNetEntry[\"freeformCfg\"] = refNetEntry[\"freeformCfg\"] + v6_cfg\n\n                refDeviceSN = refEntry[\"refSwitchSerial\"]\n                refSwitchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][refDeviceSN]\n                refSwitchOverlayInfoNetworks = refSwitchOverlayInfo[\"NETWORKS_BY_ID\"]\n                refSwitchOverlayInfoNetworks[netEntry[\"vlanId\"]] = refEntry[\"netEntry\"]\n\n            #Wrapper.print(\"TEST: netEntryParams %s refEntryParams %s\" %(netEntryTemplateParams, refEntryTemplateParams) )\n            #Even if there is a refEntry present for the network, check the FHRP priority. \n            #Ensure refEntry always corresponds to the switch that has the highest priority\n            #Default hsrp priority is 100\n            #Check that ignorePriority has not been set to true\n            if refEntryTemplateParams['ignorePriority'] != \"true\":\n                if netEntryTemplateParams[\"activePriority\"] and refEntryTemplateParams[\"activePriority\"]:\n                    if int(refEntryTemplateParams[\"activePriority\"]) < int(netEntryTemplateParams[\"activePriority\"]):\n                        replaceRefEntry = True\n                elif netEntryTemplateParams[\"activePriority\"] and int(netEntryTemplateParams[\"activePriority\"]) > 100:\n                    replaceRefEntry = True\n                elif refEntryTemplateParams[\"activePriority\"] and int(refEntryTemplateParams[\"activePriority\"]) < 100:\n                    replaceRefEntry = True\n\n        if replaceRefEntry:\n            Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] is *NEW* reference for Network \"\n                \"vlanId [%s]. Params = [%s]\" % (OVERLAY_PREFIX, funcName, fabricName, formattedName, switchOverlayInfo[\"switchRole\"],\n                netEntry[\"vlanId\"], netEntryTemplateParams))\n            #netEntry should be the new reference network Entry\n            refNetEntry = copy.deepcopy(netEntry)\n            refEntry = {\"refSwitchSerial\" : deviceSn, \"netEntry\" : refNetEntry}\n            allOverlayNets[netEntry[\"vlanId\"]] = refEntry            \n\n            # regular CLI based import.. need to auto generate the network name\n            ECLgenerateNetworkName(deviceSn, refNetEntry, respObj)    \n            \n        refEntry = allOverlayNets[netEntry[\"vlanId\"]]\n        refNetEntry = refEntry[\"netEntry\"]\n        refEntryTemplateParams = refNetEntry[\"netTemplateParams\"]\n\n                \ndef handleOverlayMigrationInt(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    switchesNeedingOverlayMigration = []\n    borderSwitches = []\n    nonBorderSwitches = []\n    Wrapper.print(\"%s %s: Start - FABRIC [%s] OVERLAY_MODE [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, OVERLAY_MODE))\n\n    # at this point the underlay migration is complete for all switches and we are ready for the overlay migration\n    for deviceSn in devices:\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n\n        # skip spine role switches since they do not have any overlays\n        if switchDict[\"switchRole\"] == \"spine\":\n            continue\n\n        if not isSwitchInOverlayMigration(deviceSn):\n            continue\n        \n        # retrieve the switch overlay info from the file stored during the underlay migration\n        Wrapper.print(\"%s: Switch [%s] - Loading overlay info from file [%s]\" % (funcName, \n            switchDict[\"fmtName\"], switchDict[\"overlayInfoFileName\"]))\n        switchOverlayInfo = Util.exe(getJSONFileContents(switchDict[\"overlayInfoFileName\"]))\n\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            borderSwitches.append(deviceSn)\n        else:\n            nonBorderSwitches.append(deviceSn)\n\n    # make the list such that all the border switches are at the end\n    switchesNeedingOverlayMigration = nonBorderSwitches + borderSwitches\n\n    # dictionary of all VRFs in the fabric. Key is the VRF vni (string)\n    allOverlayVrfs = {}\n\n    # dictionary of all networks in the fabric. Key is the network vni (integer)\n    allOverlayNets = {}\n\n    # process all the networks/vrf on the switches\n    for deviceSn in switchesNeedingOverlayMigration:\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n        switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n\n        Wrapper.print(\"%s: Switch [%s] Role [%s] collecting (%d) Networks/ (%d) Vrfs\" % (funcName,\n            switchDict[\"fmtName\"], switchDict[\"switchRole\"], len(switchOverlayInfo[\"NETWORKS_BY_ID\"]), \n            len(switchOverlayInfo[\"VRFS_BY_ID\"])))\n\n        setOverlayVrfReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayVrfs)\n        setOverlayNetReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayNets, globalOverlayInfo, respObj)\n\n    profInfo = globalOverlayInfo['cfgProfileInfo']\n    if not profInfo[\"hasCfgProfile\"]:\n        # do some validations\n        #   - the vrfVlanName, maxBgpPaths, maxIbgpPaths must be the same on all switches\n        #   - the network must be L2 or L3 on every leaf switch (no missing SVI)\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 70, \"Brownfield - Checking Overlay information consistency\") \n        for deviceSn in switchesNeedingOverlayMigration:\n            switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n            switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n\n            # check all the vrf entries for this switch with the vrf entry we plan to use to create\n            Wrapper.print(\"%s %s: Validating VRF params for switch [%s]\" % (OVERLAY_PREFIX, funcName, switchDict[\"fmtName\"]))\n            for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n                refVrfEntry = allOverlayVrfs[vrfEntry[\"vni\"]]\n                if refVrfEntry[\"refSwitchSerial\"] == deviceSn:\n                    continue\n                refVrfTemplParams = refVrfEntry[\"vrfEntry\"][\"vrfTemplateParams\"]\n                allMatch = True\n                for param in refVrfTemplParams:\n                    if param == \"vrfVlanId\":\n                        # the vlan ids could be different on different switches\n                        continue\n                    if param in vrfEntry[\"vrfTemplateParams\"]:\n                        if not checkOverlayParam(refVrfEntry[\"vrfEntry\"][\"name\"], param, refVrfEntry[\"refSwitchSerial\"], \n                            deviceSn, refVrfTemplParams[param], vrfEntry[\"vrfTemplateParams\"][param], respObj):\n                            allMatch = False\n                if not allMatch:\n                    Wrapper.print(\"%s: Fabric [%s] VRF param mismatch: Switch [%s] Ref [%s] - Params [%s] refVrfTemplParams [%s]\" %\n                        (funcName, FABRIC_NAME, switchDict[\"fmtName\"], refVrfEntry[\"refSwitchSerial\"], vrfEntry[\"vrfTemplateParams\"], refVrfTemplParams))\n\n            # check all the network entries for this switch with the network entry we plan to use to create\n            Wrapper.print(\"%s %s: Validating Network params for switch [%s]\" % (OVERLAY_PREFIX, funcName, switchDict[\"fmtName\"]))\n            for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n                refNetEntry = allOverlayNets[netEntry[\"vni\"]]\n                if refNetEntry[\"refSwitchSerial\"] == deviceSn:\n                    continue\n                refNetTemplParams = refNetEntry[\"netEntry\"][\"netTemplateParams\"]\n                allMatch = True\n                for param in refNetTemplParams:\n                    if (param == \"vlanId\") or (param == \"enableL3OnBorder\"):\n                        continue\n                    if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n                        if (param in [\"isLayer2Only\"]):\n                            # do not check this on the border\n                            continue\n\n                        # skip some additional params for the case where the SVI does not exist on the\n                        # borders, i.e, 'enableL3OnBorder' is false\n                        if netEntry[\"netTemplateParams\"]['enableL3OnBorder'] != \"true\":\n                            if (param in [\"gatewayIpAddress\", \"gatewayIpV6Address\", \"vrfName\", \"tag\", NET_PROFILE_DHCP_SERVERS_VAR]):\n                                continue\n                    if param in netEntry[\"netTemplateParams\"]:\n                        if not checkOverlayParam(refNetEntry[\"netEntry\"][\"overlayNetName\"], param, refNetEntry[\"refSwitchSerial\"], \n                            deviceSn, refNetTemplParams[param], netEntry[\"netTemplateParams\"][param], respObj):\n                            allMatch = False\n\n                if not allMatch:\n                    Wrapper.print(\"%s: Fabric [%s] Net param mismatch: Switch [%s] Ref [%s] - Params [%s] refNetTemplParams [%s]\" %\n                        (funcName, FABRIC_NAME, switchDict[\"fmtName\"], refNetEntry[\"refSwitchSerial\"], netEntry[\"netTemplateParams\"], refNetTemplParams))\n\n    # do not proceed if there are errors\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    # process the attachments\n    for deviceSn in switchesNeedingOverlayMigration:\n        switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n        processOverlayAttachments(deviceSn, switchOverlayInfo, globalOverlayInfo, allOverlayNets)\n\n    cleanupOverlayOrigClis = False\n    if ((OVERLAY_MODE == \"config-profile\") and (not profInfo[\"hasCfgProfile\"])):\n        cleanupOverlayOrigClis = (globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"] == \"true\")\n    Wrapper.print(\"%s: Fabric [%s] cleanupOverlayOrigClis [%r] hasCfgProfile [%r]\" %\n                    (funcName, FABRIC_NAME, cleanupOverlayOrigClis, profInfo[\"hasCfgProfile\"]))\n    isFailure = False\n    \n    sortedVrfVnis = sorted(allOverlayVrfs.keys())\n    sortedNetVnis = sorted(allOverlayNets.keys())\n\n    # create the vrfs if they do not exist\n    progressBase = 60\n    numEntries = len(sortedVrfVnis)\n    numProcessed = 0\n    Wrapper.print(\"%s %s: FABRIC [%s] VRF Creations [Total = %d]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries))\n    for vrfVni in sortedVrfVnis:\n        numProcessed += 1\n        progress = progressBase + int(float(numProcessed)/float(numEntries) * 5)\n\n        vrfEntry = allOverlayVrfs[vrfVni][\"vrfEntry\"]\n\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Creating VRF [%s/%s]\" % (numProcessed, numEntries, vrfVni, vrfEntry[\"name\"])))\n\n        Wrapper.print(\"%s: FABRIC [%s]: [%d of %d] Creating TD VRF [%s/%s]. Params [%s]\" % (funcName, \n            FABRIC_NAME, numProcessed, numEntries, vrfVni, vrfEntry[\"name\"], vrfEntry[\"vrfTemplateParams\"]))\n\n        # Check the TD DB to see if the VRF has been created already\n        tdVrf = Util.exe(TD.getVrfById(FABRIC_NAME, int(vrfVni)))\n        if tdVrf:\n            # entry exists...\n            Wrapper.print(\"%s: Fabric [%s] Skip Creating Existing TD VRF [%s/%s]\" %\n                            (funcName, FABRIC_NAME, vrfVni, vrfEntry[\"name\"]))\n            continue\n\n        tdVrf = LanVRF()\n        tdVrf.setFabric(FABRIC_NAME)\n        tdVrf.setVrfId(int(vrfVni))\n        tdVrf.setVrfName(vrfEntry[\"name\"])\n        tdVrf.setVrfTemplate(globalOverlayInfo[\"vrfProfileName\"])\n        tdVrf.setVrfExtensionTemplate(globalOverlayInfo[\"vrfExtProfileName\"])\n        tdVrf.setVrfTemplateConfig(json.dumps(vrfEntry[\"vrfTemplateParams\"]))\n\n        # create the VRF\n        newResp = TD.createOrUpdateVrf(FABRIC_NAME, tdVrf, False)\n        if not newResp.isRetCodeSuccess():\n            isFailure = True\n            Util.processRespObj(respObj, newResp)\n    \n    if not isFailure:\n        # create the networks if they do not exist\n        progressBase = 65\n        numEntries = len(sortedNetVnis)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: FABRIC [%s] Network Creations [Total = %d]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries))\n        for netVni in sortedNetVnis:\n            numProcessed += 1\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 5)\n\n            netEntry = allOverlayNets[netVni][\"netEntry\"]\n            netName = netEntry[\"overlayNetName\"] if netEntry[\"overlayNetName\"] else netEntry[\"cfgProfileName\"]\n\n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Creating Network [%s/%s]\" % (numProcessed, numEntries, netVni, netName)))\n\n            Wrapper.print(\"%s: FABRIC [%s] [%d of %d] Creating TD Network [%s/%s] Params [%s]\" % (funcName,\n                FABRIC_NAME, numProcessed, numEntries, netVni, netName, netEntry[\"netTemplateParams\"]))\n            \n            # Check the TD DB to see if the network has been created already\n            updateNetwork = False\n            tdNet = Util.exe(TD.getNetworkById(FABRIC_NAME, int(netVni)))\n            if tdNet:\n                Wrapper.print(\"%s: Fabric [%s] Skip Creating Existing TD Network [%s/%s]\" % (funcName, FABRIC_NAME, netVni, netName))\n                continue\n\n            tdNet = LanNetwork()\n            tdNet.setFabric(FABRIC_NAME)\n            tdNet.setNetworkName(netName)\n            tdNet.setNetworkId(int(netVni))\n            tdNet.setVrf(netEntry[\"vrfName\"])\n            tdNet.setNetworkTemplate(globalOverlayInfo[\"networkProfileName\"])\n            tdNet.setNetworkExtensionTemplate(globalOverlayInfo[\"networkExtProfileName\"])\n            tdNet.setNetworkTemplateConfig(json.dumps(netEntry[\"netTemplateParams\"]))\n\n            # create the network\n            newResp = TD.createOrUpdateNetwork(FABRIC_NAME, tdNet, False)\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Util.processRespObj(respObj, newResp)\n    \n    if not isFailure:\n        # do the overlay VRF attach as needed\n        progressBase = 70\n        numEntries = len(sortedVrfVnis)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: Start - FABRIC [%s] Attaching VRFs [Total = %d]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries))\n        for vrfVniId in sortedVrfVnis:\n            numProcessed += 1\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 10)\n\n            vrfAttach = globalOverlayInfo[\"VRF_ATTACH\"][vrfVniId]\n            vrfName = vrfAttach.getVrfName()\n\n            Wrapper.print(\"%s %s: Fabric [%s] [%d of %d] Attaching VRF [%s/%s] [Attach Count = %d] - Start\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME,\n                numProcessed, numEntries, vrfVniId, vrfName, len(vrfAttach.getLanAttachList())))\n\n            for attachEntry in vrfAttach.getLanAttachList():\n                switchDict = globalOverlayInfo[\"SWITCH_INFO\"][attachEntry.getSerialNumber()]\n                Wrapper.print(\"-----[%s], Name [%s/%s], Vlan [%d], ExtensionVals [%s] InstanceVals [%s] FF [%s]\" % (switchDict[\"fmtName\"],\n                    attachEntry.getVrfName(), attachEntry.getProfileName(), attachEntry.getVlan(), attachEntry.getExtensionValues(),\n                    attachEntry.getInstanceValues(), attachEntry.getFreeformConfig()))\n\n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Attaching VRF [%s/%s]\" % (numProcessed, numEntries, vrfVniId, vrfName)))\n\n            newResp = TD.attachVrf(FABRIC_NAME, vrfAttach)\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Wrapper.print(\"%s: Fabric [%s] Attaching VRF [%s/%s] - Failed\" % (funcName, FABRIC_NAME, vrfVniId, vrfName))\n                Util.processRespObj(respObj, newResp)\n                continue\n\n            # there could still be a failure on a success return\n            respStr = newResp.getValue()\n            # check if the response contains \"invalid\" references which indicates some issue occured\n            if \"failed\" in respStr.lower():\n                isFailure = True\n                # we have a failure\n                Wrapper.print(\"%s: Fabric [%s] Attaching VRF [%s/%s] - Failed with response [%s]\" %\n                    (funcName, FABRIC_NAME, vrfVniId, vrfName, respStr))\n                respObj.addErrorReport(funcName,\n                    \"Error attaching overlay VRF [%s]. Response = [%s]\" % (vrfName, respStr))\n                respObj.setFailureRetCode()\n                continue\n\n            if ((not isFailure) and cleanupOverlayOrigClis):\n                # create the PTI to unapply the original CLIs configs present on the switch\n                Wrapper.print(\"%s: FABRIC [%s] Cleaning up original VRF [%s/%s] CLIs\" % (funcName,\n                    FABRIC_NAME, vrfVniId, vrfName))\n                for attachEntry in vrfAttach.getLanAttachList():\n                    deviceSn = attachEntry.getSerialNumber()\n                    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n                    #Wrapper.print(\"%s: Fabric [%s] Cleanup VRF [%s,%s] - Start\" % \n                    #    (funcName, FABRIC_NAME, vrfVniId, vrfName))\n                    cfg = getSwitchOverlayVrfGeneratedCfg(vrfName, globalOverlayInfo, switchOverlayInfo)\n                    if cfg != \"\":\n                        # this should delete the old policy if any\n                        utilObj = Util()\n                        pti = utilObj.exeVal(PTIWrapper.createOrUpdate(deviceSn, \"SWITCH\", \"SWITCH\", \"CONFIG_PROFILE\",\n                            vrfName, \"VRF_OVERLAY_MIGRATION\", TOPDOWN_VRF_PROFILE_FREEFORM_PRIO,\n                            \"switch_freeform_config\", {\"DONT_EXPUNGE\" : \"\", \"CONF\" : cfg}))\n\n                        # markDelete it for CC to unapply the commands\n                        PTIWrapper.markDeleteInstance(pti.getPolicyId())\n                    #Wrapper.print(\"%s: Fabric [%s] Cleanup VRF [%s,%s] - Done\" % \n                    #    (funcName, FABRIC_NAME, vrfVniId, vrfName))\n\n        Wrapper.print(\"%s %s: End - FABRIC [%s] Attaching VRFs\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n    if not isFailure:\n        # do the overlay network attach in batches\n        batchInfo = {}\n        count = 0\n        batchIndex = 0\n        netAttachList = []\n        vniList = []\n        for vniId in sortedNetVnis:\n            vniStr = str(vniId)\n            netAttachList.append(globalOverlayInfo[\"NETWORK_ATTACH\"][vniStr])\n            vniList.append(vniStr)\n            count += 1\n            if count >= BF_NETWORK_ATTACH_BATCH_SIZE:\n                batchIndex += 1\n                batchInfo[batchIndex] = {\"vniList\": vniList, \"netAttachList\" : netAttachList}\n                # Wrapper.print(\"%s %s: Added Batches %d. Num %d\" % (OVERLAY_PREFIX, funcName, batchIndex, len(netAttachList)))\n\n                # start a new batch\n                count = 0\n                netAttachList = []\n                vniList = []\n\n        if len(netAttachList):\n            batchIndex += 1\n            batchInfo[batchIndex] = {\"vniList\": vniList, \"netAttachList\" : netAttachList}\n            # Wrapper.print(\"%s %s: Added Batches %d. Num %d\" % (OVERLAY_PREFIX, funcName, batchIndex, len(netAttachList)))\n        netAttachList = None\n        vniList = None\n\n        sortedBatchIndices = sorted(batchInfo)\n        # range is 80 - 95\n        progressBase = 80\n        numEntries = len(sortedNetVnis)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: Start - Fabric [%s] Attaching Networks [Total Entries %d, Batches = %d]\" % (OVERLAY_PREFIX, funcName,\n                                                FABRIC_NAME, numEntries, len(sortedBatchIndices)))\n\n        for index in sortedBatchIndices:\n            netAttachList = batchInfo[index][\"netAttachList\"]\n\n            numProcessed += len(netAttachList)\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 15)\n\n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Attaching Networks\" % (numProcessed, numEntries)))\n            \n            Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - Start - VNIs (%d) %s\" % (OVERLAY_PREFIX, funcName,\n                                FABRIC_NAME, len(batchInfo[index][\"vniList\"]), batchInfo[index][\"vniList\"]))\n\n            # print the attachment details for this batch\n            Wrapper.print(\"%s %s: Fabric [%s] ===  Network Attachment Entries - Start ===\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n            for netAttach in netAttachList:\n                Wrapper.print(\"%s %s: Fabric [%s] Network [%s] Num Attachments [%d]\" % (OVERLAY_PREFIX, funcName,\n                                    FABRIC_NAME, netAttach.getNetworkName(), len(netAttach.getLanAttachList())))\n\n                printNetAttachList(FABRIC_NAME, globalOverlayInfo, netAttach.getLanAttachList())\n                \n            Wrapper.print(\"%s %s: Fabric [%s] ===  Network Attachment Entries - End ===\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n            newResp = TD.attachNetworks(FABRIC_NAME, netAttachList, False)\n            Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - End - isSuccess [%r]\" % (OVERLAY_PREFIX, funcName,\n                                FABRIC_NAME, newResp.isRetCodeSuccess()))\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Wrapper.print(\"%s: Fabric [%s] Attaching network failed for VNIs %s\" % (funcName, fabricName, batchInfo[index][\"vniList\"]))\n                Util.processRespObj(respObj, newResp)\n                continue\n\n            # check the return value\n            respDict = json.loads(newResp.getValue())\n            # Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - VNIs %s\" % (OVERLAY_PREFIX, funcName,\n            #                     FABRIC_NAME, batchInfo[index][\"vniList\"]))\n            for netIdKey in respDict:\n                Wrapper.print(\"Entry: [%-30s] -> [%s]\" % (netIdKey, respDict[netIdKey]))\n                statusStr = str(respDict[netIdKey])\n                if not statusStr.lower().startswith(\"success\"):\n                    isFailure = True\n                    msg = (\"%s: Fabric [%s] Network attachment [%s] failed with reason [%s]\" % (funcName,\n                                                fabricName, netIdKey, respDict[netIdKey]))\n                    Wrapper.print(msg)\n                    respObj.addErrorReport(getFabErrEntity(funcName, netIdKey+\":netAttach\"), msg)\n                    respObj.setFailureRetCode()\n                    continue\n\n            if ((not isFailure) and cleanupOverlayOrigClis):\n                # create the PTI to unapply the original CLI configs present on the switch\n                for vniStr in batchInfo[index][\"vniList\"]:\n                    netAttach = globalOverlayInfo[\"NETWORK_ATTACH\"][vniStr]\n                    netName = netAttach.getNetworkName()\n\n                    Wrapper.print(\"%s: FABRIC [%s] Cleaning up original Network [%s/%s] CLIs - Start\" % (funcName, FABRIC_NAME, vniStr, netName))\n                    for attachRec in netAttach.getLanAttachList():\n                        swiSerial = attachRec.getSerialNumber()                    \n                        switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][swiSerial]\n                        #Wrapper.print(\"%s: Fabric [%s] Cleanup network [%s/%s] - Start\" % \n                        #    (funcName, FABRIC_NAME, vniStr, netName))\n                        cfg = getSwitchOverlayNetGeneratedCfg(vniStr, globalOverlayInfo, switchOverlayInfo)\n                        if cfg != \"\":\n                            # this should delete the old policy if any\n                            utilObj = Util()\n                            pti = utilObj.exeVal(PTIWrapper.createOrUpdate(swiSerial, \"SWITCH\", \"SWITCH\", \"CONFIG_PROFILE\",\n                                netAttach.getNetworkName(), \"NETWORK_OVERLAY_MIGRATION\", TOPDOWN_NETWORK_PROFILE_FREEFORM_PRIO,\n                                \"switch_freeform_config\", {\"DONT_EXPUNGE\" : \"\", \"CONF\" : cfg}))\n\n                            # markDelete it for CC to unapply the commands\n                            PTIWrapper.markDeleteInstance(pti.getPolicyId())\n                        #Wrapper.print(\"%s: Fabric [%s] Cleanup network [%s,%s] - End\" % \n                        #    (funcName, FABRIC_NAME, vniStr, netName))\n                    Wrapper.print(\"%s: FABRIC [%s] Cleaning up original Network [%s/%s] CLIs - End\" % (funcName, FABRIC_NAME, vniStr, netName))\n\n        Wrapper.print(\"%s %s: End - Fabric [%s] Attaching Networks\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n    if not isFailure:\n        handleServicesMigration(fabricName, globalOverlayInfo, respObj, gVarDictObj)\n\n    Wrapper.print(\"%s %s: End - FABRIC [%s]. retcode [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, respObj.isRetCodeSuccess()))\n    return respObj\n\ndef getLastIPv4InSubnet(rpVniEntry):\n    ip, mask = getIPAndPrefix(rpVniEntry[\"ipv4\"])\n    #subnet, ignore = getIPAndPrefix(rpVniEntry[\"subnet\"])\n\n    ipInt = Util.IP2Int(ip)\n    #subnetInt = Util.IP2Int(subnet)\n    bcastInt =  (~(0xFFFFFFFF << (32 - int(mask)))) & 0xFFFFFFFF\n\n    lastIP = (ipInt | bcastInt) - 1\n    #Wrapper.print(\"getLastIPv4InSubnet: bcastInt [%0X] ipInt [%0X] subnetInt [%0X] lastIP [%0X]\" % (bcastInt, \n    #    ipInt, subnetInt, lastIP))\n    while True:\n        if lastIP != ipInt:\n            break\n        lastIP -= 1\n\n    ipStr = Util.Int2IP(lastIP) \n    #Wrapper.print(\"getLastIPv4InSubnet: ipStr [%s]\" % (ipStr))\n    return ipStr\n\ndef handleServicesMigration(fabricName, globalOverlayInfo, respObj, gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n\n    Wrapper.print(\"%s %s: Start - FABRIC [%s]\" % (OVERLAY_PREFIX, funcName, fabricName))\n\n    if not servicesInfo:\n        Wrapper.print(\"%s %s: End - FABRIC [%s] - No Services found\" % (OVERLAY_PREFIX, funcName, fabricName))\n        return\n\n    # create the services related entries\n    progressBase = 95\n    numEntries = len(servicesInfo[\"serviceNodes\"])\n    numProcessed = 0\n    for srvcNodeName in sorted(servicesInfo[\"serviceNodes\"]):\n        srvcEntry = servicesInfo[\"serviceNodes\"][srvcNodeName]\n\n        numProcessed += 1\n        progress = progressBase + int(float(numProcessed)/float(numEntries) * 5)\n\n        extName = srvcEntry[\"extFabricName\"]\n        swSerial = srvcEntry[\"swSerial\"]\n        swIntf = srvcEntry[\"swIntf\"]\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][swSerial]\n\n        Wrapper.print(\"%s: Processing Service Node [%s] on switch [%s]\" % (funcName, srvcNodeName, switchDict[\"fmtName\"]))\n\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n            (\"Brownfield - %d of %d - Processing Service Node [%s]\" % (numProcessed, numEntries, srvcNodeName)))\n\n        linkTemplateName = None\n        linkTemplateNvPairs = None\n        pti = getCurrentIntfPyPti(swSerial, swIntf)\n        if pti:\n            tmplName = pti.getTemplateName()\n            nvPairs = pti.getNvPairs()\n            Wrapper.print(\"%s: SN [%s] Intf [%s] Template [%s]\" % (funcName, srvcNodeName, swIntf, tmplName))\n\n            linkTemplateNvPairs = {\"SOURCE_FABRIC_NAME\" : fabricName,\n                                   \"DEST_FABRIC_NAME\" : extName,\n                                   \"SOURCE_SERIAL_NUMBER\" : swSerial,\n                                   \"DEST_SERIAL_NUMBER\" : (\"%s-%s\" % (srvcNodeName, extName)),\n                                   \"SOURCE_SWITCH_NAME\" : switchDict[\"hostName\"],\n                                   \"DEST_SWITCH_NAME\" : srvcNodeName,\n                                   \"SOURCE_IF_NAME\" : swIntf,\n                                   \"DEST_IF_NAME\" : srvcEntry[\"snIntf\"],\n                                   \"BPDUGUARD_ENABLED\" : nvPairs[\"BPDUGUARD_ENABLED\"],\n                                   \"MTU\" : nvPairs[\"MTU\"],\n                                   \"SPEED\" : nvPairs[\"SPEED\"],\n                                   \"PEER1_DESC\" : nvPairs[\"DESC\"],\n                                   \"PEER1_CONF\" : nvPairs[\"CONF\"],\n                                   \"ADMIN_STATE\" : nvPairs[\"ADMIN_STATE\"]\n                                   }\n\n            if \"int_vpc_trunk_po_11_1\" == tmplName:\n                #linkTemplateName = \"service_link_vpc\"\n                linkTemplateNvPairs = None\n                swIntf = nvPairs[\"PRIMARY_INTF\"]    # the vPCx interface\n                # comma separated string of vpc serials\n                swSerial = (\"%s,%s\" % (swSerial, srvcEntry[\"peerSwSerial\"]))\n                #linkTemplateNvPairs[\"SOURCE_IF_NAME\"] = swIntf\n                #linkTemplateNvPairs[\"SOURCE_SERIAL_NUMBER\"] = swSerial\n                #linkTemplateNvPairs[\"PC_MODE\"] = nvPairs[\"PC_MODE\"]\n            elif \"int_port_channel_trunk_host\" == tmplName:\n                linkTemplateName = \"service_link_port_channel_trunk\"\n                linkTemplateNvPairs[\"PC_MODE\"] = nvPairs[\"PC_MODE\"]\n            elif \"int_trunk_host\" == tmplName:\n                linkTemplateName = \"service_link_trunk\"\n                linkTemplateNvPairs[\"PORTTYPE_FAST_ENABLED\"] = nvPairs[\"PORTTYPE_FAST_ENABLED\"]\n            else:\n                linkTemplateNvPairs = None\n                Wrapper.print(\"**** %s: SN [%s] Intf [%s] Unexpected PTI\" % (funcName, srvcNodeName, swIntf))\n                continue\n        else:\n            linkTemplateNvPairs = None\n            Wrapper.print(\"%s: SN [%s] Intf [%s] PTI does not exist\" % (funcName, srvcNodeName, swIntf))\n\n        if srvcEntry[\"serviceNodeType\"] == \"fw\":\n            nodeType = ES.NodeType.Firewall\n        elif srvcEntry[\"serviceNodeType\"] == \"lb\":\n            nodeType = ES.NodeType.ADC\n        else:\n            nodeType = ES.NodeType.VNF\n\n        Wrapper.print(\"%s: Creating Service Node [%s] Serial [%s] Intf [%s]\" % (funcName, srvcNodeName, swSerial, swIntf))\n\n        Util.exe(ES.addServiceNode(extName, srvcNodeName, nodeType,\n            srvcEntry[\"snIntf\"], swSerial, swIntf, linkTemplateName, linkTemplateNvPairs))\n\n        # create the route peers\n        for routePeerName in srvcEntry[\"routePeers\"]:\n            rtPeerEntry = srvcEntry[\"routePeers\"][routePeerName]\n\n            if rtPeerEntry[\"isInter\"]:\n                useDefNextHop = False\n            else:\n                useDefNextHop = True if (len(rtPeerEntry[\"servicePolicies\"]) == 0) else False\n\n            Wrapper.print(\"%s: SN [%s] Processing Route Peer [%s] useDefNextHop [%r] rtPeerEntry %s\" % (funcName, srvcNodeName,\n                routePeerName, useDefNextHop, rtPeerEntry))\n\n            rpNets = rtPeerEntry[\"nets\"]\n            nextHopIp = \"\"\n            revNextHopIp = \"\"\n            if nodeType == ES.NodeType.Firewall:\n                inEntry = rpNets[\"inside\"]\n                outEntry = rpNets[\"outside\"]\n\n                if \"nextHop\" in inEntry:\n                    nextHopIp = inEntry[\"nextHop\"]\n                elif useDefNextHop and \"vni\" in inEntry:\n                    # try to get the default next hop ip\n                    nextHopIp = getLastIPv4InSubnet(servicesInfo[\"serviceNets\"][inEntry[\"vni\"]])\n                if \"nextHop\" in outEntry:\n                    revNextHopIp = outEntry[\"nextHop\"]\n                elif useDefNextHop and \"vni\" in outEntry:\n                    # try to get the default next hop ip\n                    revNextHopIp = getLastIPv4InSubnet(servicesInfo[\"serviceNets\"][outEntry[\"vni\"]])\n            else:\n                if len(rpNets) == 1:\n                    # one armed\n                    oneEntry = rpNets[\"one\"]\n                    if \"nextHop\" in oneEntry:\n                        revNextHopIp = oneEntry[\"nextHop\"]\n                    elif useDefNextHop and \"vni\" in oneEntry:\n                        # try to get the default next hop ip\n                        revNextHopIp = getLastIPv4InSubnet(servicesInfo[\"serviceNets\"][oneEntry[\"vni\"]])\n                else:\n                    twoEntry = rpNets[\"two\"]\n                    if \"nextHop\" in twoEntry:\n                        revNextHopIp = twoEntry[\"nextHop\"]\n                    elif useDefNextHop and \"vni\" in twoEntry:\n                        # try to get the default next hop ip\n                        revNextHopIp = getLastIPv4InSubnet(servicesInfo[\"serviceNets\"][twoEntry[\"vni\"]])\n\n            # update some values in the ptNvPairs\n            for rpNetEntry in rtPeerEntry[\"nets\"].values():\n                if \"ptNvPairs\" not in rpNetEntry:\n                    continue\n\n                nvPairs = rpNetEntry[\"ptNvPairs\"]\n                # add the correct VRF_NAME key\n                nvPairs[\"VRF_NAME\"] = servicesInfo[\"serviceNets\"][rpNetEntry[\"vni\"]][\"netEntry\"][\"vrfName\"]\n\n                # delete some unwanted data\n                if \".nbrLoIntf\" in nvPairs:\n                    del nvPairs[\".nbrLoIntf\"]\n                if \".peerNbrLoIntf\" in nvPairs:\n                    del nvPairs[\".peerNbrLoIntf\"]\n\n            ptNvPairs1 = None\n            ptNvPairs2 = None\n            if (nodeType == ES.NodeType.Firewall):\n                if rtPeerEntry[\"isInter\"]:\n                    ptNvPairs1 = rpNets[\"inside\"][\"ptNvPairs\"]\n                    ptNvPairs2 = rpNets[\"outside\"][\"ptNvPairs\"]\n\n                    if \"LOOPBACK_IP\" in ptNvPairs1:\n                        # eBGP peering\n                        rtPeerEntry[\"peerOption\"] = \"dynamic\"\n            else:\n                ptNvPairs1 = rpNets[\"one\"][\"ptNvPairs\"]\n                if \"two\" in rpNets:\n                    ptNvPairs2 = rpNets[\"two\"][\"ptNvPairs\"]\n\n                if ptNvPairs2 != None:\n                    if ptNvPairs2[\"VRF_NAME\"] == ptNvPairs1[\"VRF_NAME\"]:\n                        # must not provide the second nvpairs\n                        ptNvPairs2 = None\n                \n                if \"LOOPBACK_IP\" in ptNvPairs1:\n                    # eBGP peering\n                    rtPeerEntry[\"peerOption\"] = \"dynamic\"\n\n            peerTemplate = None\n            if rtPeerEntry[\"peerOption\"] == \"none\":\n                rtPeerEntry[\"peerOption\"] = ES.PeeringOption.None\n            elif rtPeerEntry[\"peerOption\"] == \"static\":\n                rtPeerEntry[\"peerOption\"] = ES.PeeringOption.StaticPeering\n                peerTemplate = \"service_static_route\"\n            elif rtPeerEntry[\"peerOption\"] == \"dynamic\":\n                rtPeerEntry[\"peerOption\"] = ES.PeeringOption.EBGPDynamicPeering\n                peerTemplate = \"service_ebgp_route\"\n\n            netList = []\n            srvcPolicyVrfName = None  # this will hold the VRF Name as it is topdown (not lower cased)\n            for netType in rpNets:\n                rpNetEntry = rpNets[netType]\n                vni = rpNetEntry[\"vni\"]\n                netEntry = servicesInfo[\"serviceNets\"][vni]\n\n                if not srvcPolicyVrfName:\n                    srvcPolicyVrfName = netEntry[\"netEntry\"][\"vrfName\"]\n                tdNet = LanNetwork()\n                tdNet.setFabric(fabricName)\n                tdNet.setNetworkName(netEntry[\"networkName\"])\n                tdNet.setNetworkId(int(vni))\n                tdNet.setVrf(netEntry[\"netEntry\"][\"vrfName\"])\n                tdNet.setNetworkTemplate(\"Service_Network_Universal\")\n                tdNet.setNetworkExtensionTemplate(globalOverlayInfo[\"networkExtProfileName\"])\n                tdNet.setNetworkTemplateConfig(json.dumps(netEntry[\"netEntry\"][\"netTemplateParams\"]))\n\n                netList.append(tdNet)\n\n            Wrapper.print(\"%s: SN [%s] Creating Route Peer [%s] nextHopIp [%s] revNextHopIp [%s] peerTemplate [%s]\"\n                \" ptNvPairs1 %s ptNvPairs2 %s\" % (funcName,\n                srvcNodeName, routePeerName, nextHopIp, revNextHopIp, peerTemplate, ptNvPairs1, ptNvPairs2))\n\n            Util.exe(ES.addRoutePeering(extName, srvcNodeName, swSerial, routePeerName, netList,\n                rtPeerEntry[\"peerOption\"], nextHopIp, revNextHopIp, peerTemplate, ptNvPairs1, ptNvPairs2, True))\n\n            # create the service policies\n            for srvcName in rtPeerEntry[\"servicePolicies\"]:\n                srvEntry = rtPeerEntry[\"servicePolicies\"][srvcName]\n\n                policyNvPairs = srvEntry[\"policyTemplateNvPairs\"]\n                srvcRevNextHopIp = revNextHopIp if srvEntry[\"isReverse\"] else \"\"\n                policyNvPairs[\"NEXT_HOP_IP\"] = nextHopIp\n                policyNvPairs[\"REVERSE_NEXT_HOP_IP\"] = srvcRevNextHopIp\n\n                Wrapper.print(\"%s: SN [%s] Route Peer [%s] Creating Service Policy [%s] nextHopIp [%s] \"\n                    \"srvcRevNextHopIp [%s] vrf [%s] policyNvPairs %s\" % (funcName, \n                    srvcNodeName, routePeerName, srvcName, nextHopIp, srvcRevNextHopIp, srvcPolicyVrfName, policyNvPairs))\n                Util.exe(ES.addServicePolicy(extName, srvcNodeName, nodeType, swSerial, routePeerName,\n                    srvcPolicyVrfName, policyNvPairs[\"SRC_NETWORK\"], policyNvPairs[\"DEST_NETWORK\"],\n                    nextHopIp, srvcRevNextHopIp, \"service_pbr\", policyNvPairs, True))\n\n    Wrapper.print(\"%s %s: End - FABRIC [%s]\" % (OVERLAY_PREFIX, funcName, fabricName))\n\ndef getSwitchOverlayVrfGeneratedCfg(vrfName, globalOverlayInfo, switchOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchDict = globalOverlayInfo[\"SWITCH_INFO\"][switchOverlayInfo[\"SERIAL\"]]\n    genCfg = \"\"\n    vrfNameLower = vrfName.lower()\n    if vrfNameLower in switchOverlayInfo[\"VRFS_NAME2VNI\"]:\n        vrfEntry = switchOverlayInfo[\"VRFS_BY_ID\"][switchOverlayInfo[\"VRFS_NAME2VNI\"][vrfNameLower][\"vni\"]]\n\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            templateName = globalOverlayInfo[\"vrfExtProfileName\"]\n        else:\n            templateName = globalOverlayInfo[\"vrfProfileName\"]\n\n        # get the template generated config\n        templateParams = copy.deepcopy(vrfEntry[\"vrfTemplateParams\"])\n        templateParams[\"vrfVlanId\"] = str(vrfEntry[\"vlanId\"])\n        # add the 'isVPC' flag also\n        templateParams[\"isVPC\"] = switchOverlayInfo[\"isVpc\"]\n        templateParams[\"platformType\"] = \"Nexus\"\n\n        Wrapper.print(\"%s: VRF [%s] Device [%s] Template [%s] Config Params [%s]\" % (funcName, \n            vrfName, switchDict[\"fmtName\"], templateName, templateParams))\n        genCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, templateParams, False, None).strip()\n    return genCfg\n\ndef getSwitchOverlayNetGeneratedCfg(netVni, globalOverlayInfo, switchOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchDict = globalOverlayInfo[\"SWITCH_INFO\"][switchOverlayInfo[\"SERIAL\"]]\n    genCfg = \"\"\n    if netVni in switchOverlayInfo[\"NETWORKS_BY_ID\"]:\n        netEntry = switchOverlayInfo[\"NETWORKS_BY_ID\"][netVni]\n\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            templateName = globalOverlayInfo[\"networkExtProfileName\"]\n        else:\n            templateName = globalOverlayInfo[\"networkProfileName\"]\n\n        # get the template generated config\n        templateParams = copy.deepcopy(netEntry[\"netTemplateParams\"])\n        templateParams[\"vlanId\"] = str(netEntry[\"vlanId\"])\n        # add the 'isVPC' flag also\n        templateParams[\"isVPC\"] = switchOverlayInfo[\"isVpc\"]\n        templateParams[\"platformType\"] = \"Nexus\"\n        Wrapper.print(\"%s: Network VNI [%s] Device [%s] Template [%s] Config Params [%s]\" % (funcName,\n            netVni, switchDict[\"fmtName\"], templateName, templateParams))\n        genCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, templateParams, False, None).strip()\n    return genCfg\n\ndef updateHifIntfPolicies(deviceSn):\n    for templateName in [\"trunk_interface_fex\", \"access_interface_fex\"]:\n        newTemplateName = \"trunk_interface\" if templateName == \"trunk_interface_fex\" else \"access_interface\"\n        srchOpt = CtrlPolicySearch()\n        srchOpt.setSerialNumber(deviceSn)\n        srchOpt.setTemplateName(templateName)\n        ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n        for pti in ptiList:\n            if pti.isDeleted():\n                continue\n\n            # create the new HIF policy with the new template name\n            PTIWrapper.create(deviceSn, pti.getEntityType(), pti.getEntityName(), pti.getSource(),\n                pti.getPriority(), newTemplateName, pti.getNvPairs())\n\n            # delete the original policy\n            PTIWrapper.deleteInstance(pti.getPolicyId())\n\ndef handleUpgradeInRecalc(dictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    topologyDataObj = dictObj[\"topologyObj\"]\n    upgradeFromVersion = dictObj[\"upgradeFromVersion\"]\n    fabricName = dictObj[\"fabricName\"]\n    Wrapper.print(\"%s(): UPGRADE_FROM_VERSION [%s]\" %(funcName, upgradeFromVersion))\n    devices = topologyDataObj.get(TopologyInfoType.SWITCHES)\n    devices = filter(None, devices)\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        # dictionary to hold the progress status of each spine processing\n        devicesStatusDict = OrderedDict()\n        devicesInfoDict = OrderedDict()\n        # dictionary of parameters\n        paramDict = {\"topologyDataObj\": topologyDataObj, \"respObj\": respObj, \"upgradeFromVersion\": upgradeFromVersion,\n                     \"fabricName\": fabricName, \"devicesStatusDict\": devicesStatusDict}\n        threadCount = Util.getThreadCount(devices)\n        devicesThread = []\n        Wrapper.print(\"%s(): threadCount [%s]\"%(funcName, threadCount))\n        for i in range(0, len(devices), threadCount):\n            tDevices = devices[i:i+threadCount]\n            for deviceSn in tDevices:\n                Wrapper.print(\"%s(): deviceSn [%s]\"%(funcName, deviceSn))\n                devicesStatusDict[deviceSn] = {\"Progress\" : \"Pending\"}\n                role = topologyDataObj.getSwitchRole(deviceSn)\n                fmtName = getFormattedSwitchName(deviceSn)\n                devicesInfoDict[deviceSn] = {\"fmtName\": fmtName, \"switchRole\": role}\n            devicesThread.append(threading.Thread(target=handleUpgrade, args=(tDevices, paramDict)))\n            devicesThread[-1].start()\n        for thread in devicesThread:\n            thread.join()\n        processThreadStatus(devicesStatusDict, devicesInfoDict, respObj)\n        devicesStatusDict.clear()\n\n        Util.exe(handleUpgradePerFabric(fabricName, dictObj))\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef handleUpgrade(tDevices, paramDict):\n    funcName = sys._getframe(0).f_code.co_name\n    topologyDataObj = paramDict[\"topologyDataObj\"]\n    upgradeFromVersion = paramDict[\"upgradeFromVersion\"]\n    fabricName = paramDict[\"fabricName\"]\n    respObj = paramDict[\"respObj\"]\n\n    Wrapper.print(\"%s: Start\" %(funcName))\n    try:\n        fabricSettings = Util.exe(FabricWrapper.get(fabricName)).getNvPairs()\n        for deviceSn in tDevices:\n            currentDeviceSn = deviceSn\n            model = topologyDataObj.getSwitchModel(deviceSn)\n            statusDict = paramDict[\"devicesStatusDict\"][deviceSn]\n            hostName = topologyDataObj.getHostName(deviceSn)\n            Wrapper.print(\"%s: Start - Switch [%s/%s] Model [%s]\" % (funcName, deviceSn, hostName, model))\n            statusDict[\"Progress\"] = \"regen started\"\n\n            if upgradeFromVersion in [\"11.5.4\"]:\n                updateHifIntfPolicies(deviceSn)\n\n            if ((fabricSettings.get(\"OVERLAY_MODE\", \"config-profile\") == \"cli\") and \n                (fabricSettings.get(\"ENABLE_EVPN\", \"true\") == \"true\")):\n                Util.exe(PTI.createOrUpdate(deviceSn, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                            ConfigPriority.temp_anycast_gateway, \"base_evpn\", {}))\n\n            if \"UNDERLAY_IS_V6\" in fabricSettings and fabricSettings[\"UNDERLAY_IS_V6\"] == \"true\":\n                if Util.isSwVersionOk(deviceSn, \"9.3(5)\"):\n                    srchOpt = CtrlPolicySearch()\n                    srchOpt.setSerialNumber(deviceSn)\n                    srchOpt.setEntityType(\"INTERFACE\")\n                    srchOpt.setTemplateName(\"interface_ipv6_link_local\")\n                    ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                    statusDict[\"Progress\"] = \"interface_ipv6_link_local regen started for \" + hostName\n                    for pti in ptiList:\n                        if pti.isDeleted():\n                            continue\n                        nvPairs = pti.getNvPairs()\n                        if \"Vlan\" not in nvPairs[\"INTF_NAME\"]:\n                            Util.exe(PTIWrapper.createOrUpdate(deviceSn, \"INTERFACE\",\n                                                   nvPairs[\"INTF_NAME\"], pti.getSource(),\n                                                   ConfigPriority.CONFIG_PRIO_INTF,\n                                                   \"interface_ipv6_link_local_bia\",\n                                                   {\"INTF_NAME\": nvPairs[\"INTF_NAME\"]}))\n                            Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n                    statusDict[\"Progress\"] = \"interface_ipv6_link_local regen completed for \" + hostName\n    \n            if fabricSettings[\"LINK_STATE_ROUTING\"] == \"ebgp\":\n                srchOpt = CtrlPolicySearch()\n                srchOpt.setSerialNumber(deviceSn)\n                srchOpt.setSource(\"UNDERLAY\")\n                srchOpt.setTemplateName(\"route_map\")\n                ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                statusDict[\"Progress\"] = \"route_map conversion to route_map_with_tag started for \" + hostName\n                for pti in ptiList:\n                    if pti.isDeleted():\n                        continue\n                    Util.exe(PTIWrapper.createOrUpdate(deviceSn, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                           ConfigPriority.abstract_route_map, \"route_map_with_tag\",\n                                           {\"ROUTE_MAP\": \"FABRIC-RMAP-REDIST-SUBNET\", \"ROUTING_TAG\": \"12345\"}))\n    \n                    Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n                statusDict[\"Progress\"] = \"route_map conversion to route_map_with_tag completed for \" + hostName\n            else:\n                switchRole = topologyDataObj.get(TopologyInfoType.GET_SWITCH_ROLE, deviceSn)\n                if \"border\" in switchRole:\n                    srchOpt = CtrlPolicySearch()\n                    srchOpt.setSerialNumber(deviceSn)\n                    srchOpt.setTemplateName(\"ext_multisite_overlay_setup_11_1\")\n                    msOverlayPtiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                    statusDict[\"Progress\"] = \"ext_multisite_overlay_setup_11_1 regen started for \" + hostName\n                    for pti in msOverlayPtiList:\n                        if pti.isDeleted():\n                            continue\n                        if \"IS_HUB_SITE\" not in pti.getNvPairs():\n                            nvPairs = copy.deepcopy(pti.getNvPairs())\n                            nvPairs[\"IS_HUB_SITE\"] = \"false\"\n                            Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), nvPairs))\n                    statusDict[\"Progress\"] = \"ext_multisite_overlay_setup_11_1 regen completed for \" + hostName\n    \n            srchOpt = CtrlPolicySearch()\n            srchOpt.setSerialNumber(deviceSn)\n            srchOpt.setTemplateName(\"ext_bgp_neighbor_rf\")\n            ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            statusDict[\"Progress\"] = \"ext_bgp_neighbor_rf regen started for \" + hostName\n            for pti in ptiList:\n                if pti.isDeleted():\n                    continue\n                nvPairs = copy.deepcopy(pti.getNvPairs())\n                nvPairs[\"IP_TYPE\"] = \"ipv4\"\n                nvPairs[\"ROUTE_MAP_NAME\"] = \"EXTCON-RMAP-FILTER-ALLOW-HOST\"\n                Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), nvPairs))\n            statusDict[\"Progress\"] = \"ext_bgp_neighbor_rf regen completed for \" + hostName\n\n            if fabricSettings[\"LINK_STATE_ROUTING\"] != \"ebgp\" and upgradeFromVersion in [\"12.1.1e\", \"12.1.2e\", \"12.1.2p\"]:\n                srchOpt = CtrlPolicySearch()\n                srchOpt.setSerialNumber(deviceSn)\n                srchOpt.setTemplateName(\"int_port_channel_leaf_tor_assoc\")\n                ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                statusDict[\"Progress\"] = \"int_port_channel_leaf_tor_assoc conversion to int_port_channel_uplink_access started for \" + hostName\n                for pti in ptiList:\n                    if pti.isDeleted():\n                        continue\n                    nvPairs = copy.deepcopy(pti.getNvPairs())\n                    # Delete the old python policy first, otherwise python policies created for members may be deleted\n                    # if the old python policy is deleted after the new python policy is created\n                    Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n                    Util.exe(PTIWrapper.create(deviceSn, pti.getEntityType(), pti.getEntityName(), pti.getSource(),\n                                               pti.getPriority(), \"int_port_channel_uplink_access\", nvPairs))\n                statusDict[\"Progress\"] = \"int_port_channel_leaf_tor_assoc conversion to int_port_channel_uplink_access completed for \" + hostName\n\n                isSwitchVPC = Util.exe(VpcWrapper.isVpc(fabricName, deviceSn))\n                if isSwitchVPC:\n                    vpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, fabricName, deviceSn))\n                    srchOpt.setSerialNumber(vpcPairSerialKey)\n                    srchOpt.setTemplateName(\"int_vpc_leaf_tor_assoc\")\n                    ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                    statusDict[\"Progress\"] = \"int_vpc_leaf_tor_assoc conversion to int_vpc_uplink_access started for \" + hostName\n                    for pti in ptiList:\n                        if pti.isDeleted():\n                            continue\n                        nvPairs = copy.deepcopy(pti.getNvPairs())\n                        # Delete the old python policy first, otherwise python policies created for members may be deleted\n                        # if the old python policy is deleted after the new python policy is created\n                        Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n                        Util.exe(PTIWrapper.create(vpcPairSerialKey, pti.getEntityType(), pti.getEntityName(), pti.getSource(),\n                                                   pti.getPriority(), \"int_vpc_uplink_access\", nvPairs))\n                    statusDict[\"Progress\"] = \"int_vpc_leaf_tor_assoc conversion to int_vpc_uplink_access completed for \" + hostName\n\n                    if upgradeFromVersion in [\"12.1.1e\"]:\n                        srchOpt.setSerialNumber(vpcPairSerialKey)\n                        srchOpt.setTemplateName(\"vpc_pair\")\n                        ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                        statusDict[\"Progress\"] = \"vpc_pair regen started for \" + hostName\n                        for pti in ptiList:\n                            if pti.isDeleted():\n                                continue\n                            nvPairs = copy.deepcopy(pti.getNvPairs())\n                            nvPairs[\"KEEP_ALIVE_HOLD_TIMEOUT\"] = \"3\"\n                            Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), nvPairs, True))\n                        statusDict[\"Progress\"] = \"vpc_pair regen completed for \" + hostName\n\n            statusDict[\"Progress\"] = \"Complete\"\n            Wrapper.print(\"%s: End - Switch [%s/%s]\" % (funcName, deviceSn, hostName))\n\n        Wrapper.print(\"%s: End\" %(funcName))\n        return respObj\n    except Exception as e:\n        msg = (\"[%s] - Unexpected error during one time regeneration of policies after upgrade. \"\n            \"Last Status [%s]\" % (getFormattedSwitchName(currentDeviceSn), (statusDict[\"Progress\"] if statusDict else \"Unknown\")))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"POLICY_REGENERATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n\n# fabric wide post upgrade handling\ndef handleUpgradePerFabric(fabricName, dictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s\" %funcName)\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        # check for vrf lite IFC for upgrade from pre 12.1.3\n        fabLinks = json.loads(Util.exe(Helper.getFabricLinks(fabricName)))\n        Wrapper.print(\"%s, fabric %s found %s links\" % (funcName, fabricName, len(fabLinks)))\n        for link in fabLinks:\n            templateName = link.get(\"templateName\", None)\n            if templateName != \"ext_fabric_setup\":\n                continue\n\n            origNvPairs = link.get(\"nvPairs\", None)\n            if not origNvPairs:\n                continue\n\n            if origNvPairs[\"AUTO_VRF_LITE_FLAG\"] != \"true\":\n                continue\n\n            sw1Info = link[\"sw1-info\"]\n            sw1_sn = sw1Info[\"sw-serial-number\"]\n            sw1_fabric_name = sw1Info[\"fabric-name\"]\n            sw1_fabric = Util.exe(FabricWrapper.get(sw1Info[\"fabric-name\"]))\n            sw1_FabricType = sw1_fabric.getFabricType()\n\n            sw2Info = link[\"sw2-info\"]\n            sw2_sn = sw2Info[\"sw-serial-number\"]\n            sw2_fabric_name = sw2Info[\"fabric-name\"]\n            sw2_fabric = Util.exe(FabricWrapper.get(sw2Info[\"fabric-name\"]))\n            sw2_FabricType = sw2_fabric.getFabricType()\n\n            if sw1_FabricType == \"External\" or sw2_FabricType == \"External\":\n                turnOffAutoDeployPeer = False\n                templateChange = \"\"\n                if sw1_FabricType == \"External\":\n                    checkSn = sw1_sn\n                else:\n                    checkSn = sw2_sn\n\n                model = Util.exe(InventoryWrapper.getSwitchModel(checkSn))\n\n                if not (Util.isNXOSDevice(checkSn, model) or Util.isIOSXEDevice(checkSn, model) or Util.isIOSXRDevice(checkSn, model)):\n                    turnOffAutoDeployPeer = True\n                elif Util.isIOSXEDevice(checkSn, model) and (origNvPairs[\"VRF_LITE_JYTHON_TEMPLATE\"] == \"Ext_VRF_Lite_Jython\" or origNvPairs[\"VRF_LITE_JYTHON_TEMPLATE\"] == \"ios_xr_Ext_VRF_Lite_Jython\"):\n                    templateChange = \"ios_xe_Ext_VRF_Lite_Jython\"\n                elif Util.isIOSXRDevice(checkSn, model) and (origNvPairs[\"VRF_LITE_JYTHON_TEMPLATE\"] == \"Ext_VRF_Lite_Jython\" or origNvPairs[\"VRF_LITE_JYTHON_TEMPLATE\"] == \"ios_xe_Ext_VRF_Lite_Jython\"):\n                    templateChange = \"ios_xr_Ext_VRF_Lite_Jython\"\n\n                if turnOffAutoDeployPeer or templateChange:\n                    # update only if IFC is not extended\n                    swId1 =  Util.exe(InterfabricConnectionWrapper.getLanSwitchId(sw1_sn));\n                    swId2 =  Util.exe(InterfabricConnectionWrapper.getLanSwitchId(sw2_sn))\n                    source_inter_fabric_connection_id = Util.exe(InterfabricConnectionWrapper.getInterfabricId(swId1, sw1Info.get(\"if-name\"),\n                                                          swId2, sw2Info.get(\"if-name\")))\n\n                    dest_inter_fabric_connection_id = Util.exe(InterfabricConnectionWrapper.getInterfabricId(swId2, sw2Info.get(\"if-name\"),\n                                                          swId1, sw1Info.get(\"if-name\")))\n\n                    source_extended = destination_extended = False\n                    if source_inter_fabric_connection_id != 0:\n                        source_extended = Util.exe(InterfabricConnectionWrapper.isInterfabricExtended(source_inter_fabric_connection_id))\n\n                    if dest_inter_fabric_connection_id != 0:\n                        destination_extended = Util.exe(InterfabricConnectionWrapper.isInterfabricExtended(dest_inter_fabric_connection_id))\n\n                    if source_extended or destination_extended:\n                        Wrapper.print(\"%s link %s has extension, skip update\" % (funcName, link[\"policyId\"]))\n                        continue\n\n                    nvPairs = copy.deepcopy(origNvPairs)\n                    if turnOffAutoDeployPeer:\n                        nvPairs[\"AUTO_VRF_LITE_FLAG\"] = \"false\"\n                        nvPairs[\"DEFAULT_VRF_FLAG\"] = \"false\"\n                        nvPairs[\"SYMMETRIC_DEFAULT_VRF_FLAG\"] = \"false\"\n                    if templateChange:\n                        nvPairs[\"VRF_LITE_JYTHON_TEMPLATE\"] = templateChange\n\n                    Wrapper.print(\"%s update link %s: turnOffAutoDeployPeer %s, templateChange %s nvPairs %s\" % (funcName, link[\"policyId\"], turnOffAutoDeployPeer, templateChange, nvPairs))\n                    Util.exe(PTIWrapper.updateInstance(link[\"policyId\"], nvPairs, True))\n\n        return respObj\n    except respObjError as e:\n        msg = (\"[%s] - Unexpected error during one time regeneration of policies after upgrade. \" % funcName)\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"POLICY_REGENERATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n\ndef getAndAddToList(fabricSettings, key, list):\n    val = fabricSettings.get(key, None)\n    if val:\n        list.append(val)\n\ndef mgmtFabricSettingsUpgrade(fabricSettings):\n    isSettingChange = False\n    # Handling DNS fabric settings\n    Wrapper.print(\"mgmtFabricSettingsUpgrade: Fabric [%s] DNS_SERVER_IP_LIST [%s]\" %\n            (FABRIC_NAME, fabricSettings.get(\"DNS_SERVER_IP_LIST\", None)))\n    if (\"DNS_SERVER_IP_LIST\" not in fabricSettings):\n        serverIPs = []\n        vrfs = []\n        \n        if fabricSettings.get(\"DNS_SERVER_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'DNS_SERVER_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'DNS_SERVER_VRF', vrfs)\n\n        if fabricSettings.get(\"DNS2_SERVER_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'DNS2_SERVER_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'DNS2_SERVER_VRF', vrfs)\n\n        isSettingChange = setFabricSettingValue(fabricSettings, \"DNS_SERVER_IP_LIST\", (\",\".join(serverIPs)))\n        isSettingChange = setFabricSettingValue(fabricSettings, \"DNS_SERVER_VRF\", (\",\".join(vrfs)))\n        \n    # Handling NTP Upgrades\n    Wrapper.print(\"mgmtFabricSettingsUpgrade: Fabric [%s] NTP_SERVER_IP_LIST [%s]\" %\n            (FABRIC_NAME, fabricSettings.get(\"NTP_SERVER_IP_LIST\", None)))\n    if (\"NTP_SERVER_IP_LIST\" not in fabricSettings):\n        serverIPs = []\n        vrfs = []\n\n        if fabricSettings.get(\"NTP_SERVER_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'NTP_SERVER_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'NTP_SERVER_VRF', vrfs)\n\n        if fabricSettings.get(\"NTP2_SERVER_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'NTP2_SERVER_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'NTP2_SERVER_VRF', vrfs)\n\n        isSettingChange = setFabricSettingValue(fabricSettings, \"NTP_SERVER_IP_LIST\", (\",\".join(serverIPs)))\n        isSettingChange = setFabricSettingValue(fabricSettings, \"NTP_SERVER_VRF\", (\",\".join(vrfs)))\n\n    # Handling SYSLOG Upgrades\n    Wrapper.print(\"mgmtFabricSettingsUpgrade: Fabric [%s] SYSLOG_SERVER_IP_LIST [%s]\" %\n            (FABRIC_NAME, fabricSettings.get(\"SYSLOG_SERVER_IP_LIST\", None)))\n    if (\"SYSLOG_SERVER_IP_LIST\" not in fabricSettings):\n        serverIPs = []\n        vrfs = []\n        sevs = []\n\n        if fabricSettings.get(\"SYSLOG_SERVER1_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'SYSLOG_SERVER1_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'SYSLOG_VRF1', vrfs)\n            getAndAddToList(fabricSettings, 'SYSLOG_SEV1', sevs)\n\n        if fabricSettings.get(\"SYSLOG_SERVER2_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'SYSLOG_SERVER2_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'SYSLOG_VRF2', vrfs)\n            getAndAddToList(fabricSettings, 'SYSLOG_SEV2', sevs)\n\n        isSettingChange = setFabricSettingValue(fabricSettings, \"SYSLOG_SERVER_IP_LIST\", (\",\".join(serverIPs)))\n        isSettingChange = setFabricSettingValue(fabricSettings, \"SYSLOG_SERVER_VRF\", (\",\".join(vrfs)))\n        isSettingChange = setFabricSettingValue(fabricSettings, \"SYSLOG_SEV\", (\",\".join(sevs)))\n\n    # Handling AAA Upgrades\n    Wrapper.print(\"mgmtFabricSettingsUpgrade: Fabric [%s] AAA_SERVER_CONF [%s]\" %\n            (FABRIC_NAME, fabricSettings.get(\"AAA_SERVER_CONF\", None)))\n    if (\"AAA_SERVER_CONF\" not in fabricSettings):\n        aaa_IP = fabricSettings.get('AAA_SERVER', \"\")\n        aaa_IP2 = fabricSettings.get('AAA2_SERVER', \"\")\n        aaa_Secret = fabricSettings.get('AAA_SECRET', \"\")\n        aaa_Secret2 = fabricSettings.get('AAA2_SECRET', \"\")\n        aaa_vrf = fabricSettings.get('AAA_VRF', \"default\")\n        aaa_vrf = fabricSettings.get('AAA_VRF', \"default\")\n        if aaa_vrf == \"\":\n            aaa_vrf = \"default\"\n        aaa_Type = fabricSettings.get('AAA_TYPE', \"none\")\n\n        configureKeys       = \"\"\n        configure_Vrfs      = \"\"\n        configureBASEAAA    = \"\" \n        update_AAA_Freeform = \"\"\n\n        Wrapper.print(\"mgmtFabricSettingsUpgrade: Fabric [%s] aaa_Type [%s]\" % (FABRIC_NAME, aaa_Type))\n        if aaa_Type != \"none\":\n            if aaa_Type == \"radius\":\n                configureKeys, configure_Vrfs, configureBASEAAA = configureRADIUS(aaa_IP, aaa_Secret, \n                                                                    aaa_IP2, aaa_Secret2, aaa_vrf, aaa_Type)\n            elif aaa_Type == \"tacacs\":\n                configureKeys, configure_Vrfs, configureBASEAAA = configureTACACS(aaa_IP, aaa_Secret,\n                                                                    aaa_IP2, aaa_Secret2, aaa_vrf, aaa_Type)\n        \n            update_AAA_Freeform = (configureKeys + configure_Vrfs + configureBASEAAA)\n        isSettingChange = setFabricSettingValue(fabricSettings, \"AAA_SERVER_CONF\", update_AAA_Freeform)\n    return isSettingChange\n\ndef configureRADIUS(aaa_IP, aaa_Secret, aaa_IP2, aaa_Secret2, aaa_vrf, aaa_Type):\n    if aaa_IP and aaa_IP2:\n        configureKeys   = \"radius-server host \" + aaa_IP + \" key 7 \" + \"\\\"\" +aaa_Secret + \"\\\"\" +\" authentication accounting\" + Util.newLine()\n        configureKeys   += \"radius-server host \" + aaa_IP2 + \" key 7 \" + \"\\\"\" + aaa_Secret2 + \"\\\"\" + \" authentication accounting\" + Util.newLine()\n        configure_Vrfs  = \"aaa group server radius AAA_RADIUS\" + Util.newLine() + \"  server \" + aaa_IP + Util.newLine() + \"  server \" + aaa_IP2 + Util.newLine() + \"  use-vrf \" + aaa_vrf + Util.newLine()\n    elif not aaa_IP2:\n        configureKeys = \"radius-server host \" + aaa_IP + \" key 7 \" + \"\\\"\" + aaa_Secret + \"\\\"\" + \" authentication accounting \" + Util.newLine()\n        configure_Vrfs  = \"aaa group server radius AAA_RADIUS\" + Util.newLine() + \"  server \" + aaa_IP + Util.newLine() + \"  use-vrf \" + aaa_vrf +Util.newLine()\n    else:\n        configureKeys = \"radius-server host \" + aaa_IP2 + \" key 7 \" + \"\\\"\" + aaa_Secret2 + \"\\\"\" + \" authentication accounting \" + Util.newLine()\n        configure_Vrfs  = \"aaa group server radius AAA_RADIUS\" + Util.newLine() + \"  server \" + aaa_IP2 + Util.newLine() + \"  use-vrf \" + aaa_vrf + Util.newLine()\n        \n    configureBASEAAA =  \"aaa authentication login default group AAA_RADIUS local\" + Util.newLine() + \"aaa authentication login console local\" + Util.newLine() + \"aaa accounting default group AAA_RADIUS\" + Util.newLine() +\"aaa authentication login error-enable\"\n    return configureKeys, configure_Vrfs, configureBASEAAA\n    \ndef configureTACACS(aaa_IP, aaa_Secret, aaa_IP2, aaa_Secret2, aaa_vrf, aaa_Type):\n    \n    configureKeys = \"\"\n    configure_Vrfs = \"\"\n    configureBASEAAA = \"\" \n    base_tacacs = \"feature tacacs+\"+Util.newLine()\n    \n    if aaa_IP and aaa_IP2:\n        configureKeys = base_tacacs + \"tacacs-server host \" + aaa_IP + \" key 7 \" + \"\\\"\" + aaa_Secret + \"\\\"\" +Util.newLine()\n        configureKeys += \"tacacs-server host \" + aaa_IP2 + \" key 7 \" + \"\\\"\" + aaa_Secret2 + \"\\\"\" +Util.newLine()\n        configure_Vrfs = \"aaa group server tacacs+ AAA_TACACS\" +Util.newLine() + \"  server \" + aaa_IP + Util.newLine() + \"  server \" + aaa_IP2 +Util.newLine() + \"  use-vrf \" + aaa_vrf +Util.newLine()\n    elif not aaa_IP2:\n        configureKeys = base_tacacs + \"tacacs-server host \" + aaa_IP + \" key 7 \" + \"\\\"\" + aaa_Secret + \"\\\"\" +Util.newLine()\n        configure_Vrfs = \"aaa group server tacacs+ AAA_TACACS\" +Util.newLine() + \"  server \" + aaa_IP +Util.newLine() + \"  use-vrf \" + aaa_vrf + Util.newLine()\n    else:\n        configureKeys = base_tacacs + \"tacacs-server host \" + aaa_IP2 + \" key 7 \" + \"\\\"\" + aaa_Secret2 + \"\\\"\" +Util.newLine()\n        configure_Vrfs = \"aaa group server tacacs+ AAA_TACACS\" +Util.newLine() + \"  server \" + aaa_IP2 +Util.newLine()+ \"  use-vrf \" + aaa_vrf + Util.newLine()\n        \n    configureBASEAAA = \"aaa authentication login default group AAA_TACACS local\" + Util.newLine() + \"aaa authentication login console local\" + Util.newLine() + \"aaa accounting default group AAA_TACACS\" + Util.newLine() + \"aaa authentication login error-enable\"\n    return configureKeys, configure_Vrfs, configureBASEAAA\n\n#\n# Handles N9K and N3K switches\n# returns the following:\n#   \"FRETTA\" - for -R series HW (Fixed chassis is N3K-xxx-R, modular is N9k with -R LCs)\n#   \"CLOUDSCALE\" - for Tahoe based HW\n#   \"NXOSV\" - for NXOSv\n#   \"OTHER\" - for all other HW types (T2)\n#   \"UNKNOWN\" - if HW type is unknown\n#\ndef getHwAsicType(topologyDataObj, sn):\n    funcName = sys._getframe(0).f_code.co_name\n    devModel = topologyDataObj.getSwitchModel(sn)\n\n    asicType = \"UNKNOWN\"\n    if Util.isN9kTahoe(topologyDataObj, sn):\n        asicType = \"CLOUDSCALE\"\n\n        # need to check further for fretta LCs\n        devModules = topologyDataObj.getSwitchModules(sn)\n\n        #Wrapper.print(\"%s: sn [%s] devModel [%s] devModules [%s]\" % (funcName, sn, devModel, devModules))\n        # need to check further for -R series\n        if not devModules:\n            if \"-R\" in devModel:\n                asicType = \"FRETTA\"\n        else:\n            for module in devModules:\n                model = module.get(\"ModelName\")\n                if model is None:\n                    # the model name is not present.. skip\n                    continue\n                if \"-R\" in model:\n                    asicType = \"FRETTA\"\n                    #Wrapper.print(\"%s: sn [%s] devModel [%s] module model [%s]\" % (funcName, sn, devModel, model))\n                    break\n    elif Util.isN9kv(topologyDataObj, sn):\n        asicType = \"NXOSV\"\n    elif \"-R\" in devModel:\n        asicType = \"FRETTA\"\n    else:\n        # has to be T2\n        asicType = \"OTHER\"\n\n    Wrapper.print(\"%s: sn [%s] devModel [%s] asicType [%s]\" % (funcName, sn, devModel, asicType))\n    return asicType\n\ndef ECLdeviceUpgradeExt(gVarDictObj, respObj, doFullProcessing):\n\n    funcName = sys._getframe(0).f_code.co_name\n\n    dictionaryObj = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = dictionaryObj[\"deviceSerial\"]\n    migrateMode = dictionaryObj[\"migrationMode\"]\n    topologyDataObj = gVarDictObj[\"topologyObj\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    vpcSrcToDstMacMap = gVarDictObj[\"vpcSrcToDstMacMap\"]\n    matchResult = dictionaryObj[\"matchResult\"]\n    interfacesRes = dictionaryObj[\"interfacesRes\"]\n    switchRole = dictionaryObj[\"switchRole\"]\n    hostName = dictionaryObj[\"hostName\"]\n    fmtName = dictionaryObj[\"fmtName\"]\n    model = dictionaryObj[\"deviceModel\"]\n    dcnmUser = gVarDictObj[\"dcnmUser\"]\n    \n    isAgg = False\n    if \"aggregation\" in switchRole.lower():\n        isAgg = True\n    Wrapper.print(\"==========%s: Fabric = %s, Serial [%s] Model [%s] Role [%s] isAgg [%r]\" % \n        (funcName, FABRIC_NAME, devSerial, model, switchRole, isAgg))\n\n    vPCInfo = dictionaryObj[\"vpcInfo\"]\n    isValidVPC = (vPCInfo[\"domainId\"] != None)\n\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    switchOverlayInfo[\"isVpc\"] = \"true\" if isValidVPC else \"false\"\n\n    device_overlay_vlans = {}\n    doOverlayMigr = False\n    if migrateMode == \"brownAdd\":\n        #Do overlay migration for both access & aggregation roles. \n        #Access will yield its network attachments that will be added as torPorts to the corresponding paired agg(s)\n        doOverlayMigr = True\n        # record state that the switch overlay migration is not completed yet\n        if isAgg:\n            switchOverlayInfo[\"doOverlayExtn\"] = \"true\"\n        putSwitchIntoOverlayMigrMode(FABRIC_NAME, devSerial)\n    elif migrateMode == \"upgrade\":\n        #TODO: IS THIS REQUIRED?\n        if switchRole.lower() != \"spine\":\n            doOverlayMigr = True\n            # the switch will be in migration mode from the backend code\n            # get the interface specific network vlan info\n            device_overlay_vlans = TopDownMigrationUtils.getOverlayInterfaceInfo(devSerial)\n            Wrapper.print(\"Fabric upgrade %s device_overlay_vlans %s\" % (devSerial, device_overlay_vlans))\n            for x in device_overlay_vlans.entrySet():\n                Wrapper.print(\" intf %s, %s\" % (x.key, x.value.getVlanList()))\n\n    if doOverlayMigr:\n        # collect all the network/vrf information for the switches\n        ECLgatherNwkVrfInfo(topologyDataObj, devSerial, matchResult, interfacesRes, globalOverlayInfo,\n                    switchOverlayInfo, migrateMode, device_overlay_vlans, respObj, dcnmUser)\n\n    if respObj.isRetCodeFailure() or (not doFullProcessing):\n        return respObj\n\n    if Util.exe(FabricWrapper.isFeatureEnabled(\"nxcloud\")):\n        manageNxCloudPolicies(devSerial, matchResult, respObj)\n\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    # add the special route-map policy template for the Aggs\n    if isAgg:\n        # do a check first\n        templateName = \"route_map\"\n        if (getTemplateMatchResults(matchResult, templateName) == None):\n            # add the match entry\n            matchResult.update({templateName : [{}]})\n\n    # process common configs\n    if isValidVPC:\n        createPTI(devSerial, {}, \"base_feature_vpc\", \"SWITCH\", \"UNDERLAY\", -1)\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"nfm_switch_user\")\n    createMatchedPtis(devSerial, matchResult, \"password_no_strength\")\n    createMatchedPtis(devSerial, matchResult, \"host_11_1\")\n    createMatchedPtis(devSerial, matchResult, \"switchnm_11_1\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"v4_mgmt_default_gateway\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"v6_mgmt_default_gateway_11_1\")\n    createMatchedPtis(devSerial, matchResult, \"feature_bfd\")\n    createMatchedPtis(devSerial, matchResult, \"feature_nxapi\")\n    createMatchedPtis(devSerial, matchResult, \"nxapi_http_port\")\n    createMatchedPtis(devSerial, matchResult, \"nxapi_https_port\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"banner\")\n    nvPairList = getTemplateMatchResults(matchResult, \"ssh_key_rsa\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            bits = nvPair.get(\"BITS\")\n            if bits != \"1024\" and bits != \"\":\n                rsaNvPair = {\"BITS\":bits}\n                Wrapper.print(\"match ssh_key_rsa %s\" % nvPair)\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n                                           \"ssh_key_rsa_force\", rsaNvPair))\n\n    createMatchedPtis(devSerial, matchResult, \"pre_config\")\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"base_bgp\")\n\n    #manageBgpRelatedBrownfieldPolicies(devSerial, matchResult, gVarDictObj, switchOverlayInfo[\"BGP_FF\"], respObj)\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"ntp_server\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"ntp_prefer_server\")\n    createMatchedPtis(devSerial, matchResult, \"clock_protocol\")\n    createMatchedPtis(devSerial, matchResult, \"clock_timezone\")\n    createMatchedPtis(devSerial, matchResult, \"clock_summertime\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"dnsList\")  #cleanup first since we use create,not update to support multiple dns_vrf\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"dns-vrfList\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_sev\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_vrf\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_vrf_no_sev\")\n\n    # check system jumbomtu\n    jumboMtuVal = \"9216\"\n    templateName = \"system_jumbomtu\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            jumboMtuVal = nvPair[\"MTU\"]\n\n    Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n        templateName, {\"MTU\" : jumboMtuVal}))\n\n    # create the internal PTI to track the switch jumbomtu setting\n    Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n        \"switch_mtu_state\", {\"JUMBO_MTU_VAL\" : jumboMtuVal}))\n\n    nvPairList = getTemplateMatchResults(matchResult, \"aaa_tacacs\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            if nvPair[\"AAA_TACACS\"] == \"tacacs+\":\n                Wrapper.print(\"match aaa_tacacs, %s\" % nvPair)\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2,\n                                           \"aaa_tacacs\", nvPair))\n\n    nvPairList = getTemplateMatchResults(matchResult, \"aaa_tacacs_use_vrf\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            if nvPair[\"AAA_TACACS\"] == \"tacacs+\":\n                Wrapper.print(\"match aaa_tacacs_use_vrf, %s\" % nvPair)\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2,\n                                           \"aaa_tacacs_use_vrf\", nvPair))\n    \n    isN7k = isModelN7k(topologyDataObj, devSerial) \n    if not isN7k:\n        if (POWER_REDUNDANCY_MODE == \"combined\"):\n            createPTI(devSerial, {}, \"power_redundancy_combined\", \"SWITCH\", \"\", -1)\n        else:\n            createPTI(devSerial, {\"REDUNDANCY_MODE\": POWER_REDUNDANCY_MODE},\n                                     \"power_redundancy\", \"SWITCH\", \"\", -1)\n\n    # handle pre-interface global unaccounted cmds\n    features_info = matchResult[\"FEATURES_INFO\"]\n    global_unaccounted = features_info[\"GLOBAL_UNACCTED\"][\"unaccounted\"]\n\n    keyChainLine = \"\"\n    '''\n    if LINK_STATE_ROUTING == \"ospf\":\n        underlayProtocolCfgLine = \"router \" + (\"ospf \" if UNDERLAY_IS_V6 == \"false\" else \"ospfv3 \") + LINK_STATE_ROUTING_TAG\n    else:\n        underlayProtocolCfgLine = \"router isis \" + LINK_STATE_ROUTING_TAG\n    Wrapper.print(\"%s: underlayProtocolCfgLine: [%s]\" % (funcName, underlayProtocolCfgLine))\n    '''\n    underlayProtocolCfgLine = \"\"\n    \n    filteredUnaccounted = []\n    feature_unaccounted = []\n\n    tcamUnaccounted = []\n    AAA_Configs = []\n    global_unaccounted_AAA = []\n    logging_Configs = []\n    snmpServer_Configs = []\n    ntp_Configs = []\n    routeMap_Configs = []\n    qos_Configs = []\n    copp_Configs = []\n    ipSla_Configs = []\n    track_Configs = []\n    netflow_Configs = []\n    vpcDomain_Configs = []\n    vlanConfig_Configs = []\n    skipAcl = False\n    skipPfxList = False\n    skipMmodeProfile = False\n    isAAABlock = False\n    isRouteMapBlock = False\n    isQosBlock = False\n    isCoppBlock = False\n    isIpSlaBlock = False\n    isTrackBlock = False\n    isNetflowBlock = False\n    isVpcDomainBlock = False\n    isVlanConfigBlock = False\n    keyChainLines = []\n    keepKeyChain = False\n    isKeyChain = False\n    startCurrAclContext = False\n    isN7KExpandTabCli = False\n    aclDict = {}\n    prefixListDict = {}\n    for line in global_unaccounted:\n        depth = (len(line) - len(line.lstrip(' '))) / 2\n        if depth == 0:\n            # top level CLIs\n            isKeyChain = False\n            keepKeyChain = False\n            isN7KExpandTabCli = False\n\n            #IP acl list parsing is done for a single acl\n            if startCurrAclContext:\n                aclDict[aclNameDesc] = currAclCmds\n                startCurrAclContext = False\n                currAclCmds = []\n\n            if skipAcl:\n                # we are out of the ACL block\n                skipAcl = False\n            elif isAAABlock:\n                # we are out of the AAA block\n                isAAABlock = False\n            elif isRouteMapBlock:\n                # we are out of the Route-map block\n                isRouteMapBlock = False\n            elif isVpcDomainBlock:\n                # we are out of the vPC domain block\n                isVpcDomainBlock = False\n            elif isVlanConfigBlock:\n                # we are out of the Vlan configuration block\n                isVlanConfigBlock = False                \n            elif isQosBlock:\n                # we are out of the current class-map/policy-map block\n                isQosBlock = False\n            elif isCoppBlock:\n                # we are out of the current control-plane class-map/policy-map block\n                isCoppBlock = False                \n            elif isTrackBlock:\n                # we are out of the current track config block\n                isTrackBlock = False\n            elif isNetflowBlock:\n                # we are out of the current netflow config block\n                isNetflowBlock = False\n            elif skipMmodeProfile:\n                # we are out of the current maintenance mode profile block\n                skipMmodeProfile = False\n                \n            if isN7k:\n                if (line.startswith(\"vlan access-map\")):\n                    isN7KExpandTabCli = True\n                    filteredUnaccounted.append(line)\n                    continue\n\n            if (line.startswith(\"power redundancy-mode\") or line.startswith(\"version\")):\n                # these should not be captured in the accounted configs\n                continue\n\n            if line.startswith(\"feature \"):\n                if \"tacacs\" not in line:\n                    feature_unaccounted.append(line)\n                else:\n                    AAA_Configs.append(line)\n                continue\n\n            if line.startswith(\"aaa\"):\n                global_unaccounted_AAA.append(line)\n                isAAABlock = True\n                continue\n\n            if line.startswith(\"hardware access-list tcam region\"):\n                tcamUnaccounted.append(line)\n                continue\n\n            if line.startswith(\"snmp-server \") or line.startswith(\"no snmp-server \"):\n                snmpServer_Configs.append(line)\n                continue\n\n            if line.startswith(\"ntp \"):\n                ntp_Configs.append(line)\n                continue\n\n            if line.startswith(\"route-map \"):\n                routeMap_Configs.append(line)\n                isRouteMapBlock = True\n                continue\n\n            if line.startswith(\"vpc domain \"):\n                vpcDomain_Configs.append(line)\n                isVpcDomainBlock = True\n                continue\n\n            if line.startswith(\"vlan configuration \"):\n                if \"aggregation\" in switchRole.lower():\n                    vlanConfig_Configs.append(line)\n                isVlanConfigBlock = True\n                continue\n              \n            if line.startswith(\"track \"):\n                track_Configs.append(line)\n                isTrackBlock = True\n                continue\n\n            if line.startswith(\"flow exporter \") or line.startswith(\"flow monitor \") or line.startswith(\"flow record \") or line.startswith(\"sampler \"):\n                netflow_Configs.append(line)\n                isNetflowBlock = True\n                continue\n              \n            if line.startswith(\"class-map type qos \") or line.startswith(\"policy-map type qos \"):\n                qos_Configs.append(line)\n                isQosBlock = True\n                continue\n\n            if line.startswith(\"class-map type control-plane \") or line.startswith(\"policy-map type control-plane \"):\n                copp_Configs.append(line)\n                isCoppBlock = True\n                continue\n              \n            aclCmdPrefixDict = {\"IP ACL: \":\"ip access-list \", \"IPv6 ACL: \":\"ipv6 access-list \", \"MAC ACL: \":\"mac access-list \"}\n            for aclCmdPrefix in aclCmdPrefixDict:\n                if line.startswith(aclCmdPrefixDict[aclCmdPrefix]):\n                    aclName = line[len(aclCmdPrefixDict[aclCmdPrefix]):].strip()\n                    aclNameDesc = aclCmdPrefix + aclName\n                    # look for NDI telemetry specific ACL that we need to skip\n                    if aclName == \"telemetryipv4acl\" or aclName == \"telemetryipv6acl\":\n                        skipAcl = True\n                    else:\n                        #Start of a new ip acl\n                        startCurrAclContext = True\n                        currAclCmds = []\n                        currAclCmds.append(line)\n                        skipAcl = True\n                    break    \n            if skipAcl:\n                continue\n\n            # look for either maintenance mode or normal mode profile and skip it\n            if line.startswith(\"configure maintenance profile \"):\n                skipMmodeProfile = True\n                continue\n\n            prefixListCmdDict = {\"IP Prefix-list: \":\"ip prefix-list \", \"IPv6 Prefix-list: \":\"ipv6 prefix-list \"}\n            for prefixListCmdPrefix in prefixListCmdDict:\n                if line.startswith(prefixListCmdDict[prefixListCmdPrefix]):\n                    prefixListName = line.split()[2]\n                    prefixListDesc = prefixListCmdPrefix + prefixListName\n                    if prefixListDesc not in prefixListDict:\n                        #Start a new prefix list\n                        prefixListDict[prefixListDesc] = []\n                        prefixListDict[prefixListDesc].append(line)\n                    else:\n                        #Append commands to the existing prefix list\n                        prefixListDict[prefixListDesc].append(line)\n                    skipPfxList = True\n                    break    \n            if skipPfxList:\n                continue\n                \n            if line.startswith(\"key chain \"):\n                isKeyChain = True\n                if (line == keyChainLine):\n                    keepKeyChain = True\n                    keyChainLines.append(line)\n                    continue\n        else:\n            # subcommands\n            if isN7KExpandTabCli:\n                # replace the tab with 6 spaces\n                line = line.replace(\"\\t\", \"      \")\n                Wrapper.print(\"%s: N7K line [%s]\" % (funcName, line))\n\n        if isKeyChain:\n            if keepKeyChain:\n                keyChainLines.append(line)\n            continue\n        elif isAAABlock:\n            global_unaccounted_AAA.append(line)\n            continue\n        elif isRouteMapBlock:\n            routeMap_Configs.append(line)\n            continue\n        elif isVpcDomainBlock:\n            vpcDomain_Configs.append(line)\n            continue\n        elif isVlanConfigBlock:\n            if \"aggregation\" in switchRole.lower():\n                vlanConfig_Configs.append(line)\n            continue          \n        elif isTrackBlock:\n            track_Configs.append(line)\n            continue\n        elif isNetflowBlock:\n            netflow_Configs.append(line)\n            continue          \n        elif isQosBlock:\n            qos_Configs.append(line)\n            continue\n        elif isCoppBlock:\n            copp_Configs.append(line)\n            continue          \n        elif startCurrAclContext:\n            currAclCmds.append(line)\n            continue\n        elif skipAcl:\n            continue\n        elif skipMmodeProfile:\n            continue\n          \n        filteredUnaccounted.append(line)\n\n    Wrapper.print(\"%s: %s ip access list acldict %s prefixlistdict %s\" % (funcName, fmtName, aclDict, prefixListDict))\n                    \n    # filter out the unaccounted key chain config specific to out ISIS auth key chain and key id\n    keyChainLinesFiltered = []\n    if keyChainLine != \"\":\n        for line in keyChainLines:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                ourBlock = False\n                if line == keyChainLine:\n                    ourBlock = True\n            elif depth == 1:\n                strippedLine = line.strip()\n                ourBlock = False\n                if strippedLine == isisKeyId:\n                    ourBlock = True\n\n            if ourBlock:\n                keyChainLinesFiltered.append(line)\n\n        if len(keyChainLinesFiltered) == 1:\n            keyChainLinesFiltered.clear()\n\n    Wrapper.print(\"%s: %s filteredUnaccounted %s\" % (funcName, fmtName, filteredUnaccounted))\n    #Wrapper.print(\"%s: keyChainLine [%s] isisKeyId [%s] keyChainLines %s keyChainLinesFiltered %s\" % (funcName, keyChainLine, isisKeyId, keyChainLines, keyChainLinesFiltered))\n\n    # update the 'global_unaccounted' to the filtered list for subsequent use\n    global_unaccounted = (filteredUnaccounted + keyChainLinesFiltered)\n\n    # look for the vrf references in matches for 'dns_vrf_one' and 'dns_vrf' policies\n    vrfsWithDns = []\n    dnsTemplates = ['dns-vrfList']\n    for templateName in dnsTemplates:\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            getVrfsWithDns(nvPairList, vrfsWithDns)\n\n    vrf_block = features_info[\"VRF_BLOCK\"]\n    for vrfStr in vrf_block.keys():\n        vrfRec = vrf_block[vrfStr]\n        vrfName = vrfStr.split(\" \")[2].strip()\n        Wrapper.print(\"%s: Processing DNS for VRF context [%s]\" % (funcName, vrfName))\n        \n        if vrfName.lower() == MGMT_VRF_NAME:\n            global_unaccounted += vrfRec[\"unaccounted\"]\n        else:\n            if vrfName in vrfsWithDns:\n                continue\n            newCfg = []\n            for line in vrfRec[\"show_run\"]:\n                strippedLine = line.strip()\n                if strippedLine.startswith(\"vrf context\") or strippedLine.startswith(\"ip name-server\"):\n                    newCfg.append(line)\n            if len(newCfg) > 1:\n                Wrapper.print(\"%s: VRF context [%s]. Name server cfg = [%s]\" % (funcName, vrfName, newCfg))\n                global_unaccounted += newCfg\n                #global_unaccounted += Util.newLine().join(newCfg)\n\n    if isAgg:\n        bgp_unaccounted = []\n        routerBgpKey = \"router bgp \" + BGP_AS\n        if routerBgpKey in features_info[\"BGP_BLOCK\"]:\n            bgp_unaccounted = features_info[\"BGP_BLOCK\"][routerBgpKey][\"unaccounted\"]\n    \n        #TODO:Revisit\n        #bgp_unaccounted.append(\"router bgp %s\" % BGP_AS)\n    \n        Wrapper.print(\"BGP unaccounted with template: %s\" % bgp_unaccounted)\n\n    ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n    for pti in ptiList:\n        Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n\n    if feature_unaccounted:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_TOP,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(feature_unaccounted)}, \"Additional Feature Configuration\"))\n\n    # need to process the config blocks collected from the 'show run'\n    linkProtoCfgLines = []\n    keyChainCfgLines = []\n    if isAgg:\n        cfgBlocksFromShRun = matchResult.get(\".SH_RUN_CFG_BLOCKS\", {})\n        for key in cfgBlocksFromShRun:\n            instances = cfgBlocksFromShRun[key]\n            if (key in [\"ROUTER_ISIS\", \"ROUTER_OSPF\"]):\n                for instance in instances:\n                    if underlayProtocolCfgLine == instance:\n                        # we are not interested in this since the policy matches would have captured the intent\n                        continue\n                    else:\n                        linkProtoCfgLines += instances[instance]\n            elif key == \"KEY_CHAIN\":\n                for instance in instances:\n                    if keyChainLine == instance:\n                        # look further into the key id of interest.. (will not get here is ISIS and auth is not enabled)\n                        isisKeyLines = []\n                        ourBlock = False\n                        for line in instances[instance]:\n                            depth = (len(line) - len(line.lstrip(' '))) / 2\n    \n                            if depth == 1:\n                                strippedLine = line.strip()\n                                ourBlock = False\n                                if strippedLine == isisKeyId:\n                                    ourBlock = True\n    \n                            if not ourBlock:\n                                isisKeyLines.append(line)\n                        if len(isisKeyLines) > 1:\n                            # the first line is the 'key chain <name>'\n                            keyChainCfgLines += isisKeyLines\n                    else:\n                        keyChainCfgLines += instances[instance]\n\n    switchOverlayInfo[\"PRE_INTF_FF\"] = (global_unaccounted + keyChainCfgLines + switchOverlayInfo[\"PRE_INTF_FF\"])\n    if switchOverlayInfo[\"PRE_INTF_FF\"]:\n        # this needs to show up before the interfaces\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(switchOverlayInfo[\"PRE_INTF_FF\"])}, BF_PRE_INTF_FF_PTI_DESC))\n    switchOverlayInfo[\"PRE_INTF_FF\"] = None\n\n    #Add switchfreeform for every ACL discovered in BF import\n    for aclEntry in aclDict:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 20,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(aclDict[aclEntry])}, aclEntry))\n                    \n    #Add Track configs discovered in BF import\n    if track_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 15,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(track_Configs)}, \"Track related configuration\"))\n\n    #Add QoS Class-map/Policy-map related configuration\n    if qos_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(qos_Configs)}, \"QoS Class-map/Policy-map configuration\"))\n\n    #Add CoPP Class-map/Policy-map related configuration\n    if copp_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(copp_Configs)}, \"Control-plane policing configuration\"))\n                    \n    #Add NTP related extra configuration\n    if ntp_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(ntp_Configs)}, \"NTP extra configuration\"))\n                    \n    #Add SNMP server related extra configuration\n    if snmpServer_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(snmpServer_Configs)}, \"SNMP extra configuration\")) \n\n    #Add Netflow related configuration\n    if netflow_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(netflow_Configs)}, \"Netflow configuration\")) \n                    \n    #Add switch freeform for every IPv4/v6 Prefix list\n    for prefixListEntry in prefixListDict:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 5,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(prefixListDict[prefixListEntry])}, prefixListEntry))\n                    \n    #Add Route-map related configuration\n    if routeMap_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 5,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(routeMap_Configs)}, \"Route-map configuration\"))\n\n    #Add vPC Domain related configuration\n    if vpcDomain_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 5,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(vpcDomain_Configs)}, \"vPC Domain configuration\"))\n\n    #Add Vlan configuration related configuration\n    if vlanConfig_Configs and \"aggregation\" in switchRole.lower():\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 5,\n                 \"switch_freeform\", {\"CONF\": Util.newLine().join(vlanConfig_Configs)}, \"VLAN config configuration\"))\n\n    # create the post interface unaccounted config block.. this must show up after the interfaces\n    global_unaccounted_AAA_INTF = []\n    filteredUnaccounted = []\n    if 'GLOBAL_POST_INTF_UNACCTED' in features_info:\n        if features_info[\"GLOBAL_POST_INTF_UNACCTED\"]:\n            global_unaccounted = features_info[\"GLOBAL_POST_INTF_UNACCTED\"][\"unaccounted\"]\n            for line in global_unaccounted:\n                depth = (len(line) - len(line.lstrip(' '))) / 2\n\n                if depth == 0:\n\n                    if isIpSlaBlock:\n                        isIpSlaBlock = False\n\n                    # top level config\n                    skipBlock = False\n                    if line.startswith(\"boot\"):\n                        # these should not be captured in the accounted configs\n                        continue\n                    if line.startswith(\"router ospf \") or line.startswith(\"router ospfv3 \") or line.startswith(\"router isis \"):\n                        if line != underlayProtocolCfgLine:\n                            # the entire configs for these will be obtained from the 'show run' already.. remove from here\n                            skipBlock = True\n                    elif line.startswith(\"ip sla \"):\n                        #Account for all IP SLA configs if present  \n                        ipSla_Configs.append(line)\n                        isIpSlaBlock = True\n                        continue                  \n                    elif line.startswith(\"logging \"):\n                        logging_Configs.append(line)\n                        continue\n\n                if skipBlock:\n                    Wrapper.print(\"underlayProtocolCfgLine: skipping line [%s]\" % line)\n                    continue\n\n                if (line.startswith(\"radius\") or line.startswith(\"tacacs\") or\n                    line.startswith(\"aaa\") or line.startswith(\"  server\")):\n                    global_unaccounted_AAA_INTF.append(line)\n                    continue\n\n                #Take care of child commands for IP SLA if present\n                if isIpSlaBlock:\n                    ipSla_Configs.append(line)\n                    continue\n\n                filteredUnaccounted.append(line)\n\n    postIntfFF = filteredUnaccounted + linkProtoCfgLines + switchOverlayInfo[\"POST_INTF_FF\"]\n    if postIntfFF:\n        # this needs to show up after the interfaces\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.POST_INTF_SWITCH_FF,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(postIntfFF)}, \"Post Interfaces Configuration\"))\n    switchOverlayInfo[\"POST_INTF_FF\"] = None\n\n    AAA_Configs += global_unaccounted_AAA_INTF\n    AAA_Configs += global_unaccounted_AAA\n    if AAA_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.AAA_SWITCH_FF,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(AAA_Configs)}, \"AAA extra configuration\")) \n\n    #Add IP SLA related configuration\n    if ipSla_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.POST_INTF_SWITCH_FF + 5,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(ipSla_Configs)}, \"IP SLA configuration\"))\n                    \n    #Add logging related extra configuration\n    if logging_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.POST_INTF_SWITCH_FF + 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(logging_Configs)}, \"Logging extra configuration\")) \n                    \n    if isAgg:\n        bgpFF = bgp_unaccounted + switchOverlayInfo[\"BGP_FF\"]\n        \n        if bgpFF:\n            Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_BOTTOM,\n                        \"switch_freeform\", {\"CONF\": Util.newLine().join(bgpFF)}, \"BGP Configuration\"))\n    switchOverlayInfo[\"BGP_FF\"] = None\n\n    # process leaf/spine specific global configs\n    vpcPairInfo = {}\n    if isAgg:\n        # process agg specific configs\n        createPTI(devSerial, {}, \"base_feature_agg\", \"SWITCH\", getSrc(\"base_feature_agg\"), -1)\n        templateName = \"feature_ospf\" if UNDERLAY_IS_V6 == \"false\" else \"feature_ospfv3\"\n        createMatchedPtis(devSerial, matchResult, templateName)\n        createMatchedPtis(devSerial, matchResult, \"feature_lacp\")\n        createMatchedPtis(devSerial, matchResult, \"feature_pim\")\n        createMatchedPtis(devSerial, matchResult, \"feature_dhcp\")\n        createMatchedPtis(devSerial, matchResult, \"eth_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv4_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv6_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"base_dhcp\")\n\n        # create the extra CLIs PTI (we will not match these from the config)\n        if EXTRA_CONF_LEAF != \"\":\n            createPTI(devSerial, {\"CONF\": EXTRA_CONF_LEAF}, \"extra_config_leaf\",\n                                  \"SWITCH\", \"UNDERLAY\", -1)\n    else:\n        #access role scenario\n        createMatchedPtis(devSerial, matchResult, \"feature_lacp\")\n        createMatchedPtis(devSerial, matchResult, \"eth_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv4_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv6_cfs\")\n\n        # create the extra CLIs PTI (we will not match these from the config)\n        if EXTRA_CONF_TOR != \"\":\n            createPTI(devSerial, {\"CONF\": EXTRA_CONF_TOR}, \"extra_config_tor\",\n                                  \"SWITCH\", \"UNDERLAY\", -1)\n                                  \n    #VPC pairing is mandatory at aggregation layer but optional at access layer                              \n    if isValidVPC:\n        vpcPairInfo[\"domainId\"] = vPCInfo[\"domainId\"]\n\n        createMatchedPtis(devSerial, matchResult, \"vpc_domain_mgmt\")\n        createMatchedPtis(devSerial, matchResult, \"vpc_domain_ipv6_nd_11_1\")\n        peerSerial = getVPCPeerDeviceSN(devSerial, vpcSrcToDstMacMap)\n        if peerSerial:\n            Util.exe(VpcWrapper.create(devSerial, peerSerial))\n\n        vpcPeerLinkPoNvPairs = { \"PO_ID\" : \"\",\n                                 \"NATIVE_VLAN\" : \"\",\n                                 \"DESC\" : \"\",\n                                 \"ALLOWED_VLAN\":\"\",\n                                 \"MEMBER_DESC\":\"\",\n                                 \"ADMIN_STATE\" : \"true\",\n                                 \"MEMBER_INTERFACES\":\"\",\n                                 \"CONF\":\"\"\n                               }\n\n        # lookup the vpc peer link PO\n        vpcMCTPoId = \"\"\n        pcRmId = -1\n        templateName = \"vpc_peer_link_po_interface\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            # we expect only one nv pair\n            entityType = getEType(templateName)\n            entityName = getEntityName(devSerial, entityType, nvPairList[0], templateName)\n            intfMatchResult = interfacesRes[entityName]\n\n            vpcPeerLinkPoNvPairs.update({\"PO_ID\" : entityName})\n\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(entityName, sys._getframe().f_lineno))\n\n            # set the PO id resource\n            portChannelIntf = entityName.lower()\n            pc, vpcMCTPoId = portChannelIntf.split(\"port-channel\")\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC Peer-Link PO: PORT_CHANNEL_ID [%s]\"%\n                          (FABRIC_NAME, key, vpcMCTPoId))\n            ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, entityName, vpcMCTPoId))\n\n            # get the interface template results to get additional info\n            templateNameMatches = intfMatchResult[\"matched_templates\"]\n            templateList = [\"interface_desc\"]\n            matchingNvPairs = getIntfMatchNvPairs(matchResult, entityName, templateList)\n            if matchingNvPairs:\n                vpcPeerLinkPoNvPairs.update({\"DESC\" : matchingNvPairs[\"interface_desc\"][\"DESC\"]})\n\n            if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                Wrapper.print(\"Device [%s] Found unaccounted cfg for portchannel intf [%s]\" % (devSerial, portChannelIntf))\n\n                # we need to scan and extract the trunk native vlan from the unaccounted config\n                vpcPeerLinkPoNvPairs[\"NATIVE_VLAN\"], updatedFFCfgList = getNativeVlanAndUpdatedUnacctCfgList(\n                                        intfMatchResult[\"unaccounted_cmds\"])\n\n                # set the updated extra config\n                vpcPeerLinkPoNvPairs.update({\"CONF\": Util.newLine().join(updatedFFCfgList)}) \n\n            templateList = [\n                            \"interface_speed\",\n                            \"interface_no_nego_auto\",\n                            \"bpduguard_disable\", \n                            \"bpduguard_enable\", \n                            \"porttype_fast_trunk\",\n                            \"porttype_fast_enable\",\n                            \"access_vlan\",\n                            \"cdp_disable_interface_11_1\"\n                           ]\n\n            configList = unaccCfgFromTemplates(portChannelIntf, templateList, intfMatchResult, matchResult)\n            if vpcPeerLinkPoNvPairs[\"CONF\"] and configList:\n                vpcPeerLinkPoNvPairs[\"CONF\"] = vpcPeerLinkPoNvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                vpcPeerLinkPoNvPairs[\"CONF\"] = Util.newLine().join(configList)\n            Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"% \n                         (devSerial, portChannelIntf, vpcPeerLinkPoNvPairs.get(\"CONF\")))\n\n         # lookup the vpc peer link peer members\n        templateName = \"vpc_peer_link_member_interface\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        vpcPeerLinkMemberInterfaces = []\n        if (nvPairList != None):\n            for memberNvPair in nvPairList:\n                if (vpcMCTPoId != memberNvPair[\"PCID\"]):\n                    # this interface does not belong to the MCT\n                    continue\n\n                entityType = getEType(templateName)\n                entityName = getEntityName(devSerial, entityType, memberNvPair, templateName)\n                intfMatchResult = interfacesRes[entityName]\n\n                # mark the interface as being processed\n                intfMatchResult.update({\"isProcessed\" : True})\n                Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(entityName, sys._getframe().f_lineno))\n\n                vpcPeerLinkMemberInterfaces.append(entityName)\n            \n                # check to see if we need the peer serial\n                try:\n                    if (vpcPairInfo[\"peerSerialNum\"] != None):\n                        # we have the info already... skip\n                        continue\n                except:\n                    # the 'peerSerialNum' key does not exist.. \n                    peerSerial = topologyDataObj.getNeighborDeviceSN(devSerial, entityName)\n                    if not (peerSerial == \"\" or peerSerial == 0):\n                        # we have a valid peer... check if it's state is complete\n                        if not isSwitchInUnderlayMigration(peerSerial):\n                            # the expected PTIs should be in place\n                            Wrapper.print(\"vPC: peer serial %s\" % peerSerial)\n                            vpcPairInfo.update({\"peerSerialNum\" : peerSerial})\n                        else:\n                            Wrapper.print(\"vPC: Found peer [%s], but, not migrated\" % peerSerial)\n\n            vpcPeerLinkPoNvPairs.update({\"MEMBER_INTERFACES\" : \",\".join(vpcPeerLinkMemberInterfaces)})\n        if vpcPairInfo.get(\"vpcFabricPair\"):\n            peerSerial = getVPCPeerDeviceSN(devSerial, vpcSrcToDstMacMap)\n            if not (peerSerial == \"\" or peerSerial == 0):\n                # we have a valid peer... check if it's state is complete\n                if not isSwitchInUnderlayMigration(peerSerial):\n                    # the expected PTIs should be in place\n                    Wrapper.print(\"vPC: peer serial %s\" % peerSerial)\n                    vpcPairInfo.update({\"peerSerialNum\" : peerSerial})\n                else:\n                    Wrapper.print(\"vPC: Found peer [%s], but, not migrated\" % peerSerial)\n            vpcPeerLinkPoNvPairs.update({\"MEMBER_INTERFACES\" : \"\"})\n            \n        if VPC_PEER_LINK_ALL_VLAN_DISABLE == \"true\":\n            vpcPeerLinkPoNvPairs.update({\"ALLOWED_VLANS\":\"none\"})\n        # we will go ahead and create the vpc peer link PO policy\n        createPTI(devSerial, vpcPeerLinkPoNvPairs, \"int_vpc_peer_link_po\", \n                  vpcPeerLinkPoNvPairs[\"PO_ID\"], \"\", pcRmId)\n        ptiTemplate = \"int_vpc_peer_link_po_member_11_1\"\n        poMemberDescAndFFUpd(devSerial, vpcPeerLinkMemberInterfaces, ptiTemplate, \n                             vpcMCTPoId, matchResult, interfacesRes, portChannelIntf)\n\n        # take care of setting the vPC related resouces in RM\n        # check if we have the peer serial number\n        peerSerial = \"\"\n        try:\n            peerSerial = vpcPairInfo[\"peerSerialNum\"]\n        except:\n            Wrapper.print(\"vPC: peer serial # does not exist.. skip setting up resources\")\n\n        if (peerSerial != \"\"):\n\n            # check that the roles of the two peers are consistent before making them a vpcPair\n            peerSwitchRole = topologyDataObj.getSwitchRole(peerSerial)\n            if switchRole != peerSwitchRole:\n                respObj.addErrorReport(getFabErrEntity(funcName, \"VPC_PAIR_ROLE\"),\n                    \"Inconsistent Role [%s] with vPC Peer switch [%s] Role [%s]. Please set roles correctly and \"\n                    \"retry.\" % (switchRole, getFormattedSwitchName(peerSerial), peerSwitchRole), devSerial)\n                respObj.setFailureRetCode()\n            else:\n                # mark the pair as a vPC\n                Wrapper.print(\"vPC: Marking [%s:%s] a pair\" % (devSerial, peerSerial))\n                if vpcPairInfo.get(\"vpcFabricPair\"):\n                    Util.exe(VpcWrapper.create(devSerial, peerSerial, \"true\"))\n                else:\n                    Util.exe(VpcWrapper.create(devSerial, peerSerial))\n\n                vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n                serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n                if ENABLE_FABRIC_VPC_DOMAIN_ID == \"false\":\n                    # Fabric setting is for unique vpc domain ids.. set the vPC domain ID in RM\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: VPC_DOMAIN_ID [%s]\"% \n                                  (FABRIC_NAME, vpcPairSerialKey, vpcPairInfo[\"domainId\"]))\n                    Util.exe(RM.set(FABRIC_NAME, \"VPC_DOMAIN_ID\", vpcPairSerialKey, vpcPairInfo[\"domainId\"]))\n\n                # dummy PTIs to check in easy fabric\n                createPTI(devSerial, {\"VPC_SERIAL\":vpcPairSerialKey}, \"vpc_serial_simulated\", \"SWITCH\", \"\" , -1)\n                createPTI(peerSerial, {\"VPC_SERIAL\":vpcPairSerialKey}, \"vpc_serial_simulated\", \"SWITCH\", \"\" , -1)\n\n    try:\n        ECLdeviceUpgradeIntf(gVarDictObj, matchResult, interfacesRes, isValidVPC, device_overlay_vlans, vpcPairInfo, respObj)\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error during interface migration\" % getFormattedSwitchName(devSerial))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":INTERFACE_MIGRATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n\n    if not respObj.isRetCodeFailure():\n        # create the IFCs\n        createIFCs(dictionaryObj, switchOverlayInfo, interfacesRes, respObj)\n\n    if not respObj.isRetCodeFailure():\n        if (doOverlayMigr and (migrateMode == \"brownAdd\")):\n            # save the switch overlay info to a file\n            writeToFile(dictionaryObj[\"overlayInfoFileName\"], json.dumps(switchOverlayInfo, indent=4, sort_keys=True), respObj)\n\n        takeSwitchOutOfUnderlayMigrMode(FABRIC_NAME, devSerial)\n\n    Wrapper.print(\"%s: Device [%s]. Success = [%r]\" % (funcName, devSerial, respObj.isRetCodeSuccess()))\n    return respObj\n\ndef ECLcheckOspfAuthAndIntfs(devSerial, matchResult, interfacesRes, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    if VRF_LITE_PROTOCOL != \"ospf\":\n        return\n\n    if LINK_STATE_ROUTING_TAG != \"\":\n        nvPairList = getTemplateMatchResults(matchResult, \"base_ospf_auth\")\n        if (nvPairList != None):\n            # there could be multiple OSPF instances.. look for the one matching the fabric setting\n            for nvPair in nvPairList:\n                if nvPair[\"OSPF_TAG\"] == LINK_STATE_ROUTING_TAG:\n                    if nvPair[\"OSPF_AREA_ID\"] != OSPF_AREA_ID:\n                        # OSPF Area Id for the OSPF instance does not match the fabric settings\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                            \"OSPF Message Digest Authentication found for default VRF, but Area Id for OSPF instance [%s] \"\n                            \"does not match the fabric settings. Expected Area Id [%s], default VRF has [%s].\" %\n                            (LINK_STATE_ROUTING_TAG, OSPF_AREA_ID, nvPair[\"OSPF_AREA_ID\"]), devSerial)\n                        respObj.setFailureRetCode()\n                    break\n\n        nvPairList = getTemplateMatchResults(matchResult, \"vrf_ospf_auth\")\n        if (nvPairList != None):\n            # there could be multiple OSPF instances.. look for the one matching the fabric setting\n            for nvPair in nvPairList:\n                if nvPair[\"OSPF_TAG\"] == LINK_STATE_ROUTING_TAG:\n                    if nvPair[\"OSPF_AREA_ID\"] != OSPF_AREA_ID:\n                        # OSPF Area Id for the OSPF instance does not match the fabric settings\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                            \"OSPF Message Digest Authentication found for VRF [%s], but Area Id for OSPF instance [%s] \"\n                            \"does not match the fabric settings. Expected Area Id [%s], VRF has [%s].\" %\n                            (nvPair[\"VRF_NAME\"], LINK_STATE_ROUTING_TAG, OSPF_AREA_ID, nvPair[\"OSPF_AREA_ID\"]), devSerial)\n                        respObj.setFailureRetCode()\n\n        for intfName in sorted(interfacesRes.keys()):\n            nvPair = getIntfTemplateNvpair(intfName, \"ospf_interface_11_1\", matchResult)\n            if nvPair:\n                if ((nvPair[\"OSPF_TAG\"] != LINK_STATE_ROUTING_TAG) or (nvPair[\"OSPF_AREA_ID\"] != OSPF_AREA_ID)):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF\"),\n                        \"Interface [%s]: OSPF related configuration mismatch. Found Process ID/Area [%s, %s], Expected [%s, %s]\" %\n                        (intfName, nvPair[\"OSPF_TAG\"], nvPair[\"OSPF_AREA_ID\"], LINK_STATE_ROUTING_TAG, OSPF_AREA_ID), devSerial)\n                    respObj.setFailureRetCode()\n\n    if OSPFv3_ROUTING_TAG != \"\":\n        for intfName in sorted(interfacesRes.keys()):\n            nvPair = getIntfTemplateNvpair(intfName, \"v6_ospf_interface\", matchResult)\n            if nvPair:\n                if ((nvPair[\"OSPF_TAG\"] != OSPFv3_ROUTING_TAG) or (nvPair[\"OSPF_AREA_ID\"] != OSPFv3_AREA_ID)):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPFv3\"),\n                        \"Interface [%s]: OSPFv3 related configuration mismatch. Found Process ID/Area [%s, %s], Expected [%s, %s]\" %\n                        (intfName, nvPair[\"OSPF_TAG\"], nvPair[\"OSPF_AREA_ID\"], OSPFv3_ROUTING_TAG, OSPFv3_AREA_ID), devSerial)\n                    respObj.setFailureRetCode()\n\ndef ECLfabricUpgrade(gVarDictObj, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    try:\n        dictionaryObj = gVarDictObj[\"DICTIONARY_OBJ\"]\n        devSerial = dictionaryObj[\"deviceSerial\"]\n        topologyDataObj = gVarDictObj[\"topologyObj\"]\n        matchResult = dictionaryObj[\"matchResult\"]\n        interfacesRes = dictionaryObj[\"interfacesRes\"]\n\n        # build a dictionary of the BGP neighbors so that we can validate only BGP related entries that match our AS#.\n        # Note: this will be used in deviceUpgrade\n        bgpNeighborDict = {}\n        dictionaryObj[\"bgpNeighborDict\"] = bgpNeighborDict\n\n        switchRole = dictionaryObj[\"switchRole\"]\n        hostName = dictionaryObj[\"hostName\"]\n        formattedName = dictionaryObj[\"fmtName\"]\n        model = dictionaryObj[\"deviceModel\"]\n\n        Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s: Switch [%s] Model [%s] Role [%s]  isN9KTahoe [%r]\" %\n                (FABRIC_NAME, funcName, formattedName, model, switchRole, (not dictionaryObj[\"n9kIsNotTahoe\"])))\n\n        # port-profiles are not supported... look for them and report error\n        features_info = matchResult[\"FEATURES_INFO\"]\n        global_unaccounted = features_info[\"GLOBAL_UNACCTED\"][\"unaccounted\"]\n        isCdpError = False\n        isPortProfileFound = False\n        for line in global_unaccounted:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                if (line.startswith(\"port-profile\")):\n                    # port-profiles are not supported\n                    isPortProfileFound = True\n                elif ((line == \"no cdp enable\") or (line.startswith(\"cdp format device-id\"))):\n                    # CDP is disabled or system id is not in expected format\n                    isCdpError = True\n\n        if isPortProfileFound:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":PORT_PROFILE\"),\n                \"Port-Profiles are not supported. Please unconfigure all the port-profiles and retry.\",\n                devSerial)\n            respObj.setFailureRetCode()\n\n        if isCdpError:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial + \":CDP\"),\n                \"CDP is disabled and/or system id is in unexpected format. Please check documentation \"\n                \" for CDP requirements to update the switch configuration and retry.\", devSerial)\n            respObj.setFailureRetCode()\n\n        vPCInfo = {\"virtualVPC\" : False, \"userPeerLinkVlanPtiId\" : None, \"peerLinkVlan\" : VPC_PEER_LINK_VLAN}\n        vPCInfo[\"hasVpcConfig\"], vPCInfo[\"domainId\"] = getVpcDomainId(devSerial, matchResult)\n        dictionaryObj[\"vpcInfo\"] = vPCInfo\n\n        if vPCInfo[\"domainId\"]:\n            #   - check to make sure we have atleast one match for each of the vPC related templates\n            vpcTemplates = getECLVpcMandatoryTemplateList(dictionaryObj[\"n9kIsNotTahoe\"])\n            for templateName in vpcTemplates:\n                if (getTemplateMatchResults(matchResult, templateName) == None):\n                    # did not find any matches... vPC config is inconsistent\n                    Wrapper.print(\"%s: Switch [%s] Did not find a match for vPC template [%s]\" % (funcName, formattedName, templateName))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC\"),\n                               \"Did not find expected vPC configuration for [%s] template.\" % (templateName), devSerial)\n                    respObj.setFailureRetCode()\n                    isValidVPC = False\n            vPCInfo[\"virtualVPC\"] = False\n        else:\n            if vPCInfo[\"hasVpcConfig\"]:\n                # we did not find the vPC domain config match, report an error\n                templateName = \"base_vpc_domain_11_1\"\n                domainId = \"1000\"\n                if ENABLE_FABRIC_VPC_DOMAIN_ID == \"true\":\n                    domainId = FABRIC_VPC_DOMAIN_ID\n                params = {\"DOMAIN_ID\" : domainId}\n                cfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, params, False, None)\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC\"),\n                       \"Please ensure the following vPC domain configuration exists: %s%s\" % (Util.newLine(), cfg), devSerial)\n                respObj.setFailureRetCode()\n\n        Wrapper.print(\"%s: Switch [%s] vPC Info [%s]\" % (funcName, formattedName, vPCInfo))\n\n        if switchRole.lower() == \"aggregation\":\n            # check the Fabric Settings for VRF_LITE_PROTOCOL related configured values\n            if VRF_LITE_PROTOCOL == \"ospf\":\n                if LINK_STATE_ROUTING_TAG != \"\":\n                    ospfInstanceNvpair = None\n                    nvPairList = getTemplateMatchResults(matchResult, \"router_ospf\")\n                    if (nvPairList != None):\n                        # there could be multiple OSPF instances.. look for the one matching the fabric setting\n                        for nvPair in nvPairList:\n                            if nvPair[\"OSPF_TAG\"] == LINK_STATE_ROUTING_TAG:\n                                ospfInstanceNvpair = nvPair\n                                break\n\n                    if not ospfInstanceNvpair:\n                        # we did not find the expected OSPF instance\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF Routing Tag\"),\n                           \"Did not find OSPF instance [%s] that matches the fabric settings. \"\n                           \"Please ensure device has expected configuration of 'router ospf'.\" %\n                           (LINK_STATE_ROUTING_TAG), devSerial)\n                        respObj.setFailureRetCode()\n\n                if OSPFv3_ROUTING_TAG != \"\":\n                    ospfInstanceNvpair = None\n                    nvPairList = getTemplateMatchResults(matchResult, \"router_ospfv3\")\n                    if (nvPairList != None):\n                        # there could be multiple OSPF instances.. look for the one matching the fabric setting\n                        for nvPair in nvPairList:\n                            if nvPair[\"OSPF_TAG\"] == OSPFv3_ROUTING_TAG:\n                                ospfInstanceNvpair = nvPair\n                                break\n\n                    if not ospfInstanceNvpair:\n                        # we did not find the expected OSPFv3 instance\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPFv3 Routing Tag\"),\n                           \"Did not find OSPFv3 instance [%s] that matches the fabric settings. \"\n                           \"Please ensure device has expected configuration of 'router ospfv3'.\" %\n                           (OSPFv3_ROUTING_TAG), devSerial)\n                        respObj.setFailureRetCode()\n            elif VRF_LITE_PROTOCOL == \"ebgp\":\n                # check if the BGP AS # matches the configured value\n                bgpConfigFound = False\n                # use base bgp if router id is there which is optional for vlan fabric\n                nvPairList = getTemplateMatchResults(matchResult, \"base_bgp\")\n                if (nvPairList != None):\n                    bgpConfigFound = True\n                    # we expect only one\n                    switchBgpAs = nvPairList[0][\"BGP_AS\"].strip()\n                    if switchBgpAs != BGP_AS:\n                        Wrapper.print(\"Switch is Aggregation, but no BGP config configured\")\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AS\"),\n                                               \"BGP AS # [%s] on the device is not matching with \"\n                                               \"fabric setting BGP AS # [%s]\" % (switchBgpAs, BGP_AS), devSerial)\n                        respObj.setFailureRetCode()\n                        # proceed to next error check\n                else:\n                    bgpAsUnacc = \"\"\n                    for bgpCmd in features_info[\"BGP_BLOCK\"]:\n                        if \"router bgp \" in bgpCmd:\n                             bgpAsUnacc = bgpCmd.split(\"router bgp \")[1].strip()\n                             break\n                    if bgpAsUnacc != \"\" and bgpAsUnacc != BGP_AS:\n                        Wrapper.print(\"Switch is Aggregation, but no BGP config configured in unaccounted also\")\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AS\"),\n                                               \"BGP AS # [%s] on the device is not matching with \"\n                                               \"fabric setting BGP AS # [%s]\" % (bgpAsUnacc, BGP_AS), devSerial)\n                        respObj.setFailureRetCode()\n                    elif bgpAsUnacc == \"\":\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AS\"),\n                                               \"ebgp routing protocol is enabled in fabric settings, \"\n                                               \"please ensure device also has expected bgp configuration\", devSerial)\n                        respObj.setFailureRetCode()\n\n            ECLcheckOspfAuthAndIntfs(devSerial, matchResult, interfacesRes, respObj)\n\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error during configuration consistency check\" % formattedName)\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":CONFIG_CHECK\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Switch [%s]. Success = [%r]\" % (FABRIC_NAME,\n            funcName, formattedName, respObj.isRetCodeSuccess()))\n        return respObj\n\ndef getMatchResultObjFromGOI(fabricName, deviceSn, globalOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n    Wrapper.print(\"switchDict [%s]\"%(switchDict))\n    matchResult = Util.exe(getJSONFileContents(switchDict[\"matchResultsFileName\"]))\n    return matchResult\n   \n\ndef ECLhandleVlanFF(fabricName, deviceSn, globalOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n    overlayVlansList = switchOverlayInfo[\"OVERLAY_VLANS\"]\n    matchResult = getMatchResultObjFromGOI(fabricName, deviceSn, globalOverlayInfo)\n    Wrapper.print(\"matchResult [%s]\"%(matchResult))\n    if not matchResult:\n        return \n    featuresInfo = matchResult[\"FEATURES_INFO\"]\n\n    globalUnaccounted = featuresInfo[\"GLOBAL_UNACCTED\"][\"unaccounted\"]\n    vlanInfoDict = featuresInfo[\"VLAN_BLOCK\"]\n    Wrapper.print(\"%s: Switch [%s] collecting (%d) Networks/ (%d) Vrfs\" % \n                  (funcName, deviceSn, len(switchOverlayInfo[\"NETWORKS_BY_ID\"]),\n                   len(switchOverlayInfo[\"VRFS_BY_ID\"])))\n    Wrapper.print(\"vlanInfoDict [%s] overlayVlansList [%s]\"%(vlanInfoDict, overlayVlansList))\n    vlanIdFFDict = {}\n    overlayVlansStrList = map(str, overlayVlansList)\n    for vlanIdCmd in vlanInfoDict:\n        #Wrapper.print(\"vlan cmd [%s] \"%(vlanIdCmd))\n        vlanId = vlanIdCmd.lstrip(\"vlan \")\n        vlanCmdsDict = vlanInfoDict.get(vlanIdCmd)\n        #Wrapper.print(\"vlan  [%s] cmdInfoDict %s\"%(vlanId, vlanCmdsDict))\n        unacctdPresent = False\n        if vlanId in overlayVlansStrList:\n            l1 = vlanIdMatchedCmdsList = vlanCmdsDict[\"show_run\"]\n            l2 = vlanIdUnaccCmdsList = vlanCmdsDict[\"unaccounted\"]\n            #Wrapper.print(\"vlan  [%s] vlanIdMatchedCmdsList %s\"%(vlanId, vlanIdMatchedCmdsList))\n            #Wrapper.print(\"vlan  [%s] vlanIdUnaccCmdsList %s\"%(vlanId, vlanIdUnaccCmdsList))\n            isVlanIdBlock = False\n            vlanCmdsListForFF = []\n            pairs = itertools.izip_longest(l1, l2)\n            for (i,j) in pairs:\n                if i == j:\n                    vlanCmdsListForFF.append(i) \n                elif i:\n                    vlanCmdsListForFF.append(i)\n                elif j:\n                    vlanCmdsListForFF.append(j)\n            #Wrapper.print(\"vlanId [%s] vlanCmdsListForFF [%s]\"%(vlanId, vlanCmdsListForFF))\n            if len(vlanCmdsListForFF) < 2:\n                #vlan id command alone is not needed\n                continue\n            vlanIdFFDict[vlanId] = []\n            vlanIdFFList = vlanIdFFDict[vlanId]\n            for line in vlanCmdsListForFF:\n                depth = (len(line) - len(line.lstrip(' '))) / 2\n                if depth == 0:\n                    if isVlanIdBlock:\n                        # we are out of the Vlan configuration block\n                        isVlanIdBlock = False\n                    if line.startswith(\"vlan \"):\n                        vlanIdFFList.append(line)\n                        isVlanIdBlock = True\n                        continue\n                if isVlanIdBlock and line not in vlanIdFFList:\n                    unacctdPresent = True\n                    vlanIdFFList.append(line)\n            Wrapper.print(\"vlan id [%s] vlanIdFFList [%s]\"%(vlanId, vlanIdFFDict[vlanId]))\n    Wrapper.print(\"vlanIdFFDict [%s]\"%(vlanIdFFDict))\n\n    vlanConfigFFDict = {}\n    vlanConfigOverlayFFDict = {}\n    vlanConfigNoOverlayFFDict = {}\n    isVlanConfigBlock = False\n    vlanConfigFFList = []\n    vlanConfigId = \"\"\n    for line in globalUnaccounted:\n        depth = (len(line) - len(line.lstrip(' '))) / 2\n        if depth == 0:\n            if isVlanConfigBlock:\n                # we are out of the Vlan configuration block\n                isVlanConfigBlock = False\n            if line.startswith(\"vlan configuration \"):\n                vlanConfigId = line.lstrip(\"vlan configuration \") \n                #Wrapper.print(\"vlanConfigId [%s]  line [%s]\"%(vlanConfigId, line))\n                if vlanConfigId in overlayVlansStrList:\n                    vlanConfigFFDict = vlanConfigOverlayFFDict \n                else:\n                    vlanConfigFFDict = vlanConfigNoOverlayFFDict \n                vlanConfigFFDict[vlanConfigId] = []\n                vlanConfigFFList = vlanConfigFFDict[vlanConfigId]\n                vlanConfigFFList.append(line)\n                isVlanConfigBlock = True\n                continue\n        if isVlanConfigBlock and vlanConfigId:\n            #Wrapper.print(\"isVlanConfigBlock [%s] vlanConfigId [%s]  line [%s]\"%(isVlanConfigBlock, vlanConfigId, line))\n            vlanConfigFFList = vlanConfigFFDict[vlanConfigId]\n            vlanConfigFFList.append(line)\n            continue\n        Wrapper.print(\"vlanConfigFFList [%s]\"%(vlanConfigFFList))\n    Wrapper.print(\"vlanConfigFFDict [%s]\"%(vlanConfigFFDict)) \n    \n    vlaIdFreeformDict = {} \n    finalFreeformDict = mergeNestedDict(vlanIdFFDict, vlanConfigFFDict)\n\n    Wrapper.print(\"finalFreeformDict [%s]\"%(finalFreeformDict))\n    for vlanId in finalFreeformDict:\n        finalVlanIdFreeform = finalFreeformDict[vlanId]\n        vlanFreeformStr = \"\"\n        if vlanId in overlayVlansStrList and len(finalVlanIdFreeform) == 2:\n            vlanIdFFStr = Util.newLine().join(finalVlanIdFreeform[0])\n            vlanConfigFFStr = Util.newLine().join(finalFreeformDict[vlanId][1])\n            vlanFreeformStr = vlanIdFFStr + Util.newLine() + vlanConfigFFStr\n            Wrapper.print(\"vlanIdFFStr [%s]\"%(vlanIdFFStr))\n            Wrapper.print(\"vlanConfigFFStr [%s]\"%(vlanConfigFFStr))\n        elif len(finalVlanIdFreeform) == 1:\n            # vlan configuration commands are combined with same subcommands\n            vlanFreeformStr = Util.newLine().join(finalVlanIdFreeform[0])\n        Wrapper.print(\"vlanFreeformStr [%s]\"%(vlanFreeformStr))\n        if vlanFreeformStr:\n            ptiDescription = \"Vlan %s extra configuration\"%(vlanId)\n            Util.exe(PTIWrapper.create(deviceSn, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 5,\n                    \"switch_freeform\", {\"CONF\": vlanFreeformStr}, ptiDescription))\ndef mergeNestedDict(d1, d2):\n    d = {}\n    for key in set(list(d1.keys()) + list(d2.keys())):\n        try:\n            d.setdefault(key,[]).append(d1[key])        \n        except KeyError:\n            pass\n\n        try:\n            d.setdefault(key,[]).append(d2[key])          \n        except KeyError:\n            pass\n    return d\ndef ECLhandleOverlayMigrationInt(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj, topologyDataObj, vrfSviInstanceValues):\n    funcName = sys._getframe(0).f_code.co_name\n    switchesNeedingOverlayMigration = []\n    borderSwitches = []\n    nonBorderSwitches = []\n    Wrapper.print(\"%s %s: Start - FABRIC [%s] OVERLAY_MODE [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, OVERLAY_MODE))\n\n    # at this point the underlay migration is complete for all switches and we are ready for the overlay migration\n    for deviceSn in devices:\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n\n        # skip access role switches for now\n        if switchDict[\"switchRole\"] == \"access\":\n            Wrapper.print(\"%s %s: handle access switch vlan freeform\"%(fabricName, deviceSn))\n            ECLhandleVlanFF(fabricName, deviceSn, globalOverlayInfo)\n            continue\n  \n        if not isSwitchInOverlayMigration(deviceSn):\n            continue\n        \n        # retrieve the switch overlay info from the file stored during the underlay migration\n        Wrapper.print(\"%s: Switch [%s] - Loading overlay info from file [%s]\" % (funcName, \n            switchDict[\"fmtName\"], switchDict[\"overlayInfoFileName\"]))\n        switchOverlayInfo = Util.exe(getJSONFileContents(switchDict[\"overlayInfoFileName\"]))\n\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            borderSwitches.append(deviceSn)\n        else:\n            nonBorderSwitches.append(deviceSn)\n\n    # make the list such that all the border switches are at the end\n    switchesNeedingOverlayMigration = nonBorderSwitches + borderSwitches\n\n    # dictionary of all VRFs in the fabric. Key is the VRF vni (string)\n    allOverlayVrfs = {}\n\n    # dictionary of all networks in the fabric. Key is the network vni (integer)\n    allOverlayNets = {}\n\n    # process all the networks/vrf on the switches\n    for deviceSn in switchesNeedingOverlayMigration:\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n        switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n\n        Wrapper.print(\"%s: Switch [%s] Role [%s] collecting (%d) Networks/ (%d) Vrfs\" % (funcName,\n            switchDict[\"fmtName\"], switchDict[\"switchRole\"], len(switchOverlayInfo[\"NETWORKS_BY_ID\"]), \n            len(switchOverlayInfo[\"VRFS_BY_ID\"])))\n\n        ECLsetOverlayVrfReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayVrfs)\n        ECLsetOverlayNetReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayNets, globalOverlayInfo, respObj)\n\n    profInfo = globalOverlayInfo['cfgProfileInfo']\n    if not profInfo[\"hasCfgProfile\"]:\n        # do some validations\n        #   - the vrfVlanName, maxBgpPaths, maxIbgpPaths must be the same on all switches\n        #   - the network must be L2 or L3 on every leaf switch (no missing SVI)\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 70, \"Brownfield - Checking Overlay information consistency\") \n        for deviceSn in switchesNeedingOverlayMigration:\n            switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n            switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n\n            # check all the vrf entries for this switch with the vrf entry we plan to use to create\n            Wrapper.print(\"%s %s: Validating VRF params for switch [%s]\" % (OVERLAY_PREFIX, funcName, switchDict[\"fmtName\"]))\n            for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n                refVrfEntry = allOverlayVrfs[vrfEntry[\"name\"]]\n                if refVrfEntry[\"refSwitchSerial\"] == deviceSn:\n                    continue\n                refVrfTemplParams = refVrfEntry[\"vrfEntry\"][\"vrfTemplateParams\"]\n                allMatch = True\n                for param in refVrfTemplParams:\n                    if (param in [\"vrfDescription\"]):\n                        continue\n                    if param in vrfEntry[\"vrfTemplateParams\"]:\n                        if not checkOverlayParam(refVrfEntry[\"vrfEntry\"][\"name\"], param, refVrfEntry[\"refSwitchSerial\"], \n                            deviceSn, refVrfTemplParams[param], vrfEntry[\"vrfTemplateParams\"][param], respObj):\n                            allMatch = False\n                if not allMatch:\n                    Wrapper.print(\"%s: Fabric [%s] VRF param mismatch: Switch [%s] Ref [%s] - Params [%s] refVrfTemplParams [%s]\" %\n                        (funcName, FABRIC_NAME, switchDict[\"fmtName\"], refVrfEntry[\"refSwitchSerial\"], vrfEntry[\"vrfTemplateParams\"], refVrfTemplParams))\n\n            # check all the network entries for this switch with the network entry we plan to use to create\n            Wrapper.print(\"%s %s: Validating Network params for switch [%s] [%s]\" % (OVERLAY_PREFIX, funcName, switchDict[\"fmtName\"], allOverlayNets))\n            for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n                refNetEntry = allOverlayNets[netEntry[\"vlanId\"]]\n                if refNetEntry[\"refSwitchSerial\"] == deviceSn:\n                    continue\n                refNetTemplParams = refNetEntry[\"netEntry\"][\"netTemplateParams\"]\n\n                Wrapper.print(\"%s %s: netEntry[%s] refNetEntry[%s]\" % (funcName, switchDict[\"fmtName\"], netEntry, refNetEntry))\n\n                #\n                #Network should only be present on 2 Agg peers of a given vPC Agg pair\n                #RefEntry will have switch specific fields like pip1, ipv6_pip1, activePriority, intfDescription\n                #These fields from netEntry need to be populated to pip2, ipv6_pip2, standbyPriority, intfDescription2\n                #TODO: Handle various error cases\n                refNetTemplParams[\"pip2\"] = netEntry[\"netTemplateParams\"][\"pip1\"]\n                refNetTemplParams[\"ipv6_pip2\"] = netEntry[\"netTemplateParams\"][\"ipv6_pip1\"]\n                refNetTemplParams[\"standbyPriority\"] = \"100\" if not netEntry[\"netTemplateParams\"][\"activePriority\"] else netEntry[\"netTemplateParams\"][\"activePriority\"]\n                refNetTemplParams[\"intfDescription2\"] = netEntry[\"netTemplateParams\"][\"intfDescription\"]\n                \n \n                allMatch = True\n                for param in refNetTemplParams:\n\n                    if (param in [\"pip1\", \"pip2\", \"ipv6_pip1\", \"ipv6_pip2\", \"activePriority\", \"standbyPriority\", \"intfDescription\", \"intfDescription2\"]):\n                        continue                \n                    \n                    if param in netEntry[\"netTemplateParams\"]:\n                        if not checkOverlayParam(refNetEntry[\"netEntry\"][\"overlayNetName\"], param, refNetEntry[\"refSwitchSerial\"], \n                            deviceSn, refNetTemplParams[param], netEntry[\"netTemplateParams\"][param], respObj):\n                            allMatch = False\n\n                if not allMatch:\n                    Wrapper.print(\"%s: Fabric [%s] Net param mismatch: Switch [%s] Ref [%s] - Params [%s] refNetTemplParams [%s]\" %\n                        (funcName, FABRIC_NAME, switchDict[\"fmtName\"], refNetEntry[\"refSwitchSerial\"], netEntry[\"netTemplateParams\"], refNetTemplParams))\n\n    # do not proceed if there are errors\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    # process the attachments\n    for deviceSn in switchesNeedingOverlayMigration:\n        switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n        ECLprocessOverlayAttachments(deviceSn, switchOverlayInfo, globalOverlayInfo, allOverlayNets, topologyDataObj, vrfSviInstanceValues)\n\n\n    isFailure = False\n    \n    sortedVrfs = allOverlayVrfs.keys()\n    sortedNets = allOverlayNets.keys()\n\n    # create the vrfs if they do not exist\n    progressBase = 60\n    numEntries = len(sortedVrfs)\n    numProcessed = 0\n    Wrapper.print(\"%s %s: FABRIC [%s] VRF Creations [Total = %d]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries))\n    for vrf in sortedVrfs:\n        numProcessed += 1\n        progress = progressBase + int(float(numProcessed)/float(numEntries) * 5)\n\n        vrfEntry = allOverlayVrfs[vrf][\"vrfEntry\"]\n        vrfTemplateParams = vrfEntry[\"vrfTemplateParams\"]\n\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Creating VRF [%s/%s]\" % (numProcessed, numEntries, vrf, vrfEntry[\"name\"])))\n\n        Wrapper.print(\"%s: FABRIC [%s]: [%d of %d] Creating TD VRF [%s/%s]. Params [%s]\" % (funcName, \n            FABRIC_NAME, numProcessed, numEntries, vrf, vrfEntry[\"name\"], vrfEntry[\"vrfTemplateParams\"]))\n\n        isDefaultVrf = False\n        # Check the TD DB to see if the VRF has been created already\n        tdVrf = Util.exe(TD.getVrf(FABRIC_NAME, vrf))\n        if tdVrf:\n            tdVrfName = tdVrf.getVrfName()\n            isDefaultVrf = tdVrfName == \"default\"\n            if not isDefaultVrf:\n                # entry exists...\n                Wrapper.print(\"%s: Fabric [%s] Skip Creating Existing TD VRF [%s/%s]\" %\n                          (funcName, FABRIC_NAME, vrf, vrfEntry[\"name\"]))\n                continue\n        updateVrf = False\n        if isDefaultVrf:\n            existingVrfTmptParams = json.loads(tdVrf.getVrfTemplateConfig())\n            bfIpVer = vrfTemplateParams[\"VRF_IP_VERSION\"]\n            existingVrfTmptParams.update({\"VRF_IP_VERSION\":bfIpVer})\n            vrfTemplateParams = existingVrfTmptParams\n            updateVrf = True\n        else:\n            tdVrf = LanVRF()\n            tdVrf.setFabric(FABRIC_NAME)\n            tdVrf.setVrfName(vrfEntry[\"name\"])\n            tdVrf.setVrfTemplate(globalOverlayInfo[\"vrfProfileName\"])\n        #tdVrf.setVrfExtensionTemplate(globalOverlayInfo[\"vrfExtProfileName\"])\n        tdVrf.setVrfTemplateConfig(json.dumps(vrfTemplateParams))\n\n        # create the VRF\n        newResp = TD.createOrUpdateVrf(FABRIC_NAME, tdVrf, updateVrf)\n        if not newResp.isRetCodeSuccess():\n            isFailure = True\n            Util.processRespObj(respObj, newResp)\n\n    if not isFailure:\n        # create the networks if they do not exist\n        progressBase = 65\n        numEntries = len(sortedNets)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: FABRIC [%s] Network Creations [Total = %d]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries))\n        for network in sortedNets:\n            numProcessed += 1\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 5)\n\n            netEntry = allOverlayNets[network][\"netEntry\"]\n            netName = netEntry[\"overlayNetName\"] if netEntry[\"overlayNetName\"] else netEntry[\"cfgProfileName\"]\n\n            #Adding network name to the template param list\n            netEntry[\"netTemplateParams\"][\"networkName\"] = netName\n            \n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Creating Network [%s/%s]\" % (numProcessed, numEntries, network, netName)))\n\n            Wrapper.print(\"%s: FABRIC [%s] [%d of %d] Creating TD Network [%s/%s] Params [%s]\" % (funcName,\n                FABRIC_NAME, numProcessed, numEntries, network, netName, netEntry[\"netTemplateParams\"]))\n\n            # Check the TD DB to see if the network has been created already\n            updateNetwork = False\n            tdNet = Util.exe(TD.getNetwork(FABRIC_NAME, netName))\n            if tdNet:\n                Wrapper.print(\"%s: Fabric [%s] Skip Creating Existing TD Network [%s/%s]\" % (funcName, FABRIC_NAME, network, netName))\n                continue\n\n            tdNet = LanNetwork()\n            tdNet.setFabric(FABRIC_NAME)\n            tdNet.setNetworkName(netName)\n            tdNet.setVrf(netEntry[\"vrfName\"])\n            tdNet.setNetworkTemplate(globalOverlayInfo[\"networkProfileName\"])\n            #tdNet.setNetworkExtensionTemplate(globalOverlayInfo[\"networkExtProfileName\"])\n            tdNet.setNetworkTemplateConfig(json.dumps(netEntry[\"netTemplateParams\"]))\n\n            # create the network\n            newResp = TD.createOrUpdateNetwork(FABRIC_NAME, tdNet, False)\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Util.processRespObj(respObj, newResp)\n\n    Wrapper.print(\"%s: Finished creating VRFs/Networks for FABRIC [%s] isFailure %s\" % (funcName, FABRIC_NAME, isFailure))\n    Wrapper.print(\"%s: VRFs %s Networks %s\" % (funcName, sortedVrfs, sortedNets))\n          \n    if not isFailure:\n        # do the VRF attach as needed\n        progressBase = 70\n        numEntries = len(sortedVrfs)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: Start - FABRIC [%s] Attaching VRFs [Total = %d] %s\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries, sortedVrfs))\n        for vrf in sortedVrfs:\n            numProcessed += 1\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 10)\n\n            #Skip default VRF attachments\n            #if vrf == DEFAULT_VRF_NAME:\n            #    continue\n              \n            vrfAttach = globalOverlayInfo[\"VRF_ATTACH\"][vrf]\n            vrfName = vrfAttach.getVrfName()\n\n            Wrapper.print(\"%s %s: Fabric [%s] [%d of %d] Attaching VRF [%s/%s] [Attach Count = %d] - Start\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME,\n                numProcessed, numEntries, vrf, vrfName, len(vrfAttach.getLanAttachList())))\n\n            for attachEntry in vrfAttach.getLanAttachList():\n                switchDict = globalOverlayInfo[\"SWITCH_INFO\"][attachEntry.getSerialNumber()]\n                Wrapper.print(\"-----[%s], Name [%s/%s], Vlan [%s], ExtensionVals [%s] InstanceVals [%s] FF [%s]\" % (switchDict[\"fmtName\"],\n                    attachEntry.getVrfName(), attachEntry.getProfileName(), attachEntry.getVlan(), attachEntry.getExtensionValues(),\n                    attachEntry.getInstanceValues(), attachEntry.getFreeformConfig()))\n\n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Attaching VRF [%s]\" % (numProcessed, numEntries, vrfName)))\n\n            newResp = TD.attachVrf(FABRIC_NAME, vrfAttach)\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Wrapper.print(\"%s: Fabric [%s] Attaching VRF [%s] - Failed\" % (funcName, FABRIC_NAME, vrfName))\n                Util.processRespObj(respObj, newResp)\n                continue\n\n            # there could still be a failure on a success return\n            respStr = newResp.getValue()\n            # check if the response contains \"invalid\" references which indicates some issue occured\n            if \"failed\" in respStr.lower():\n                isFailure = True\n                # we have a failure\n                Wrapper.print(\"%s: Fabric [%s] Attaching VRF [%s] - Failed with response [%s]\" %\n                    (funcName, FABRIC_NAME, vrfName, respStr))\n                respObj.addErrorReport(funcName,\n                    \"Error attaching overlay VRF [%s]. Response = [%s]\" % (vrfName, respStr))\n                respObj.setFailureRetCode()\n                continue\n\n        Wrapper.print(\"%s %s: End - FABRIC [%s] Attaching VRFs\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n    if not isFailure:\n        # do the overlay network attach in batches\n        batchInfo = {}\n        count = 0\n        batchIndex = 0\n        netAttachList = []\n        vlanIdList = []\n        for vlanId in sortedNets:\n            netAttachList.append(globalOverlayInfo[\"NETWORK_ATTACH\"][vlanId])\n            vlanIdList.append(vlanId)\n            count += 1\n            if count >= BF_NETWORK_ATTACH_BATCH_SIZE:\n                batchIndex += 1\n                batchInfo[batchIndex] = {\"vlanIdList\": vlanIdList, \"netAttachList\" : netAttachList}\n                Wrapper.print(\"%s %s: Added Batches %d. Num %d\" % (OVERLAY_PREFIX, funcName, batchIndex, len(netAttachList)))\n\n                # start a new batch\n                count = 0\n                netAttachList = []\n                vlanIdList = []\n\n        if len(netAttachList):\n            batchIndex += 1\n            batchInfo[batchIndex] = {\"vlanIdList\": vlanIdList, \"netAttachList\" : netAttachList}\n            Wrapper.print(\"%s %s: Added Batches %d. Num %d\" % (OVERLAY_PREFIX, funcName, batchIndex, len(netAttachList)))\n        netAttachList = None\n        vlanIdList = None\n\n        sortedBatchIndices = sorted(batchInfo)\n        # range is 80 - 95\n        progressBase = 80\n        numEntries = len(sortedNets)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: Start - Fabric [%s] Attaching Networks [Total Entries %d, Batches = %d]\" % (OVERLAY_PREFIX, funcName,\n                                                FABRIC_NAME, numEntries, len(sortedBatchIndices)))\n\n        for index in sortedBatchIndices:\n            netAttachList = batchInfo[index][\"netAttachList\"]\n\n            numProcessed += len(netAttachList)\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 15)\n\n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Attaching Networks\" % (numProcessed, numEntries)))\n            \n            Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - Start - Networks (%d) %s\" % (OVERLAY_PREFIX, funcName,\n                                FABRIC_NAME, len(batchInfo[index][\"vlanIdList\"]), batchInfo[index][\"vlanIdList\"]))\n\n            # print the attachment details for this batch\n            Wrapper.print(\"%s %s: Fabric [%s] ===  Network Attachment Entries - Start ===\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n            for netAttach in netAttachList:\n                Wrapper.print(\"%s %s: Fabric [%s] Network [%s] Num Attachments [%d]\" % (OVERLAY_PREFIX, funcName,\n                                    FABRIC_NAME, netAttach.getNetworkName(), len(netAttach.getLanAttachList())))\n\n                printNetAttachList(FABRIC_NAME, globalOverlayInfo, netAttach.getLanAttachList())\n                \n            Wrapper.print(\"%s %s: Fabric [%s] ===  Network Attachment Entries - End ===\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n            newResp = TD.attachNetworks(FABRIC_NAME, netAttachList, False)\n            Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - End - isSuccess [%r]\" % (OVERLAY_PREFIX, funcName,\n                                FABRIC_NAME, newResp.isRetCodeSuccess()))\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Wrapper.print(\"%s: Fabric [%s] Attaching network failed for VNIs %s\" % (funcName, fabricName, batchInfo[index][\"vniList\"]))\n                Util.processRespObj(respObj, newResp)\n                continue\n\n            # check the return value\n            respDict = json.loads(newResp.getValue())\n            Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - Networks %s\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, batchInfo[index][\"vlanIdList\"]))\n            for netIdKey in respDict:\n                Wrapper.print(\"Entry: [%-30s] -> [%s]\" % (netIdKey, respDict[netIdKey]))\n                statusStr = str(respDict[netIdKey])\n                if not statusStr.lower().startswith(\"success\"):\n                    isFailure = True\n                    msg = (\"%s: Fabric [%s] Network attachment [%s] failed with reason [%s]\" % (funcName,\n                                                fabricName, netIdKey, respDict[netIdKey]))\n                    Wrapper.print(msg)\n                    respObj.addErrorReport(getFabErrEntity(funcName, netIdKey+\":netAttach\"), msg)\n                    respObj.setFailureRetCode()\n                    continue\n\n        Wrapper.print(\"%s %s: End - Fabric [%s] Attaching Networks\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n    Wrapper.print(\"%s %s: End - FABRIC [%s]. retcode [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, respObj.isRetCodeSuccess()))\n    return respObj\n\ndef ECLgetNetworkSviParams(interfacesRes, sviName, netEntry, switchOverlayInfo, overlayVrfMisconfigList, errDetectionDict, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = switchOverlayInfo[\"SERIAL\"]\n    switchRole = switchOverlayInfo[\"switchRole\"]\n\n    intfMatchResult = interfacesRes.get(sviName)\n    Wrapper.print(\"%s: Switch [%s] Role [%s] SVI [%s] Exists [%r] doOverlayExtn [%s]\" %\n            (funcName, devSerial, switchRole, sviName, (True if intfMatchResult else False), switchOverlayInfo[\"doOverlayExtn\"]))\n    #This is a layer-2 only network, so by default corresponds to a topdown vlan        \n    if intfMatchResult == None:\n        return True\n\n    #TODO: key and value are both vrfName\n    overlayVrfsNameToVrfName = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    #Key is vrfName, value is vrfEntry\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n   \n    netTemplateParams = netEntry[\"netTemplateParams\"]\n\n    #Assume default vrf by default for the SVI\n    vrfName = \"default\"\n\n    params = {}\n\n    # SVI exists.. need to check further\n    #   - must be enabled with FHRP as per fabric settings\n    #   - can belong to default or non-default VRF\n   \n    isValidFHRPSvi = False\n    dhcpServerList = []\n    ipAddrSecCount = 1\n    ip_addr_prefix_str = []\n    ipv6_addr_prefix_str = []\n    other_fhrp_subcmds = []\n    other_fhrpv6_subcmds = []\n    cur_fhrp_top_cli = \"\"\n    cur_fhrpv6_top_cli = \"\"\n    intf_unaccounted_cmds = intfMatchResult[\"unaccounted_cmds\"]\n    v4_fhrp_priority_cmd = None\n    v4_fhrp_priority = None\n    v6_fhrp_priority_cmd = None\n    v6_fhrp_priority = None\n\n    #Init ignorePriority to false as its the default value\n    params['ignorePriority'] = \"false\"\n    #VRRP shutdown is a default command that doesnt show up in show run. No shutdown shows up in show run.\n    if \"vrrp\" in FHRP_PROTOCOL:\n        if FHRP_PROTOCOL == \"vrrp\":\n            params['VRRP_ENABLE'] = \"false\"\n        else:\n            #VRRPv3 has a different default compared to vrrp wrt show run/show run all behavior\n            params['VRRP_ENABLE'] = \"true\"\n        #preempt is default with vrrp so it shows up in show run all and not show run\n        params[\"preempt\"]  = \"true\"\n    else:\n        #HSRP case, no preempt is default and shows up in show run all and not show run \n        params[\"preempt\"]  = \"false\"\n\n    '''\n    #Check whether this SVI corresponds to a VLAN that qualifies as a top down VLAN\n    if FHRP_PROTOCOL not in intfMatchResult[\"show_run_cmds\"]:\n        Wrapper.print(\"%s: Switch [%s] Role [%s] SVI [%s] does not correspond to a top-down VLAN\" % (funcName, devSerial, switchRole, sviName))      \n        return False\n    '''\n    \n    for line in intfMatchResult[\"show_run_cmds\"]:\n        orig_cmd = line\n        line = line.rstrip()\n        depth = (len(line) - len(line.lstrip(' '))) / 2\n        cmd = line.strip()\n        tokens = cmd.split()\n        if depth == 1:\n            # look for the expected top level commands\n            if cmd.startswith('vrf member '):\n                vrfName = tokens[2]\n                if vrfName.lower() not in overlayVrfsNameToVrfName:\n                    # invalid vrf??\n                    Wrapper.print(\"%s: ERROR - SVI [%s] Belongs to non-existent VRF [%s]\" % (funcName, sviName, vrfName))\n                    # check to ensure we report the error for the vrf only once\n                    if vrfName not in overlayVrfMisconfigList:\n                        isValidFHRPSvi = False\n                        overlayVrfMisconfigList.append(vrfName)\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"),\n                           \"Possible missing configuration(s) for Overlay VRF [%s]. Please resolve and retry Recalculate & Deploy\" %\n                           (vrfName), devSerial)\n                        respObj.setFailureRetCode()\n                    return\n            elif cmd.startswith('hsrp version '):\n                params['HSRP_VERSION'] = tokens[2]\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]\n            elif cmd.startswith('hsrp ') and tokens[1].isnumeric():\n                if FHRP_PROTOCOL != \"hsrp\":\n                    errorMsg = (\"Switch has hsrp configuration in SVI [%s], but First Hop Redundancy Protocol (FHRP) in Fabric Settings is set to [%s]. <br>\"\n                                \"Please select the appropriate FHRP protocol or change switch configuration accordingly and retry Recalculate & Deploy.\"%(sviName, FHRP_PROTOCOL))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"), errorMsg, devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                if \"ipv6\" in cmd:\n                    context = \"hsrpv6\"\n                    cur_fhrpv6_top_cli = orig_cmd\n                    params['GROUP_V6'] = tokens[1]\n                    if 'GROUP' not in params:\n                        params['GROUP'] = tokens[1]\n                else:\n                    context = \"hsrpv4\"\n                    cur_fhrp_top_cli = orig_cmd\n                    params['GROUP'] = tokens[1]\n                isValidFHRPSvi = True\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]\n            elif cmd.startswith('vrrp ') and tokens[1].isnumeric():\n                if FHRP_PROTOCOL != \"vrrp\":\n                    errorMsg = (\"Switch has vrrp configuration in SVI [%s], but First Hop Redundancy Protocol (FHRP) in Fabric Settings is set to [%s]. <br>\"\n                                \"Please select the appropriate FHRP protocol or change switch configuration accordingly and retry Recalculate & Deploy.\"%(sviName, FHRP_PROTOCOL))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"), errorMsg, devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                context = \"vrrpv4\"\n                isValidFHRPSvi = True\n                cur_fhrp_top_cli = orig_cmd\n                params['GROUP'] = tokens[1]\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]\n            elif cmd.startswith('vrrpv3 ') and tokens[1].isnumeric():\n                if FHRP_PROTOCOL != \"vrrp3\":\n                    errorMsg = (\"Switch has vrrp3 configuration in SVI [%s], but First Hop Redundancy Protocol (FHRP) in Fabric Settings is set to [%s]. <br>\"\n                                \"Please select the appropriate FHRP protocol or change switch configuration accordingly and retry Recalculate & Deploy.\"%(sviName, FHRP_PROTOCOL))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"), errorMsg, devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                if \"ipv6\" in cmd:\n                    context = \"vrrpv6\"\n                    cur_fhrpv6_top_cli = orig_cmd\n                    params['GROUP_V6'] = tokens[1]\n                    if 'GROUP' not in params:\n                        params['GROUP'] = tokens[1]\n                else:\n                    context = \"vrrpv4\"\n                    cur_fhrp_top_cli = orig_cmd\n                    params['GROUP'] = tokens[1]\n                isValidFHRPSvi = True\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]                       \n            elif cmd.startswith('ip address '):\n                #If there are secondary IPv4 addresses under this SVI so let it go to interface freeform\n                if \"secondary\" not in cmd:\n                    # primary IPv4 address with prefix\n                    ip_addr_prefix_str = tokens[2].split(\"/\")\n                    params['pip1'] = ip_addr_prefix_str[0]\n                    if \"tag\" in cmd:\n                        params['tag'] = tokens[4]\n                else:\n                    #needs to generate freeform intent for this additional v6 address\n                    intfMatchResult[\"unaccounted_cmds\"].append(line)\n                    continue        \n            elif cmd.startswith('ipv6 address '):\n                #If there are additional IPv6 addresses under this SVI so let it go to interface freeform\n                if 'ipv6_pip1' not in params:\n                    ipv6_addr_prefix_str = tokens[2].split(\"/\")\n                    params['ipv6_pip1'] = ipv6_addr_prefix_str[0]\n                    if \"tag\" in cmd:\n                        params['tag'] = tokens[4]\n                else:\n                    #needs to generate freeform intent for this additional v6 address\n                    intfMatchResult[\"unaccounted_cmds\"].append(line)\n                    continue\n            elif cmd.startswith('ip ospf message-digest-key '):\n                if VRF_LITE_PROTOCOL != \"ospf\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"),\n                       \"OSPF Authentication Key found on SVI [%s], but VRF-Lite Routing Protocol is not ospf\" %\n                       (sviName), devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                params['VRF_LITE_PROTOCOL'] = \"ospf\"\n                params['OSPF_AUTH_ENABLE'] = \"true\"\n                params['OSPF_AUTH_KEY_ID'] = tokens[3]\n                params['OSPF_AUTH_KEY'] = tokens[6]\n            elif cmd.startswith('ip ospf passive-interface'):\n                if VRF_LITE_PROTOCOL != \"ospf\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"),\n                       \"OSPF Passive Interface found on SVI [%s], but VRF-Lite Routing Protocol is not ospf\" %\n                       (sviName), devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                params['VRF_LITE_PROTOCOL'] = \"ospf\"\n                params['enableOspfPassive'] = \"true\"\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]\n            elif cmd.startswith('ospfv3 passive-interface'):\n                if VRF_LITE_PROTOCOL != \"ospf\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"),\n                       \"OSPFv3 Passive Interface found on SVI [%s], but VRF-Lite Routing Protocol is not ospf\" %\n                       (sviName), devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                params['VRF_LITE_PROTOCOL'] = \"ospf\"\n                params['enableOspfv3Passive'] = \"true\"\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]\n            elif cmd.startswith('ip dhcp relay address ') or cmd.startswith('ipv6 dhcp relay address '):\n                if len(dhcpServerList) >= NET_PROFILE_DHCP_SERVERS_MAX:\n                    intfMatchResult[\"unaccounted_cmds\"].append(line)\n                    continue\n                dhcpServerList.append({\"srvrAddr\" : tokens[4], \"srvrVrf\" : (tokens[6] if (\"use-vrf\" in cmd) else \"\")})\n            elif cmd.startswith('ip flow monitor ') and cmd.endswith('input'):\n                params['ENABLE_NETFLOW'] = \"true\"\n                params['SVI_NETFLOW_MONITOR'] = tokens[3]                \n            elif cmd.startswith('description '):\n                params['intfDescription'] = cmd[len('description '):]\n            elif cmd.startswith('mtu '):\n                params['mtu'] = cmd[len('mtu '):]\n        elif depth == 2:\n            if \"hsrp\" in context or \"vrrp\" in context:\n                if cmd.startswith('ip ') and context == \"hsrpv4\" and 'gatewayIpAddress' not in params and len(ip_addr_prefix_str) == 2:\n                    params['gatewayIpAddress'] = tokens[1] + \"/\" + ip_addr_prefix_str[1]\n                elif cmd.startswith('ip ') and isValidV6IpAddr(tokens[1]) and context == \"hsrpv6\" and 'gatewayIpV6Address' not in params and len(ipv6_addr_prefix_str) == 2:\n                    #There is another command that starts with 'ip': ip autoconfig\n\n                    #Check VIP and parent v6_pip are in the same subnet\n                    if getV6NetworkFromCIDR(tokens[1], ipv6_addr_prefix_str[1]) == getV6NetworkFromCIDR(ipv6_addr_prefix_str[0], ipv6_addr_prefix_str[1]):\n                        #v6 VIP is in the same subnet as the v6 primary address\n                        params['gatewayIpV6Address'] = tokens[1] + \"/\" + ipv6_addr_prefix_str[1]\n                    else:    \n                        #FHRP v6 VIP config should go into freeform \n                        other_fhrpv6_subcmds.append(orig_cmd)\n                elif cmd.startswith('address ') and context == \"vrrpv4\" and 'gatewayIpAddress' not in params and len(ip_addr_prefix_str) == 2:\n                    if FHRP_PROTOCOL == \"vrrpv3\":\n                        if \"primary\" in cmd:\n                            params['gatewayIpAddress'] = tokens[1] + \"/\" + ip_addr_prefix_str[1]\n                    else:\n                        params['gatewayIpAddress'] = tokens[1] + \"/\" + ip_addr_prefix_str[1]\n                    #These must be additional IPv4 secondary addresses\n                    if \"secondary\" in cmd:\n                        other_fhrp_subcmds.append(orig_cmd)\n                elif cmd.startswith('address ') and context == \"vrrpv6\" and len(ipv6_addr_prefix_str) == 2:\n                    if \"primary\" not in cmd:\n                        if 'gatewayIpV6Address' not in params:\n                            params['gatewayIpV6Address'] = tokens[1] + \"/\" + ipv6_addr_prefix_str[1]\n                        else:\n                            #These must be additional IPv6 addresses\n                            other_fhrpv6_subcmds.append(orig_cmd)\n                    else:\n                        params['ipv6_linklocal_vip'] = tokens[1]\n                elif cmd.startswith('preempt') and len(tokens) < 2:\n                    params['preempt'] = \"true\"\n                elif cmd.startswith('no preempt'):\n                    params['preempt'] = \"false\"                    \n                elif cmd.startswith(\"priority\"):\n                    if len(tokens) < 3 and params['ignorePriority'] != \"true\":\n                        #Depending on group id, either v4 or v6 fhrp commands may appear first. Lower group id comes first in show run.\n                        params['activePriority'] = tokens[1]\n                        if context == \"hsrpv4\" or context == \"vrrpv4\":\n                            #Store v4 priority cmd to use in case v6 fhrp has a custom priority\n                            v4_fhrp_priority_cmd = orig_cmd\n                            #Store v4 priority to compare it later with v6 priority. If mismatch detected, both should go to freeform\n                            v4_fhrp_priority = params['activePriority']\n                            \n                            #Check if v4 and v6 fhrp priorities are matching\n                            if v6_fhrp_priority and v6_fhrp_priority != params['activePriority']:\n                                #priority will need to go into freeform\n                                params['ignorePriority'] = \"true\"\n                                other_fhrp_subcmds.append(orig_cmd)\n                                if v6_fhrp_priority_cmd:\n                                    other_fhrpv6_subcmds.append(v6_fhrp_priority_cmd)\n                        else:\n                            #Store v6 priority cmd to use in case v4 fhrp has a custom priority\n                            v6_fhrp_priority_cmd = orig_cmd\n                            #Store v6 priority to compare it later with v4 priority. If mismatch detected, both should go to freeform\n                            v6_fhrp_priority = params['activePriority']\n                            \n                            #Check if v4 and v6 fhrp priorities are matching\n                            if v4_fhrp_priority and v4_fhrp_priority != params['activePriority']:\n                                #priority will need to go into freeform\n                                params['ignorePriority'] = \"true\"\n                                other_fhrpv6_subcmds.append(orig_cmd)\n                                if v4_fhrp_priority_cmd:\n                                    other_fhrp_subcmds.append(v4_fhrp_priority_cmd)\n                    else:\n                        #this means there is a custom priority command\n                        params['ignorePriority'] = \"true\"\n                        if context == \"hsrpv4\" or context == \"vrrpv4\":\n                            #Handle custom priority command under hsrp/vrrp sub mode for v4 scenarios\n                            other_fhrp_subcmds.append(orig_cmd)\n                            if v6_fhrp_priority_cmd:\n                                other_fhrpv6_subcmds.append(v6_fhrp_priority_cmd)\n                        else:\n                            #Handle custom priority command under hsrp/vrrp sub mode for v6 scenarios\n                            other_fhrpv6_subcmds.append(orig_cmd)\n                            if v4_fhrp_priority_cmd:\n                                other_fhrp_subcmds.append(v4_fhrp_priority_cmd)\n                                \n                elif cmd.startswith(\"mac-address\"):\n                    params['mac'] = tokens[1]\n                elif \"no shutdown\" in cmd:\n                    params['VRRP_ENABLE'] = \"true\"\n                else:\n                    if context == \"hsrpv4\" or context == \"vrrpv4\":\n                        if not cmd.startswith(\"exit\"):\n                            #Handle other unmatched commands under hsrp/vrrp sub mode for v4 scenarios\n                            other_fhrp_subcmds.append(orig_cmd)\n                    else:\n                        if not cmd.startswith(\"exit\"):\n                            #Handle other unmatched commands under hsrp/vrrp sub mode for v6 scenarios\n                            other_fhrpv6_subcmds.append(orig_cmd)\n                        \n            if orig_cmd in intf_unaccounted_cmds:\n                index = intf_unaccounted_cmds.index(orig_cmd)\n                del intf_unaccounted_cmds[index]\n\n    if isValidFHRPSvi:\n        if vrfName == \"\":\n            return False\n\n        params[\"vrfName\"] = vrfName\n        params[NET_PROFILE_DHCP_SERVERS_VAR] = buildOverlayNetDhcpStructString(dhcpServerList, vrfName)\n        errDetectionDict.update({sviName:{\"params\":params}})\n        \n        #this means no priority was configured under fhrp\n        if \"activePriority\" not in params:\n            params['ignorePriority'] = \"true\"\n            \n        # move the params to the network template params\n        for paramName in params.keys():\n            netTemplateParams[paramName] = params[paramName]\n\n        netEntry[\"vrfName\"] = netTemplateParams[\"vrfName\"]\n        netTemplateParams[\"isLayer2Only\"] = \"false\"\n\n        # add this network to the VRF network membership list\n        overlayVrfsInfoById[vrfName][\"networks\"].append(str(netEntry[\"vlanId\"]))\n\n        if len(other_fhrp_subcmds) > 0:\n            intf_unaccounted_cmds.append(cur_fhrp_top_cli)\n            intf_unaccounted_cmds = intf_unaccounted_cmds + other_fhrp_subcmds\n        if len(other_fhrpv6_subcmds) > 0:\n            intf_unaccounted_cmds.append(cur_fhrpv6_top_cli)\n            intf_unaccounted_cmds = intf_unaccounted_cmds + other_fhrpv6_subcmds            \n        intfMatchResult[\"unaccounted_cmds\"] = intf_unaccounted_cmds\n        Wrapper.print(\"%s: Switch [%s] Role [%s] SVI [%s] intf_unaccounted_cmds %s other_fhrp_subcmds %s other_fhrpv6_subcmds %s\" %\n            (funcName, devSerial, switchRole, sviName, intf_unaccounted_cmds, other_fhrp_subcmds, other_fhrpv6_subcmds))\n            \n        return True\n    else:\n        return False  \n        \ndef ECLgatherNwkVrfInfo(topologyDataObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, \n                        switchOverlayInfo, migrateMode, device_overlay_vlans, respObj, dcnmUser):\n    funcName = sys._getframe(0).f_code.co_name\n    switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n    role = switchInfo['switchRole']\n    formattedName = switchInfo[\"fmtName\"]\n    vPCInfo = switchInfo[\"vpcInfo\"]\n\n    Wrapper.print(\"%s %s: Start - FABRIC [%s] Switch [%s] Role [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, formattedName, role))\n\n    # get a list of all vlans on the switch\n    vlanMatchRes = matchResults[\"FEATURES_INFO\"][\"VLAN_BLOCK\"]\n    for vlanStr in vlanMatchRes.keys():\n        vlanListStr = vlanStr[5:]\n        vlanList = Util.getIntegerRange(vlanListStr)\n        isMultiVlans = False\n        if len(vlanMatchRes) == 1:\n            # we have a single entry....this has to be set of all vlans on switch\n            isMultiVlans = True\n        else:\n            if len(vlanList) > 1:\n                # this has to be set of multiple vlans on switch\n                isMultiVlans = True\n        if isMultiVlans:\n            switchOverlayInfo[\"ALL_VLANS\"].extend(vlanList)\n\n    utilObj = Util()\n    allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n\n    numVlans = len(switchOverlayInfo[\"ALL_VLANS\"])\n    Wrapper.print(\"%s: Switch [%s] Role [%s] migrateMode [%s]  Vlans (%d)[%s]\" % (funcName,\n        formattedName, role, migrateMode, numVlans, allVlansOnSwitchStr))\n\n    hasCfgProfiles = False\n    Wrapper.print(\"%s: Switch [%s] hasCfgProfiles [%r] All Vlans = [%d] [%s]\" % (funcName, formattedName, \n        hasCfgProfiles, len(switchOverlayInfo[\"ALL_VLANS\"]), switchOverlayInfo[\"ALL_VLANS\"]))\n        \n    vrfEntries = []\n    if role.lower() == \"aggregation\":\n        #Get a list of all VRFs from the switch\n        sshObj = None\n        newRespObj = WrappersResp.getRespObj()\n        newRespObj.setSuccessRetCode()\n        try:\n            sshObj = Util.exe(getOptSSHConnection(FABRIC_NAME, devSerial, dcnmUser))\n        except Exception as e:\n            Wrapper.print(\"PDM: Failed to get SSH connection for : [%s] [%s]. Will skip\" % (devSerial, str(e)))\n            respObj.addErrorReport(getFabErrEntity(\"PDM\", devSerial+\":SSH\"),\n                                  \"Failed to get SSH connection. \"\n                                  \"Please ensure LAN credentials and retry Recalculate & Deploy\", devSerial)\n            respObj.setFailureRetCode()\n        \n        shVrfJson = getSwitchCmdJsonOutput(sshObj, devSerial, \"show vrf | json\", newRespObj)\n    \n        if not newRespObj.isRetCodeSuccess():\n            Util.processRespObj(respObj, newRespObj)\n            return respObj    \n        sshObj.close()\n        sshObj = None    \n    \n        if (((shVrfJson is None) or (shVrfJson == \"\")) or \n            (\"TABLE_vrf\" not in shVrfJson)):\n            # something is wrong.. respObj must have the required error\n            Wrapper.print(\"%s: Switch [%s]: did not find any VRFs Overlays on switch\" % (funcName, formattedName))\n            return\n    \n        if not isinstance(shVrfJson[\"TABLE_vrf\"][\"ROW_vrf\"], list):\n            # this is a single entry.. make a list\n            vrfRows = [shVrfJson[\"TABLE_vrf\"][\"ROW_vrf\"]]\n        else:\n            # this is a list already!\n            vrfRows = shVrfJson[\"TABLE_vrf\"][\"ROW_vrf\"]\n    \n        Wrapper.print(\"%s: Switch [%s] vrfRows %s\" % (funcName, formattedName, vrfRows))\n        for vrfRow in vrfRows:\n            vrfStr = vrfRow[\"vrf_name\"]\n            #Special VRFs should be treated as non top down VRFs\n            if vrfStr == MGMT_VRF_NAME or vrfStr == EGRESS_LB_VRF:\n                continue\n    \n            vrfEntries.append(vrfRow)\n    \n    switchHasOverlays = True\n\n    #TODO:Handle upgrade later\n    if migrateMode == \"upgrade\":\n        switchOverlayInfo[\"OVERLAY_VLANS\"] = getAllTopDownVlans(devSerial, device_overlay_vlans)\n    elif migrateMode == \"brownAdd\":\n        if switchHasOverlays:\n            profInfo = globalOverlayInfo['cfgProfileInfo']\n            if profInfo[\"hasCfgProfile\"] == None:\n                # set the cfg profile status since this is the first time\n                profInfo[\"hasCfgProfile\"] = hasCfgProfiles\n                profInfo[\"refSwitch\"] = devSerial\n\n            Wrapper.print(\"%s: Switch [%s] cfgProfileInfo [%s]\" % (funcName, formattedName, profInfo))\n\n            ECLgatherCliNwkVrfs(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, switchOverlayInfo, vrfEntries)\n\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    overlayVrfsNameToVni = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n    utilObj = Util()\n    allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n    overlayVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"OVERLAY_VLANS\"])\n\n    Wrapper.print(\"%s: Switch [%s] ALL_VLANS = [%d][%s] OVERLAY_VLANS = [%d][%s]\" %  (funcName, formattedName,\n            len(switchOverlayInfo[\"ALL_VLANS\"]), allVlansOnSwitchStr, \n            len(switchOverlayInfo[\"OVERLAY_VLANS\"]), overlayVlansOnSwitchStr))\n\n    localVlans = list(set(switchOverlayInfo[\"ALL_VLANS\"]) - set(switchOverlayInfo[\"OVERLAY_VLANS\"]))\n\n    Wrapper.print(\"%s: Switch [%s] local vlans = [%d][%s]\" % (funcName, formattedName, len(localVlans), localVlans))\n\n    # Process local SVIs in deviceUpgradeIntf() if the SVI vlan is in the vlan list\n    # Otherwise, put the local SVI configs into the FF\n    # Remove SVI vlans from the \"vlan xxx\" list as these vlans will be included in int_vlan\n    freeformSVICfg = []\n    updatedVlanList = copy.copy(localVlans)\n    for intfName in sorted(interfacesRes.keys()):\n        if not intfName.lower().startswith(\"vlan\"):\n            # not an SVI\n            continue\n\n        intfMatchResult = interfacesRes[intfName]\n\n        vlanIdStr = intfName[4:]\n        vlanId = int(vlanIdStr)\n        if (vlanId in switchOverlayInfo[\"OVERLAY_VLANS\"]):\n            # skip the overlay SVI, the VPC peer link vlan\n            intfMatchResult.update({\"isProcessed\" : True})\n            continue\n\n        if ((vlanId in switchOverlayInfo[\"ALL_VLANS\"]) and (vlanId != 1)):\n            Wrapper.print(\"%s: SVI vlan [%d] \" % (funcName, vlanId))\n            # remove the SVI vlan as the vlan will be included in int_vlan\n            updatedVlanList.remove(vlanId)\n\n        if isIntfProcessed(intfMatchResult):\n            continue\n\n        if ((vlanId not in switchOverlayInfo[\"ALL_VLANS\"]) or (vlanId == 1)):\n            Wrapper.print(\"%s: Local SVI [%s] that has no vlan config\" % (funcName, intfName))\n            freeformSVICfg.append(\"interface %s\" % intfName)\n            freeformSVICfg += intfMatchResult[\"show_run_cmds\"]\n            intfMatchResult.update({\"isProcessed\" : True})\n\n    Wrapper.print(\"%s: Switch [%s] updated local vlan list = [%d][%s]\" %\n                  (funcName, formattedName, len(updatedVlanList), updatedVlanList))\n\n    # build the toplevel vlan xxx config\n    freeformCfg = []\n    if len(updatedVlanList):\n        util = Util()\n        freeformCfg.append(\"vlan \" + util.vlanStrFromList(updatedVlanList))\n\n    for vlanId in localVlans:\n        vlanIdStr = str(vlanId)\n        vlanRec = getMatchingResultVlan(vlanIdStr, matchResults)\n        if vlanRec:\n            #Wrapper.print(\"%s: vlan [%s] is not an overlay vlan\" % (funcName, vlanIdStr))\n            isPvlan = False\n            for vlanCmd in vlanRec[\"show_run\"]:\n                if \"private-vlan\" in vlanCmd:\n                    isPvlan = True\n            if isPvlan:\n                Wrapper.print(\"%s: vlan [%s] has unsupported pvlan cmd: %s\" % (funcName, vlanIdStr, vlanCmd))\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":PVLAN OVERLAY\"),\n                    \"Cannot have private-vlan config on VLANs.\", devSerial)\n                respObj.setFailureRetCode()\n                return\n            freeformCfg += vlanRec[\"show_run\"]\n\n    switchOverlayInfo[\"PRE_INTF_FF\"] += freeformCfg + freeformSVICfg\n    \n    freeformCfg = []\n    if role.lower() == \"aggregation\":\n        if \"VRF_LITE_PROTOCOL\" == \"ebgp\":\n            # form the 'router bgp <as>' key to lookup\n            routerBgpKey = \"router bgp \" + BGP_AS\n            if routerBgpKey in matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"]:\n                bgpVrfMatchRes = matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"][routerBgpKey]\n                freeformCfg = switchOverlayInfo[\"BGP_FF\"]\n                for bgpVrfName in bgpVrfMatchRes.keys():\n                    bgpvrfRec = bgpVrfMatchRes.get(bgpVrfName)\n                    if bgpVrfName == \"unaccounted\":\n                        continue\n                    vrfName = bgpVrfName.split(\" \")[1].strip()\n                    #Wrapper.print(\"%s: Processing BGP VRF [%s]\" % (funcName, vrfName))\n    \n                    if vrfName.lower() not in overlayVrfsNameToVni:\n                        #Wrapper.print(\"%s: BGP VRF [%s]: show run CLI processing\" % (funcName, vrfName))\n                        freeformCfg += bgpvrfRec[\"show_run\"]\n\n    switchOverlayInfo[\"POST_INTF_FF\"] += freeformCfg\n    Wrapper.print(\"%s %s: End - FABRIC [%s] Switch [%s] Role [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, formattedName, role))\n\ndef ECLgatherCliNwkVrfs(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, switchOverlayInfo, vrfEntries):\n    funcName = sys._getframe(0).f_code.co_name\n    switchRole = switchOverlayInfo[\"switchRole\"]\n    vlanNameSupported = (globalOverlayInfo[\"overlayVlanNameSupported\"] == \"true\")\n    includeAllCfg = True\n    \n    Wrapper.print(\"%s: Switch [%s] Role [%s] vlanNameSupported [%r], includeAllCfg [%r]\" % \n        (funcName, devSerial, switchRole, vlanNameSupported, includeAllCfg))\n\n    sviVlanIdToVrfNameDict = {}\n    sviVlanIdToIp4Dict = {}\n    sviVlanIdToPrefix4Dict = {}\n    sviVlanIdToIp6Dict = {}\n    sviVlanIdToPrefix6Dict = {}\n\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"int_vlan\")\n    srchOpt.setEntityType(\"INTERFACE\")\n    srchOpt.setSource(\"\")\n    sviPtis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    for pti in sviPtis:\n        if not pti.isDeleted():\n            ptiNvPairs = pti.getNvPairs()\n            vrfName = ptiNvPairs.get(\"INTF_VRF\")\n            intfName = ptiNvPairs.get(\"INTF_NAME\").lower()\n            vlanId = intfName.lstrip(\"Vlan\")\n            ip4 = ptiNvPairs.get(\"IP\")\n            prefix4 = ptiNvPairs.get(\"PREFIX\")\n            if ip4 and prefix4:\n                sviVlanIdToIp4Dict [vlanId] = ip4 \n                sviVlanIdToPrefix4Dict [vlanId] = prefix4 \n            ffConfList = ptiNvPairs.get(\"CONF\").splitlines()\n            for ffConf in ffConfList:\n                ffConf = ffConf.strip()\n                if \"ipv6 address\" in ffConf:\n                    ipPrefix6 = ffConf.lstrip(\"ipv6 address\")\n                    ip6, prefix6 = ipPrefix6.split(\"/\") \n                    if ip6 and prefix6:\n                        sviVlanIdToIp4Dict [vlanId] = ip6\n                        sviVlanIdToPrefix6Dict [vlanId] = prefix6 \n           \n\n            sviVlanIdToVrfNameDict[vlanId] = vrfName\n\n\n    #TODO:If private-vlan is enabled on the vlan then fail BF import or let it go to freeform?\n    vlanIdInfo = {}\n    nvPairList = getTemplateMatchResults(matchResults, \"vlan_name_11_1\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            # check to make sure the name is not the default\n            vlanIdInt = int(nvPair[\"VLAN\"])\n            vlanName = nvPair[\"NAME\"]\n            if vlanName == (\"VLAN%04d\" % vlanIdInt):\n                vlanName = \"\"\n            vlanIdInfo.update({nvPair[\"VLAN\"] : {\"name\" : vlanName}})\n\n    Wrapper.print(\"%s: Switch [%s] vlanIdInfo [%s]\" % (funcName, devSerial, vlanIdInfo))\n\n    #Check for netflow monitor attached to a VLAN\n    nvPairList = getTemplateMatchResults(matchResults, \"vlan_netflow\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            netflow_monitor_name = nvPair[\"NETFLOW_MONITOR_NAME\"]\n            #nvPair[\"VLAN\"] can be a vlan list with - and , like vlan configuration 8-9,12\n            #break it down so that we have an element in the vlanInfo dictionary for each vlan\n            vlan_config_list = nvPair[\"VLAN\"].split(',')\n            for elem in vlan_config_list:\n                if '-' in elem:\n                    start_vlan_range, end_vlan_range = elem.split('-')\n                    for v_int in range(int(start_vlan_range), int(end_vlan_range)+1):\n                        v = str(v_int)\n                        if v not in vlanIdInfo:\n                            vlanIdInfo.update({v : {\"vlan_netflow_monitor\" : netflow_monitor_name}})\n                        else:\n                            vlanNameElem = vlanIdInfo[v]\n                            vlanIdInfo.update({v : [ vlanNameElem, {'vlan_netflow_monitor': netflow_monitor_name}]})\n                else:\n                    v = elem\n                    if v not in vlanIdInfo:\n                        vlanIdInfo.update({v : {\"vlan_netflow_monitor\" : netflow_monitor_name}})\n                    else:\n                        vlanNameElem = vlanIdInfo[v]\n                        vlanIdInfo.update({v : [ vlanNameElem, {'vlan_netflow_monitor': netflow_monitor_name}]})\n            \n    Wrapper.print(\"%s: Switch [%s] vlanIdInfo [%s]\" % (funcName, devSerial, vlanIdInfo))\n\n    if switchRole.lower() == \"aggregation\":\n        \n        # dictionary of vrf name (key) and its description (value)\n        vrfDescInfo = {}\n        nvPairList = getTemplateMatchResults(matchResults, \"vrf_desc_11_1\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                vrfDescInfo.update({nvPair[\"VRF_NAME\"] : nvPair[\"DESC\"]})\n    \n        Wrapper.print(\"%s: Switch [%s] vrfDescInfo [%s]\" % (funcName, devSerial, vrfDescInfo))\n    \n        #TODO: key and value are both vrfName\n        overlayVrfsNameToVrfName = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n        #Key is vrfName, value is vrfEntry\n        overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n    \n        # process the VRFs first\n        Wrapper.print(\"%s: **** Processing VRFs %s\" % (funcName, vrfEntries))\n    \n        for vrf in vrfEntries:\n            vrfName = vrf['vrf_name']\n            Wrapper.print(\"%s: **** Processing VRFs %s\" % (funcName, vrfName))\n\n            # parameters used during VRF create\n            vrfTemplateParams = {\n                \"vrfVlanId\" : \"\",\n                \"vrfName\": vrfName,\n                \"vrfVlanName\" : \"\",\n                \"vrfIntfDescription\" : \"\",\n                \"vrfDescription\" : vrfDescInfo[vrfName] if vrfDescInfo.get(vrfName) else \"\",\n                \"tag\" : \"\",\n                \"VRF_IP_VERSION\": \"IPv4_and_IPv6\",\n                \"enablePerVpcPeering\" : \"false\",\n                \"mtu\" : \"9216\",\n                \"SVI_CONF\" : \"\",\n                \"maxBgpPaths\" : \"1\",\n                \"vrfRouteMap\" : \"\",\n                \"configureStaticDefaultRouteFlag\" : \"false\",\n                \"BGP_AUTH_ENABLE\": \"false\",\n                \"bgpPassword\": \"\",\n                \"bgpPasswordKeyType\": \"3\",\n                \"VRF_LITE_PROTOCOL\": VRF_LITE_PROTOCOL,\n                \"asn\": \"\",\n                \"ENABLE_NETFLOW\": \"\",\n                \"NETFLOW_MONITOR\": \"\"\n            }\n    \n            if VRF_LITE_PROTOCOL == \"ospf\":\n                vrfTemplateParams.update(\n                  {\"OSPF_PROCESS_TAG\": LINK_STATE_ROUTING_TAG,\n                   \"OSPF_AREA_ID\": OSPF_AREA_ID,\n                   \"OSPFv3_PROCESS_TAG\": OSPFv3_ROUTING_TAG,\n                   \"OSPFv3_AREA_ID\": OSPFv3_AREA_ID,\n                   \"OSPF_AUTH_ENABLE\": \"false\",\n                   \"OSPF_AUTH_KEY_ID\": \"127\",\n                   \"OSPF_AUTH_KEY\": \"\"\n                  })\n\n            vrfEntry = {\n                        'name' : vrfName,\n                        'vlanId' : \"\",\n                        'vrfTemplateParams' : vrfTemplateParams,\n                        # list of network VLANs (integer) associated with this VRF\n                        'networks' : [],\n                        # VRF attach extension values\n                        'extensionVals' : \"\",\n                        # VRF attach instance values\n                        'instanceVals' : \"\",\n                        # the additional configuration that could not be accounted for in the config profile\n                        'freeformCfg' : None,\n                       }\n    \n            nvPairList = getTemplateMatchResults(matchResults, \"bgp_overlay_vrf_ipv4_redist_rmap_11_1\")\n            if (nvPairList != None):\n                for nvPair in nvPairList:\n                    if nvPair[\"VRF_NAME\"] == vrfName:\n                        vrfTemplateParams[\"vrfRouteMap\"] = nvPair[\"RMAP\"] \n                        break\n            nvPairList = getTemplateMatchResults(matchResults, \"bgp_overlay_vrf_ipv4_max_bgp_paths_11_1\")\n            if (nvPairList != None):\n                for nvPair in nvPairList:\n                    if nvPair[\"VRF_NAME\"] == vrfName:\n                        vrfTemplateParams[\"maxBgpPaths\"] = nvPair[\"MAX_PATHS\"]\n                        break\n\n            ip4AfPresent = False\n            ip6AfPresent = False\n            if vrfName == \"default\":\n                ip4AfPresent, ip6AfPresent = ECLGetVrfNeighborIp4OrIp6(devSerial, vrfName, overlayVrfsInfoById, matchResults)\n            else:\n                nvPairList = getTemplateMatchResults(matchResults, \"vrf_af\")\n                if (nvPairList != None):\n                    for nvPair in nvPairList:\n                        if nvPair[\"VRF_NAME\"] == vrfName:\n                            if nvPair[\"IP_VERSION\"] == \"ipv4\":\n                                ip4AfPresent = True\n                            else:\n                                ip6AfPresent = True\n\n            if ip4AfPresent and ip6AfPresent:\n                vrfTemplateParams[\"VRF_IP_VERSION\"] = \"IPv4_and_IPv6\"\n            elif ip4AfPresent:\n                vrfTemplateParams[\"VRF_IP_VERSION\"] = \"IPv4_only\"\n            elif ip6AfPresent:\n                vrfTemplateParams[\"VRF_IP_VERSION\"] = \"IPv6_only\"\n            vrfEntry[\"freeformCfg\"] = ECLgetVrfFreeformCfg(devSerial, vrfName, \"\", \n                                                           matchResults, interfacesRes, includeAllCfg, switchOverlayInfo)\n            overlayVrfsNameToVrfName[vrfEntry[\"name\"].lower()] = {\"origName\" : vrfEntry[\"name\"], \"vni\" : vrfEntry[\"name\"]}\n            overlayVrfsInfoById[vrfEntry[\"name\"]] = vrfEntry\n            Wrapper.print(\"%s: Switch [%s]. VRF VNI [%s]. Entry %s\" % (funcName, devSerial, vrfName, vrfEntry))\n            \n    # process the networks\n    Wrapper.print(\"%s: **** Processing Networks\" % (funcName))\n    networksInfo = switchOverlayInfo[\"NETWORKS_BY_ID\"]\n    overlayVrfMisconfigList = []\n\n    utilObj = Util()\n    allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n    \n    #Assume all vlans can be configured from top down\n    vlanList = list(set(switchOverlayInfo[\"ALL_VLANS\"]) - set(switchOverlayInfo[\"OVERLAY_VLANS\"]))\n\n    Wrapper.print(\"%s: vlan List [%s] str [%s] allvlans [%s] overlayvlans [%s] post vrfs under consideration\" % \n                  (funcName, vlanList, allVlansOnSwitchStr, switchOverlayInfo[\"ALL_VLANS\"], switchOverlayInfo[\"OVERLAY_VLANS\"]))\n\n    errDetectionDict = {}\n    for vlanId in vlanList:\n        #TODO: Skip vlan 1 for now\n        if vlanId == 1:\n            continue\n          \n        Wrapper.print(\"%s: Network VLAN [%s] under consideration for top-down addition\" % (funcName, vlanId))\n\n        switchOverlayInfo[\"OVERLAY_VLANS\"].append(vlanId)\n        Wrapper.print(\"%s: switchOverlayVLANs so far [%s] vlanId[name] %s %s\" % (funcName, switchOverlayInfo[\"OVERLAY_VLANS\"], vlanIdInfo, vlanIdInfo.get(str(vlanId))))\n\n        vlanNameStr = \"\"\n        vlanNetflowMonitor = \"\"\n        netflowEnable = \"false\"\n        if vlanIdInfo.get(str(vlanId)):\n            vlanIdInfoelem = vlanIdInfo.get(str(vlanId))\n            if len(vlanIdInfoelem) > 1:\n                for x in vlanIdInfoelem:\n                    if \"name\" in x:\n                        vlanNameStr = x['name']\n                        continue\n        \n                    if \"vlan_netflow_monitor\" in x:\n                        netflowEnable = \"true\"\n                        vlanNetflowMonitor = x['vlan_netflow_monitor']\n                        continue\n            else:\n                if \"name\" in vlanIdInfoelem:\n                    vlanNameStr = vlanIdInfoelem['name']\n                elif \"vlan_netflow_monitor\" in vlanIdInfoelem:\n                    netflowEnable = \"true\"\n                    vlanNetflowMonitor = vlanIdInfoelem['vlan_netflow_monitor']\n    \n        netTemplateParams = {\n            # mandatory parameters\n            'vlanId' : \"\",\n            'vlanName' : vlanNameStr,\n            'tag' : \"\",\n            'vrfName' : \"NA\",\n            'gatewayIpAddress' : \"\",\n            'pip1' : \"\",\n            'pip2' : \"\",\n            'gatewayIpV6Address' : \"\",\n            'ipv6_pip1' : \"\",\n            'ipv6_pip2' : \"\",\n            'ipv6_linklocal_vip' : \"\",\n            'intfDescription' : \"\",\n            'intfDescription2' : \"\",\n            'mtu' : \"\",\n            'redundancyType' : FHRP_PROTOCOL,\n            'ignorePriority' : \"false\",\n            'activePriority' : \"\",\n            'standbyPriority' : \"\",\n            'preempt' : \"false\",\n            'GROUP' : \"\",\n            'GROUP_V6': \"\",\n            'mac' : \"\",\n            'VRRP_ENABLE' : \"false\",\n            'dhcpServers' : \"\",\n            \"ENABLE_NETFLOW\": netflowEnable,\n            \"SVI_NETFLOW_MONITOR\": \"\",            \n            \"VLAN_NETFLOW_MONITOR\": vlanNetflowMonitor,            \n            'HSRP_VERSION' : \"1\",\n            \"VRF_LITE_PROTOCOL\": VRF_LITE_PROTOCOL,\n            'isLayer2Only' : \"true\",\n            }\n\n        if VRF_LITE_PROTOCOL == \"ospf\":\n            netTemplateParams.update(\n              {\"OSPF_AUTH_ENABLE\": \"false\",\n               \"OSPF_AUTH_KEY_ID\": \"127\",\n               \"OSPF_AUTH_KEY\": \"\",\n               \"enableOspfPassive\": \"false\",\n               \"enableOspfv3Passive\": \"false\"\n              })\n\n        netEntry = {\n            # the 'overlayNetName' will be set later \n            'vlanId' : vlanId,\n            'vlanName' : netTemplateParams[\"vlanName\"],\n            \"netTemplateParams\" : netTemplateParams,\n            'vrfName' : \"NA\",\n            # Network attach extension values\n            'extensionVals' : \"\",\n            # the additional configuration that could not be accounted for in the config profile\n            'freeformCfg' : \"\",\n            # list of interface names. Collected from trunk and access host interfaces where the vlan is enabled explictly,\n            'attachInfo' : [],\n            # list of Tor/access interface names. Collected from trunk and access host interfaces where the vlan is enabled explictly,\n            # Tor/access devices are attached to the leaf/aggregation devices and their interfaces are listed as candidates when \n            # network is attached on the corresponding parent leaf/aggregation device.\n            'torPorts' : [],\n        }\n\n        #TODO: Do we need to handle case of spurious VLANs on access that are not on the aggregation layer?\n        if switchRole.lower() == \"aggregation\":\n            # need to check if a SVI exists for this vlan\n            sviName = 'Vlan'+ str(vlanId)\n            validTopDownNetworkFlag = ECLgetNetworkSviParams(interfacesRes, sviName, netEntry, switchOverlayInfo, overlayVrfMisconfigList, errDetectionDict, respObj)\n            if not validTopDownNetworkFlag:\n                switchOverlayInfo[\"OVERLAY_VLANS\"].remove(vlanId)\n                continue\n        \"\"\"\n        for entry in errDetectionDict:\n             entryParams = entry[\"params\"]\n        \"\"\"\n        if (netTemplateParams[\"vlanId\"] == \"\"):\n            # this is the first time we are initializing... set it to the vlan we find. Most likely the same vlan\n            # will be used in all switches. Note that the attach will be for the exact vlan found on the switches\n            netTemplateParams[\"vlanId\"] = netEntry[\"vlanId\"]\n        netEntry[\"freeformCfg\"] = ECLgetNetworkFreeformCfg(str(vlanId), matchResults, interfacesRes, False)\n        networksInfo[netEntry[\"vlanId\"]] = netEntry\n        switchOverlayInfo[\"NETWORKS_VLAN2VNI\"][netEntry[\"vlanId\"]] = netEntry[\"vlanId\"]\n         \ndef ECLgetVrfFreeformCfg(devSerial, vrfName, vrfVlanStr, matchResults, interfacesRes,\n                                                        includeAllCfg, switchOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: vrfName [%s] vrfVlanStr [%s] includeAllCfg [%r]\" % (funcName, vrfName, vrfVlanStr, includeAllCfg))\n    freeformCfg = getVlanCfg(vrfVlanStr, matchResults, includeAllCfg)\n    freeformCfg += getSviCfg(vrfVlanStr, interfacesRes, includeAllCfg, True, None)\n    freeformCfg += getVrfCfg(vrfName, matchResults, includeAllCfg)\n\n    filteredFF = [\"\"]\n    routerBgpKey = \"router bgp \" + BGP_AS\n    bgpRec = matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"].get(routerBgpKey)\n    if bgpRec != None:\n        vrfKey = 'vrf ' + vrfName\n        vrfRec = bgpRec.get(vrfKey)\n        if vrfRec != None:\n            if includeAllCfg:\n                filteredFF.extend(vrfRec[\"show_run\"])\n            else:\n                if len(vrfRec[\"unaccounted\"]) > 0:\n                    filteredFF.extend(vrfRec[\"unaccounted\"])\n\n    if len(filteredFF):\n        freeformCfg += Util.newLine().join(filteredFF)\n\n    return freeformCfg.strip()\n\ndef ECLgetNetworkFreeformCfg(netVlanStr, matchResults, interfacesRes, includeAllCfg):\n    Wrapper.print(\"getNetworkFreeformCfg: netVlanStr [%s]\" % (netVlanStr))\n\n    freeformCfg = getVlanCfg(netVlanStr, matchResults, includeAllCfg)\n    freeformCfg += ECLgetSviCfg(netVlanStr, interfacesRes, includeAllCfg, False)\n\n    return freeformCfg.strip()\n\ndef getIpsFromNvPairs(templateNameMatches, matchResult, matchingNvPairs, intfName, inOutDict):\n    funcName = sys._getframe(0).f_code.co_name\n    poIp4               = inOutDict[\"poIp4\"] \n    poPrefix4           = inOutDict[\"poPrefix4\"]\n    poIp6               = inOutDict[\"poIp6\"]\n    poPrefix6           = inOutDict[\"poPrefix6\"]\n    poRoutingTag        = inOutDict[\"poRoutingTag\"]\n    unaccCfg6           = inOutDict[\"unaccCfg6\"]\n    unaccCfg6WithTag    = inOutDict[\"unaccCfg6WithTag\"]\n\n    isIp4TagPresent = isIp6TagPresent = False\n    poTag4 = poTag6 = \"\"\n    if \"interface_ipv4_tag_11_1\" in templateNameMatches:\n        poTag4 = matchingNvPairs[\"interface_ipv4_tag_11_1\"][\"TAG\"]\n        isIp4TagPresent = True\n    if \"interface_ipv6_tag_11_1\" in templateNameMatches:\n        poTag6 = matchingNvPairs[\"interface_ipv6_tag_11_1\"][\"TAG\"]\n        isIp6TagPresent = True\n\n    if isIp4TagPresent or isIp6TagPresent:\n        if poTag4:\n            poRoutingTag = poTag4\n        elif poTag6:\n            poRoutingTag = poTag6\n        else:\n            #default tag will be from v4\n            poRoutingTag = poTag4\n\n    if \"interface_ipv4_tag_11_1\" in templateNameMatches:\n        poIp4 = matchingNvPairs[\"interface_ipv4_tag_11_1\"][\"IP\"]\n        poPrefix4 = matchingNvPairs[\"interface_ipv4_tag_11_1\"][\"PREFIX\"]\n        Wrapper.print(\"Found ip [%s], prefix [%s]\"%(poIp4, poPrefix4))\n    elif \"interface_ipv4_11_1\" in templateNameMatches:\n        poIp4 = matchingNvPairs[\"interface_ipv4_11_1\"][\"IP\"]\n        poPrefix4 = matchingNvPairs[\"interface_ipv4_11_1\"][\"PREFIX\"]\n        Wrapper.print(\"Found ip [%s], prefix [%s]\"%(poIp4, poPrefix4))\n    if \"interface_ipv6_tag_11_1\" in templateNameMatches:\n        count = 1\n        matchingMultiNvPairs = getIntfMatchMultiNvPairs(matchResult, intfName, [\"interface_ipv6_tag_11_1\"])\n        for item in matchingMultiNvPairs[\"interface_ipv6_tag_11_1\"]:\n            tmpIp6 = item[\"IP\"]\n            tmpPrefix6 = item[\"PREFIX\"]\n            tmpTag = item[\"TAG\"]\n            if count == 1 and not poIp6 and tmpIp6 != poIp6: #not already accounted\n                poIp6 = tmpIp6\n                poPrefix6 = tmpPrefix6\n            else: # if not first and already accounted one is chosen\n                if tmpTag:\n                    ip6MaskTag = \"ipv6 address %s/%s tag %s\"%(ip6Tmp,prefix6Tmp, tmpTag)\n                else:\n                    ip6MaskTag = \"ipv6 address %s/%s\"%(ip6Tmp, prefix6Tmp)\n                if unaccCfg6WithTag:\n                    unaccCfg6WithTag = unaccCfg6WithTag + Util.newLine() + ip6MaskTag\n                else:\n                    unaccCfg6WithTag = ip6MaskTag\n            count = count+1\n        Wrapper.print(\"Found ip6 [%s], prefix6 [%s], tag [%s]\"%(poIp6, poPrefix6, poRoutingTag))\n        Wrapper.print(\"Found unaccCfg6WithTag [%s]\"%(unaccCfg6WithTag))\n    if \"interface_ipv6_11_1\" in templateNameMatches:\n        count = 1\n        matchingMultiNvPairs = getIntfMatchMultiNvPairs(matchResult, intfName, [\"interface_ipv6_11_1\"])\n        for item in matchingMultiNvPairs[\"interface_ipv6_11_1\"]:\n            tmpIp6 = item[\"IP\"]\n            tmpPrefix6 = item[\"PREFIX\"]\n            if count == 1 and not poIp6 and tmpIp6 != poIp6: #not already accounted\n                poIp6 = tmpIp6\n                poPrefix6 = tmpPrefix6\n            else:\n                ip6Mask = \"ipv6 address %s/%s\"%(tmpIp6, tmpPrefix6)\n                if unaccCfg6:\n                    unaccCfg6 = unaccCfg6 + Util.newLine() + ip6Mask\n                else:\n                    unaccCfg6 = ip6Mask\n            count = count+1\n        Wrapper.print(\"Found ip6 [%s], prefix6 [%s]\"%(poIp6, poPrefix6))\n        Wrapper.print(\"Found unaccCfg6 [%s]\"%(unaccCfg6))\n    inOutDict.update({\"poIp4\":poIp4, \"poPrefix4\":poPrefix4, \"poIp6\":poIp6, \"poPrefix6\":poPrefix6, \n                      \"poRoutingTag\": poRoutingTag, \"unaccCfg6\":unaccCfg6, \"unaccCfg6WithTag\":unaccCfg6WithTag})\n    Wrapper.print(\"%s(): L3 port-channel output dict [%s]\"%(funcName, str(inOutDict))) \n    return inOutDict\n\ndef ECLdeviceUpgradeIntf(gVarDictObj, matchResult, interfacesRes, isValidVPC, device_overlay_vlans, vpcPairInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    topologyDataObj = gVarDictObj[\"topologyObj\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    switchInfo = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n    migrateMode = switchInfo[\"migrationMode\"]\n    fmtName = switchInfo[\"fmtName\"]\n    switchRole = switchInfo['switchRole']\n    fabricName = FABRIC_NAME\n    allFabricInterfaces = topologyDataObj.get(TopologyInfoType.ALL_FABRIC_INTFS, devSerial)\n    Wrapper.print(\"%s: [%s] all Fabric intf %s\" % (funcName, fmtName, allFabricInterfaces))\n\n    linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, devSerial,  Helper.getNbrTypeInternal()))\n    # collect the FEX IDs info\n    fexList = {}\n    nvPairList = getTemplateMatchResults(matchResult, \"base_fex\")\n    if (nvPairList != None):\n        # build the FEX dictionary\n        for nvPair in nvPairList:\n            fexList[nvPair[\"FEX_ID\"]] = nvPair\n    else:\n        nvPairList = getTemplateMatchResults(matchResult, \"base_fex_N7k\")\n        if (nvPairList != None):\n            # build the FEX dictionary\n            for nvPair in nvPairList:\n                fexList[nvPair[\"FEX_ID\"]] = nvPair\n    Wrapper.print(\"%s: [%s]  device %s fexList [%s]\" % (funcName, fmtName, devSerial, fexList))\n    vpcLinkMemberInterfaces = []\n    isVPC = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, devSerial))\n    vpcPairSerialKey = \"\"\n    if isVPC:\n        vpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, devSerial))\n        Wrapper.print(\"%s(): vPC: pair [%s]\" % (funcName, vpcPairSerialKey))\n        serials = vpcPairSerialKey.split(Helper.DELIMITER)\n        vpcSn = devSerial\n        vpcPeerSn = serials[1] if vpcSn == serials[0] else serials[0]\n        vpcLinkMemberInterfaces = topologyDataObj.get(TopologyInfoType.VPC_PEER_LINK_MEMBERS, vpcSn, vpcPeerSn)\n    Wrapper.print(\"%s: [%s] - vpc Link members [%s]\" % (funcName, fmtName, vpcLinkMemberInterfaces))\n\n    # special handling for breakout interfaces\n    templateName = \"breakout_interface\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        ptiSource = getSrc(templateName)\n        for nvPair in nvPairList:\n            Wrapper.print(\"Breakout: slot [%s], ports [%s]\" % (nvPair[\"SLOT\"], nvPair[\"PORT\"]))\n\n            # if the PORT is a range, then we need to unroll it into individual PTIs\n            ports = getIntegerRange(nvPair[\"PORT\"])\n\n            # create individual PTIs for each port\n            for port in ports:\n                # update the 'PORT' key value in the policy instance\n                nvPair[\"PORT\"] = str(port)\n                entityName = \"Ethernet\" + nvPair[\"SLOT\"] + \"/\" + nvPair[\"PORT\"]\n                createPTI(devSerial, nvPair, templateName, entityName, ptiSource, -1)\n\n    # process PO and vPC host ports\n    poInterfaces = {}\n\n    # gather the PO and vPC info in two passes\n    # pass 1: the main PO interfaces list\n    # pass 2: the corresponding members\n    for roundNum in range(1,3):\n        for intfName in sorted(interfacesRes.keys()):\n            # get the interface match results\n            intfMatchResult = interfacesRes[intfName]\n\n            # skip interfaces that have been processed\n            if isIntfProcessed(intfMatchResult):\n                continue\n\n            templateNameMatches = intfMatchResult[\"matched_templates\"]\n\n            if roundNum == 1:\n                # Pass 1 - gather the parent PO entries\n                if (intfName.lower().startswith(\"port-channel\")):\n                    isAccessPort = False\n                    isDot1qTunnel = False\n                    isFexPo = False\n                    isL3Po = False\n                    subIntf = False\n                    if (\"fex_port_channel_interface\" in templateNameMatches):\n                        # this is a FEX PO\n                        isFexPo = True\n                    elif((\"access_interface\" in templateNameMatches) or \n                         (\"access_interface_fex\" in templateNameMatches) or \n                         (\"port_channel_access_interface\" in templateNameMatches) or\n                         (\"port_channel_dot1q_tunnel_interface\" in templateNameMatches) or\n                         (\"dot1q_tunnel_interface\" in templateNameMatches)):\n                        # treat dot1q tunnel port as access\n                        isAccessPort = True\n\n                        if ((\"port_channel_dot1q_tunnel_interface\" in templateNameMatches) or\n                            (\"dot1q_tunnel_interface\" in templateNameMatches)):\n                            isDot1qTunnel = True\n                    elif (\"port_channel_routed_interface\" in templateNameMatches):\n                        isL3Po = True\n                    elif (\"interface_subintf\" in templateNameMatches):\n                        isL3Po = True\n                    elif not (\"port_channel_trunk_interface_11_1\" in templateNameMatches):\n                        # not a normal PO we understand\n                        Wrapper.print(\"Incomplete policy match - PO [%s]\" % intfName)\n                        continue\n                    \n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n                    Wrapper.print(\"Switch [%s] : Found PO [%s] isFexPo [%r] isAccessPort [%r] isDot1qTunnel [%r] isL3Po [%r] \" % (devSerial,\n                            intfName, isFexPo, isAccessPort, isDot1qTunnel, isL3Po))\n\n                    # record this PO, with the key as the PO id\n                    # extract the id\n                    portChannelIntf = intfName.lower()\n                    pc, pcid = portChannelIntf.split(\"port-channel\")\n\n                    poMtu = \"1500\"\n                    poSpeed = \"auto\"\n                    poAdminState = \"true\"\n                    poDesc = \"\"\n                    orphanPort = \"false\"\n                    bpduGuardState = \"no\"\n                    porttype_fast_enable = \"false\"\n                    porttype_fast_trunk = \"false\"\n                    vpcId = \"\"\n                    fexId = \"\"\n                    access_vlan = \"\"\n                    native_vlan = \"\"\n                    poIp4 = \"\"\n                    poPrefix4 = \"\"\n                    poIp6 = \"\"\n                    poPrefix6 = \"\"\n                    poRoutingTag = \"\"\n                    dot1qVlan = \"\"\n                    poVrf = \"\"\n                    unaccCfg6 = \"\" \n                    unaccCfg6WithTag = \"\" \n                    l3PoDict = {}\n                    if (\"interface_mtu\" in templateNameMatches):\n                        poMtu = matchingNvPairs[\"interface_mtu\"][\"MTU\"]\n                    if (\"interface_speed\" in templateNameMatches):\n                        poSpeed = matchingNvPairs[\"interface_speed\"][\"SPEED\"]\n                    if isFexPo:\n                        fexId = matchingNvPairs[\"fex_port_channel_interface\"][\"FEX_ID\"]\n                    if (\"shut_interface\" in templateNameMatches):\n                        poAdminState = \"false\"\n                    if (\"interface_desc\" in templateNameMatches):\n                        poDesc = matchingNvPairs[\"interface_desc\"][\"DESC\"]\n                    if (\"interface_orphan_port\" in templateNameMatches):\n                        orphanPort = \"true\"\n                    if (\"bpduguard_enable\" in templateNameMatches):\n                        bpduGuardState = \"true\"\n                    if (\"bpduguard_disable\" in templateNameMatches):\n                        bpduGuardState = \"false\"\n                    if (\"porttype_fast_trunk\" in templateNameMatches):\n                        porttype_fast_trunk = \"true\"\n                    if (\"porttype_fast_enable\" in templateNameMatches):\n                        porttype_fast_enable = \"true\"\n                    if (\"port_channel_vpc_id_11_1\" in templateNameMatches):\n                        vpcId = matchingNvPairs[\"port_channel_vpc_id_11_1\"][\"VPC_ID\"]\n                        Wrapper.print(\"Found vpcId [%s]\" % vpcId)\n                    if (\"access_vlan\" in templateNameMatches and matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"] !=1):\n                        access_vlan = processAccessIntfOverlayInfo(devSerial, migrateMode, \n                            intfName, matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"],\n                            globalOverlayInfo, device_overlay_vlans)\n                    if (\"native_vlan\" in templateNameMatches):\n                        native_vlan = matchingNvPairs[\"native_vlan\"][\"NATIVE_VLAN\"]\n                    if \"interface_ipv4_tag_11_1\" in templateNameMatches:\n                        isL3Po = True\n                    elif \"interface_ipv4_11_1\" in templateNameMatches:\n                        isL3Po = True\n                    if \"interface_ipv6_tag_11_1\" in templateNameMatches:\n                        isL3Po = True\n                    elif \"interface_ipv6_11_1\" in templateNameMatches:\n                        isL3Po = True\n\n                    if \"interface_subintf\" in templateNameMatches and \".\" in pcid:\n                        dot1qVlan = matchingNvPairs[\"interface_subintf\"][\"VLAN\"]\n                        Wrapper.print(\"Found dot1q Vlan [%s]\"%(dot1qVlan))\n                        isL3Po = True\n                        subIntf = True\n\n                    if isL3Po and \"interface_vrf\" in templateNameMatches:\n                        poVrf = matchingNvPairs[\"interface_vrf\"][\"INTF_VRF\"]\n                        Wrapper.print(\"Found po vrf [%s]\"%(poVrf))\n\n                    l3PoDict = {\"poIp4\": \"\", \"poPrefix4\":\"\", \"poIp6\": \"\", \"poPrefix6\":\"\", \n                                \"poRoutingTag\": \"\", \"unaccCfg6\":\"\", \"unaccCfg6WithTag\":\"\"}\n                    if isL3Po:\n                        getIpsFromNvPairs(templateNameMatches, matchResult, matchingNvPairs, intfName, l3PoDict)\n\n                    allowed_vlans = \"none\"\n                    allowed_vlan_orig = \"none\"\n                    if (\"port_channel_trunk_interface_11_1\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"port_channel_trunk_interface_11_1\"][\"ALLOWED_VLANS\"]\n                    elif (\"trunk_interface\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"trunk_interface\"][\"ALLOWED_VLANS\"]\n                    elif (\"trunk_interface_fex\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"trunk_interface_fex\"][\"ALLOWED_VLANS\"]\n                    elif (\"port_channel_routed_interface\" in templateNameMatches):\n                        isL3Po = True\n                    \n                    if not isAccessPort and not isL3Po:\n                        allowed_vlans = processTrunkIntfOverlayInfo(devSerial, migrateMode, intfName,\n                                    allowed_vlan_orig, globalOverlayInfo, device_overlay_vlans)\n                    unaccCfg = \"\"\n                    if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                        Wrapper.print(\"Device [%s]: Found unaccounted cfg for portchannel intf [%s]\" % (devSerial, intfName))\n                        unaccCfg = Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"]) \n\n                    templateList = [\n                                    \"bfd_interface_auth\",\n                                    \"bfd_no_echo_interface\", \n                                    \"ospf_p2p_interface\",\n                                    \"ospf_interface_auth\",\n                                    \"isis_p2p_inteface\",\n                                    \"isis_interface_auth\",\n                                    \"isis_interface_auth_no_lvl\",\n                                    \"vlan_interface_fwd_mode_11_1\",\n                                    \"interface_ipv6_11_1\",\n                                    \"interface_ipv6_tag_11_1\",\n                                    \"cdp_disable_interface_11_1\"\n                                   ]\n                    if isAccessPort:\n                        templateList.append(\"porttype_fast_trunk\")\n                    elif not isL3Po:\n                        templateList.append(\"access_vlan\")\n                        templateList.append(\"porttype_fast_enable\")\n                    elif isL3Po:\n                        templateList.remove(\"interface_ipv6_11_1\")\n                        templateList.remove(\"interface_ipv6_tag_11_1\")\n\n                    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n                    if unaccCfg and configList:\n                        unaccCfg = unaccCfg + Util.newLine() + Util.newLine().join(configList)\n                    elif configList:\n                        unaccCfg = Util.newLine().join(configList)\n\n                    if isL3Po:\n                        unaccCfg6 = l3PoDict.get(\"unaccCfg6\", \"\")\n                        unaccCfg6WithTag = l3PoDict.get(\"unaccCfg6WithTag\", \"\")\n                        if unaccCfg6:\n                            unaccCfg = unaccCfg + Util.newLine() + unaccCfg6\n                        if unaccCfg6WithTag: \n                            unaccCfg = unaccCfg + Util.newLine() + unaccCfg6WithTag\n                    if not isL3Po:\n                        poInterfaces.update({pcid : {\"name\" : intfName,\n                                                     \"mtu\" : poMtu,\n                                                     \"speed\" : poSpeed,\n                                                     \"vpcId\" : vpcId,\n                                                     \"poMode\" : \"active\",\n                                                     \"poDesc\" : poDesc,\n                                                     \"orphanPort\" : orphanPort,\n                                                     \"adminState\" : poAdminState,\n                                                     \"bpduguard\" : bpduGuardState,\n                                                     \"porttype_fast_enable\" : porttype_fast_enable,\n                                                     \"porttype_fast_trunk\" : porttype_fast_trunk,\n                                                     \"fexId\" : fexId,\n                                                     \"allowed_vlans\": allowed_vlans,\n                                                     \"access_vlan\": access_vlan,\n                                                     \"native_vlan\": native_vlan,\n                                                     \"access_port\": isAccessPort,\n                                                     \"dot1q_tunnel\" : isDot1qTunnel,\n                                                     \"members\" : [],\n                                                     \"poConf\" : unaccCfg,\n                                                     \"isL3Po\"   : False\n                                                     }\n                                                     })\n                    else:\n                        poInterfaces.update({pcid : {\"name\"       : intfName,\n                                                     \"mtu\"        : poMtu,\n                                                     \"speed\"      : poSpeed,\n                                                     \"vpcId\"      : vpcId,\n                                                     \"fexId\"      : fexId,\n                                                     \"poDesc\"     : poDesc,\n                                                     \"ip4\"        : l3PoDict.get(\"poIp4\", \"\"),\n                                                     \"prefix4\"    : l3PoDict.get(\"poPrefix4\", \"\"),\n                                                     \"ip6\"        : l3PoDict.get(\"poIp6\", \"\"),\n                                                     \"prefix6\"    : l3PoDict.get(\"poPrefix6\", \"\"),\n                                                     \"tag\"        : l3PoDict.get(\"poRoutingTag\", \"\"),\n                                                     \"vrf\"        : poVrf,\n                                                     \"dot1qVlan\"  : dot1qVlan,\n                                                     \"poMode\"     : \"active\",\n                                                     \"poDesc\"     : poDesc,\n                                                     \"adminState\" : poAdminState,\n                                                     \"members\"    : [],\n                                                     \"poConf\"     : unaccCfg,\n                                                     \"isL3Po\"     : True,\n                                                     \"isSubIntf\"  : True if (\".\" in pcid or subIntf) else False\n                                                     }\n                                                     })\n\n                    Wrapper.print(\"Switch [%s] : Added entry for l3Po [%s] PO [%s] id [%s]\" % (devSerial, isL3Po, intfName, pcid))\n                    Wrapper.print(\"Switch [%s] : Added entry [%r]\" % (devSerial, poInterfaces))\n\n            else:\n                # Pass 2 - gather the PO/vPC member entries\n                if ((\"port_channel_mode_on\" in templateNameMatches) or\n                    (\"port_channel_mode\" in templateNameMatches)):\n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    # TODO: check if this a host vPC or regular PO based on the 'vpc' config\n                    templatesToCheck = [\"port_channel_mode_on\",\n                                        \"port_channel_mode\"\n                                       ]\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templatesToCheck)\n\n                    pcid = \"\"\n                    mode = \"\"\n                    for templateName in matchingNvPairs:\n                        if (\"port_channel_mode_on\" == templateName):\n                            # record the PO mode\n                            pcid = matchingNvPairs[templateName][\"PCID\"]\n                            mode = \"on\"\n                            break\n                        elif (\"port_channel_mode\" == templateName):\n                            # record the PO mode\n                            pcid = matchingNvPairs[templateName][\"PCID\"]\n                            mode = matchingNvPairs[templateName][\"PC_MODE\"]\n                            break\n\n                    Wrapper.print(\"Switch [%s] - Found PO member intf [%s] mode [%s] parent PO id [%s]\" %\n                        (devSerial, intfName, mode, pcid))\n                    # lookup the main PO dictionary object\n                    try:\n                        parentPo = poInterfaces[pcid]\n                        # update the PO mode\n                        parentPo[\"poMode\"] = mode\n                        # add this interface as a member\n                        parentPo[\"members\"].append(intfName)\n                    except:\n                        intfMatchResult.update({\"isProcessed\" : False})\n                        Wrapper.print(\"ERROR: Switch [%s] Did not find parent PO for intf [%s] id [%s]\" % \n                                                    (devSerial, intfName, pcid))\n                elif (\"fex_po_member_interface\" in templateNameMatches):\n                    Wrapper.print(\"Found FEX member [%s]\" % intfName)\n                    #Wrapper.print(str(templateNameMatches))\n\n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, [\"fex_po_member_interface\"])\n\n                    # lookup the main PO dictionary object\n                    pcid = matchingNvPairs[\"fex_po_member_interface\"][\"PCID\"]\n                    try:\n                        parentPo = poInterfaces[pcid]\n                        Wrapper.print(\"PO: [%s]. adding fex member [%s]\" % (pcid, intfName))\n\n                        # add this interface as a member\n                        parentPo[\"members\"].append(intfName)\n                    except:\n                        intfMatchResult.update({\"isProcessed\" : False})\n                        Wrapper.print(\"ERROR: Did not find parent FEX PO for intf [%s] id [%s]\" % \n                                                (intfName, pcid))\n\n    # create the host PO and VPCs\n    for pcid in poInterfaces:\n        poEntry = poInterfaces[pcid]\n        poName = poEntry[\"name\"]\n        vpcIntfName = \"vPC\" + poEntry[\"vpcId\"]\n        isL3Po = poEntry[\"isL3Po\"]\n        isL3SubIfPo = poEntry[\"isSubIntf\"] if isL3Po else False\n\n        Wrapper.print(\"poName [%s] isL3Po [%s] isL3SubIfPo [%s] process poEntry [%r]\" % (poName, isL3Po, isL3SubIfPo, poEntry))\n\n        intfMatchResult = interfacesRes[poName]\n        if (poEntry[\"fexId\"] != \"\"):\n            if (poEntry[\"vpcId\"] != \"\"):\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: VPC_ID [%s] FEX_ID :[%s]\" % (FABRIC_NAME, key, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n\n                # check if we have the peer serial number\n                peerSerial = \"\"\n                try:\n                    peerSerial = vpcPairInfo[\"peerSerialNum\"]\n                    Wrapper.print(\"AAFEX: peer device [%s] is found for device[%s].\"%(peerSerial, devSerial))\n                except:\n                    Wrapper.print(\"AAFEX: peer serial # is empty. create PTIs to save vpc host info for later use\")\n                    \"\"\"\n                    memberIntfParams = {}\n                    for member in poEntry[\"members\"]:\n                        templatesToCheck = [\"interface_desc\"]\n                        matchingNvPairs = getIntfMatchNvPairs(matchResult, member, templatesToCheck)\n                        if \"interface_desc\" in matchingNvPairs:\n                            desc = matchingNvPairs[\"interface_desc\"][\"DESC\"]\n                        else:\n                            desc = \"\"\n                        if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                            Wrapper.print(\"AAFEX: Device [%s]: Found unaccounted cfg for aa fex po intf [%s]\" % (devSerial, member))\n                            unaccCfgMember = Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"])\n                        else:\n                            unaccCfgMember = \"\"\n                        memberIntfParams.update({member: {\"SN\": devSerial, \"DESC\": desc, \"CONF\": unaccCfgMember}}) \n                    \"\"\"\n\n                    nvPairs = {\"PO_ID\": poName,\n                               \"FEX_ID\" : poEntry[\"fexId\"],\n                               \"MTU\": Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                               \"PO_DESC\": poEntry[\"poDesc\"],\n                               \"ADMIN_STATE\": poEntry[\"adminState\"],\n                               \"DESC\": fexList[poEntry[\"fexId\"]][\"DESC\"],\n                               \"MEMBER_INTERFACES\": \",\".join(poEntry[\"members\"]),\n                               \"INTF_NAME\": vpcIntfName,\n                               \"PO_CONF\":poEntry[\"poConf\"]\n                              }\n                    templateList = [\n                                    \"access_vlan\", \n                                    \"porttype_fast_enable\",\n                                    \"porttype_fast_trunk\",\n                                    \"interface_ipv4_tag_11_1\"\n                                    ]\n                    configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n                    if nvPairs[\"PO_CONF\"] and configList:\n                        nvPairs[\"PO_CONF\"] = nvPairs[\"PO_CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                    elif configList:\n                        nvPairs[\"PO_CONF\"] = Util.newLine().join(configList)\n\n                    # create the vpc host PO trunk jython policy\n                    Wrapper.print(\"Creating standalone fex host PO [%s] vpc [%s] fexid [%s] policy\" % (poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                    createPTI(devSerial, nvPairs, \"int_aa_fex_standalone_11_1\", vpcIntfName, \"temp\", -1)\n                    #need to delete PTI if peer not found in the end\n                    continue\n\n                # vpc host case\n                Wrapper.print(\"AAFEX: Creating AA host PO [%s] vpc [%s] fexid [%s] policy\" %(poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                # we also need to get the vPC trunk host intf info of the peer\n                peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\",\n                                                          vpcIntfName, \"temp\",\n                                                          \"int_aa_fex_standalone_11_1\"))\n\n                peer_member_intfs = \"\"\n                peer_po_desc = \"\"\n                peer_po_conf = \"\"\n                peer_pcid = \"\"\n                peer_fex_desc = \"\"\n                peer_fex_id = \"\"\n                for peervPCpti in peerIntfvPCPTIs:\n                    peer_member_intfs = peervPCpti.getNvPairs()[\"MEMBER_INTERFACES\"]\n                    peer_fex_desc = peervPCpti.getNvPairs()[\"DESC\"]\n                    peer_fex_id =  peervPCpti.getNvPairs()[\"FEX_ID\"]\n                    peer_po_desc = peervPCpti.getNvPairs()[\"PO_DESC\"]\n                    peer_po_conf = peervPCpti.getNvPairs()[\"PO_CONF\"]\n                    discard, peer_pcid = peervPCpti.getNvPairs()[\"PO_ID\"].split(\"port-channel\")\n                    Wrapper.print(\"Deleting peer fex intf [%s] PTIs\" % peer_member_intfs)\n                    Wrapper.print(\"peer fex_desc:[%s], fex_id:[%s], po_desc:[%s], po_id:[%s]\" %\n                                  (peer_fex_desc, peer_fex_id, peer_po_desc, peer_pcid))\n                    Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n                    break\n\n                # get the vPC pair key with the internal serial1:serial2 format\n                vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n                Wrapper.print(\"AA Host PO: pair string [%s]\" % (vpcPairSerialKey))\n                serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n                nvPairs = {\"INTF_NAME\" : vpcIntfName,\n                           \"ADMIN_STATE\": poEntry[\"adminState\"],\n                           \"PEER1_PCID\": \"\",\n                           \"PEER2_PCID\": \"\",\n                           \"PEER1_MEMBER_INTERFACES\": \"\",\n                           \"PEER2_MEMBER_INTERFACES\": \"\",\n                           \"DESC\": \"\",\n                           \"PC_MODE\" : poEntry[\"poMode\"],\n                           \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"PEER1_PO_DESC\": \"\",\n                           \"PEER2_PO_DESC\": \"\",\n                           \"PEER1_PO_CONF\": \"\",\n                           \"PEER2_PO_CONF\": \"\",\n                           \"createVpc\" : \"true\",\n                           \"FEX_ID\" : \"\",\n                           \"FABRIC_NAME\" : FABRIC_NAME\n                          }\n\n                nvPairs[\"FEX_ID\"] = poEntry[\"fexId\"]\n                nvPairs[\"DESC\"] = fexList[poEntry[\"fexId\"]][\"DESC\"]\n                if (serials[0] == devSerial):\n                    nvPairs[\"PEER1_SN\"] = devSerial\n                    nvPairs[\"PEER1_PCID\"] = pcid\n                    nvPairs[\"PEER1_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                    nvPairs[\"PEER1_PO_DESC\"] = poEntry[\"poDesc\"]\n                    nvPairs[\"PEER1_PO_CONF\"] = poEntry[\"poConf\"]\n\n                    nvPairs[\"PEER2_SN\"] = peerSerial\n                    nvPairs[\"PEER2_PCID\"] = peer_pcid\n                    nvPairs[\"PEER2_MEMBER_INTERFACES\"] = peer_member_intfs\n                    nvPairs[\"PEER2_PO_DESC\"] = peer_po_desc\n                    nvPairs[\"PEER2_PO_CONF\"] = peer_po_conf\n\n                else:\n                    nvPairs[\"PEER1_SN\"] = peerSerial\n                    nvPairs[\"PEER1_PCID\"] = peer_pcid\n                    nvPairs[\"PEER1_MEMBER_INTERFACES\"] = peer_member_intfs\n                    nvPairs[\"PEER1_PO_DESC\"] = peer_po_desc\n                    nvPairs[\"PEER1_PO_CONF\"] = peer_po_conf\n\n                    nvPairs[\"PEER2_SN\"] = devSerial\n                    nvPairs[\"PEER2_PCID\"] = pcid\n                    nvPairs[\"PEER2_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                    nvPairs[\"PEER2_PO_DESC\"] = poEntry[\"poDesc\"]\n                    nvPairs[\"PEER2_PO_CONF\"] = poEntry[\"poConf\"]\n\n                Wrapper.print(\"SN:[%s] PEER_SN:[%s] - AA host nvPairs [%s]\"% (devSerial, peerSerial, nvPairs))\n\n                #Sanity to ensure valid AA fex config\n                if (nvPairs[\"PEER1_PCID\"] == \"\" or\n                    nvPairs[\"PEER2_PCID\"] == \"\" or\n                    nvPairs[\"FEX_ID\"] == \"\" ):\n                    Wrapper.print(\"Orphan AA!!! bail out\")\n                    \"\"\"\n                    respObj.setWarningRetCode()\n                    respObj.addWarnReport(getFabErrEntity(unaccountedConfigError.__name__, devSerial+ \":vpc \" +poEntry[\"vpcId\"]),\n                                  \"SN: [%s] FEX with vPC ID [%s] configuration is not correct !!! Either vPC po on Peer or FEX_ID [%s] is missing\"%\n                                  (devSerial, poEntry[\"vpcId\"], nvPairs[\"FEX_ID\"]))\n                    \"\"\"\n                    intfMatchResult.update({\"isProcessed\" : False})\n                    continue\n\n                key = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, peerSerial, vpcIntfName))\n                ignore, vpcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", devSerial, key, poEntry[\"vpcId\"]))\n                ignore, vpcRmId2 = Util.exeRM(RM.findRMDetails(FABRIC_NAME, \"VPC_ID\", key, peerSerial, poEntry[\"vpcId\"]))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s]: VPC_ID [%s] rmId [%s], peer rmId [%s]\" % (FABRIC_NAME, key, poEntry[\"vpcId\"], vpcRmId1, vpcRmId2))\n\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                ignore, pcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+pcid, pcid))\n                ignore, fexRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s] FEX_ID [%s] fexRmId [%s]\"\n                              % (FABRIC_NAME, key, pcid, \"port-channel\"+pcid, pcRmId1, poEntry[\"fexId\"], fexRmId1))\n\n                key = Util.exe(Helper.getKey(\"Device\", peerSerial))\n                ignore, pcRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+peer_pcid, peer_pcid))\n                ignore, fexRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                #Wrapper.print(\"FAB [%s] RM SET: Key [%s]: PORT_CHANNEL_ID [%s] rmId [%s] FEX_ID [%s] fexRmId [%s]\" % (FABRIC_NAME, key, peer_pcid, pcRmId2, poEntry[\"fexId\"], fexRmId2))\n\n                rmIds = [vpcRmId1] + [vpcRmId2] + [fexRmId1] + [fexRmId2]+ [pcRmId1] + [pcRmId2]\n\n                # create the AA fex vpc host PO trunk jython policy\n                Wrapper.print(\"Creating AA FEX vpc host PO [%s] vpc [%s] fexid [%s] policy\" % (poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                createPTI(vpcPairSerialKey, nvPairs, \"int_port_channel_aa_fex\", vpcIntfName,\n                          getSrc(\"int_port_channel_aa_fex\"), rmIds)\n\n                sn1 = sn2 = memberIntfsPeer1 = memberIntfsPeer2 =  poPCIdPeer1 = poPCIdPeer2 = \"\"\n                if nvPairs[\"PEER1_SN\"] == devSerial:\n                    sn1 = devSerial\n                    sn2 = peerSerial\n                    memberIntfsPeer1 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                    memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                    memberIntfsPeer2 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                    memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                    poPCIdPeer1 = nvPairs[\"PEER1_PCID\"]\n                    poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n                elif nvPairs[\"PEER2_SN\"] == devSerial:\n                    sn1 = devSerial\n                    sn2 = peerSerial\n                    memberIntfsPeer1 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                    memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                    memberIntfsPeer2 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                    memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                    poPCIdPeer1 = nvPairs[\"PEER2_PCID\"]\n                    poPCIdPeer2 = nvPairs[\"PEER1_PCID\"]\n                ptiTemplate = \"int_fex_po_member_11_1\"\n                peerMatchResult, peerInterfacesRes = getSwitchMatchResults(peerSerial)\n                poMemberDescAndFFUpd(sn1, memberIntfsPeer1List, ptiTemplate, \n                                     poPCIdPeer1, matchResult, interfacesRes, vpcIntfName)\n                poMemberDescAndFFUpd(sn2, memberIntfsPeer2List, ptiTemplate,\n                                     poPCIdPeer2, peerMatchResult, peerInterfacesRes, vpcIntfName)\n            else:\n                Wrapper.print(\"====%s(): devSerial %s poEntry[%s]\"%(funcName, devSerial, poEntry))\n                # standalone fex\n                nvPairs = {\"PO_ID\" : poName,\n                           \"FEX_ID\" : poEntry[\"fexId\"],\n                           \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"PO_DESC\" : poEntry[\"poDesc\"],\n                           \"ADMIN_STATE\" : poEntry[\"adminState\"],\n                           \"DESC\" : fexList[poEntry[\"fexId\"]][\"DESC\"],\n                           \"CONF\" : poEntry[\"poConf\"],\n                           \"MEMBER_INTERFACES\" : \",\".join(poEntry[\"members\"]),\n                           \"FABRIC_NAME\" : FABRIC_NAME\n                          }\n\n                templateList = [\n                                \"access_vlan\", \n                                \"porttype_fast_enable\",\n                                \"porttype_fast_trunk\",\n                                \"interface_ipv4_tag_11_1\"\n                               ]\n                configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n                if nvPairs[\"CONF\"] and configList:\n                    nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                elif configList:\n                    nvPairs[\"CONF\"] = Util.newLine().join(configList)\n\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]: FEX_ID [%s]\" % (FABRIC_NAME, key, pcid, poEntry[\"fexId\"]))\n                ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n                ignore, fexRmId = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                rmIds = [pcRmId] + [fexRmId]\n                # create the FEX PO policy\n                Wrapper.print(\"Creating FEX [%s] policy\" % poName)\n                createPTI(devSerial, nvPairs, \"int_port_channel_fex\", poName, \"\", rmIds)\n\n                memberIntfs = nvPairs.get(\"MEMBER_INTERFACES\")\n                memberIntfsList = memberIntfs.split(\",\") if memberIntfs else []\n                ignore, poPCId = poName.split(\"port-channel\")\n                ptiTemplate = \"int_fex_po_member_11_1\"\n                poMemberDescAndFFUpd(devSerial, memberIntfsList, ptiTemplate, \n                                     poPCId, matchResult, interfacesRes, poName)\n        elif (poEntry[\"vpcId\"] != \"\"):\n\n            # check if we have the peer serial number\n            peerSerial = \"\"\n            try:\n                peerSerial = vpcPairInfo[\"peerSerialNum\"]\n            except:\n                Wrapper.print(\"vPC: peer serial # is empty. create PTIs to save vpc host info for later use\")\n                nvPairs = {\"INTF_NAME\": vpcIntfName,\n                           \"ADMIN_STATE\": poEntry[\"adminState\"],\n                           \"PEER1_MEMBER_INTERFACES\": \"\" if (len(poEntry[\"members\"]) == 0) else (\",\".join(poEntry[\"members\"])),\n                           \"PC_MODE\": poEntry[\"poMode\"],\n                           \"BPDUGUARD_ENABLED\": poEntry[\"bpduguard\"],\n                           \"MTU\": Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"SPEED\": Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]),\n                           \"PO_ID\": poName,\n                           \"PO_DESC\": poEntry[\"poDesc\"],\n                           \"PO_CONF\":poEntry[\"poConf\"],\n                           \"ALLOWED_VLANS\" : poEntry[\"allowed_vlans\"],\n                           \"ACCESS_VLAN\" : poEntry[\"access_vlan\"],\n                           \"NATIVE_VLAN\" : poEntry[\"native_vlan\"],\n                           \"createVpc\": \"true\"\n                           }\n                # create the vpc host PO trunk jython policy\n                Wrapper.print(\"Creating standalone vpc host PO [%s] vpc [%s] policy\" % (poName, poEntry[\"vpcId\"]))\n                if poEntry[\"access_port\"]:\n                    templateName = \"int_vpc_access_host_standalone_11_1\"\n                else:\n                    nvPairs[\"NATIVE_VLAN\"] = poEntry[\"native_vlan\"] if poEntry[\"native_vlan\"] != \"\" else \"1\"\n                    templateName = \"int_vpc_trunk_host_standalone_11_1\"\n                createPTI(devSerial, nvPairs, templateName, vpcIntfName, \"temp\", -1)\n                #need to delete PTI if peer not found in the end\n                continue\n\n            # vpc host case\n            Wrapper.print(\"Switch [%s] : vPC: Creating vpc host PO [%s] vpc [%s] policy\" % (devSerial, poName, poEntry[\"vpcId\"]))\n            # we also need to get the vPC host intf info of the peer\n            if poEntry[\"access_port\"]:\n                templateName = \"int_vpc_access_host_standalone_11_1\"\n            else:\n                templateName = \"int_vpc_trunk_host_standalone_11_1\"\n            peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\", vpcIntfName, \"temp\", templateName))\n\n            peer_member_intfs = \"\"\n            peer_po_desc = \"\"\n            peer_po_conf = \"\"\n            peer_pcid = \"\"\n            peer_po_mtu = \"\"\n            peer_po_speed = \"Auto\"\n            peer_allowed_vlan = \"all\"\n            peer_access_vlan = \"\"\n            peer_native_vlan = \"\"\n            po_mode = poEntry[\"poMode\"]\n            for peervPCpti in peerIntfvPCPTIs:\n                peerNvPairs = peervPCpti.getNvPairs()\n                peer_member_intfs = peerNvPairs[\"PEER1_MEMBER_INTERFACES\"]\n                if len(peer_member_intfs) > 0:\n                    # the po mode must be valid on the peer.. use that\n                    po_mode = peerNvPairs[\"PC_MODE\"]\n                peer_po_desc = peerNvPairs[\"PO_DESC\"]\n                peer_po_conf = peerNvPairs[\"PO_CONF\"]\n                peer_po_mtu = peerNvPairs[\"MTU\"]\n                peer_po_speed = peerNvPairs[\"SPEED\"]\n                discard, peer_pcid = peerNvPairs[\"PO_ID\"].split(\"port-channel\")\n                peer_allowed_vlan = peerNvPairs[\"ALLOWED_VLANS\"]\n                peer_access_vlan = peerNvPairs[\"ACCESS_VLAN\"]\n                peer_native_vlan = peerNvPairs[\"NATIVE_VLAN\"]\n                Wrapper.print(\"Deleting peer vpc intf [%s] PTIs\" % peer_member_intfs)\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n                break\n\n            # get the vPC pair key with the internal serial1:serial2 format\n            vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n            Wrapper.print(\"vPC Host PO: pair string [%s]\" % (vpcPairSerialKey))\n            serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n            # Check the vPC port-channel speed config between the vPC peers.\n            # If not the same, add the speed config to the interface freeform and let users fix the config.\n            # Set the SPEED param to \"Auto\" so that no interface_speed policy will be created for the po.\n            addSpeedConfig = []\n            peerAddSpeedConfig = []\n            if Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]) == peer_po_speed:\n                vpcSpeed = peer_po_speed\n            else:\n                vpcSpeed = \"Auto\"\n                if poEntry[\"speed\"] != \"auto\":\n                    addSpeedConfig.append(\"%sspeed %s\" %(INTF_FIRST_LVL_SPACING, poEntry[\"speed\"]))\n                if peer_po_speed != \"Auto\":\n                    peerAddSpeedConfig.append(\"%sspeed %s\" %(INTF_FIRST_LVL_SPACING, Util.mapEnumToSwitchSpeed(peer_po_speed)))\n            \n            nvPairs = {\"INTF_NAME\" : vpcIntfName,\n                       \"ENABLE_MIRROR_CONFIG\": \"false\",\n                       \"ADMIN_STATE\": poEntry[\"adminState\"],\n                       \"PEER1_PCID\": \"\",\n                       \"PEER2_PCID\": \"\",\n                       \"PEER1_MEMBER_INTERFACES\": \"\",\n                       \"PEER2_MEMBER_INTERFACES\": \"\",\n                       \"PEER1_PO_DESC\": \"\",\n                       \"PEER2_PO_DESC\": \"\",\n                       \"PEER1_PO_CONF\": \"\",\n                       \"PEER2_PO_CONF\": \"\",\n                       \"PC_MODE\" : po_mode,\n                       \"BPDUGUARD_ENABLED\": poEntry[\"bpduguard\"],\n                       \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                       \"SPEED\": vpcSpeed,\n                       \"createVpc\" : \"true\"\n                      }\n\n            if (serials[0] == devSerial):\n                nvPairs[\"PEER1_SN\"] = devSerial\n                nvPairs[\"PEER1_PCID\"] = pcid\n                nvPairs[\"PEER1_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                nvPairs[\"PEER1_PO_DESC\"] = poEntry[\"poDesc\"]\n                nvPairs[\"PEER1_ALLOWED_VLANS\"] = poEntry[\"allowed_vlans\"]\n                nvPairs[\"PEER1_ACCESS_VLAN\"] = poEntry[\"access_vlan\"]\n                nvPairs[\"PEER1_NATIVE_VLAN\"] = \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"]\n                nvPairs[\"PEER1_PO_CONF\"] = poEntry[\"poConf\"] \n                if addSpeedConfig:\n                    nvPairs[\"PEER1_PO_CONF\"] = nvPairs[\"PEER1_PO_CONF\"] + Util.newLine() + Util.newLine().join(addSpeedConfig)\n\n                nvPairs[\"PEER2_SN\"] = peerSerial\n                nvPairs[\"PEER2_PCID\"] = peer_pcid\n                nvPairs[\"PEER2_MEMBER_INTERFACES\"] = peer_member_intfs\n                nvPairs[\"PEER2_PO_DESC\"] = peer_po_desc\n                nvPairs[\"PEER2_ALLOWED_VLANS\"] = peer_allowed_vlan\n                nvPairs[\"PEER2_ACCESS_VLAN\"] = peer_access_vlan\n                nvPairs[\"PEER2_NATIVE_VLAN\"] = \"\" if peer_native_vlan == \"1\" else peer_native_vlan\n                nvPairs[\"PEER2_PO_CONF\"] = peer_po_conf\n                if peerAddSpeedConfig:\n                    nvPairs[\"PEER2_PO_CONF\"] = nvPairs[\"PEER2_PO_CONF\"] + Util.newLine() + Util.newLine().join(peerAddSpeedConfig)\n            else:\n                nvPairs[\"PEER1_SN\"] = peerSerial\n                nvPairs[\"PEER1_PCID\"] = peer_pcid\n                nvPairs[\"PEER1_MEMBER_INTERFACES\"] = peer_member_intfs\n                nvPairs[\"PEER1_PO_DESC\"] = peer_po_desc\n                nvPairs[\"PEER1_ALLOWED_VLANS\"] = peer_allowed_vlan\n                nvPairs[\"PEER1_ACCESS_VLAN\"] = peer_access_vlan\n                nvPairs[\"PEER1_NATIVE_VLAN\"] = \"\" if peer_native_vlan == \"1\" else peer_native_vlan\n                nvPairs[\"PEER1_PO_CONF\"] = peer_po_conf\n                if peerAddSpeedConfig:\n                    nvPairs[\"PEER1_PO_CONF\"] = nvPairs[\"PEER1_PO_CONF\"] + Util.newLine() + Util.newLine().join(peerAddSpeedConfig)\n\n                nvPairs[\"PEER2_SN\"] = devSerial\n                nvPairs[\"PEER2_PCID\"] = pcid\n                nvPairs[\"PEER2_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                nvPairs[\"PEER2_PO_DESC\"] = poEntry[\"poDesc\"]\n                nvPairs[\"PEER2_ALLOWED_VLANS\"] = poEntry[\"allowed_vlans\"]\n                nvPairs[\"PEER2_ACCESS_VLAN\"] = poEntry[\"access_vlan\"]\n                nvPairs[\"PEER2_NATIVE_VLAN\"] = \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"]\n                nvPairs[\"PEER2_PO_CONF\"] = poEntry[\"poConf\"] \n                if addSpeedConfig:\n                    nvPairs[\"PEER2_PO_CONF\"] = nvPairs[\"PEER2_PO_CONF\"] + Util.newLine() + Util.newLine().join(addSpeedConfig)\n            Wrapper.print(\"SN:[%s] PEER_SN:[%s] - vPC host nvPairs [%s]\"% (devSerial, peerSerial, nvPairs))\n\n            #Sanity to ensure valid vPC host config\n            if (nvPairs[\"PEER1_PCID\"] == \"\" or\n                nvPairs[\"PEER2_PCID\"] == \"\" ):\n                Wrapper.print(\"Orphan vPC host!!! bail out\")\n                \"\"\"\n                respObj.setWarningRetCode()\n                respObj.addWarnReport(getFabErrEntity(unaccountedConfigError.__name__, devSerial+ \":vpc \" +poEntry[\"vpcId\"]),\n                                      \"SN: [%s] vpc [%s] configuration is not correct !!! peer vpc po is missing\"%\n                                      (devSerial, poEntry[\"vpcId\"]))\n                \"\"\"\n                intfMatchResult.update({\"isProcessed\" : False})\n                continue\n\n            entityName = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, peerSerial, vpcIntfName))\n            ignore, vpcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", devSerial, entityName, poEntry[\"vpcId\"]))\n            ignore, vpcRmId2 = Util.exeRM(RM.findRMDetails(FABRIC_NAME, \"VPC_ID\", entityName, peerSerial, poEntry[\"vpcId\"]))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s]: VPC_ID [%s] rmId [%s] peer rmId [%s]\" % (FABRIC_NAME, entityName, poEntry[\"vpcId\"], vpcRmId1, vpcRmId2))\n\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            ignore, pcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s]\" % (FABRIC_NAME, key, pcid, poName, pcRmId1))\n\n            key = Util.exe(Helper.getKey(\"Device\", peerSerial))\n            ignore, pcRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+peer_pcid, peer_pcid))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s]\" % (FABRIC_NAME, key, pcid, \"port-channel\"+peer_pcid, pcRmId2))\n\n            rmIds = [vpcRmId1] + [vpcRmId2] + [pcRmId1] + [pcRmId2]\n            \n            # create the vpc host PO trunk jython policy\n            #Wrapper.print(\"Creating vpc host PO [%s] vpc [%s] policy\" % (poName, poEntry[\"vpcId\"]))\n            if poEntry[\"access_port\"]:\n                if poEntry[\"dot1q_tunnel\"]:\n                    templateName = \"int_vpc_dot1q_tunnel\"\n                    ptiTemplate = \"int_vpc_dot1q_tunnel_po_member_11_1\"\n                else:\n                    templateName = \"int_vpc_access_host\"\n                    ptiTemplate = \"int_vpc_access_po_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_enable\"]\n            else:\n                templateName = \"int_vpc_trunk_host\"\n                ptiTemplate = \"int_vpc_trunk_po_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_trunk\"]\n                  \n            createPTI(vpcPairSerialKey, nvPairs, templateName, vpcIntfName, getSrc(templateName), rmIds)\n\n            sn1 = sn2 = memberIntfsPeer1 = memberIntfsPeer2 =  poPCIdPeer1 = poPCIdPeer2 = \"\"\n            if nvPairs[\"PEER1_SN\"] == devSerial:\n                sn1 = devSerial\n                sn2 = peerSerial\n                memberIntfsPeer1 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                memberIntfsPeer2 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                poPCIdPeer1 = nvPairs[\"PEER1_PCID\"]\n                poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n            elif nvPairs[\"PEER2_SN\"] == devSerial:\n                sn1 = devSerial\n                sn2 = peerSerial\n                memberIntfsPeer1 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                memberIntfsPeer2 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n                poPCIdPeer2 = nvPairs[\"PEER1_PCID\"]\n            \n            peerMatchResult, peerInterfacesRes = getSwitchMatchResults(peerSerial)\n            poMemberDescAndFFUpd(sn1, memberIntfsPeer1List, ptiTemplate, \n                                 poPCIdPeer1, matchResult, interfacesRes, vpcIntfName)\n            poMemberDescAndFFUpd(sn2, memberIntfsPeer2List, ptiTemplate, \n                                 poPCIdPeer2, peerMatchResult, peerInterfacesRes, vpcIntfName)\n        elif isL3Po or isL3SubIfPo:\n            # regular PO case\n            Wrapper.print(\"FAB [%s]: isL3Po [%s] isL3SubIfPo [%s], create l3 po for [%r]\" % (FABRIC_NAME, isL3Po, isL3SubIfPo, poEntry))\n            nvPairs = {\n                       \"INTF_VRF\"       : poEntry[\"vrf\"],\n                       \"IP\"             : poEntry[\"ip4\"],\n                       \"PREFIX\"         : poEntry[\"prefix4\"],\n                       \"IPv6\"           : poEntry[\"ip6\"],\n                       \"IPv6_PREFIX\"    : poEntry[\"prefix6\"],\n                       \"ROUTING_TAG\"    : poEntry[\"tag\"],\n                       \"MTU\"            : poEntry[\"mtu\"],\n                       \"SPEED\"          : Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]),\n                       \"DESC\"           : poEntry[\"poDesc\"],\n                       \"ADMIN_STATE\"    : poEntry[\"adminState\"],\n                       \"CONF\"           : poEntry[\"poConf\"],\n                      }\n            pcRmId = -1\n            if not isL3SubIfPo:\n                nvPairs.update({\"PO_ID\": poName})\n                nvPairs.update({\"PC_MODE\": poEntry[\"poMode\"]})\n                nvPairs.update({\"MEMBER_INTERFACES\" : \"\" if (len(poEntry[\"members\"]) == 0) else (\",\".join(poEntry[\"members\"]))})\n                nvPairs.update({\"SPEED\": Util.mapSwitchSpeedToEnum(poEntry[\"speed\"])})\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]\" % (FABRIC_NAME, key, pcid))\n                ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]: PC rmId [%s]\" % (FABRIC_NAME, key, pcid, pcRmId))\n            else:\n                nvPairs.update({\"INTF_NAME\": poName})\n                dot1qVlan = poEntry[\"dot1qVlan\"]\n                nvPairs.update({\"VLAN\": dot1qVlan})\n                rmIds = [setDot1qRMResource(fabricName, devSerial, poName, dot1qVlan)]\n                Wrapper.print(\"%s: Switch [%s] poName [%s] dot1qVlan [%s] rmIds [%s]\" % (funcName, devSerial, poName, dot1qVlan, rmIds))\n\n            # create the L3 Port-channel jython policy\n            Wrapper.print(\"Creating L3 PO [%s] policy\" % poName)\n            templateList = [\n                            \"cdp_disable_interface_11_1\",\n                            \"interface_no_nego_auto\",\n                            \"isis_interface\",\n                            \"v6_isis_interface\",\n                            \"ospf_interface_11_1\",\n                            \"v6_ospf_interface\",\n                            \"ospf_p2p_interface\",\n                            \"isis_p2p_interface\",\n                            \"pim_interface\",\n                            \"ospf_interface_auth\",\n                            \"pim_interface_hello_auth\",\n                            \"isis_interface_auth\",\n                            \"isis_interface_auth_no_lvl\",\n                            \"routed_interface_no_ip_redirects\",\n                            \"bfd_interface_auth\",\n                           ]\n            if not isL3SubIfPo:\n                templateName = \"int_l3_port_channel\"\n                ptiTemplate  = \"int_l3_port_channel_member\"\n            else:\n                templateName = \"int_subif\"\n\n            configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n            Wrapper.print(\"device [%s] Interface [%s] nvPairs [%s] freeform config[%s]\"%(devSerial, poName,nvPairs, nvPairs.get(\"CONF\")))\n            createPTI(devSerial, nvPairs, templateName, poName, getSrc(templateName), pcRmId)\n\n            if not isL3SubIfPo:\n                memberIntfs = nvPairs.get(\"MEMBER_INTERFACES\")\n                memberIntfsList = memberIntfs.split(\",\") if memberIntfs else []\n                ignore, poPCId = poName.split(\"port-channel\")\n                poMemberDescAndFFUpd(devSerial, memberIntfsList, ptiTemplate, \n                                     poPCId, matchResult, interfacesRes, poName)\n        else:\n            # regular L2 PO case\n            nvPairs = {\"PO_ID\" : poName, \"PC_MODE\" : poEntry[\"poMode\"],\n                       \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                       \"SPEED\": Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]),\n                       \"DESC\" : poEntry[\"poDesc\"],\n                       \"ENABLE_ORPHAN_PORT\" : poEntry[\"orphanPort\"],\n                       \"ADMIN_STATE\" : poEntry[\"adminState\"],\n                       \"BPDUGUARD_ENABLED\" : poEntry[\"bpduguard\"],\n                       \"ALLOWED_VLANS\" : poEntry[\"allowed_vlans\"],\n                       \"PORTTYPE_FAST_ENABLED\": poEntry[\"porttype_fast_enable\"],\n                       \"ACCESS_VLAN\" : poEntry[\"access_vlan\"],\n                       \"NATIVE_VLAN\" : \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"],\n                       \"CONF\" : poEntry[\"poConf\"],\n                       \"MEMBER_INTERFACES\" : \",\".join(poEntry[\"members\"])\n                      }\n\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]\" % (FABRIC_NAME, key, pcid))\n            ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]: rmId [%s]\" % (FABRIC_NAME, key, pcid, pcRmId))\n\n            # create the host PO trunk jython policy\n            Wrapper.print(\"Creating PO [%s] policy\" % poName)\n            templateList = [\n                            \"interface_ipv4_tag_11_1\",\n                           ]\n            if poEntry[\"access_port\"]:\n                templateList.append(\"porttype_fast_trunk\")\n                if poEntry[\"dot1q_tunnel\"]:\n                    templateName = \"int_port_channel_dot1q_tunnel_host\"\n                    ptiTemplate = \"int_port_channel_dot1q_tunnel_member_11_1\"\n                else:\n                    templateName = \"int_port_channel_access_host\"\n                    ptiTemplate = \"int_port_channel_access_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_enable\"]\n            else:\n                templateList.append(\"access_vlan\") \n                templateList.append(\"porttype_fast_enable\")\n                templateName = \"int_port_channel_trunk_host\"\n                ptiTemplate = \"int_port_channel_trunk_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_trunk\"]\n                \n            configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n            Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"%(devSerial, poName, nvPairs.get(\"CONF\")))\n            createPTI(devSerial, nvPairs, templateName, poName, getSrc(templateName), pcRmId)\n\n            memberIntfs = nvPairs.get(\"MEMBER_INTERFACES\")\n            memberIntfsList = memberIntfs.split(\",\") if memberIntfs else []\n            ignore, poPCId = poName.split(\"port-channel\")\n            poMemberDescAndFFUpd(devSerial, memberIntfsList, ptiTemplate, \n                                 poPCId, matchResult, interfacesRes, poName)\n    # delete dangling standalone vpc PTI.\n    peerSerial = \"\"\n    try:\n        peerSerial = vpcPairInfo[\"peerSerialNum\"]\n    except:\n        pass\n    if peerSerial:\n        peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"temp\"))\n        for peervPCpti in peerIntfvPCPTIs:\n            vpcIntf = peervPCpti.getEntityName()\n            Wrapper.print(\"Standalone AA/vPC host policy found with %s\"%(vpcIntf))\n            if vpcIntf:\n                ptiListPeer1 = Util.exe(PTIWrapper.get(devSerial, \"INTERFACE\", vpcIntf))\n                ptiListPeer2 = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\", vpcIntf))\n                po1 = ptiListPeer1[0].nvPairs.get(\"PO_ID\") if ptiListPeer1 else \"\"\n                po2 = ptiListPeer2[0].nvPairs.get(\"PO_ID\") if ptiListPeer2 else \"\"\n                Wrapper.print(\"vpc [%s] with po1 [%s] and po2 [%s]\"%(vpcIntf, po1, po2))\n                if not ptiListPeer1 or not ptiListPeer2:\n                    errorEntity = getFabErrEntity(funcName, devSerial+ \":vpc \" + peerSerial)\n                    Wrapper.print(\"vpcPair %s:%s - doesn't have proper vpc id %s or port-channel configuration \"\n                                  \"for interface %s,%s \"%(devSerial, peerSerial, vpcIntf.strip(\"vPC\"), po1, po2))\n                    #respObj.setWarningRetCode()\n                    #respObj.addWarnReport(errorEntity, \"vpcPair %s:%s - doesn't have proper vpc id %s or port-channel configuration \"\n            if peervPCpti.getTemplateName() == \"int_aa_fex_standalone_11_1\":\n                Wrapper.print(\"deleting AA standalone host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n            if peervPCpti.getTemplateName() == \"int_vpc_trunk_host_standalone_11_1\":\n                Wrapper.print(\"deleting vPC standalone trunk host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n            if peervPCpti.getTemplateName() == \"int_vpc_access_host_standalone_11_1\":\n                Wrapper.print(\"deleting vPC standalone access host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n    # process rest of the interfaces\n    for intfName in sorted(interfacesRes.keys()):\n        lowerIntfName = intfName.lower()\n        intfMatchResult = interfacesRes[intfName]\n        Wrapper.print(\"Processing intf [%s]. Processed = %r\" % \n                      (intfName, isIntfProcessed(intfMatchResult)))\n\n        if isIntfProcessed(intfMatchResult):\n            continue\n\n        templateNameMatches = intfMatchResult[\"matched_templates\"]\n        # remove some mutually exclusive matches\n        if (\"trunk_interface\" in templateNameMatches):\n            if (\"trunk_interface_fex\" in templateNameMatches):\n                # we will delete this since it is redundant\n                templateNameMatches.remove(\"trunk_interface\")\n\n        #Wrapper.print(\"%s(): Matched templates [%s]\"%(funcName, templateNameMatches))\n        matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n        #TODO:Revisit for scenarios where access/agg may be connected without port-channels\n        if ((intfName in allFabricInterfaces) and (intfName not in vpcLinkMemberInterfaces)):\n            # processs the fabric interfaces\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is fabric interface, marked as processed at line [%s]\"%(intfName,\n                sys._getframe().f_lineno))\n            continue\n          \n        #TODO: Handle Vlan 1 for ECL fabrics\n        if (lowerIntfName.startswith(\"vlan\")):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            ignore, rmId = Util.exeRM(RM.set(FABRIC_NAME, \"TOP_DOWN_NETWORK_VLAN\", key, lowerIntfName, lowerIntfName[4:]))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: TOP_DOWN_NETWORK_VLAN [%s] intfName [%s] rmId [%s]\" %\n                          (FABRIC_NAME, key, lowerIntfName[4:], lowerIntfName, rmId))\n            nvPairs = getVlanIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n            createPTI(devSerial, nvPairs, \"int_vlan\", intfName, getSrc(\"int_vlan\"), rmId)\n            continue\n        elif (intfName.startswith(\"mgmt\")):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getMgmtIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n            PTIWrapper.createOrUpdate(devSerial, \"INTERFACE\", intfName, \"\", ConfigPriority.INTF_MGMT,\n                                \"int_mgmt\", nvPairs)\n            continue\n        elif ((\"p2p_routed_interface\" in templateNameMatches or \"interface_ipv6_11_1\" in templateNameMatches) and\n              (intfName in vpcLinkMemberInterfaces)):\n            # this is a vpc peer keep alive interface\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is vpc peer keep alive interface, marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getFabricIntfNvPairs(FABRIC_NAME, devSerial, intfName, matchingNvPairs, \n                                           LINK_STATE_ROUTING, REPLICATION_MODE, \n                                           intfMatchResult, matchResult, True)\n            nvPairs[\"IS_COMPLETE\"] = \"false\"\n            nvPairs[\"RMID_LIST\"] = \"\"\n            # check to see if the peer device is in the topology and get its details\n            peerIntf, peerSerialNum = getPoPeerDeviceSN(topologyDataObj, devSerial, intfName)\n            dictObj = {}\n            dictObj[\"FABRIC_NAME\"] = FABRIC_NAME\n            dictObj[\"FABRIC_INTERFACE\"] = FABRIC_NAME\n            dictObj[\"localSerialNum\"] = devSerial\n            dictObj[\"localIntfName\"] = intfName\n            dictObj[\"peerSerialNum\"] = peerSerialNum\n            dictObj[\"peerIntfName\"] = peerIntf\n            dictObj[\"localHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, devSerial)\n            dictObj[\"peerHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, peerSerialNum)\n            dictObj[\"linkNbrList\"] = linkNbrList\n\n            templateList = [\n                        \"interface_speed\",\n                        \"interface_no_nego_auto\",\n                        \"interface_ipv4_tag_11_1\",\n                        \"interface_ipv6_tag_11_1\",\n                        \"cdp_disable_interface_11_1\",\n                        \"routed_interface_no_ip_redirects\"\n                        ]\n            configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n\n            dictObj[\"localNvPairs\"] = nvPairs\n            Util.exe(manageVPCPKAIntf(dictObj))\n            continue\n        elif (intfName.startswith(\"loopback\")):\n            #TODO: Need to handle loopback interface properly with IP/ID in RM tracked for BF for both default and non-default VRF\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # get the id\n            loopbackId = intfName[8:]\n            #Wrapper.print(\"Found loopback ID: [%s]\" % loopbackId)\n\n            rmId = -1\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            ignore, rmId = Util.exeRM(RM.set(FABRIC_NAME, \"LOOPBACK_ID\", key, intfName, loopbackId))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s] rmId [%s]\" %\n                          (FABRIC_NAME, key, loopbackId, intfName, rmId))\n            createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME, rmId)\n            continue\n        elif (\"access_interface\" in templateNameMatches or \n              \"access_interface_fex\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the host port jython policy\n            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            templateName = \"int_access_host\"\n            createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n            continue\n        elif (\"dot1q_tunnel_interface\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the host port jython policy\n            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            templateName = \"int_dot1q_tunnel_host\"\n            createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n            continue\n        elif ((\"trunk_interface\" in templateNameMatches) or\n              (\"trunk_interface_fex\" in templateNameMatches)):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getTrunkIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            createPTI(devSerial, nvPairs, \"int_trunk_host\", intfName, getSrc(\"int_trunk_host\"), -1)\n            continue\n        elif (\"routed_interface\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Routed Intf: [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n            createRoutedIntf(switchInfo, intfName, matchingNvPairs, True)\n            continue\n        elif ((\"eth_sub_interface\" in templateNameMatches) or\n              (\"eth_sub_interface_tag\" in templateNameMatches)):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the sub-interface jython policy\n            Wrapper.print(\"Creating Sub-interface policy for [%s]\" % intfName)\n            dot1qID, nvPairs = getSubIntfNvPairs(switchInfo, intfName, matchingNvPairs)\n            if dot1qID:\n                Wrapper.print(\"%s: Switch [%s] intfName [%s] dot1qID [%s] \" % (funcName, devSerial, intfName, dot1qID))\n                rmId = setDot1qRMResource(fabricName, devSerial, intfName, dot1qID)\n            createPTI(devSerial, nvPairs, \"int_subif\", intfName, getSrc(\"int_subif\"), rmId)\n            continue\n        else:\n            createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME)\n\n        # mark the interface as being processed\n        intfMatchResult.update({\"isProcessed\" : True})\n        Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n    Wrapper.print(\"%s: [%s] Success = [%r]\" % (funcName, fmtName, respObj.isRetCodeSuccess()))\n    return respObj\n\n# \n# Determine the connectivity between access & agg switches. \n# Topologies to be handled: \n# 1. vPC access attached to vPC agg (topo 4)\n# 2. standalone access dual-attached to vPC agg (topo 2)\n# 3. standalone access single attached via eth/trunk to one of the vPC agg peers (topo 3a)\n# 4. standalone access single attached via layer-2 port-channel/trunk to one of the vPC agg peers (topo 3b)\n#\ndef accessAggPairingBF(topologyDataObj, respObj):\n    try:\n        funcName = sys._getframe(0).f_code.co_name\n\n        Wrapper.print(\"=========== %s ========\" % (funcName))\n\n        aggs = topologyDataObj.get(TopologyInfoType.AGGS)\n        if not aggs:\n            Wrapper.print(\"%s: No aggregations in the fabric, skip\")\n            respObj.setSuccessRetCode()\n            return respObj\n\n        # access device that peers with the agg vpc peer.\n        # Access in this list will be ignored if it has been processed for auto-pair already\n        # either because of its vpc peer, or it was processed by a previous agg\n        accessPairedList = []\n\n        for aggSn in aggs:\n\n            aggVpcPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, FABRIC_NAME, aggSn))\n\n            Wrapper.print(\"%s: aggSn %s, vpc peer %s\" % (funcName, aggSn, aggVpcPeerSn))\n\n            linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, aggSn, Helper.getNbrTypeInternal()))\n\n            for nbrLink in linkNbrList:\n                if nbrLink[\"link-type\"] not in [\"ethisl\", \"lan_planned_link\"]:\n                    Wrapper.print(\"%s: Link for node: %s is not ethisl or lan_planned_link: %s IGNORE\" %\n                                    (funcName, aggSn, nbrLink[\"link-type\"]))\n                    continue\n\n                sw1_sn, sw2_sn = getSNsFromNbrList(nbrLink)\n\n                if sw1_sn == aggSn:\n                    nbrSn = sw2_sn\n                else:\n                    nbrSn = sw1_sn\n\n                nbrSwitchRole = topologyDataObj.getSwitchRole(nbrSn)\n                if nbrSwitchRole != \"access\":\n                    Wrapper.print(\"%s: skip %s role %s\" % (funcName, nbrSn, nbrSwitchRole))\n                    continue\n\n                if nbrSn in accessPairedList:\n                    Wrapper.print(\"%s: %s already paired, skip\" % (funcName, nbrSn))\n                    continue\n\n                device_fabric_name = Util.exe(InventoryWrapper.getFabricNameForSwitch(nbrSn))\n                if device_fabric_name != FABRIC_NAME:\n                    Wrapper.print(\"%s: skip %s in fabric %s\" % (funcName, nbrSn, device_fabric_name))\n                    continue\n\n                Util.exe(handleOneAccessAggPairingBF(topologyDataObj, nbrSn, aggSn, aggVpcPeerSn, accessPairedList, respObj))\n                accessPairedList.append(nbrSn)\n\n        Wrapper.print(\"%s: end of pairing, paired list %s\" % (funcName, accessPairedList))\n\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef handleOneAccessAggPairingBF(topologyDataObj, accessSn, aggSn, aggPeerSn, accessPairedList, respObj):\n    try:\n        funcName = sys._getframe(0).f_code.co_name\n        Wrapper.print(\"%s:%s agg <%s, %s>\" % (funcName, accessSn, aggSn, aggPeerSn))\n\n        isAccessVpc = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, accessSn))\n        if isAccessVpc:\n            # topology 4\n            accessVpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, accessSn))\n            aggSnPaired = Util.exe(ToRWrapper.getTorAssociation(accessVpcPairSerialKey))\n\n            accessPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, FABRIC_NAME, accessSn))\n\n            if aggSnPaired and aggSn in aggSnPaired:\n                # Access VPC already paired with agg VPC, no change\n                Wrapper.print(\"%s: topo #4, pair present <%s, %s> - <%s, %s>, no change\" % (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n                accessPairedList.append(accessPeerSn)\n                return respObj\n\n            # pair (accessSn, accessPeerSn) with (aggSn, aggPeerSn)\n            Wrapper.print(\"%s: topo #4, pair <%s, %s> - <%s, %s>\" %\n                           (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n            Util.exe(addAccessAggPairingBF(aggSn, aggPeerSn, accessSn, accessPeerSn, respObj))\n            accessPairedList.append(accessPeerSn)\n        else:\n            accessPeerSn = \"\"\n            aggSnPaired = Util.exe(ToRWrapper.getTorAssociation(accessSn))\n            aggVpcPeerConnected = isSwitchConnected(topologyDataObj, accessSn, aggPeerSn)\n\n            Wrapper.print(\"%s:%s aggSnPaired %s, aggVpcPeerConnected %s\" % (funcName, accessSn, aggSnPaired, aggVpcPeerConnected))\n            if aggSnPaired and aggSn in aggSnPaired:\n                # Access is already paired with agg, no change\n                Wrapper.print(\"%s: topo #2 or #3 <%s, %s> - <%s, %s>, no change but should not come here!\" % (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n                return respObj\n                \n            if aggVpcPeerConnected:\n                # topology 2, pair (accessSn) with (aggSn, aggPeerSn)\n                Wrapper.print(\"%s: topo #2, pair <%s, %s> - <%s>\" % (funcName, aggSn, aggPeerSn, accessSn))\n                Util.exe(addAccessAggPairingBF(aggSn, aggPeerSn, accessSn, \"\", respObj))\n            else:\n                # topology 3, pair (accessSn) with (aggSn)\n                Wrapper.print(\"%s: topo #3, pair <%s> - <%s>\" % (funcName, aggSn, accessSn))\n                Util.exe(addAccessAggPairingBF(aggSn, \"\", accessSn, \"\", respObj))\n\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef addAccessAggPairingBF(aggSn, aggPeerSn, accessSn, accessPeerSn, respObj):\n    try:\n        funcName = sys._getframe(0).f_code.co_name\n        Wrapper.print(\"%s <%s,%s>: <%s, %s>\"% (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n\n        # re-order aggSn/aggPeerSn, accessSn/accessPeerSn if order matters\n        if accessPeerSn:\n            if accessSn < accessPeerSn:\n                accessSNs = accessSn + \",\" + accessPeerSn\n            else:\n                accessSNs = accessPeerSn + \",\" + accessSn\n        else:\n            accessSNs = accessSn\n\n        torImpl = TorImpl()\n        one_entry = ToRLeaf()\n        pairing_data = []\n\n        one_entry.setLeafSN(aggSn)\n        one_entry.setTorSNs(accessSNs)\n        pairing_data.append(one_entry)\n\n        if aggPeerSn:\n            second_entry = ToRLeaf()\n            second_entry.setLeafSN(aggPeerSn)\n            second_entry.setTorSNs(accessSNs)\n            pairing_data.append(second_entry)\n\n        Wrapper.print(\"pairing_data %s\"% pairing_data)\n        torImpl.insertOrUpdateTorPair(FABRIC_NAME, pairing_data)\n\n        return respObj\n    except respObjError as e:\n        return e.value\n\n#For a given network and a given agg device, this function should return the list of all ports attached to the network \n#on the access devices that are paired with this agg device. \n#This goes into the \"torPorts\" parameter during network attach for this agg\ndef getAggTorPorts(topologyDataObj, aggSn, networkId, respObj, globalOverlayInfo):\n    try:\n        funcName = sys._getframe(0).f_code.co_name\n        Wrapper.print(\"=========== %s ========\" % (funcName))\n\n        aggPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, FABRIC_NAME, aggSn))\n        Wrapper.print(\"%s: aggSn %s, vpc peer %s\" % (funcName, aggSn, aggPeerSn))\n\n        torPorts = []\n\n        accesses = topologyDataObj.get(TopologyInfoType.ACCESSES)\n        if not accesses:\n            Wrapper.print(\"%s: No access devices in the fabric, skip\")\n            respObj.setSuccessRetCode()\n            return torPorts\n        \n        #Determine if accessSn is paired to the aggSn    \n        for accessSn in accesses:\n            switchDict = globalOverlayInfo[\"SWITCH_INFO\"][accessSn]\n            switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][accessSn]\n\n            #Wrapper.print(\"%s: aggSn %s accessSn %s switchDict %s switchOverlayInfo %s\" % (funcName, aggSn, accessSn, switchDict, switchOverlayInfo))\n\n            #Extract the right network entry for this accessSn\n            if networkId in switchOverlayInfo[\"NETWORKS_BY_ID\"]:\n                netEntry = switchOverlayInfo[\"NETWORKS_BY_ID\"][networkId]\n            else:\n                Wrapper.print(\"%s: aggSn %s accessSn %s Ignoring network with vlanId %s\" % (funcName, aggSn, accessSn, networkId))\n                return torPorts\n                \n            Wrapper.print(\"%s: aggSn %s accessSn %s netEntry %s\" % (funcName, aggSn, accessSn, netEntry))\n  \n            isAccessVpc = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, accessSn))\n            if isAccessVpc:\n                # topology 4\n                accessVpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, accessSn))\n                aggSnPaired = Util.exe(ToRWrapper.getTorAssociation(accessVpcPairSerialKey))\n    \n                accessPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, FABRIC_NAME, accessSn))\n    \n                if aggSnPaired and aggSn in aggSnPaired:\n                    # Access VPC is b2b paired with with agg VPC\n                    Wrapper.print(\"%s: topo #4, pair present <%s, %s> - <%s, %s>, no change\" % (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n\n                    #Need to filter out access uplink ports that are part of the uplink_access policies \n                    #These are the interfaces connected between access-agg based on the b2b vpc\n                    Wrapper.print(\"%s: device %s[%s] attachInfo %s UplinkInts %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, netEntry[\"attachInfo\"], switchDict[\"accessUplinkIntfs\"]))\n                    \n                    accessNetAttachInfo = set(netEntry[\"attachInfo\"]) - set(switchDict[\"accessUplinkIntfs\"])\n                    Wrapper.print(\"%s: device %s[%s] accessNetAttachInfo %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, accessNetAttachInfo))\n\n                    accessNetAttachInfoStr = \",\".join(accessNetAttachInfo)\n\n                    formattedAccessNetAttachInfo = switchDict[\"hostName\"] + \"(\" + accessNetAttachInfoStr + \")\"\n                    Wrapper.print(\"%s: device %s[%s] fmtattachInfo %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, formattedAccessNetAttachInfo))\n                    \n                    torPorts.append(formattedAccessNetAttachInfo)\n            else:\n                accessPeerSn = \"\"\n                aggSnPaired = Util.exe(ToRWrapper.getTorAssociation(accessSn))\n                aggVpcPeerConnected = isSwitchConnected(topologyDataObj, accessSn, aggPeerSn)\n    \n                Wrapper.print(\"%s:%s aggSnPaired %s, aggVpcPeerConnected %s\" % (funcName, accessSn, aggSnPaired, aggVpcPeerConnected))\n                if aggSnPaired and aggSn in aggSnPaired:\n                    # Access is paired with agg\n                    Wrapper.print(\"%s: topo #2 or #3 <%s, %s> - <%s, %s>\" % (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n\n                    if aggVpcPeerConnected:\n                        # topology 2, (accessSn) is dual-attached/paired with (aggSn, aggPeerSn)\n                        Wrapper.print(\"%s: topo #2, pair <%s, %s> - <%s>\" % (funcName, aggSn, aggPeerSn, accessSn))\n                    else:\n                        # topology 3, (accessSn) is only paired with (aggSn)\n                        Wrapper.print(\"%s: topo #3, pair <%s> - <%s>\" % (funcName, aggSn, accessSn))\n\n                    #Need to filter out access uplink ports that are part of the uplink_access policies \n                    #These are the interfaces connected between access-agg\n                    Wrapper.print(\"%s: device %s[%s] attachInfo %s UplinkInts %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, netEntry[\"attachInfo\"], switchDict[\"accessUplinkIntfs\"]))\n                    \n                    accessNetAttachInfo = set(netEntry[\"attachInfo\"]) - set(switchDict[\"accessUplinkIntfs\"])\n                    Wrapper.print(\"%s: device %s[%s] accessNetAttachInfo %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, accessNetAttachInfo))\n\n                    accessNetAttachInfoStr = \",\".join(accessNetAttachInfo)\n\n                    formattedAccessNetAttachInfo = switchDict[\"hostName\"] + \"(\" + accessNetAttachInfoStr + \")\"\n                    Wrapper.print(\"%s: device %s[%s] fmtattachInfo %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, formattedAccessNetAttachInfo))\n                    \n                    torPorts.append(formattedAccessNetAttachInfo)\n\n        return torPorts\n    except respObjError as e:\n        #TODO: Handle exception properly\n        Wrapper.print(\"%s:Exception while processing agg torPorts for %s %s\" % (funcName, aggSn, e))\n        return []\n\ndef handleTorLeafPairingBF(topologyDataObj, torSn, respObj, globalOverlayInfo):\n    try:\n        funcName = sys._getframe(0).f_code.co_name\n        Wrapper.print(\"=========== Entering %s(): ========\" % (funcName))\n        #Wrapper.print(\"=========== %s ========%s\" % (funcName, globalOverlayInfo))\n        policyIdNum = 0\n        switchInfo = globalOverlayInfo[\"SWITCH_INFO\"]\n        leafSn = leafVpcPeerSn = \"\"\n        torVpcPeerSn = \"\"\n        leafPcRmId = leafVpcPeerPcRmId = leafVpcRmId = leafVpcPeerVpcRmId = -1\n        torPcRmId = torVpcPeerPcRmId = torVpcRmId = torVpcPeerVpcRmId = -1\n        leafMemberList = []\n        leafVpcPeerMemberList = []\n        torMemberList = []\n        torVpcPeerMemberList = []\n        shutInterfaceList = []\n        torVpcPairSerialKey = leafVpcPairSerialKey = \"\"\n        isTorVpc = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, torSn))\n        if isTorVpc:\n            torVpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, torSn))\n            serials = torVpcPairSerialKey.split(Helper.DELIMITER)\n            torSn = serials[0]\n            torVpcPeerSn = serials[1]\n            leafSns = Util.exe(ToRWrapper.getTorAssociation(torVpcPairSerialKey))\n            Wrapper.print(\"%s(): accessSn %s accessVpcPairSerialKey %s aggSns %s\" % (funcName, torSn, torVpcPairSerialKey, leafSns))\n        else:\n            leafSns = Util.exe(ToRWrapper.getTorAssociation(torSn))\n            Wrapper.print(\"%s(): accessSn %s aggSns %s\" % (funcName, torSn, leafSns))\n\n        sn0 = sn1 = \"\"\n        if leafSns == None or len(leafSns) == 0:\n            respObj.addErrorReport(getFabErrEntity(funcName, torSn),\n                                   \"Aggregation devices are not present in the fabric \"\n                                   \"or connections between Aggregation and Access devices are not proper, \"\n                                   \"please have the valid topology and try again\",torSn)\n            respObj.setFailureRetCode()\n            return respObj\n        elif len(leafSns) == 1:\n            for sn in leafSns:\n                leafSn = sn\n            isLeafVpc = False\n        elif len(leafSns) == 2:\n            for sn in leafSns:\n                if not sn0:\n                    sn0 = sn\n                if sn0 is not sn:\n                    sn1 = sn\n                    break\n            isLeafVpc = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, sn0))\n            if not isLeafVpc:\n                vpcFeaturePtiList = Util.exe(PTI.get(sn0, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", \"base_feature_vpc\"))\n                if vpcFeaturePtiList:\n                    Wrapper.print(\"%s(): was a vpc!!! \")\n                    leafSn = sn0\n                    leafVpcPeerSn = sn1 \n            else:\n                Wrapper.print(\"%s(): is a vpc!!! \")\n                leafVpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, sn0))\n                serials = leafVpcPairSerialKey.split(Helper.DELIMITER)\n                leafSn = serials[0]\n                leafVpcPeerSn = serials[1]\n        else:\n            Wrapper.print(\"%s(): ERROR!!! accessSn %s getAccessAssociation() returns aggSns %s (size=%d)\" %\n                          (funcName, torSn, leafSns, len(leafSns)))\n            return respObj\n            \n        Wrapper.print(\"%s(): accessSn:[%s] accessVpcPeerSn:[%s] aggSn:[%s] aggVpcPeerSn:[%s] isAggVpc:%r isAccessVpc:%r\" %\n                      (funcName, torSn, torVpcPeerSn, leafSn, leafVpcPeerSn, isLeafVpc, isTorVpc))\n\n        leafPcId = \"\"\n        torPcId = \"\"\n        leafVpcPeerPcId = \"\"\n        torVpcPeerPcId = \"\"\n        leafVpcId = \"\"\n        torVpcId = \"\"\n\n        linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, torSn, Helper.getNbrTypeInternal()))\n        torNetworkIntfs = getTorNetworkIntfsFromNbrList(torSn, linkNbrList)\n\n        for torIntf in torNetworkIntfs:\n            torNbrInfo = getTorNbrInfo(torSn, torIntf, linkNbrList)\n            Wrapper.print(\"%s() accessSn %s accessIntf %s accessNbrInfo %s\" %(funcName, torSn, torIntf, torNbrInfo))\n\n            if not torNbrInfo.get(\"nbrSn\"):\n                continue\n\n            #Given the torIntf, determine the PC ID or vPC ID/PC ID associated with its parent interface on the access\n            #That must already have been reserved in RM for the vanilla port-channel or vpc interfaces\n            #Need to free up that RM before doing allocating new RM Id and associating it with the uplink_access PTI\n            ptiList = Util.exe(PTIWrapper.getPTIs(torSn, \"INTERFACE\", torIntf, \"PYTHON\"))\n            for pti in ptiList:\n                intf_source = pti.getSource()\n                Wrapper.print(\"%s() accessSn %s accessIntf %s accessNbrInfo %s source %s\" %(funcName, torSn, torIntf, torNbrInfo, intf_source))\n                if intf_source.lower().find(\"port-channel\") != -1:\n                    #means its a layer-2 port-channel scenario\n                    torPcId = intf_source.split('port-channel')[1]\n                elif intf_source.lower().find(\"vpc\") != -1:\n                    #means its a vPC host port scenario\n                    torVpcId = intf_source.split('vPC')[1]\n                    if not torVpcPairSerialKey:\n                        respObj.addErrorReport(getFabErrEntity(funcName, torSn),\n                                   \"Incorrect vpc configuration found in port-channel%s between Aggregation and Access devices. <br>\"\n                                   \"Please correct this interface configuration and try again.\"%(torVpcId) ,torSn)\n                        respObj.setFailureRetCode()\n                        return respObj\n                    #means its a vPC host port scenario\n                    torVpcIntf = \"vPC\" + torVpcId\n                    #Determine the corresponding PC Id for each vpc peer\n                    ptiList1 = Util.exe(PTIWrapper.getPTIs(torVpcPairSerialKey, \"INTERFACE\", torVpcIntf, \"PYTHON\"))\n                    for pti1 in ptiList1:\n                        nvPairs = pti1.getNvPairs()\n                        torPcId = nvPairs.get(\"PEER1_PCID\",\"\")\n                        torVpcPeerPcId = nvPairs.get(\"PEER2_PCID\",\"\")\n                        break    \n                else:\n                    #standalone interface which is NOT expected between agg-access\n                    Wrapper.print(\"%s(): Ethernet interface scenario: accessSn %s accessIntf %s accessNbrInfo %s\" %(funcName, torSn, torIntf, torNbrInfo))\n                break\n\n            nbrSn = torNbrInfo.get(\"nbrSn\")\n            nbrIntf = torNbrInfo.get(\"nbrIntf\")\n            #Given the nbrIntf, determine the PC ID or vPC ID/PC ID associated with its parent interface on the agg\n            #That must already have been reserved in RM for the vanilla port-channel or vpc interfaces\n            #Need to free up that RM before doing allocating new RM Id and associating it with the uplink_access PTI\n            ptiList = Util.exe(PTIWrapper.getPTIs(nbrSn, \"INTERFACE\", nbrIntf, \"PYTHON\"))\n            for pti in ptiList:\n                intf_source = pti.getSource()\n                Wrapper.print(\"%s() aggSn %s aggIntf %s source %s\" %(funcName, nbrSn, nbrIntf, intf_source))\n                if intf_source.lower().find(\"port-channel\") != -1:\n                    #means its a layer-2 port-channel scenario\n                    leafPcId = intf_source.split('port-channel')[1]\n                elif intf_source.lower().find(\"vpc\") != -1:\n                    #means its a vPC host port scenario\n                    leafVpcId = intf_source.split('vPC')[1]\n                    if not leafVpcPairSerialKey:\n                        respObj.addErrorReport(getFabErrEntity(funcName, nbrSn),\n                                   \"Incorrect vpc configuration found in port-channel%s between Aggregation and Access devices. <br>\"\n                                   \"Please correct this interface configuration and try again.\"%(leafVpcId) ,nbrSn)\n                        respObj.setFailureRetCode()\n                        return respObj\n\n                    leafVpcIntf = \"vPC\" + leafVpcId\n                    #Determine the corresponding PC Id for each vpc peer\n                    ptiList1 = Util.exe(PTIWrapper.getPTIs(leafVpcPairSerialKey, \"INTERFACE\", leafVpcIntf, \"PYTHON\"))\n                    for pti1 in ptiList1:\n                        nvPairs = pti1.getNvPairs()\n                        leafPcId = nvPairs.get(\"PEER1_PCID\",\"\")\n                        leafVpcPeerPcId = nvPairs.get(\"PEER2_PCID\",\"\")\n                        break    \n                else:\n                    #standalone interface which is NOT expected between agg-access\n                    Wrapper.print(\"%s(): Ethernet interface scenario: aggSn %s aggIntf %s\" %(funcName, nbrSn, nbrIntf))\n                break\n\n            Wrapper.print(\"%s() leafPcId %s torPcId %s leafVpcPeerPcId %s torVpcPeerPcId %s leafVpcId %s torVpcId %s\" %\n                              (funcName, leafPcId, torPcId, leafVpcPeerPcId, torVpcPeerPcId, leafVpcId, torVpcId))\n            if not isTorVpc:\n                torPOIntf = \"port-channel\" + torPcId\n                leafVpcIntf = \"vPC\" + leafVpcId\n                leafPOIntf = \"port-channel\" + leafPcId\n                leafVpcPeerPOIntf = \"port-channel\" + leafVpcPeerPcId\n                \n                '''\n                entityName = Helper.getUUIDBySerialNumber(torSn)\n                #torPcId, torPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, entityName))\n                ignore, torPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, entityName, torPcId))\n                torPOIntf = \"port-channel\" + torPcId\n                if not isLeafVpc:\n                    leafUUID = Helper.getUUIDBySerialNumber(leafSn)\n                    torUUID = Helper.getUUIDBySerialNumber(torSn)\n                    entityName = (\"%s%s%s\" % (leafUUID, Helper.DELIMITER, torUUID))\n                    #leafPcId, leafPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, entityName))\n                    ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, entityName, leafPcId))\n                else:\n                    entityName = (\"%s%s%s\" % (leafVpcPairSerialKey, Helper.CARET_JYTHON, torSn))\n                    #leafVpcId, leafVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafSn, entityName))\n                    ignore, leafVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafSn, entityName, leafVpcId))\n                    ignore, leafVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafVpcPeerSn, entityName, leafVpcId))\n                    leafVpcIntf = \"vPC\" + leafVpcId\n                    ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafVpcIntf, leafPcId))\n                    ignore, leafVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafVpcPeerSn, leafVpcIntf, leafVpcPeerPcId))\n                '''    \n            else:\n                Wrapper.print(\"%s() pass RM handling here\" %(funcName))\n                leafVpcIntf = \"vPC\" + leafVpcId\n                torVpcIntf = \"vPC\" + torVpcId\n                torPOIntf = \"port-channel\" + torPcId\n                leafPOIntf = \"port-channel\" + leafPcId\n                torVpcPeerPOIntf = \"port-channel\" + torVpcPeerPcId\n                leafVpcPeerPOIntf = \"port-channel\" + leafVpcPeerPcId\n                \n                '''\n                # Leaf must also be VPC\n                entityName = (\"%s%s%s\" % (leafVpcPairSerialKey, Helper.CARET_JYTHON, torVpcPairSerialKey))\n                #leafVpcId, leafVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafSn, entityName))\n                ignore, leafVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafSn, entityName, leafVpcId))\n                ignore, leafVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafVpcPeerSn, entityName, leafVpcId))\n                Wrapper.print(\"%s() Back-to-back VPC: accessSn %s entityName %s aggVpcId %s\" %\n                              (funcName, torSn, entityName, leafVpcId))\n\n                #torVpcId, torVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", torSn, torVpcPairSerialKey))\n                ignore, torVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", torSn, torVpcPairSerialKey, torVpcId))\n                ignore, torVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", torVpcPeerSn, torVpcPairSerialKey, torVpcId))\n                leafVpcIntf = \"vPC\" + leafVpcId\n                torVpcIntf = \"vPC\" + torVpcId\n                Wrapper.print(\"%s() Back-to-back VPC: accessSn %s accessVpcPairSerialKey %s accessVpcId %s\" %\n                              (funcName, torSn, torVpcPairSerialKey, torVpcId))\n\n                ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafVpcIntf, leafPcId))\n                ignore, leafVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafVpcPeerSn, leafVpcIntf, leafVpcPeerPcId))\n\n                ignore, torPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, torVpcIntf, torPcId))\n                ignore, torVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torVpcPeerSn, torVpcIntf, torVpcPeerPcId))\n                '''\n                \n            if nbrSn == leafSn:\n                leafMemberList.append(nbrIntf)\n                torMemberList.append(torIntf)\n            elif nbrSn == leafVpcPeerSn:\n                leafVpcPeerMemberList.append(nbrIntf)\n                torMemberList.append(torIntf)\n\n        if torVpcPeerSn != \"\":\n            torVpcPeerLinkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, torVpcPeerSn, Helper.getNbrTypeInternal()))\n            torVpcPeerNetworkIntfs = getTorNetworkIntfsFromNbrList(torVpcPeerSn, torVpcPeerLinkNbrList)\n            for torIntf in torVpcPeerNetworkIntfs:\n                torNbrInfo = getTorNbrInfo(torVpcPeerSn, torIntf, torVpcPeerLinkNbrList)\n                Wrapper.print(\"%s() accessVpcPeerSn %s accessIntf %s accessNbrInfo %s\" %(funcName, torVpcPeerSn, torIntf, torNbrInfo))\n\n                if not torNbrInfo.get(\"nbrSn\"):\n                    continue\n\n                nbrSn = torNbrInfo.get(\"nbrSn\")\n                nbrIntf = torNbrInfo.get(\"nbrIntf\")\n                if nbrSn == leafSn:\n                    leafMemberList.append(nbrIntf)\n                    torVpcPeerMemberList.append(torIntf)\n                elif nbrSn == leafVpcPeerSn:\n                    leafVpcPeerMemberList.append(nbrIntf)\n                    torVpcPeerMemberList.append(torIntf)\n\n        if (not torMemberList or not leafMemberList or\n            (isLeafVpc and not leafVpcPeerMemberList) or\n            (isTorVpc and not torVpcPeerMemberList)):\n            Wrapper.print(\"%s(): Not all Aggregation-Access port-channels have members between Aggregation device [%s] and Access device [%s]\"%\n                          (funcName, leafVpcPairSerialKey if isLeafVpc else leafSn, torVpcPairSerialKey if isTorVpc else torSn))\n            respObj.addErrorReport(getFabErrEntity(funcName, torSn),\n                                   \"Not all Aggregation-Access port-channels have members between Aggregation device [%s] and Access device [%s]\"%\n                                   (leafVpcPairSerialKey if isLeafVpc else leafSn, torVpcPairSerialKey if isTorVpc else torSn), torSn)\n            respObj.setFailureRetCode()\n            return respObj\n\n        torHostName = Util.exe(InventoryWrapper.getHostName(torSn))\n        leafHostName = Util.exe(InventoryWrapper.getHostName(leafSn))\n        leafVpcPeerHostName = Util.exe(InventoryWrapper.getHostName(leafVpcPeerSn)) if leafVpcPeerSn != \"\" else \"\"\n        torVpcPeerHostName = Util.exe(InventoryWrapper.getHostName(torVpcPeerSn)) if torVpcPeerSn != \"\" else \"\"\n        torVpcPairHostName = torHostName + \"~\" + torVpcPeerHostName if torVpcPeerHostName != \"\" else \"\"\n        leafVpcPairHostName = leafHostName + \"~\" + leafVpcPeerHostName if leafVpcPeerHostName != \"\" else \"\"\n\n        aggAccPOTemplates = [\"int_port_channel_trunk_member_11_1\", \"int_vpc_trunk_po_member_11_1\",\n                             \"int_port_channel_uplink_access_member\", \"int_vpc_uplink_access_po_member\"]\n        if len(torMemberList) > 0:\n            intf_source = \"\"\n            ref_pcId = \"\"\n            errorMsg = \"\"\n            for intf in torMemberList:\n                ptiList = Util.exe(PTIWrapper.getPTIs(torSn, \"INTERFACE\", intf, \"PYTHON\"))\n                if ptiList:\n                    if ptiList[0].isDeleted():\n                        continue\n                    intf_source = ptiList[0].getSource()\n                    templateName = ptiList[0].getTemplateName()\n                    if templateName in aggAccPOTemplates:\n                        PO_ID = ptiList[0].getNvPairs()[\"PO_ID\"]\n                        pcId = PO_ID.lower().split('port-channel')[1]\n                        if ref_pcId == \"\":\n                            ref_pcId = pcId\n                        elif pcId != ref_pcId:\n                            errorMsg = (\"Found more than 1 port-channel between Aggregation [%s/%s] and Access [%s/%s]. \"\n                                        \"Please check the member interface(s) on Access: %s\" %\n                                        (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                         torHostName, torSn, \",\".join(torMemberList)))\n                    else:\n                        errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                    \"Please check this interface on Access: %s\" %\n                                    (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                     torHostName, torSn, intf))\n                else:\n                    Wrapper.print(\"SN %s: torMember intf [%s] has no policy attached\" % (torSn, intf))\n                    errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                \"Please check this interface on Access: %s\" %\n                                (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                 torHostName, torSn, intf))\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, torSn), errorMsg, torSn)\n                    respObj.setFailureRetCode()\n                    break\n\n            if errorMsg == \"\":\n                if isTorVpc and intf_source.lower().find(\"port-channel\") != -1:\n                    errorMsg = (\"Access is in vPC but the uplink access port-channel [%s] is not a vPC port-channel\" % intf_source.lower())\n                elif not isTorVpc and intf_source.lower().find(\"vpc\") != -1:\n                    errorMsg = (\"Access is not in vPC but the uplink access port-channel [%s] is a vPC port-channel\" % intf_source)\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, torSn), errorMsg, torSn)\n                    respObj.setFailureRetCode()\n\n        if len(leafMemberList) > 0:\n            intf_source = \"\"\n            ref_pcId = \"\"\n            errorMsg = \"\"\n            for intf in leafMemberList:\n                ptiList = Util.exe(PTIWrapper.getPTIs(leafSn, \"INTERFACE\", intf, \"PYTHON\"))\n                if ptiList:\n                    if ptiList[0].isDeleted():\n                        continue\n                    intf_source = ptiList[0].getSource()\n                    templateName = ptiList[0].getTemplateName()\n                    if templateName in aggAccPOTemplates:\n                        PO_ID = ptiList[0].getNvPairs()[\"PO_ID\"]\n                        pcId = PO_ID.lower().split('port-channel')[1]\n                        if ref_pcId == \"\":\n                            ref_pcId = pcId\n                        elif pcId != ref_pcId:\n                            errorMsg = (\"Found more than 1 port-channel between Aggregation [%s/%s] and Access [%s/%s]. \"\n                                        \"Please check the member interface(s) on Aggregation: %s\" %\n                                        (leafHostName, leafSn,\n                                         torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn,\n                                         \",\".join(leafMemberList)))\n                    else:\n                        errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                    \"Please check this interface on Aggregation: %s\" %\n                                    (leafHostName, leafSn,\n                                     torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn, intf))\n                else:\n                    Wrapper.print(\"SN %s: leafMember intf [%s] has no policy attached\" % (leafSn, intf))\n                    errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                \"Please check this interface on Aggregation: %s\" %\n                                (leafHostName, leafSn,\n                                 torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn, intf))\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, leafSn), errorMsg, leafSn)\n                    respObj.setFailureRetCode()\n                    break\n\n            if errorMsg == \"\":\n                if isLeafVpc and intf_source.lower().find(\"port-channel\") != -1:\n                    errorMsg = (\"Aggregation is in vPC but the uplink access port-channel [%s] is not a vPC port-channel\" % intf_source.lower())\n                elif not isLeafVpc and intf_source.lower().find(\"vpc\") != -1:\n                    errorMsg = (\"Aggregation is not in vPC but the uplink access port-channel [%s] is a vPC port-channel\" % intf_source)\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, leafSn), errorMsg, leafSn)\n                    respObj.setFailureRetCode()\n\n        if isLeafVpc and len(leafVpcPeerMemberList) > 0:\n            intf_source = \"\"\n            ref_pcId = \"\"\n            errorMsg = \"\"\n            for intf in leafVpcPeerMemberList:\n                ptiList = Util.exe(PTIWrapper.getPTIs(leafVpcPeerSn, \"INTERFACE\", intf, \"PYTHON\"))\n                if ptiList:\n                    if ptiList[0].isDeleted():\n                        continue\n                    intf_source = ptiList[0].getSource()\n                    templateName = ptiList[0].getTemplateName()\n                    if templateName in aggAccPOTemplates:\n                        PO_ID = ptiList[0].getNvPairs()[\"PO_ID\"]\n                        pcId = PO_ID.lower().split('port-channel')[1]\n                        if ref_pcId == \"\":\n                            ref_pcId = pcId\n                        elif pcId != ref_pcId:\n                            errorMsg = (\"Found more than 1 port-channel between Aggregation [%s/%s] and Access [%s/%s]. \"\n                                        \"Please check the member interface(s) on Aggregation: %s\" %\n                                        (leafVpcPeerHostName, leafVpcPeerSn,\n                                         torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn,\n                                         \",\".join(leafVpcPeerMemberList)))\n                    else:\n                        errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                    \"Please check this interface on Aggregation: %s\" %\n                                    (leafVpcPeerHostName, leafVpcPeerSn,\n                                     torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn, intf))\n                else:\n                    Wrapper.print(\"SN %s: leafVpcPeerMember intf [%s] has no policy attached\" % (leafVpcPeerSn, intf))\n                    errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                \"Please check this interface on Aggregation: %s\" %\n                                (leafVpcPeerHostName, leafVpcPeerSn,\n                                 torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn, intf))\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, leafVpcPeerSn), errorMsg, leafVpcPeerSn)\n                    respObj.setFailureRetCode()\n                    break\n\n            if errorMsg == \"\":\n                if intf_source.lower().find(\"port-channel\") != -1:\n                    errorMsg = (\"Aggregation is in vPC but the uplink access port-channel [%s] is not a vPC port-channel\" % intf_source.lower())\n                    respObj.addErrorReport(getFabErrEntity(funcName, leafVpcPeerSn), errorMsg, leafVpcPeerSn)\n                    respObj.setFailureRetCode()\n\n        if isTorVpc and len(torVpcPeerMemberList) > 0:\n            intf_source = \"\"\n            ref_pcId = \"\"\n            errorMsg = \"\"\n            for intf in torVpcPeerMemberList:\n                ptiList = Util.exe(PTIWrapper.getPTIs(torVpcPeerSn, \"INTERFACE\", intf, \"PYTHON\"))\n                if ptiList:\n                    if ptiList[0].isDeleted():\n                        continue\n                    intf_source = ptiList[0].getSource()\n                    templateName = ptiList[0].getTemplateName()\n                    if templateName in aggAccPOTemplates:\n                        PO_ID = ptiList[0].getNvPairs()[\"PO_ID\"]\n                        pcId = PO_ID.lower().split('port-channel')[1]\n                        if ref_pcId == \"\":\n                            ref_pcId = pcId\n                        elif pcId != ref_pcId:\n                            errorMsg = (\"Found more than 1 port-channel between Aggregation [%s/%s] and Access [%s/%s]. \"\n                                        \"Please check the member interface(s) on Access: %s\" %\n                                        (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                         torVpcPeerHostName, torVpcPeerSn, \",\".join(torVpcPeerMemberList)))\n                    else:\n                        errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                    \"Please check this interface on Access: %s\" %\n                                    (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                     torVpcPeerHostName, torVpcPeerSn, intf))\n                else:\n                    Wrapper.print(\"SN %s: torVpcPeerMember intf [%s] has no policy attached\" % (torVpcPeerSn, intf))\n                    errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                \"Please check this interface on Access: %s\" %\n                                (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                 torVpcPeerHostName, torVpcPeerSn, intf))\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, torVpcPeerSn), errorMsg, torVpcPeerSn)\n                    respObj.setFailureRetCode()\n                    break\n\n            if errorMsg == \"\":\n                if intf_source.lower().find(\"port-channel\") != -1:\n                    errorMsg = (\"Access is in vPC but the uplink access port-channel [%s] is not a vPC port-channel\" % intf_source.lower())\n                    respObj.addErrorReport(getFabErrEntity(funcName, torVpcPeerSn), errorMsg, torVpcPeerSn)\n                    respObj.setFailureRetCode()\n\n        if respObj.isRetCodeFailure():\n            entityName = (\"%s%s%s\" % (torVpcPairSerialKey if isTorVpc else torSn, Helper.CARET_JYTHON, leafVpcPairSerialKey if isLeafVpc else leafSn))\n            respObj.addErrorReport(getFabErrEntity(funcName, entityName),\n                \"Unsupported Topology: Found multiple port-channels or vPC interfaces<br> for links \"\n                \"between aggregation and access switches. <br>All links between aggregation and access switches \"\n                \"<br>should be part of a single port-channel or vPC interface. <br>\"\n                \"Please correct the configuration and try again.\")\n            return respObj\n\n        torMemberIntfs = \",\".join(torMemberList)\n        leafMemberIntfs = \",\".join(leafMemberList)\n\n        srchOpt = CtrlPolicySearch()\n        if not isTorVpc:\n            srchOpt.setSerialNumber(torSn)\n            srchOpt.setEntityType(\"INTERFACE\")\n            srchOpt.setEntityName(torPOIntf)\n            srchOpt.setTemplateContentType(\"PYTHON\")\n            srchOpt.setTemplateName(\"int_port_channel_trunk_host\")\n            ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            if ptiList:\n                pti = ptiList[0]\n                nvPairs = copy.deepcopy(pti.getNvPairs())\n\n                Wrapper.print(\"%s(): accessSn [%s] Deleting trunk PO [%s] with policyId %s, nvPairs [%s]\" %\n                              (funcName, torSn, torPOIntf, pti.getPolicyId(), nvPairs))\n\n                #Get old RM associated with the tor PC and delete it               \n                ignore, oldTorPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, torPOIntf))\n                PTI.deleteInstance(pti.getPolicyId())\n                RM.deleteResource(oldTorPcRmId)\n\n                Wrapper.print(\"%s(): Deleted RMIds [%s]\" % (funcName, oldTorPcRmId))\n                \n                entityName = Helper.getUUIDBySerialNumber(torSn)\n                #torPcId, torPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, entityName))\n                policyIdNum = Util.exe(PTIWrapper.getPolicyID())\n\n                Wrapper.print(\"%s(): PolicyId number for not tor vPC [%s]\" %(funcName, policyIdNum))\n                ignore, torPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, entityName, torPcId))\n                RM.linkResource(policyIdNum, torPcRmId)\n\n                if not isLeafVpc:\n                    nvPairs.update({\"SWITCH_ROLE\": \"access\", \"NBR_SERIAL_NUMBER\": leafSn, \"NBR_INTF_NAME\": leafPOIntf})\n                else:\n                    nvPairs.update({\"SWITCH_ROLE\": \"access\", \"NBR_SERIAL_NUMBER\": leafVpcPairSerialKey, \"NBR_INTF_NAME\": leafVpcIntf})\n\n                nvPairs.pop(\"POLICY_ID\", \"ignore if not found\")\n                torPcRmIdList = [torPcRmId]\n                #should be called with List of rm Id\n                Util.exe(PTI.createOrUpdate(torSn, \"INTERFACE\", torPOIntf, \"\",\n                                            ConfigPriority.CONFIG_PRIO_INTF_PO, torPcRmIdList,\n                                            \"int_port_channel_uplink_access\", nvPairs, policyIdNum))\n                Wrapper.print(\"%s(): accessSn [%s] Created access PO [%s] with nvPairs [%s], accessPcRmId %s\" %\n                              (funcName, torSn, torPOIntf, nvPairs, torPcRmIdList))\n\n        # In the case of topo 3, access single attached to one of the 2 aggs of an agg vpc pair, isLeafVpc == False\n        nvPairs = {}\n        if not isLeafVpc:\n            srchOpt.setSerialNumber(leafSn)\n            srchOpt.setEntityType(\"INTERFACE\")\n            srchOpt.setEntityName(leafPOIntf)\n            srchOpt.setTemplateContentType(\"PYTHON\")\n            srchOpt.setTemplateName(\"int_port_channel_trunk_host\")\n            ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            if ptiList:\n                pti = ptiList[0]\n                nvPairs = copy.deepcopy(ptiList[0].getNvPairs())\n\n                Wrapper.print(\"%s(): leafSn [%s] Deleting leaf PO [%s] with policyId %s, nvPairs [%s]\" %\n                              (funcName, leafSn, leafPOIntf, pti.getPolicyId(), nvPairs))\n\n                #Get old RM associated with the leaf PC and delete it               \n                ignore, oldLeafPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafPOIntf))\n                PTI.deleteInstance(pti.getPolicyId())\n                RM.deleteResource(oldLeafPcRmId)\n                \n                #Do RM set for the leaf port-channel interface\n                leafUUID = Helper.getUUIDBySerialNumber(leafSn)\n                torUUID = Helper.getUUIDBySerialNumber(torSn)\n                entityName = (\"%s%s%s\" % (leafUUID, Helper.DELIMITER, torUUID))\n                policyIdNum = Util.exe(PTIWrapper.getPolicyID())\n                Wrapper.print(\"%s(): PolicyId number for not leaf vPC [%s]\" %(funcName, policyIdNum))\n                ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, entityName, leafPcId))\n                RM.linkResource(policyIdNum, leafPcRmId)\n\n                nvPairs.pop(\"POLICY_ID\", \"ignore if not found\")\n                nvPairs.update({\"SWITCH_ROLE\": \"aggregation\", \"NBR_SERIAL_NUMBER\": torSn, \"NBR_INTF_NAME\": torPOIntf})\n                leafPcRmIdList = [leafPcRmId]\n                #should be called with List of rm Id\n                Util.exe(PTI.createOrUpdate(leafSn, \"INTERFACE\", leafPOIntf, \"\",\n                                            ConfigPriority.CONFIG_PRIO_INTF_PO, leafPcRmIdList,\n                                            \"int_port_channel_uplink_access\", nvPairs, policyIdNum))\n                Wrapper.print(\"%s(): leafSn [%s] Created leaf PO [%s] with nvPairs [%s], leafPcRmId %s\" %\n                              (funcName, leafSn, leafPOIntf, nvPairs, leafPcRmIdList))\n                              \n        nvPairs = {}\n        if isLeafVpc:\n            leafVpcPeerMemberIntfs = \",\".join(leafVpcPeerMemberList)\n            srchOpt.setSerialNumber(leafVpcPairSerialKey)\n            srchOpt.setEntityType(\"INTERFACE\")\n            srchOpt.setEntityName(leafVpcIntf)\n            srchOpt.setTemplateContentType(\"PYTHON\")\n            srchOpt.setTemplateName(\"int_vpc_trunk_host\")\n            ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            if ptiList:\n                pti = ptiList[0]\n                nvPairs = copy.deepcopy(ptiList[0].getNvPairs())\n                #nvPairs[\"PEER1_MEMBER_INTERFACES\"] = leafMemberIntfs\n                #nvPairs[\"PEER2_MEMBER_INTERFACES\"] = leafVpcPeerMemberIntfs\n                #Delete the previous vpc host interface PTI\n                Wrapper.print(\"%s(): vPC-agg [%s] Deleting vPC-agg intf [%s] with policyId %s, nvPairs [%s]\" %\n                              (funcName, leafVpcPairSerialKey, leafVpcIntf, pti.getPolicyId(), nvPairs))\n                              \n                #Get old RM associated with the vPC and delete it               \n                ignore, oldLeafVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafSn, leafVpcPairSerialKey))\n                ignore, oldLeafVpcPeerRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafVpcPeerSn, leafVpcPairSerialKey))\n                ignore, oldLeafPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafPOIntf))\n                ignore, oldLeafVpcPeerPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafVpcPeerSn, leafVpcPeerPOIntf))\n\n                PTI.deleteInstance(pti.getPolicyId())\n                RM.deleteResource(oldLeafVpcRmId)\n                RM.deleteResource(oldLeafVpcPeerRmId)\n                RM.deleteResource(oldLeafPcRmId)\n                RM.deleteResource(oldLeafVpcPeerPcRmId)\n                \n                Wrapper.print(\"%s(): Deleted RMIds [%s] [%s] [%s] [%s]\" %\n                              (funcName, oldLeafVpcRmId, oldLeafVpcPeerRmId, oldLeafPcRmId, oldLeafVpcPeerPcRmId))\n                \n                if not isTorVpc:\n                    nvPairs.update({\"SWITCH_ROLE\": \"aggregation\", \"NBR_SERIAL_NUMBER\": torSn, \"NBR_INTF_NAME\": torPOIntf})\n\n\n                    entityName = (\"%s%s%s\" % (leafVpcPairSerialKey, Helper.CARET_JYTHON, torSn))\n                    policyIdNum = Util.exe(PTIWrapper.getPolicyID())\n                    Wrapper.print(\"%s(): PolicyId number for not tor vPC [%s]\" %(funcName, policyIdNum))\n                    #leafVpcId, leafVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafSn, entityName))\n                    ignore, leafVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafSn, entityName, leafVpcId))\n                    RM.linkResource(policyIdNum, leafVpcRmId)\n                    ignore, leafVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafVpcPeerSn, entityName, leafVpcId))\n                    RM.linkResource(policyIdNum, leafVpcPeerVpcRmId)\n                    Wrapper.print(\"%s() Back-to-back VPC: accessSn %s entityName %s aggVpcId %s\" %\n                                  (funcName, torSn, entityName, leafVpcId))\n    \n                    ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafVpcIntf, leafPcId))\n                    RM.linkResource(policyIdNum, leafPcRmId)\n                    ignore, leafVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafVpcPeerSn, leafVpcIntf, leafVpcPeerPcId))\n                    RM.linkResource(policyIdNum, leafVpcPeerPcRmId)\n                        \n                    leafRmIdList = [leafPcRmId] + [leafVpcPeerPcRmId] + [leafVpcRmId] + [leafVpcPeerVpcRmId]\n                    nvPairs.pop(\"POLICY_ID\", \"ignore if not found\")\n                    #should be called with List of rm Id\n                    Util.exe(PTI.createOrUpdate(leafVpcPairSerialKey, \"INTERFACE\", leafVpcIntf, \"\",\n                                                ConfigPriority.CONFIG_PRIO_INTF_PO, leafRmIdList,\n                                                \"int_vpc_uplink_access\", nvPairs, policyIdNum))\n                    Wrapper.print(\"%s(): vPC-agg [%s] Created vPC-agg intf [%s] with nvPairs [%s], aggRmId %s\" %\n                                  (funcName, leafVpcPairSerialKey, leafVpcIntf, nvPairs, leafRmIdList))\n\n                else:\n                    nvPairs.update({\"SWITCH_ROLE\": \"aggregation\", \"NBR_SERIAL_NUMBER\": torVpcPairSerialKey, \"NBR_INTF_NAME\": torVpcIntf})\n\n                    entityName = (\"%s%s%s\" % (leafVpcPairSerialKey, Helper.CARET_JYTHON, torVpcPairSerialKey))\n                    #leafVpcId, leafVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafSn, entityName))\n                    policyIdNum = Util.exe(PTIWrapper.getPolicyID())\n                    Wrapper.print(\"%s(): PolicyId number for not leaf vPC [%s]\" %(funcName, policyIdNum))\n                    ignore, leafVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafSn, entityName, leafVpcId))\n                    RM.linkResource(policyIdNum, leafVpcRmId)\n\n                    ignore, leafVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafVpcPeerSn, entityName, leafVpcId))\n                    RM.linkResource(policyIdNum, leafVpcPeerVpcRmId)\n                    Wrapper.print(\"%s() Back-to-back VPC: accessSn %s entityName %s aggVpcId %s\" %\n                                  (funcName, torSn, entityName, leafVpcId))\n    \n                    ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafVpcIntf, leafPcId))\n                    RM.linkResource(policyIdNum, leafPcRmId)\n                    ignore, leafVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafVpcPeerSn, leafVpcIntf, leafVpcPeerPcId))\n                    RM.linkResource(policyIdNum, leafVpcPeerPcRmId)\n \n                    leafRmIdList = [leafPcRmId] + [leafVpcPeerPcRmId] + [leafVpcRmId] + [leafVpcPeerVpcRmId]\n                    nvPairs.pop(\"POLICY_ID\", \"ignore if not found\")\n                    #should be called with List of rm Id\n                    Util.exe(PTI.createOrUpdate(leafVpcPairSerialKey, \"INTERFACE\", leafVpcIntf, \"\",\n                                                ConfigPriority.CONFIG_PRIO_INTF_PO, leafRmIdList,\n                                                \"int_vpc_uplink_access\", nvPairs, policyIdNum))\n                    Wrapper.print(\"%s(): vPC-agg [%s] Created vPC-agg intf [%s] with nvPairs [%s], aggRmId %s\" %\n                                  (funcName, leafVpcPairSerialKey, leafVpcIntf, nvPairs, leafRmIdList))\n\n        nvPairs = {}\n        if isTorVpc:\n            torVpcPeerMemberIntfs = \",\".join(torVpcPeerMemberList)\n            srchOpt.setSerialNumber(torVpcPairSerialKey)\n            srchOpt.setEntityType(\"INTERFACE\")\n            srchOpt.setEntityName(torVpcIntf)\n            srchOpt.setTemplateContentType(\"PYTHON\")\n            srchOpt.setTemplateName(\"int_vpc_trunk_host\")\n            ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            if ptiList:\n                pti = ptiList[0]\n                nvPairs = copy.deepcopy(ptiList[0].getNvPairs())\n                #nvPairs[\"PEER1_MEMBER_INTERFACES\"] = torMemberIntfs\n                #nvPairs[\"PEER2_MEMBER_INTERFACES\"] = torVpcPeerMemberIntfs\n                Wrapper.print(\"%s(): vPC-access [%s] Deleting vPC-access intf [%s] with policyId %s, nvPairs [%s]\" %\n                              (funcName, torVpcPairSerialKey, torVpcIntf, pti.getPolicyId(), nvPairs))\n\n                #Get old RM associated with the vPC and delete it               \n                ignore, oldTorVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", torSn, torVpcPairSerialKey))\n                ignore, oldTorVpcPeerRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", torVpcPeerSn, torVpcPairSerialKey))\n                ignore, oldTorPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, torPOIntf))\n                ignore, oldTorVpcPeerPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", torVpcPeerSn, torVpcPeerPOIntf))\n                PTI.deleteInstance(pti.getPolicyId())\n                RM.deleteResource(oldTorVpcRmId)\n                RM.deleteResource(oldTorVpcPeerRmId)\n                RM.deleteResource(oldTorPcRmId)\n                RM.deleteResource(oldTorVpcPeerPcRmId)\n\n                Wrapper.print(\"%s(): Deleted RMIds [%s] [%s] [%s] [%s]\" %\n                              (funcName, oldTorVpcRmId, oldTorVpcPeerRmId, oldTorPcRmId, oldTorVpcPeerPcRmId))\n                              \n                #torVpcId, torVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", torSn, torVpcPairSerialKey))\n\n                policyIdNum = Util.exe(PTIWrapper.getPolicyID())\n                Wrapper.print(\"%s(): PolicyId number for not torVpc vPC [%s]\" %(funcName, policyIdNum))\n                ignore, torVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", torSn, torVpcPairSerialKey, torVpcId))\n                RM.linkResource(policyIdNum, torVpcRmId)\n\n                ignore, torVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", torVpcPeerSn, torVpcPairSerialKey, torVpcId))\n                RM.linkResource(policyIdNum, torVpcPeerVpcRmId)\n                leafVpcIntf = \"vPC\" + leafVpcId\n                torVpcIntf = \"vPC\" + torVpcId\n                Wrapper.print(\"%s() Back-to-back VPC: accessSn %s accessVpcPairSerialKey %s accessVpcId %s\" %\n                              (funcName, torSn, torVpcPairSerialKey, torVpcId))\n\n                ignore, torPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, torVpcIntf, torPcId))\n                RM.linkResource(policyIdNum, torPcRmId)\n                ignore, torVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torVpcPeerSn, torVpcIntf, torVpcPeerPcId))\n                RM.linkResource(policyIdNum, torVpcPeerPcRmId)\n                \n                \n                torRmIdList = [torPcRmId] + [torVpcPeerPcRmId] + [torVpcRmId] + [torVpcPeerVpcRmId]\n                nvPairs.update({\"SWITCH_ROLE\": \"access\", \"NBR_SERIAL_NUMBER\": leafVpcPairSerialKey, \"NBR_INTF_NAME\": leafVpcIntf})\n                nvPairs.pop(\"POLICY_ID\", \"ignore if not found\")\n                #should be called with List of rm Id\n                Util.exe(PTI.createOrUpdate(torVpcPairSerialKey, \"INTERFACE\", torVpcIntf, \"\",\n                                            ConfigPriority.CONFIG_PRIO_INTF_PO, torRmIdList,\n                                            \"int_vpc_uplink_access\", nvPairs, policyIdNum))\n                Wrapper.print(\"%s(): vPC-access [%s] Created vPC-access intf [%s] with nvPairs [%s], accessRmId %s\" %\n                              (funcName, torVpcPairSerialKey, torVpcIntf, nvPairs, torRmIdList))\n        \n        if not isTorVpc:\n            if not isLeafVpc:\n                Util.exe(ToRWrapper.setLeafTorAssociation(leafSn, leafPOIntf, torSn, torPOIntf))\n                Wrapper.print(\"%s(): setAggAccessAssociation: aggSn %s aggPOIntf %s accessSn %s accessPOIntf %s\" %\n                              (funcName, leafSn, leafPOIntf, torSn, torPOIntf))\n                switchInfo[leafSn][\"accessUplinkIntfs\"].append(leafPOIntf.capitalize())\n                switchInfo[torSn][\"accessUplinkIntfs\"].append(torPOIntf.capitalize())\n            else:   \n                Util.exe(ToRWrapper.setLeafTorAssociation(leafSn, \"port-channel\"+leafPcId, torSn, torPOIntf))\n                Util.exe(ToRWrapper.setLeafTorAssociation(leafVpcPeerSn, \"port-channel\"+leafVpcPeerPcId, torSn, torPOIntf))\n                Wrapper.print(\"%s(): setAggAccessAssociation: aggSn %s aggPOIntf %s accessSn %s accessPOIntf %s\" %\n                              (funcName, leafSn, \"port-channel\"+leafPcId, torSn, torPOIntf))\n                Wrapper.print(\"%s(): setAggAccessAssociation: aggVpcPeerSn %s aggVpcPeerPOIntf %s accessSn %s accessPOIntf %s\" %\n                              (funcName, leafVpcPeerSn, \"port-channel\"+leafVpcPeerPcId, torSn, torPOIntf))\n                switchInfo[leafSn][\"accessUplinkIntfs\"].append((\"port-channel\"+leafPcId).capitalize())\n                switchInfo[leafVpcPeerSn][\"accessUplinkIntfs\"].append((\"port-channel\"+leafVpcPeerPcId).capitalize())\n                switchInfo[torSn][\"accessUplinkIntfs\"].append(torPOIntf.capitalize())\n        else:\n            Util.exe(ToRWrapper.setLeafTorAssociation(leafSn, \"port-channel\"+leafPcId, torSn, \"port-channel\"+torPcId))\n            Util.exe(ToRWrapper.setLeafTorAssociation(leafSn, \"port-channel\"+leafPcId, torVpcPeerSn, \"port-channel\"+torVpcPeerPcId))\n            Util.exe(ToRWrapper.setLeafTorAssociation(leafVpcPeerSn, \"port-channel\"+leafVpcPeerPcId, torSn, \"port-channel\"+torPcId))\n            Util.exe(ToRWrapper.setLeafTorAssociation(leafVpcPeerSn, \"port-channel\"+leafVpcPeerPcId, torVpcPeerSn, \"port-channel\"+torVpcPeerPcId))\n            switchInfo[leafSn][\"accessUplinkIntfs\"].append((\"port-channel\"+leafPcId).capitalize())\n            switchInfo[leafVpcPeerSn][\"accessUplinkIntfs\"].append((\"port-channel\"+leafVpcPeerPcId).capitalize())\n            switchInfo[torSn][\"accessUplinkIntfs\"].append((\"port-channel\"+torPcId).capitalize())\n            switchInfo[torVpcPeerSn][\"accessUplinkIntfs\"].append((\"port-channel\"+torVpcPeerPcId).capitalize())\n        return respObj\n    except Exception as e:\n        if policyIdNum and policyIdNum > 0:\n            Wrapper.print(\"%s(): clean resource for pid %s\"%(funcName, policyIdNum))\n            PTIWrapper.deletePtiVsRMForPolicyId(policyIdNum) \n        if isinstance(e, respObjError):\n            return e.value\n        else:\n            errorMsg = (\"Unexpected error in Access/Aggregation pairing for Access switch [%s], switches are still in migration mode\"%(torSn))\n            Util.handleException(errorMsg, e, respObj)\n\ndef getTorNetworkIntfsFromNbrList(sn, linkNbrList):\n    funcName = sys._getframe(0).f_code.co_name\n    linkType = \"\"\n    intraISLIntfs = []\n    Wrapper.print(\"=======%s():-Start for [%s]=======\"%(funcName, sn))\n    for linkNbr in linkNbrList:\n        sw1Info = json.loads(linkNbr.get(\"sw2-info\"))\n        sw2Info = json.loads(linkNbr.get(\"sw1-info\"))\n        sw2_sn, sw1_sn = getSNsFromNbrList(linkNbr)\n        Wrapper.print(\"==%s(): SWITCH1 INFO==[%s]\"%(funcName, sw1Info))\n        Wrapper.print(\"==%s(): SWITCH2 INFO==[%s]\"%(funcName, sw2Info))\n        linkType = linkNbr.get(\"link-type\")\n        operState = linkNbr.get(\"is-present\")\n        isSwitchVPC = isVPCPair(sw1_sn, sw2_sn)\n        Wrapper.print (\"%s(): vpcPair [%s] linkType [%s] oper [%s] \"\n                       \"SN1:SN2:IFNAME1:IFNAME2 [%s:%s-%s:%s] SwRole1:SwRole2 [%s:%s] fabric1:fabric2 [%s:%s]\" %\n                       (funcName, isSwitchVPC, linkType, operState,\n                        sw1_sn, sw2_sn,\n                        sw1Info.get(\"if-name\"), sw2Info.get(\"if-name\"),\n                        sw1Info.get(\"switch-role\"), sw2Info.get(\"switch-role\"),\n                        sw1Info.get(\"fabric-name\"), sw2Info.get(\"fabric-name\")))\n\n        #TODO: Need to handle deletion of int_pre_provisioned_fabric_link PTI when using planned_link\n        if isSwitchVPC or (linkType != \"ethisl\" and linkType != \"lan_planned_link\"):\n            continue\n\n        intraIntf = nbrSwitchRole = \"\"\n        if (sw1_sn == sn):\n            intraIntf = sw1Info.get(\"if-name\")\n            nbrSwitchRole = sw2Info.get(\"switch-role\")\n        elif (sw2_sn == sn):\n            intraIntf = sw2Info.get(\"if-name\")\n            nbrSwitchRole = sw1Info.get(\"switch-role\")\n\n        if intraIntf and \"Ethernet\" in intraIntf and nbrSwitchRole == \"aggregation\":\n            intraISLIntfs.append(intraIntf)\n\n    Wrapper.print(\"===%s() All ethisl/planned links:[%s]===\"%(funcName, intraISLIntfs))\n    Wrapper.print(\"===%s()-End for [%s]===\"%(funcName, sn))\n    return (intraISLIntfs)\n\ndef getTorNbrInfo(sn, intf, linkNbrList):\n    funcName = sys._getframe(0).f_code.co_name\n    nbrInfo = {\"nbrSn\":\"\", \"nbrIntf\":\"\"}\n    nbrSn = nbrIntf = \"\"\n    for linkNbr in linkNbrList:\n        sw1Info = json.loads(linkNbr.get(\"sw2-info\"))\n        sw2Info = json.loads(linkNbr.get(\"sw1-info\"))\n        linkType = linkNbr.get(\"link-type\")\n        operState = linkNbr.get(\"is-present\")\n        Wrapper.print(\"%s() sn %s intf %s linkType %s operState %s sw1Info %s sw2Info %s\" %\n                      (funcName, sn, intf, linkType, operState, sw1Info, sw2Info))\n        #if linkType != \"ethisl\" or operState == \"false\":\n        if linkType != \"ethisl\" and linkType != \"lan_planned_link\":\n            continue\n        sw2_sn, sw1_sn = getSNsFromNbrList(linkNbr)\n        if (sw1_sn == sn and sw1Info.get(\"if-name\") == intf):\n            fabric = sw1Info.get(\"fabric-name\")\n            nbrIntf = sw2Info.get(\"if-name\")\n            nbrSn = sw2_sn\n        if (sw2_sn == sn and sw2Info.get(\"if-name\") == intf):\n            fabric = sw2Info.get(\"fabric-name\")\n            nbrIntf = sw1Info.get(\"if-name\")\n            nbrSn = sw1_sn\n        if nbrIntf and nbrSn:\n            Wrapper.print(\"%s() fab: %s link [%s] [%s] <---> [%s] [%s]\" %\n                          (funcName, fabric, sn, intf, nbrIntf, nbrSn))\n            nbrInfo.update({\"nbrSn\":nbrSn, \"nbrIntf\":nbrIntf})\n            break\n    return nbrInfo\n\ndef getSNsFromNbrList(nbrLink):\n    sw1_info = json.loads(nbrLink[\"sw1-info\"])\n    sw2_info = json.loads(nbrLink[\"sw2-info\"])\n\n    if \"is-vdc\" in sw1_info and sw1_info[\"is-vdc\"] == \"true\":\n        sw1_sn = Util.getVDCSn(sw1_info)\n    else:\n        sw1_sn = sw1_info[\"sw-serial-number\"]\n\n    if \"is-vdc\" in sw2_info and sw2_info[\"is-vdc\"] == \"true\":\n        sw2_sn = Util.getVDCSn(sw2_info)\n    else:\n        sw2_sn = sw2_info[\"sw-serial-number\"]\n\n    return sw1_sn, sw2_sn\n\ndef isSwitchConnected(topologyDataObj, deviceSn1, deviceSn2):\n    funcName = sys._getframe(0).f_code.co_name\n    linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, deviceSn1, Helper.getNbrTypeInternal()))\n\n    for nbrLink in linkNbrList:\n        if nbrLink[\"link-type\"] not in [\"ethisl\", \"lan_planned_link\"]:\n            Wrapper.print(\"%s: Link for node: %s is not ethisl or lan_planned_link: %s IGNORE\" %\n                            (funcName, deviceSn1, nbrLink[\"link-type\"]))\n            continue\n\n        sw1_sn, sw2_sn = getSNsFromNbrList(nbrLink)\n\n        if sw1_sn == deviceSn2 or sw2_sn == deviceSn2:\n            Wrapper.print(\"%s: access-agg <%s, %s> connected\" % (funcName, deviceSn1, deviceSn2))\n            return True\n\n    Wrapper.print(\"%s: access-agg <%s, %s> NOT connected\" % (funcName, deviceSn1, deviceSn2))\n    return False\n\ndef isVPCPair(sn1, sn2):\n    isSwitchVPC1 = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, sn1))\n    isSwitchVPC2 = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, sn2))\n    if not isSwitchVPC1 or not isSwitchVPC2:\n        return False\n    vpcPairSerialKey1 = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, sn1))\n    vpcPairSerialKey2 = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, sn2))\n    if vpcPairSerialKey1 == vpcPairSerialKey2:\n        return True\n    return False\n\ndef ECLgetSviCfg(vlanIdStr, interfacesRes, includeAllCfg, isVrf):\n    funcName = sys._getframe(0).f_code.co_name\n    freeformCfg = \"\"\n    sviName = 'Vlan'+ vlanIdStr\n    intfMatchResult = interfacesRes.get(sviName)\n    if intfMatchResult != None:\n        if includeAllCfg:\n            ffList = [\"interface \" + sviName]\n            ffList += intfMatchResult[\"show_run_cmds\"]\n            freeformCfg += (Util.newLine() + Util.newLine().join(ffList))\n        else:\n            if len(intfMatchResult[\"unaccounted_cmds\"]) > 0:\n                Wrapper.print(\"%s: sviName [%s]. Unaccounted [%s]\" % (funcName, sviName, intfMatchResult[\"unaccounted_cmds\"]))\n\n                sviUnacctCmds = []\n\n                # - these commands have issues with negation. Ex: to remove 'no ip redirects' CC will issue 'ip redirects'\n                #   which causes the command to actually get removed on switch\n                overlaySpecialSviCmds = [\"no ip redirects\", \"no ipv6 redirects\"]\n                sviHasOtherUnaccCmds = False\n\n                # special case some overlay SVI commands.. the redirect and forward related configs do not\n                # have policies to match\n                overlaySviCmds = [\"no shutdown\"]\n                for cmd in intfMatchResult[\"unaccounted_cmds\"]:\n                    strippedCmd = cmd.strip()\n                    if strippedCmd in overlaySviCmds:\n                        continue\n                    elif strippedCmd not in overlaySpecialSviCmds:\n                        sviHasOtherUnaccCmds = True\n\n                    sviUnacctCmds.append(cmd)\n\n                '''\n                if \"vlan_interface\" in intfMatchResult[\"matched_templates\"]:\n                    # this policy being present indicates both the CLI are present.. add them \n                    for cmd in overlaySpecialSviCmds:\n                        sviUnacctCmds.append(INTF_FIRST_LVL_SPACING + cmd)\n                '''\n                \n                Wrapper.print(\"%s: sviName [%s]. sviUnacctCmds [%s]\" % (funcName, sviName, sviUnacctCmds))\n                if len(sviUnacctCmds) > 0:\n                    finalCfgToAddToFreeform = None\n                    if sviHasOtherUnaccCmds:\n                        finalCfgToAddToFreeform = sviUnacctCmds\n\n                    if finalCfgToAddToFreeform:\n                        cfg = Util.newLine().join(finalCfgToAddToFreeform)\n                        freeformCfg += (Util.newLine() + \"interface \" + sviName + Util.newLine() + cfg)\n\n                        '''\n                        # we need to add the 'no shutdown' config to avoid an issue seen with CC trying to\n                        # remove individual config lines.. otherwise CC will generate 'shutdown' to negate 'no shutdown'\n                        if \"no_shut_interface\" in intfMatchResult[\"matched_templates\"]:\n                            freeformCfg += (Util.newLine() + (\"%sno shutdown\" % INTF_FIRST_LVL_SPACING))\n                        '''    \n                        Wrapper.print(\"%s: sviName [%s]. freeformCfg [%s]\" % (funcName, sviName, freeformCfg))\n    return freeformCfg\n    \n##\n","newContent":"##template properties\nname =fabric_upgrade_11_1;\ndescription = ;\ntags = ;\nuserDefined = false;\nsupportedPlatforms = All;\ntemplateType = POLICY;\ntemplateSubType = NA;\ncontentType = PYTHON;\nimplements = ;\ndependencies = ;\npublished = false;\nimports = ;\n##\n##template variables\n\n#    Copyright (c) 2019-2023 by Cisco Systems, Inc.\n#    All rights reserved.\n\n##\n##template content\n\nfrom com.cisco.dcbu.vinci.rest.services.jython import *\nfrom com.cisco.dcbu.vinci.rest.services.jython import PTIWrapper as PTI\nfrom com.cisco.dcbu.vinci.rest.services.jython import ResourceManagerWrapper as RM\nfrom com.cisco.dcbu.vinci.rest.services.jython import InterfaceManagerWrapper as IM\nfrom com.cisco.dcbu.vinci.rest.services.jython import TopDownOverlayWrapper as TD\nfrom com.cisco.dcbu.vinci.rest.services.jython import ElasticServiceWrapper as ES\nfrom com.cisco.dcbu.vinci.rest.services.jython import BackupRestoreWrapper as BRW\nfrom com.cisco.dcbu.vinci.rest.services.jython import InterfaceTypeEnum\nfrom com.cisco.dcbu.topdown.resource import LanUpgradeInterface\nfrom com.cisco.dcbu.pti.resource import CtrlPolicySearch\nfrom com.cisco.dcbu.easy.resource import CtrlFabric\nfrom com.cisco.dcbu.topdown.util import TopDownMigrationUtils\nfrom com.cisco.dcbu.topdown.resource import LanVRF\nfrom com.cisco.dcbu.topdown.resource import LanVRFAttach\nfrom com.cisco.dcbu.topdown.resource import LanAttachByVRF\nfrom com.cisco.dcbu.topdown.resource import LanSwitchDetailsByVRF\nfrom com.cisco.dcbu.topdown.resource import LanNetwork\nfrom com.cisco.dcbu.topdown.resource import LanAttachDetailsByNetwork\nfrom com.cisco.dcbu.topdown.resource import LanAttachByNetwork\nfrom com.cisco.dcbu.topdown.resource import LanAttach\nfrom com.cisco.dcbu.topdown.resource import LanNetworkStatus\nfrom com.cisco.dcbu.topdown.resource import LanSwitchDetailsByNetwork\nfrom com.cisco.dcbu.sm.server.web.cfgtemplates import ConfigTemplateHandler\nfrom com.cisco.dcbu.tor.service import ToRWrapper\nfrom com.cisco.dcbu.tor.impl import TorImpl\nfrom com.cisco.dcbu.tor.resource import ToRLeaf\nfrom com.cisco.dcbu.jython.resource import Category\nfrom com.cisco.dcbu.jython.resource import EntityType as ET\nfrom com.cisco.dcbu.easy.util.jython.impl import FabricErrorLogger\n\nfrom topology import *\nfrom utility import *\nfrom underlay import *\nimport subprocess\nfrom collections import OrderedDict\n\nimport sys, traceback\nimport re\nimport glob\nimport os\nimport json\nimport logging\nimport datetime\nimport time\nimport inspect\nimport filecmp\nimport struct\nimport socket\nimport itertools\nfrom distutils.version import LooseVersion\n\nPOLICY_TEMPLATE_BASE_DIR = \"/usr/local/cisco/dcm/dcnm/data/templates/\"\n\n# Switch import related base directory and filenames\nSH_RUN_FILENAME = \"show_run\"\nSH_RUN_ALL_FILENAME = \"show_run_all\"\nMATCH_RESULT_FILENAME = \"result.txt\"\nINTF_MATCH_RESULT_FILENAME = \"intfResult.txt\"\nOVERLAY_INFO_FILENAME = \"overlay_info.txt\"\nIMPORT_METADATA_FILENAME = \"import_meta\"\n\nOVERLAY_PREFIX = \"----OVERLAY:\"\n\n# DCNM HA conf\nhaConf = \"/usr/local/cisco/dcm/fm/ha/ha-setup.conf\"\n\n# SSH connection read timeout value in milliseconds (10 minutes)\nSSH_CONN_READ_TIMEOUT = 600000\n\nINTF_FIRST_LVL_SPACING = \"  \"\n\nTOPDOWN_VRF_PROFILE_FREEFORM_PRIO      = 1540\nTOPDOWN_NETWORK_PROFILE_FREEFORM_PRIO  = 1550\n\n# VRF Lite IFC Python Template Name\nVRF_LITE_IFC_PYTHON_POLICY = \"Ext_VRF_Lite_Jython\"\n\nMAX_TOPDOWN_NETWORK_NAME_LENGTH = 64\n\nMGMT_VRF_NAME = \"management\"\nDEFAULT_VRF_NAME = \"default\"\n#New special vrf present in N9k systems with version 10.3.x\nEGRESS_LB_VRF = \"egress-loadbalance-resolution-\"\nGF_MGMT_VRF_FF_PTI_DESC = \"management vrf configuration\"\nBF_PRE_INTF_FF_PTI_DESC = \"Pre Interfaces Configuration\"\n\nBF_NETWORK_ATTACH_BATCH_SIZE = 100\n\nNET_PROFILE_DHCP_SERVERS_VAR = \"dhcpServers\"\nNET_PROFILE_DHCP_SERVERS_MAX = 16\n\nNO_DISK_SPACE_ERR_MSG = \"No space left on device\".lower()\n\n# template metadata dictionary\n# Note: defaults if a key is not provided:\n#               \"etype\" -> \"SWITCH\"\n#               \"source\" -> \"UNDERLAY\"\ntemplate_metadata = {\n    # Common Global\n    \"password_no_strength\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"nfm_switch_snmp_user\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"pre_config\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"pre_config_9300PX\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"tcam_pre_config_9300\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"tcam_pre_config_9500\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"tcam_pre_config_vxlan\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"nfm_switch_user\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"ssh_key_rsa\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"host_11_1\" : {\"source\":\"\", \"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"switchnm_11_1\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"v4_mgmt_default_gateway\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"v6_mgmt_default_gateway_11_1\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"dnsList\" :     {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"dns-vrfList\" : {\"source\" : \"\", \"prio\" : 911},\n    \"power_redundancy_combined\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"power_redundancy\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_dhcp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_ospf\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_ospfv3\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_ospf_auth\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"bfd_ospf\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"keychain\" : {\"source\" : \"ISIS_AUTH_UNDERLAY\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_isis_auth\" : {\"source\" : \"ISIS_AUTH_UNDERLAY\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"bfd_isis_af_ipv4\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"base_isis_level2\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"isis_overload\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_isis_level2_internal\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_multicast_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_pim_asm_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_pim_bidir_11_1\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bfd_pim\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_bgp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"anycast_rp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"syslog_server\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"syslog_server_sev\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"syslog_server_vrf\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"syslog_server_vrf_no_sev\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"ntp_server\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"ntp_prefer_server\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"clock_protocol\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"clock_timezone\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"clock_summertime\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"aaa_radius\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_radius_key\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"aaa_radius_use_vrf\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_radius_src_interface\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_radius_deadtime\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_tacacs\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_tacacs_key\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"aaa_tacacs_use_vrf\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"aaa_tacacs_src_interface\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"base_aaa\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL3},\n    \"bgp_overlay_ipv4_vrf_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_ipv6_vrf_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv4_redist_rmap_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv6_redist_rmap_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv4_max_bgp_paths_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv6_max_bgp_paths_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv4_max_ibgp_paths_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_overlay_vrf_ipv6_max_ibgp_paths_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_cluster_id\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"evpn_multisite\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"evpn_multisite_pip\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"evpn_bgp_neighbor_auth\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"bfd_bgp_neighbor\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"feature_bfd\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"feature_nxapi\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"nxapi_http_port\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"nxapi_https_port\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"hardware_profile_port_mode\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"banner\": {\"source\": \"\", \"prio\": ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"apply_profile\": {\"source\": \"\", \"prio\": ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_bgp_external\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n\n    # Applies only to a vPC Pair\n    \"base_feature_vpc\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_vpc_domain_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_peer_switch\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_domain_ipv6_nd_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_domain_mgmt\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_domain_mgmt_no_src_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_delay_restore\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_domain_autorecovery\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_VPC_TOP_LVL1},\n    \"vpc_domain_autorecovery_default\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_VPC_TOP_LVL1},\n    \"vpc_peer_link_vlan\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_peer_link_vlan_9300PX\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"vpc_domain_virtual_peerlink\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n\n    # Applies only to a Leaf\n    \"base_feature_leaf_upg\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"eth_cfs\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"ipv4_cfs\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"ipv6_cfs\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"feature_ospf\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_ospfv3\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_isis\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_tacacs\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_pim\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_ngoam\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_lacp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_nv_overlay\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP + 1},\n    \"feature_ngmvpn\": {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"trm_multicast_multipath\": {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"feature_interface_vlan_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_vlan_based_vnsegment_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_dhcp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"evpn_bgp_rr_neighbor\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"v6_evpn_bgp_rr_neighbor\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"mvpn_bgp_rr_neighbor\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"l3_trm\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"bgp_peer_template\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"bgp_neighbor_inherit\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"anycast_gateway\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"system_jumbomtu\" : {\"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"system_nve_infra_vlan\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"route_map\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"enable_ngoam\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"evpn_bgp_advertise_pip\": {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"extra_config_leaf\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_BOTTOM},\n    \"base_fex\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"base_fex_N7k\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"enable_fex\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"vlan_vnseg_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"vlan_name_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"overlay_vrf_ipv4_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"overlay_vrf_ipv6_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"vrf_desc_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"evpn_vni_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"evpn_vni_rt_both_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n\n    # Applies only to a Spine\n    \"base_feature_spine_upg\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"vpc_serial_simulated\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"evpn_bgp_rr\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"v6_evpn_bgp_rr\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"mvpn_bgp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1},\n    \"mvpn_bgp_rr_11_1\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2},\n    \"extra_config_spine\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_BOTTOM},\n\n    # Common Interface\n    \"nve_advertise_vmac\": {\"eType\" : \"INTERFACE\", \"source\" : \"UNDERLAY\", \"prio\" : ConfigPriority.nve_interface},\n    \"mgmt_interface_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"mgmt0\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"breakout_interface\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"loopback_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.loopback_interface},\n    \"loopback_interface_with_tag\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.loopback_interface},\n    \"v6_loopback_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.loopback_interface},\n    \"v6_loopback_interface_with_tag\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.loopback_interface},\n    \"phantom_loopback_interface_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.loopback_interface},\n    \"unnumbered_fabric_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"pim_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n\n    \"int_freeform\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"trunk_interface\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"access_interface\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n\n    \"trunk_interface_fex\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_trunk_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_access_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_dot1q_tunnel_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_routed_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n\n    \"int_vlan\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_subif\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.routed_interface},\n\n    \"port_channel_trunk_interface_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_port_channel_trunk_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n\n    \"int_port_channel_trunk_member_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : 510},\n    \"int_port_channel_dot1q_tunnel_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_port_channel_dot1q_tunnel_member_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : 510},\n    \"int_port_channel_access_host\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_port_channel_access_member_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : 510},\n    \"int_l3_port_channel\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_l3_port_channel_member\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_HOST_INTF},\n    \"int_vpc_trunk_host_standalone_11_1\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\": ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_dot1q_tunnel\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_trunk_host\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_trunk_po_member_11_1\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_access_host_standalone_11_1\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\": ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_access_host\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_access_po_member_11_1\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"bpduguard_disable\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"bpduguard_enable\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"porttype_fast_trunk\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"access_vlan\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"ospf_interface_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"v6_ospf_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"isis_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"isis_p2p_interface\": {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"v6_isis_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"isis_interface_auth\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"isis_interface_auth_no_lvl\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"ospf_p2p_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"ospf_interface_auth\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"pim_interface_hello_auth\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"bfd_no_echo_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"bfd_interface_auth\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \n    \"shut_interface_force\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"shut_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"no_shut_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_desc\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_mtu\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_speed\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_no_nego_auto\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL2},\n    \"interface_orphan_port\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL2},\n    \"port_channel_mode_on\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"port_channel_mode\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"int_fabric_num_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.fabric_interface},\n    \"int_fabric_unnum_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.fabric_interface},\n    \"int_fabric_ipv6_link_local\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.fabric_interface},\n    \"int_vpc_peer_keep_alive_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"int_fabric_loopback_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_LOOPBACK},\n    \"int_fabric_phantom_rp_loopback_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_LOOPBACK},\n    \"int_port_channel_fex\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_aa_fex_standalone_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"temp\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_port_channel_aa_fex\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_fex_po_member_11_1\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"fex_port_channel_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"fex_po_member_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"vlan_interface_fwd_mode_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"int_loopback\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_LOOPBACK},\n\n    # Applies only to a Leaf\n    \"int_nve\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_NVE},\n    \"int_mgmt\" : {\"eType\" : \"INTERFACE\", \"source\" : \"\", \"prio\" : ConfigPriority.INTF_MGMT},\n    \"nve_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_NVE},\n    \"nve_holddown_time\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_NVE},\n    \"nve_anycast_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_NVE},\n    \"nve_interface_vni_mcast_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"nve_interface_vni_suppress_arp_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"nve_interface_vni_ir_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"nve_interface_vni_vrf_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_ipv4_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_ipv4_tag_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_ipv6_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"interface_ipv6_tag_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_sec_ip_v4_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_sec_ip_v4_tag_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_dhcp_relay_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_dhcp_relay_vrf_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_dhcp_relay_src_lo_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vlan_interface_ipv6_link_local_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n\n    \"route-map\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"interface_vrf\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"overlay_vlan_intf_fwd_mode\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n\n    # Applies only to a vPC Pair\n    \"vpc_nve_loopback\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"vpc_nve_loopback_with_tag_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n    \"int_fabric_vlan_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"vlan_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"vpc_peer_link\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"int_vpc_peer_link_po\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"int_vpc_peer_link_po_member_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"vpc_peer_link_po_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"vpc_peer_link_member_interface\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF},\n    \"port_channel_vpc_id_11_1\" : {\"eType\" : \"INTERFACE\", \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_SUB_LVL1},\n\n    # Applies only to ECL\n    \"base_feature_agg\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_TOP},\n    \"feature_bgp\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"router_ospf\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"router_ospfv3\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"spanning_tree_classic\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"spanning_tree_classic_config\" : {\"prio\" : ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP},\n    \"int_vpc_uplink_access\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_uplink_access_po\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    \"int_vpc_uplink_access_po_member\": {\"eType\": \"INTERFACE\", \"source\": \"\",\n                                                        \"prio\" : ConfigPriority.CONFIG_PRIO_INTF_PO},\n    }\n\n# policy templates that apply to both spine and leafs\ncommon_templates_list = [\n    \"keychain\",\n    \"pre_config\",\n    \"pre_config_9300PX\",\n    \"tcam_pre_config_9300\",\n    \"tcam_pre_config_9500\",\n    \"tcam_pre_config_vxlan\",\n    \"nfm_switch_user\",\n    \"ssh_key_rsa\",\n    \"host_11_1\",\n    \"switchnm_11_1\",\n    \"v4_mgmt_default_gateway\",\n    \"v6_mgmt_default_gateway_11_1\",\n    \"nfm_switch_snmp_user\",\n    \"base_feature_vpc\",\n    \"feature_isis\",\n    \"feature_lacp\",\n    \"feature_pim\",\n    \"feature_pbr\",\n    \"feature_ngoam\",\n    \"feature_nv_overlay\",\n    \"feature_ngmvpn\",\n    \"trm_multicast_multipath\",\n    \"feature_interface_vlan_11_1\",\n    \"feature_vlan_based_vnsegment_11_1\",\n    \"feature_dhcp\",\n    \"base_bgp\",\n    \"base_ospf_auth\",\n    \"base_isis_auth\",\n    \"base_isis_level2\",\n    \"base_isis_level2_internal\",\n    \"isis_overload\",\n    \"base_multicast_11_1\",\n    \"base_pim_asm_11_1\",\n    \"base_pim_bidir_11_1\",\n    \"base_dhcp\",\n    \"dnsList\",\n    \"dns-vrfList\",\n    \"ntp_server\",\n    \"ntp_prefer_server\",\n    \"clock_protocol\",\n    \"clock_summertime\",\n    \"clock_timezone\",\n    \"syslog_server\",\n    \"syslog_server_sev\",\n    \"syslog_server_vrf\",\n    \"syslog_server_vrf_no_sev\",\n    \"anycast_rp\",\n    \"bgp_peer_template\",\n    \"bgp_neighbor_inherit\",\n    \"system_nve_infra_vlan\",\n    \"evpn_multisite\",\n    \"copp_policy\",\n    \"vpc_domain_l3_pka_vrf_11_1\",\n    \"evpn_bgp_neighbor_auth\",\n    \"feature_bfd\",\n    \"bfd_ospf\",\n    \"bfd_isis_af_ipv4\",\n    \"bfd_pim\",\n    \"bfd_bgp_neighbor\",\n    \"feature_nxapi\",\n    \"nxapi_http_port\",\n    \"nxapi_https_port\",\n    \"route_map\",\n    \"banner\",\n    \"apply_profile\",\n    \"evpn_bgp_rr_neighbor\",\n    \"v6_evpn_bgp_rr_neighbor\",\n    \"mvpn_bgp_rr_neighbor\",\n    ]\n\n# policy templates for NxCloud that apply to all devices\nnxcloud_templates_list = [\n    \"intersight_proxy_internal\",\n    \"intersight_proxy_port_internal\",\n    \"intersight_src_intf_internal\",\n    \"intersight_use_vrf_internal\"\n    ]\n\ninterface_templates_list = [\n    \"interface_ipv4_11_1\",\n    \"interface_ipv6_11_1\",\n    \"routed_interface_no_ip_redirects\",\n    \"ospf_p2p_interface\",\n    \"ospf_interface_auth\",\n    \"pim_interface_hello_auth\",\n    \"isis_p2p_interface\",\n    \"isis_interface_auth\",\n    \"isis_interface_auth_no_lvl\",\n    \"phantom_loopback_interface_11_1\",\n    \"interface_port_type_fabric\",\n    \"bfd_no_echo_interface\",\n    \"bfd_interface_auth\",\n    \"pim_interface\",\n    \"unnumbered_fabric_interface\",\n    \"unnumbered_fabric_interface_nov6\",\n    \"routed_interface\",\n    \"eth_sub_interface\",\n    \"eth_sub_interface_tag\",\n    \"p2p_routed_interface\",\n    \"p2p_routed_interface_tag\",\n    \"nve_advertise_vmac\",\n    \"nve_holddown_time\",\n    \"interface_vrf\",\n    \"mgmt_interface_11_1\",\n    \"breakout_interface\",\n    \"cdp_disable_interface_11_1\",\n    \"trunk_interface\",\n    \"access_interface\",\n    \"port_channel_access_interface\",\n    \"port_channel_trunk_interface_11_1\",\n    \"dot1q_tunnel_interface\",\n    \"port_channel_dot1q_tunnel_interface\",\n    \"bpduguard_disable\",\n    \"bpduguard_enable\",\n    \"porttype_fast_trunk\",\n    \"porttype_fast_enable\",\n    \"access_vlan\",\n    \"native_vlan\",\n    \"interface_desc\",\n    \"interface_mtu\",\n    \"interface_speed\",\n    \"interface_no_nego_auto\",\n    \"interface_orphan_port\",\n    \"port_channel_mode_on\",\n    \"port_channel_mode\",\n    \"port_channel_routed_interface\"\n]\n\nv4_underlay_templates_list = [\n    \"feature_ospf\",\n    \"base_ospf\",\n    \"vlan_interface\",\n    ]\n\ninterface_v4_underlay_templates_list = [\n    \"ospf_interface_11_1\",\n    \"isis_interface\",\n    \"loopback_interface\",\n    \"loopback_interface_with_tag\"\n    ]\n\nv6_underlay_templates_list = [\n    \"feature_ospfv3\",\n    \"base_ospfv3\"\n    ]\n\ninterface_v6_underlay_templates_list = [\n    \"v6_ospf_interface\",\n    \"v6_isis_interface\",\n    \"v6_loopback_interface\",\n    \"v6_loopback_interface_with_tag\",\n    \"v6_vlan_interface\",\n    \"v6_vlan_interface_link_local\",\n    \"interface_ipv6_link_local\",\n    \"interface_ipv6_link_local_bia\"\n    ]\n\n# policy templates that apply to leafs only\nleaf_templates_list = [\n    \"anycast_gateway\",\n    \"evpn_bgp_rr_neighbor_send_comm_both\",\n    \"l3_trm\",\n    \"enable_ngoam\",\n    \"evpn_bgp_advertise_pip\",\n    \"system_jumbomtu\",\n    \"base_feature_leaf_upg\",\n    \"eth_cfs\",\n    \"ipv4_cfs\",\n    \"ipv6_cfs\"\n    ]\n\ninterface_leaf_templates_list = [\n    \"nve_interface\",\n    \"nve_anycast_interface\",\n    ]\n\n# policy related to overlays on leafs \nleaf_overlay_templates_list = [\n    \"vlan_vnseg_11_1\",\n    \"vlan_name_11_1\",\n    \"overlay_vrf_ipv4_11_1\",\n    \"overlay_vrf_ipv6_11_1\",\n    \"vrf_desc_11_1\",\n    \"evpn_vni_11_1\",\n    \"evpn_vni_rt_both_11_1\",\n    \"bgp_overlay_ipv4_vrf_11_1\",\n    \"bgp_overlay_ipv6_vrf_11_1\",\n    \"bgp_overlay_vrf_ipv4_redist_rmap_11_1\",\n    \"bgp_overlay_vrf_ipv6_redist_rmap_11_1\",\n    \"bgp_overlay_vrf_ipv4_max_bgp_paths_11_1\",\n    \"bgp_overlay_vrf_ipv6_max_bgp_paths_11_1\",\n    \"bgp_overlay_vrf_ipv4_max_ibgp_paths_11_1\",\n    \"bgp_overlay_vrf_ipv6_max_ibgp_paths_11_1\"\n]\n\ninterface_leaf_overlay_templates_list = [\n    \"nve_interface_vni_mcast_11_1\",\n    \"nve_interface_vni_suppress_arp_11_1\",\n    \"nve_interface_vni_ir_11_1\",\n    \"nve_interface_vni_vrf_11_1\",\n    \"interface_ipv4_tag_11_1\",\n    \"interface_ipv6_tag_11_1\",\n    \"vlan_interface_sec_ip_v4_11_1\",\n    \"vlan_interface_sec_ip_v4_tag_11_1\",\n    \"vlan_interface_dhcp_relay_11_1\",\n    \"vlan_interface_dhcp_relay_vrf_11_1\",\n    \"vlan_interface_dhcp_relay_src_lo_11_1\",\n    \"vlan_interface_ipv6_link_local_11_1\",\n    \"vlan_interface_fwd_mode_11_1\",\n]\n\n# policy templates that apply to spines only\nspine_templates_list =[\n    \"evpn_bgp_rr\",\n    \"v6_evpn_bgp_rr\",\n    \"evpn_bgp_rr_send_comm_both\",\n    \"mvpn_bgp\",\n    \"mvpn_bgp_rr_11_1\",\n    \"base_feature_spine_upg\",\n    \"bgp_cluster_id\",\n    #\"interface_qos_service_policy\",\n    ]\n\n# policy templates that apply to vPC leaves only\nleaf_vpc_templates_list =[\n    \"base_vpc_domain_11_1\",\n    \"vpc_peer_switch\",\n    \"vpc_nve_loopback\",\n    \"vpc_peer_link_po_interface\",\n    \"vpc_peer_link_member_interface\",\n    ]\n\nleaf_vpc_host_templates_list =[\n    \"port_channel_vpc_id_11_1\"\n    ]\n\nleaf_vpc_additional_templates_list =[\n    \"vpc_domain_mgmt\",\n    \"vpc_domain_mgmt_no_src_11_1\",\n    \"vpc_domain_ipv6_nd_11_1\",\n    \"vpc_delay_restore\",\n    \"vpc_domain_autorecovery\",\n    \"vpc_nve_loopback_with_tag_11_1\",\n    \"vpc_domain_autorecovery_default\",\n    \"vpc_domain_virtual_peerlink_dscp\"\n    ]\n\n# shut/no shut policy templates that apply to all.\n# These need to be at the end of the lists.. the subsequent code assumes this\ninterface_shut_no_shut_templates_list =[\n    \"shut_interface_force\",\n    \"shut_interface\",\n    \"no_shut_interface\"\n    ]\n\nfabric_bgp_tmpl_type, fabric_bgp_tmpl_name = \"\", \"\"\n\n# FEX policy templates that apply to leaves only\nleaf_fex_templates_list =[\n    \"base_fex\",\n    \"base_fex_N7k\",\n    \"enable_fex\",\n    \"trunk_interface_fex\",\n    \"access_interface_fex\",\n    \"fex_port_channel_interface\",\n    \"fex_po_member_interface\"\n]\n\n# policy templates that apply to agg devices\nagg_templates_list = [\n    \"keychain\",\n    \"pre_config\",\n    \"nfm_switch_user\",\n    \"ssh_key_rsa\",\n    \"host_11_1\",\n    \"switchnm_11_1\",\n    \"v4_mgmt_default_gateway\",\n    \"v6_mgmt_default_gateway_11_1\",\n    \"nfm_switch_snmp_user\",\n    \"base_feature_vpc\",\n    \"feature_lacp\",\n    \"feature_pim\",\n    \"feature_pbr\",\n    \"feature_interface_vlan_11_1\",\n    \"feature_dhcp\",\n    \"feature_bgp\",\n    \"base_bgp\",\n    #\"base_bgp_external\",\n    \"base_ospf_auth\",\n    \"base_pim_asm_11_1\",\n    \"base_pim_bidir_11_1\",\n    \"base_dhcp\",\n    \"dnsList\",\n    \"dns-vrfList\",\n    \"ntp_server\",\n    \"ntp_prefer_server\",\n    \"clock_protocol\",\n    \"clock_summertime\",\n    \"clock_timezone\",\n    \"syslog_server\",\n    \"syslog_server_sev\",\n    \"syslog_server_vrf\",\n    \"syslog_server_vrf_no_sev\",\n    \"copp_policy\",\n    \"vpc_domain_l3_pka_vrf_11_1\",\n    \"feature_nxapi\",\n    \"nxapi_http_port\",\n    \"nxapi_https_port\",\n    \"route_map\",\n    \"banner\",\n    \"system_jumbomtu\",\n    \"base_feature_agg\",\n    \"eth_cfs\",\n    \"feature_ospf\",\n    \"base_ospf\",\n    \"router_ospf\",\n    \"router_ospfv3\",\n    \"extra_config_leaf\",\n    \"feature_tacacs\",\n    \"vlan_name_11_1\",\n    \"vlan_netflow\",\n    \"vrf_desc_11_1\",\n    \"vrf_ospf_auth\",\n    \"vrf_af\",\n    #\"spanning_tree_classic\",\n    #\"spanning_tree_classic_config\",\n    \"base_vpc_domain_11_1\",\n    \"vpc_peer_link_po_interface\",\n    \"vpc_peer_link_member_interface\",\n    \"port_channel_vpc_id_11_1\",\n    \"vpc_domain_mgmt\",\n    \"vpc_domain_mgmt_no_src_11_1\",\n    \"vpc_domain_ipv6_nd_11_1\",\n    \"vpc_delay_restore\",\n    \"vpc_domain_autorecovery\",\n    \"vpc_domain_autorecovery_default\",\n    \"bgp_overlay_vrf_ipv4_max_bgp_paths_11_1\",\n    \"bgp_overlay_vrf_ipv6_max_bgp_paths_11_1\",    \n    ]\n\n\nECL_interface_templates_list = [\n    \"interface_ipv4_11_1\",\n    \"interface_ipv6_11_1\",\n    \"routed_interface_no_ip_redirects\",\n    #\"vlan_interface_sec_ip_v4_11_1\",\n    #\"vlan_interface_sec_ip_v4_tag_11_1\",\n    \"vlan_interface_dhcp_relay_11_1\",\n    \"vlan_interface_dhcp_relay_vrf_11_1\",\n    \"interface_ipv4_tag_11_1\",\n    \"interface_ipv6_tag_11_1\",\n    \"routed_interface\",\n    \"eth_sub_interface\",\n    \"interface_subintf\",\n    \"eth_sub_interface_tag\",\n    \"p2p_routed_interface\",\n    \"p2p_routed_interface_tag\",\n    \"interface_vrf\",\n    \"mgmt_interface_11_1\",\n    \"breakout_interface\",\n    \"cdp_disable_interface_11_1\",\n    \"trunk_interface\",\n    \"access_interface\",\n    \"port_channel_access_interface\",\n    \"port_channel_trunk_interface_11_1\",\n    \"dot1q_tunnel_interface\",\n    \"port_channel_dot1q_tunnel_interface\",\n    \"bpduguard_disable\",\n    \"bpduguard_enable\",\n    \"porttype_fast_trunk\",\n    \"porttype_fast_enable\",\n    \"access_vlan\",\n    \"native_vlan\",\n    \"interface_desc\",\n    \"interface_mtu\",\n    \"interface_speed\",\n    \"interface_no_nego_auto\",\n    \"interface_orphan_port\",\n    \"port_channel_mode_on\",\n    \"port_channel_mode\",\n    \"port_channel_routed_interface\",\n    \"ospf_interface_auth\",\n    \"ospf_interface_11_1\",\n    \"v6_ospf_interface\",\n]\n\n'''\ninterface_agg_templates_list = [\n    \"int_vpc_uplink_access\",\n    \"int_vpc_uplink_access_po\",\n    \"int_vpc_uplink_access_po_member\",  \n    ]\n'''\n\ndef getVpcTemplateList(isNotTahoe):\n    templatesList = []\n    templatesList.extend(leaf_vpc_templates_list)\n    templatesList.extend(leaf_vpc_host_templates_list)\n    templatesList.extend(leaf_vpc_additional_templates_list)\n\n    return templatesList\n\ndef getVpcMandatoryTemplateList(isNotTahoe):\n    templatesList =[\n        \"vpc_nve_loopback\",\n        \"vpc_peer_link_po_interface\",\n        \"vpc_peer_link_member_interface\",\n        \"port_channel_vpc_id_11_1\"\n        ]\n    return templatesList\n\ndef getECLVpcMandatoryTemplateList(isNotTahoe):\n    templatesList =[\n        \"vpc_peer_link_po_interface\",\n        \"vpc_peer_link_member_interface\",\n        \"port_channel_vpc_id_11_1\"\n        ]\n    return templatesList\n\n\ndef getTemplateList(migrModeStr, isNotTahoe, isExternalFab, isSpineOrAgg, fabricTechnology):\n    includeCommon = True\n    templatesList = []\n    if migrModeStr == \"reSync\":\n        templatesList.extend([\"system_jumbomtu\", \"vpc_pair_vpc_domain_vrf_mgmt\",\n                              \"vpc_pair_vpc_domain_non_default_vrf\", \"vpc_peer_link_po_interface\",\n                              \"vpc_pair_vpc_domain_vrf_mgmt_no_hold\", \"vpc_pair_vpc_domain_non_default_vrf_no_hold\"])\n        templatesList.extend(interface_templates_list)\n        templatesList.extend(leaf_vpc_host_templates_list)\n        templatesList.extend(interface_leaf_templates_list)\n        if not isExternalFab:\n            templatesList.extend(interface_leaf_overlay_templates_list)\n        templatesList.extend(interface_v4_underlay_templates_list)\n        templatesList.extend(interface_v6_underlay_templates_list)\n    elif migrModeStr == \"changeIP\":\n        includeCommon = False\n        # we are interested in the vrf context management and mgmt0 intf\n        templatesList.extend([\"cdp_disable_interface_11_1\", \"interface_desc\", \"v4_mgmt_default_gateway\",\n                              \"dns-vrfList\", \"interface_speed\", \"interface_ipv4_11_1\", \"interface_ipv6_11_1\"])\n    else:\n        if fabricTechnology != \"VLANFabric\":\n            templatesList.extend(common_templates_list)\n            if Util.exe(FabricWrapper.isFeatureEnabled(\"nxcloud\")):\n                fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n                ALLOW_NXC = fabricSettings.get(\"ALLOW_NXC\", \"false\")\n                if ALLOW_NXC == \"true\":\n                    templatesList.extend(nxcloud_templates_list)\n            templatesList.extend(interface_templates_list)\n            if UNDERLAY_IS_V6 == \"false\":\n                templatesList.extend(v4_underlay_templates_list)\n                templatesList.extend(interface_v4_underlay_templates_list)\n            else:\n                templatesList.extend(v6_underlay_templates_list)\n                templatesList.extend(interface_v6_underlay_templates_list)\n            templatesList.extend(spine_templates_list)\n            templatesList.extend(leaf_templates_list)\n            templatesList.extend(interface_leaf_templates_list)\n    \n            if not isSpineOrAgg:\n                # we can move more of the leaf specific policies here, but, the existing lists are not accurate\n                # will keep them as-is\n                templatesList.extend(leaf_overlay_templates_list)\n                templatesList.extend(interface_leaf_overlay_templates_list)\n    \n            templatesList.extend(getVpcTemplateList(isNotTahoe))\n        else:    \n            if Util.exe(FabricWrapper.isFeatureEnabled(\"nxcloud\")):\n                fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n                ALLOW_NXC = fabricSettings.get(\"ALLOW_NXC\", \"false\")\n                if ALLOW_NXC == \"true\":\n                    templatesList.extend(nxcloud_templates_list)\n            templatesList.extend(ECL_interface_templates_list)\n            templatesList.extend(agg_templates_list)\n            #templatesList.extend(interface_agg_templates_list)\n\n    if includeCommon:\n        # common lists\n        templatesList.extend(leaf_fex_templates_list)\n    # this must be at the end\n    templatesList.extend(interface_shut_no_shut_templates_list)\n    return templatesList\n\ndef IP2Int(ip):\n    o = map(int, ip.split('.'))\n    res = (16777216 * o[0]) + (65536 * o[1]) + (256 * o[2]) + o[3]\n    return res\n\ndef Int2IP(ipnum):\n    o1 = int(ipnum / 16777216) % 256\n    o2 = int(ipnum / 65536) % 256\n    o3 = int(ipnum / 256) % 256\n    o4 = int(ipnum) % 256\n    return '%(o1)s.%(o2)s.%(o3)s.%(o4)s' % locals()\n\n# ipAddr and prefix are strings\ndef getSubnetStringWithPrefix(ipAddr, prefix):\n    # calculate the fabric interface subnet pool\n    localIPNetInt = IP2Int(ipAddr)\n    netMaskInt = (0xFFFFFFFF << (32 - int(prefix)))\n    netInt = localIPNetInt & netMaskInt\n    netIntStr = Int2IP(netInt)\n    Wrapper.print(\"ipAddr [%s/%s] netMaskInt [%s] netInt [%s]\" % \n                        (ipAddr, prefix, Int2IP(netMaskInt), netIntStr))\n\n    return (netIntStr + \"/\" +prefix)\n\n#TODO:Move this to fabric utility to avoid duplication\ndef ipv6BitOps(a1, a2, operator=0):\n    a1 = struct.unpack('4I', a1)\n    a2 = struct.unpack('4I', a2)\n    fop = [ lambda x,y: x | y,\n            lambda x,y: x & y,\n            lambda x,y: x ^ y\n          ]  \n    ret = map(fop[operator%len(fop)], a1, a2)\n    t = ''.join(map(lambda x: struct.pack('I', x), ret))\n    return t\n    \ndef ipV6AndOps(a1, a2):\n    return ipv6BitOps(a1, a2, 1)\n\ndef getV6MaskFromPrefix(m):\n    m = int(m)\n    t = []\n    for i in xrange(0, 4):\n        t.append(max(0, 2**32  - 2**(32-min(32, m))))\n        m -= 32\n    return ''.join(map(lambda x: struct.pack('!I', x), t))\n\ndef getV6PToN(ip):\n    if not ip:\n        return \"\"\n    return socket.inet_pton(socket.AF_INET6, ip) \n\ndef getV6NToP(nb):\n    return socket.inet_ntop(socket.AF_INET6, nb) \n\ndef getV6NetworkFromCIDR(ip, prefix):\n    mask = getV6MaskFromPrefix(prefix)\n    ptonIP = getV6PToN(ip)\n    return socket.inet_ntop(socket.AF_INET6, ipV6AndOps(ptonIP, mask))\n\ndef isValidV6IpAddr(addr):\n    try:\n        socket.inet_pton(socket.AF_INET6, addr)\n        return True\n    except socket.error:\n        return False\n\n# utility API to return a list of integers from an integer range string\n# input: \"1-3,5,7,10-12\"\n# output: [1, 2, 3, 5, 7, 10, 11, 12]\ndef getIntegerRange(rangeStr):\n    return sum(((list(range(*[int(j) + k for k,j in enumerate(i.split('-'))]))\n                        if '-' in i else [int(i)]) for i in rangeStr.split(',')), [])\n\ndef getTemplateMatchResults(matchResults, templateName):\n    matchRes = matchResults.get(templateName, None)\n    #Wrapper.print(\"Template [%s] matchRes [%s]\" % (templateName, matchRes))\n    if (matchRes != None) and (len(matchRes) == 0):\n        # treat this as if the template does not exist\n        #Wrapper.print(\"Template [%s]. # of matches = [%d]\" % \n        #                        (templateName, len(matchRes)))\n        matchRes = None\n\n    return matchRes\n\ndef getIntfEntityName(nvPair, templateName):\n    entityName = None\n    # need to get the interface name\n    try:\n        entityName = nvPair[\"INTF_NAME\"]\n    except:\n        #Wrapper.print (\"Error - Could not get INTF_NAME value for template [%s]\" % templateName)\n        # check some special cases where the interface variable is not 'INTF_NAME'\n        if (templateName == \"mgmt_interface_11_1\"):\n            entityName = \"mgmt0\"\n        elif (templateName == \"vlan_interface\" or templateName == \"v6_vlan_interface\" or templateName == \"v6_vlan_interface_link_local\" or templateName == \"nve_advertise_vmac\"):\n            entityName = nvPair[\"INTF_NAME\"]\n        elif (templateName == \"fex_port_channel_interface\"):\n            entityName = \"port-channel\" + nvPair[\"PCID\"]\n        else:\n            # not sure how to handle this case\n            Wrapper.print (\"Error - Could not get INTF_NAME value\")\n    return entityName\n\ndef getEntityName(devSerial, entityType, nvPair, templateName):\n    entityName = None\n    if (entityType == \"INTERFACE\"):\n        entityName = getIntfEntityName(nvPair, templateName)\n    else:\n        # for 'SWITCH' entity type, the entity name is \"SWITCH\"\n        entityName = \"SWITCH\"\n\n    return entityName\n\ndef getEType(templateName):\n    eType = \"SWITCH\"\n    try:\n        eType = template_metadata[templateName][\"eType\"]\n    except:\n        pass\n    return eType\n\ndef getSrc(templateName):\n    src = \"UNDERLAY\"\n    try:\n        src = template_metadata[templateName][\"source\"]\n    except:\n        pass\n    return src\n\ndef getPrio(templateName):\n    prio = 500\n    try:\n        prio = template_metadata[templateName][\"prio\"]\n    except:\n        pass\n    return prio\n\n#get loopback interface string \ndef getLbIntfName(type):\n    if type == \"bgp\":\n        return \"loopback\" + BGP_LB_ID\n    elif type == \"nve\":\n        return \"loopback\" + NVE_LB_ID\n    elif type == \"anycast\":\n        return \"loopback\" + ANYCAST_LB_ID\n    elif type == \"rp\":\n        return \"loopback\" + RP_LB_ID\n    elif type == \"phantom_rp1\":\n        return \"loopback\" + PHANTOM_RP_LB_ID1\n    elif type == \"phantom_rp2\":\n        return \"loopback\" + PHANTOM_RP_LB_ID2\n\ndef createPTI(devSerial, nvPair, templateName, entityName, ptiSource, rmId, isUpdate=True):\n    funcName = sys._getframe(0).f_code.co_name  # used in below error\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    if (entityName == None):\n        # invalid name\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":createPTI\"),\n           \"Internal failure trying to create policy [%s] - entity name not provided\" % (templateName), devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n\n    entityType = getEType(templateName)\n    ptiPrio = getPrio(templateName)\n\n    # get ready to create the PTI\n    if (rmId == -1):\n        if isUpdate:\n            Util.exe(PTIWrapper.createOrUpdate(devSerial, entityType, entityName, ptiSource,\n                                       ptiPrio, templateName, nvPair))\n        else:\n            Util.exe(PTIWrapper.create(devSerial, entityType, entityName, ptiSource,\n                                       ptiPrio, templateName, nvPair))\n    else:\n        if isUpdate:\n            Util.exe(PTIWrapper.createOrUpdate(devSerial, entityType, entityName, ptiSource,\n                                       ptiPrio, rmId, templateName, nvPair))\n        else:\n            Util.exe(PTIWrapper.create(devSerial, entityType, entityName, ptiSource,\n                                       ptiPrio, rmId, templateName, nvPair))\n\n    \"\"\"\n    MsgStr = (\"[%s]. Entity/Name [%s/%s] Prio = %d NVPairs = %s\" % \n               (templateName, entityType, entityName, ptiPrio, nvPair))\n    Wrapper.print(\"PTI Created - [%s]\" % MsgStr)\n    \"\"\"\n    return respObj\n\ndef createPtis(devSerial, nvPairList, templateName, isUpdate=True):\n    for nvPair in nvPairList:\n        entityName = getEntityName(devSerial, getEType(templateName), nvPair, templateName)\n        createPTI(devSerial, nvPair, templateName, entityName, getSrc(templateName), -1, isUpdate)\n\n#a call from outside the template to create matched ptis\ndef createMatchedPtisExternal(inputParams):\n    createMatchedPtis(inputParams[\"devSerial\"],inputParams[\"matchResult\"],\n                      inputParams[\"templateName\"])\n\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    return respObj\n\ndef createMatchedPtis(devSerial, matchResult, templateName, isUpdate=True):\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        createPtis(devSerial, nvPairList, templateName, isUpdate)\n\ndef deleteAndCreateMatchedPtis(devSerial, matchResult, templateName):\n    Wrapper.print(\"deleteAndCreateMatchedPtis - devSerial [%s] templateName [%s]\" % \n                        (devSerial, templateName))\n    entityType = getEType(templateName)\n    entityName = getEntityName(devSerial, entityType, None, templateName)\n\n    # delete existing PTIs\n    PTIWrapper.delete(devSerial, entityType, entityName, getSrc(templateName), templateName)\n        \n    # create new PTIs\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        createPtis(devSerial, nvPairList, templateName, False)\n\ndef getIntfMatchMultiNvPairs(matchResult, intfName, templateList):\n    matches = {}\n\n    for templateName in templateList:\n        # get the match results for the template\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            # need to look for the nvPair that matches the intf\n            for nvPair in nvPairList:\n                interfaceName = getIntfEntityName(nvPair, templateName)\n                if ((interfaceName != None) and (interfaceName == intfName)):\n                    # this is of interest to us\n                    if templateName not in matches:\n                        matches[templateName] = []\n                    matches[templateName].append(nvPair)\n        #else:\n        #    Wrapper.print(\"getIntfMatchMultiNvPairs: No matches for [%s] on intf [%s]\" % \n        #                (templateName, intfName))\n    return matches\n\ndef getIntfMatchNvPairs(matchResult, intfName, templateList):\n    matches = {}\n\n    for templateName in templateList:\n        # get the match results for the template\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            # need to look for the nvPair that matches the intf\n            for nvPair in nvPairList:\n                interfaceName = getIntfEntityName(nvPair, templateName)\n                if ((interfaceName != None) and (interfaceName == intfName)):\n                    # we found what we are looking for\n                    matches.update({templateName : nvPair})\n                    break\n        #else:\n        #    Wrapper.print(\"getIntfMatchNvPairs: No matches for [%s] on intf [%s]\" % \n        #                (templateName, intfName))\n    return matches\n\ndef isIntfProcessed(intfMatchResult):\n    isProcessed = False\n    try:\n        isProcessed = intfMatchResult[\"isProcessed\"]\n    except:\n        pass\n    return isProcessed\n\ndef getFabErrEntity(fnName, entityName=None):\n    if entityName:\n        return fnName + \":\" + entityName\n    else:\n        return fnName\n\ndef isIpv6Addr(ip):\n    if \":\" in ip:\n        return True\n    else:\n        return False\n\ndef getVlanList(vlanRange):\n    vlanList = vlanRange.split(\",\")\n    allVlanList = []\n    for vlan in vlanList:\n        if \"-\" in vlan:\n            vRange = filter(None,vlan.split(\"-\"))\n            if len(vRange) == 2:\n                start = int(vRange[0])\n                end = int(vRange[1]) + 1 \n                for i in range(start, end):\n                    allVlanList.append(str(i))\n        else:\n            allVlanList.append(vlan)\n    return filter(None,allVlanList)\n\ndef putSwitchIntoBfMigrMode(fabricName, devSerial):\n    setMigrationState(fabricName, devSerial, {\"POST_ADD\":\"false\", \"UNDERLAY\" : \"true\", \"OVERLAY\" : \"false\"}, \"Brownfield Add\")\n\ndef putSwitchIntoChangeDiscIPAddressMigrMode(fabricName, devSerial):\n    setMigrationState(fabricName, devSerial, {\"CHANGE_DISC_IP\":\"true\"}, \"Discovery IP Address Change\")\n\ndef putSwitchIntoOverlayMigrMode(fabricName, devSerial):\n    formattedName = getFormattedSwitchName(devSerial)\n    Wrapper.print(\"=======ACTION: FAB [%s]. Put switch [%s] into overlay migration mode\" % (fabricName, formattedName))\n    ptis = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\",\"\", \"switch_migration_state\"))\n    for pti in ptis:\n        nvPairs = pti.getNvPairs()\n        if nvPairs:\n            Wrapper.print(\"putSwitchIntoOverlayMigrMode: Switch [%s] Migration [%s] NvPair = [%s]\" % \n                                    (devSerial, formattedName, nvPairs))\n            newNvPairs = copy.deepcopy(nvPairs)\n            newNvPairs[\"OVERLAY\"] = \"true\"\n            Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, \"switch_migration_state\", newNvPairs))\n        break\n\ndef takeSwitchOutOfUnderlayMigrMode(fabricName, devSerial):\n    formattedName = getFormattedSwitchName(devSerial)\n    Wrapper.print(\"=======ACTION: FAB [%s]. Take switch [%s] out of underlay migration mode\" % (fabricName, formattedName))\n    ptis = Util.getSwitchMigrationModePtis(devSerial)\n    for pti in ptis:\n        nvPairs = pti.getNvPairs()\n        # assume only underlay migration needs to be done\n        delPti = True\n        if nvPairs:\n            Wrapper.print(\"takeSwitchOutOfUnderlayMigrMode: Switch [%s] Migration [%s] NvPair = [%s]\" % \n                                    (devSerial, formattedName, nvPairs))\n            if nvPairs.get(\"OVERLAY\", \"false\") == \"true\":\n                # overlay still needs to be migrated\n                newNvPairs = copy.deepcopy(nvPairs)\n                newNvPairs[\"UNDERLAY\"] = \"false\"\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, \"switch_migration_state\", newNvPairs))\n                delPti = False\n        if delPti:\n            Util.exe(PTIWrapper.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_migration_state\"))\n        break\n\n# checks if the switch is in underlay migration mode\ndef isSwitchInUnderlayMigration(devSerial):\n    #   \"UNDERLAY\" : the value indicates the following:\n    #                   > not present or \"true\" - underlay migration not completed\n    #                   > \"false\"  - underlay migration not completed\n    retVal = False\n    policies = Util.getSwitchMigrationModePtis(devSerial)\n    if len(policies) > 0:\n        retVal = True\n        for pti in policies:\n            nvPairs = pti.getNvPairs()\n            if nvPairs:\n                Wrapper.print(\"isSwitchInUnderlayMigration: Switch [%s] Migration [%s] NvPair = [%s]\" % \n                                        (devSerial, Util.getMigrationDetailString(nvPairs), nvPairs))\n                if nvPairs.get(\"UNDERLAY\", \"true\") == \"false\":\n                    retVal = False\n                break\n    return retVal\n\n# checks if the switch is in underlay migration mode\ndef isSwitchInOverlayMigration(devSerial):\n    #   \"OVERLAY\" : - This will be ignored if POST_ADD = \"true\"\n    #                 if present, then the value indicates the following:\n    #                   > \"false\" - overlay migration completed\n    #                   > \"true\"  - overlay migration not completed\n    retVal = False\n    policies = Util.getSwitchMigrationModePtis(devSerial)\n    for pti in policies:\n        nvPairs = pti.getNvPairs()\n        if nvPairs:\n            Wrapper.print(\"isSwitchInOverlayMigration: Switch [%s] Migration [%s] NvPair = [%s]\" % \n                                    (devSerial, Util.getMigrationDetailString(nvPairs), nvPairs))\n            if nvPairs.get(\"OVERLAY\", \"false\") == \"true\":\n                retVal = True\n            break\n    return retVal\n\ndef delMigrationState(FABRIC_NAME, devSerial):\n    Wrapper.print(\"=======ACTION: FAB [%s]. Switch [%s] - Take out of migration mode\" % (FABRIC_NAME, devSerial))\n    PTIWrapper.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_migration_state\")\n\n#\n# The 'switch_migration_state' PTI has the following variables:\n#  {\n#   \"POST_ADD\" : - if present, then the value indicates the following:\n#                   > \"true\"  - greenfield add (preserveConfig = no)\n#                   > \"false\" - brownfiled add (preserveConfig = yes) - import underlay & overlay\n#                - if not present, then it is a upgrade case - import underlay only\n#   \"UNDERLAY\" : the value indicates the following:\n#                   > not present or \"true\" - underlay migration not completed\n#                   > \"false\"  - underlay migration completed\n#   \"OVERLAY\" : - This will be ignored if POST_ADD = \"true\"\n#                 if present, then the value indicates the following:\n#                   > \"false\" - overlay migration completed\n#                   > \"true\"  - overlay migration not completed\n#  }\n#\ndef setMigrationState(FABRIC_NAME, devSerial, nvPair, desc=\"\"):\n    Wrapper.print(\"=======ACTION: FAB [%s]. Switch [%s] - Move into migration mode [%s] NVPair = [%s]\" % \\\n        (FABRIC_NAME, devSerial, Util.getMigrationDetailString(nvPair), nvPair))\n    # check if PTI exists\n    ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_migration_state\"))\n    if len(ptiList) > 0:\n        # update the first instance\n        Util.exe(PTIWrapper.updateInstance(ptiList[0].getPolicyId(), nvPair))\n    else:\n        # create a new policy with the provided description string\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, \"switch_migration_state\", nvPair, desc))\n\ndef isModelN7k(topologyDataObj, sn):\n    model = topologyDataObj.getSwitchModel(sn)\n    if model.startswith(\"N7\") or \":\" in sn:\n      return True\n    else:\n      return False\n      \ndef switchCleanupWithoutReloadN7k(devSerial, dcnmUser):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    sshObj = None\n    Wrapper.print(\"%s(): Entering switch cleanup for : [%s]\" % (funcName, devSerial))\n    try:\n        sshObj = Util.exe(InventoryWrapper.getSSHConnection(devSerial, dcnmUser))\n    except Exception as e:\n        Wrapper.print(\"%s(): Failed to get SSH connection for : [%s] [%s]. Will skip\" %\n                      (funcName, devSerial, str(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":SSH\"),\n                               \"Failed to get SSH connection for switch cleanup. \"\n                               \"Please try again Recalculate & Deploy\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n    try:\n        sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n\n        Wrapper.print(\"%s(): delete older files = [%s]\" % (funcName, devSerial))\n        firstCmdOut = sshObj.send('''echo 'delete EASY-SW-RUNNING-CONFIG' | vsh''', sshConnReadTimeout)\n        firstCmd = '''echo 'delete EASY-SW-RUNNING-CONFIG' | vsh'''\n        Wrapper.print(\"%s(): [%s] Attempting to send first command [%s] response %s.\" % (funcName, devSerial, firstCmd, firstCmdOut))\n        if \"Permission denied\" in firstCmdOut:\n            errorMsg = (\"Switch [%s]: Insufficient privileges to read switch configuration. \"\n                        \"Please change the discovery user role to have network-admin privileges and \"\n                        \"retry Recalculate & Deploy.\" % devSerial)\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n        sshObj.send('''echo 'delete INTF_BRIEF_CONFIG' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): collect run = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show run > EASY-SW-RUNNING-CONFIG''', sshConnReadTimeout)\n        cmd = '''show file bootflash:EASY-SW-RUNNING-CONFIG | section '^interface mgmt0' '''\n        mgmtCmdOut = sshObj.send(cmd, sshConnReadTimeout)\n        if (len(mgmtCmdOut) == 0):\n            noSwitchDiskSpaceError(devSerial, respObj)\n            return respObj\n\n        Wrapper.print(\"%s(): collect int brief = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show int br > INTF_BRIEF_CONFIG''', sshConnReadTimeout)\n\n        # clean the switch for greenfield import with following\n        Wrapper.print(\"%s(): Cleaning config profiles = [%s]\" % (funcName, devSerial))\n        Wrapper.print(\"%s(): no apply for profiles = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc apply | sed 's/apply/no apply/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): no configure for profiles = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc 'configure profile' | sed 's/configure profile/no configure profile/g' | vsh''', sshConnReadTimeout)\n        #Wrapper.print(\"%s(): remove ppm db = [%s]\" % (funcName, devSerial))\n        #sshObj.send('''show system internal config-profile config database | ex 'config attributes:' |  awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n\n        Wrapper.print(\"%s(): cleaning fex config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"feature-set fex\" | ex \"install feature-set fex\" | grep -v allow | sort | sed 's/feature-set fex/no feature-set fex/g' | vsh''', sshConnReadTimeout)\n\n        Wrapper.print(\"%s(): cleaning system jumbo mtu config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system jumbomtu\" | sed 's/system jumbomtu/no system jumbomtu/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning access list config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"ip access-list\" | sed 's/ip access-list/no ip access-list/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning route-map config = [%s]\" % (funcName, devSerial))\n        #TODO:Needs to be enhanced to only use route-map definition rather than every line that has route-maps?\n        sshObj.send('''show run rpm | inc route-map | sort | sed 's/route-map/no route-map/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning vpc peer link port-channel config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"interface port-channel\" | sort | sed 's/interface port-channel/no interface port-channel/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning features = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc feature | ex tacacs+ | grep -v allow | sort | sed 's/feature/no feature/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning VRFs = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"vrf context \" | ex management | sed 's/vrf context/no vrf context/g' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'no nv overlay evpn' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"cfs\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"snmp-server host\" | grep traps | sed 's/snmp-server host/no snmp-server host/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning loopback = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | grep Lo | cut -c -6 | sed 's/Lo/no interface Lo/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning port channels = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG  | grep Po | ex Port-channel | ex Port | cut -c -6 | sed 's/Po/no interface Po/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning Vlans = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"vlan 1\" | sed 's/vlan/no vlan/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning all Ethernet interfaces = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | grep Eth | grep -v Ethernet | cut -d ' ' -f 1 | sed 's/Eth/default interface Eth/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Unshutting Ethernet interfaces = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | grep Eth | grep -v Ethernet | cut -d ' ' -f 1 | sed 's/Eth/interface Eth/g' | sed 's/$/ ; no shutdown/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): remove switch from maintenance mode = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system mode maintenance\" | sed 's/system mode maintenance/no system mode maintenance non-interactive/g' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning completed for [%s]\" % (funcName, devSerial))\n        maintenanceMode = True\n        for i in range(10):\n            Wrapper.print(\"%s(): Check if switch [%s] is out of maintenance mode\" % (funcName, devSerial))\n            cmd = \"show system mode | grep 'System Mode: Maintenance'\"\n            cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n            if (len(cmdOut) == 0):\n                maintenanceMode = False\n                Wrapper.print(\"%s(): switch [%s] is out of maintenance mode\" % (funcName, devSerial))\n                break\n            else:\n                Wrapper.print(\"%s(): sleeping [count %s] for 10 seconds to get the switch out of maintenance mode = [%s]\" % (funcName, (i+1), devSerial))\n                time.sleep(10)\n        if maintenanceMode == True:\n            sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system mode maintenance\" | sed 's/system mode maintenance/no system mode maintenance non-interactive/g' | vsh''', sshConnReadTimeout)\n            cmd = \"show system mode | grep 'System Mode: Maintenance'\"\n            cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n            if (len(cmdOut) != 0):\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                                   \"Please get the switch out of maintenance mode\", devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"configure maintenance profile maintenance-mode\" | sed 's/configure maintenance profile maintenance-mode/no configure maintenance profile maintenance-mode/g' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"configure maintenance profile normal-mode\" | sed 's/configure maintenance profile normal-mode/no configure maintenance profile normal-mode/g' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'delete MIN-EASY-SW-RUNNING-CONFIG' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'delete ef-minimum-config' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show run > MIN-EASY-SW-RUNNING-CONFIG''', sshConnReadTimeout)\n        #Skip the boot variable and tcam checks for N7k platforms\n\n        # clean the switch for greenfield import, keep the minimum config\n        # as the switch will go through reload\n        Wrapper.print(\"%s(): Replacing config for [%s]\" % (funcName, devSerial))\n        sshObj.send('''show run | ex fex >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep hostname >>  ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep switchname >>  ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'no password' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep username >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'ip domain-lookup' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run radius >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run tacacs+ >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run aaa >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'interface breakout module' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'snmp-server user' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run aaa >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep switch-packets >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''echo 'vlan 1' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run vrf management | begin 'vrf context' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run interface mgmt0 | b version | exclude version >> ef-minimum-config''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): minimum config replace started = [%s]\" % (funcName, devSerial))\n        sshObj.send('''echo 'configure replace bootflash:ef-minimum-config' | vsh ''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): minimum config replace completed = [%s]\" % (funcName, devSerial))\n        Wrapper.print(\"%s(): Delete temporary files completed = [%s]\" % (funcName, devSerial))\n        cmd = \"echo 'copy running-config startup-config'\"\n        cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n    except Exception as e:\n        Wrapper.print(\"%s(): Exception!!! Switch [%s] cleanup, exception[%s] \" % (funcName, devSerial, repr(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                               \"Error cleaning switch configuration. \"\n                               \"Please retry Recalculate & Deploy.\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n    finally:\n        Wrapper.print(\"%s(): Closing SSH connection %s\"%(funcName, devSerial))\n        sshObj.close()\n        sshObj = None\n        Wrapper.print(\"%s(): Exiting switch cleanup for without reload: [%s]\" % (funcName, devSerial))\n    return respObj\n\ndef switchCleanupWithoutReload(devSerial, dcnmUser):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    sshObj = None\n    Wrapper.print(\"%s(): Entering switch cleanup for : [%s]\" % (funcName, devSerial))\n    try:\n        sshObj = Util.exe(InventoryWrapper.getSSHConnection(devSerial, dcnmUser))\n    except Exception as e:\n        Wrapper.print(\"%s(): Failed to get SSH connection for : [%s] [%s]. Will skip\" %\n                      (funcName, devSerial, str(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":SSH\"),\n                               \"Failed to get SSH connection for switch cleanup. \"\n                               \"Please try again Recalculate & Deploy\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n    try:\n        sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n\n        Wrapper.print(\"%s(): delete older files = [%s]\" % (funcName, devSerial))\n        firstCmdOut = sshObj.send('''echo 'delete EASY-SW-RUNNING-CONFIG' | vsh''', sshConnReadTimeout)\n        firstCmd = '''echo 'delete EASY-SW-RUNNING-CONFIG' | vsh'''\n        Wrapper.print(\"%s(): [%s] Attempting to send first command [%s] response %s.\" % (funcName, devSerial, firstCmd, firstCmdOut))\n        if \"Permission denied\" in firstCmdOut:\n            errorMsg = (\"Switch [%s]: Insufficient privileges to read switch configuration. \"\n                        \"Please change the discovery user role to have network-admin privileges and \"\n                        \"retry Recalculate & Deploy.\" % devSerial)\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n        sshObj.send('''echo 'delete INTF_BRIEF_CONFIG' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): collect run = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show run > EASY-SW-RUNNING-CONFIG''', sshConnReadTimeout)\n        cmd = '''show file bootflash:EASY-SW-RUNNING-CONFIG | section '^interface mgmt0' '''\n        mgmtCmdOut = sshObj.send(cmd, sshConnReadTimeout)\n        if (len(mgmtCmdOut) == 0):\n            noSwitchDiskSpaceError(devSerial, respObj)\n            return respObj\n\n        Wrapper.print(\"%s(): collect int brief = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show int br > INTF_BRIEF_CONFIG''', sshConnReadTimeout)\n\n        # clean the switch for greenfield import with following\n        Wrapper.print(\"%s(): Cleaning config profiles = [%s]\" % (funcName, devSerial))\n        Wrapper.print(\"%s(): no apply for profiles = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc apply | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): no configure for profiles = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc 'configure profile' | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): remove ppm db = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show system internal config-profile config database | ex 'config attributes:' |  awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n\n        Wrapper.print(\"%s(): cleaning fex config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"feature-set fex\" | ex \"install feature-set fex\" | grep -v allow | sort | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n\n        Wrapper.print(\"%s(): cleaning system jumbo mtu config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system jumbomtu\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning access list config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"ip access-list\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning route-map config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show run rpm | inc route-map | sort | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): cleaning vpc peer link port-channel config = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"interface port-channel\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning features = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc feature | ex tacacs+ | grep -v allow | sort | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'no nv overlay evpn' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"cfs\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"snmp-server host\" | grep traps | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning loopback = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | grep Lo | cut -c -6 | awk '{print \"no interface \"$1}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning port channels = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG  | grep Po | ex Port-channel | ex Port | cut -c -6 | awk '{print \"no interface \"$1}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning infra-vlans = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"infra-vlan\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning Vlans = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"vlan 1\" | awk '{print \"no \"$0}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning access interfaces = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | inc \"access\" | grep \"Eth\" | awk '{print \"interface \" $1 \" ; shut ; no description ; no switchport  ; no shut\"}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning routed interfaces = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | inc \"routed\" | grep \"Eth\" | awk '{print \"interface \" $1 \" ; shut ; no description ; switchport ; no switchport ; no shut\"}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning trunk interfaces = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file INTF_BRIEF_CONFIG | inc \"trunk\" | grep \"Eth\" | awk '{print \"interface \" $1 \" ; shut ; no description ; no switchport  ; no mtu  ; no shut\"}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): remove switch from maintenance mode = [%s]\" % (funcName, devSerial))\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system mode maintenance\" | awk '{print \" no \"$0 \" non-interactive\"}' | vsh''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): Cleaning completed for [%s]\" % (funcName, devSerial))\n        maintenanceMode = True\n        for i in range(10):\n            Wrapper.print(\"%s(): Check if switch [%s] is out of maintenance mode\" % (funcName, devSerial))\n            cmd = \"show system mode | grep 'System Mode: Maintenance'\"\n            cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n            if (len(cmdOut) == 0):\n                maintenanceMode = False\n                Wrapper.print(\"%s(): switch [%s] is out of maintenance mode\" % (funcName, devSerial))\n                break\n            else:\n                Wrapper.print(\"%s(): sleeping [count %s] for 10 seconds to get the switch out of maintenance mode = [%s]\" % (funcName, (i+1), devSerial))\n                time.sleep(10)\n        if maintenanceMode == True:\n            sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"system mode maintenance\" | awk '{print \" no \"$0 \" non-interactive\"}' | vsh''', sshConnReadTimeout)\n            cmd = \"show system mode | grep 'System Mode: Maintenance'\"\n            cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n            if (len(cmdOut) != 0):\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                                   \"Please get the switch out of maintenance mode\", devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n\n        sshObj.send('''show file EASY-SW-RUNNING-CONFIG | inc \"configure maintenance profile maintenance-mode\" | awk '{print \" no \"$0 }' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'delete MIN-EASY-SW-RUNNING-CONFIG' | vsh''', sshConnReadTimeout)\n        sshObj.send('''echo 'delete ef-minimum-config' | vsh''', sshConnReadTimeout)\n        sshObj.send('''show run > MIN-EASY-SW-RUNNING-CONFIG''', sshConnReadTimeout)\n        cmd = \"show file MIN-EASY-SW-RUNNING-CONFIG | grep 'boot nxos'\"\n        cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n        if (len(cmdOut) == 0):\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                                   \"Boot variables are not set on the switch. \"\n                                   \"Please try again after setting bootvars\", devSerial)\n            respObj.setFailureRetCode()\n            return respObj\n        cmd = \"show file MIN-EASY-SW-RUNNING-CONFIG | grep 'hardware access-list tcam'\"\n        cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | inc \"hardware access-list tcam\" | awk '{print \" no \"$0 }' | vsh''', sshConnReadTimeout)\n        if (len(cmdOut) > 0):\n            Wrapper.print(\"%s(): Configured tcams [%s] for switch [%s]\" % (funcName, cmdOut, devSerial))\n            respObj.addWarnReport(getFabErrEntity(funcName, devSerial),\n                                   \"Had non default TCAM carving configured, which is/are removed during switch import. \"\n                                   \"Please be aware switch reload is must after any TCAM carving configuration change. \"\n                                   \"Please make sure to reload the switch from the Switches page \"\n                                   \"after Recalculate & Deploy.\", devSerial)\n            respObj.setWarningRetCode()\n\n        # clean the switch for greenfield import, keep the minimum config\n        # as the switch will go through reload\n        Wrapper.print(\"%s(): Replacing config for [%s]\" % (funcName, devSerial))\n        sshObj.send('''show run vdc | ex fex >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep redundancy-mode >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep hostname >>  ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep switchname >>  ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'no password' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep username >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'ip domain-lookup' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run radius >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run tacacs+ >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run aaa >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'interface breakout module' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'copp profile' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'snmp-server user' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run aaa >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep switch-packets >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''echo 'vlan 1' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run vrf management | begin 'vrf context' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'system routing' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'hardware profile portmode' >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show run interface mgmt0 | b version | exclude version >> ef-minimum-config''', sshConnReadTimeout)\n        sshObj.send('''show file MIN-EASY-SW-RUNNING-CONFIG | grep 'boot nxos' >> ef-minimum-config''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): minimum config replace started = [%s]\" % (funcName, devSerial))\n        sshObj.send('''echo 'configure replace bootflash:ef-minimum-config' | vsh ''', sshConnReadTimeout)\n        Wrapper.print(\"%s(): minimum config replace completed = [%s]\" % (funcName, devSerial))\n        Wrapper.print(\"%s(): Delete temporary files completed = [%s]\" % (funcName, devSerial))\n        cmd = \"echo 'copy running-config startup-config'\"\n        cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n    except Exception as e:\n        Wrapper.print(\"%s(): Exception!!! Switch [%s] cleanup, exception[%s] \" % (funcName, devSerial, repr(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                               \"Error cleaning switch configuration. \"\n                               \"Please retry Recalculate & Deploy.\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n    finally:\n        Wrapper.print(\"%s(): Closing SSH connection %s\"%(funcName, devSerial))\n        sshObj.close()\n        sshObj = None\n        Wrapper.print(\"%s(): Exiting switch cleanup for without reload: [%s]\" % (funcName, devSerial))\n    return respObj\n\ndef switchCleanupWithReload(gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = gVarDictObj.get(\"deviceSerial\")\n    fabricName = gVarDictObj[\"FABRIC_NAME\"]\n\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n\n    Wrapper.print(\"%s(): Fabric [%s] Switch [%s] - START\" % (funcName, fabricName, devSerial))\n    sshObj = None\n    try:\n        sshObj  = gVarDictObj[\"deviceSSHConnObj\"] \n        #sshObj = Util.exe(getOptSSHConnection(devSerial))\n    except Exception as e:\n        Wrapper.print(\"%s(): Failed to get SSH connection for : [%s] [%s]. Will skip\" % \n                      (funcName, devSerial, str(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":SSH\"),\n                               \"Failed to get SSH connection for switch cleanup. \"\n                               \"Please try again Recalculate & Deploy\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n\n    try:\n        sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n        shCfgFileName = 'show file EASY-SW-RUNNING-CONFIG '\n        minCfgFileName = 'ef-minimum-config'\n\n        Wrapper.print(\"%s(): check boot param = [%s]\" % (funcName, devSerial))\n        cmd = shCfgFileName + \"| grep 'boot nxos'\"\n        cmdOut = getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout)\n        if (len(cmdOut) == 0):\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                                   \"Boot variables are not set on the switch. \"\n                                   \"Please try again after setting bootvars\", devSerial)\n            respObj.setFailureRetCode()\n            return respObj\n\n        Wrapper.print(\"%s(): delete older files = [%s]\" % (funcName, devSerial))\n        getSSHCmdOuput(devSerial, sshObj, 'delete EASY_SW_INTF_BRIEF', sshConnReadTimeout)\n        getSSHCmdOuput(devSerial, sshObj, 'delete poap_replay* ', sshConnReadTimeout)\n\n        cmdOut = getSSHCmdOuput(devSerial, sshObj, '''show interface brief > EASY_SW_INTF_BRIEF''', sshConnReadTimeout)\n        if NO_DISK_SPACE_ERR_MSG in cmdOut.lower():\n            noSwitchDiskSpaceError(devSerial, respObj)\n            return respObj\n\n        # clean the switch for greenfield import, keep the minimum config\n        # as the switch will go through reload\n\n        cmdList = [\n            '''show run vdc | ex fex | ex 'system vlan' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep redundancy-mode >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'ssh key dsa' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'ip domain-lookup' >> ''' + minCfgFileName,\n            shCfgFileName + '''| section ^radius >> ''' + minCfgFileName,\n            shCfgFileName + '''| section '^ip tacacs' >> ''' + minCfgFileName,\n            shCfgFileName + '''| section ^tacacs >> ''' + minCfgFileName,\n            shCfgFileName + '''| section ^aaa >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'copp profile' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'snmp-server user' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep switch-packets >> ''' + minCfgFileName,\n            '''echo 'vlan 1' >> ''' + minCfgFileName,\n            shCfgFileName + '''| section '^vrf context management' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'system routing' >> ''' + minCfgFileName,\n            shCfgFileName + '''| section '^interface mgmt0' >> ''' + minCfgFileName,\n            shCfgFileName + '''| section '^line console' >> ''' + minCfgFileName,\n            shCfgFileName + '''| grep 'boot nxos' >> ''' + minCfgFileName,\n            '''show file EASY_SW_INTF_BRIEF | grep Eth | ex '\\.'| grep -v Ethernet | awk '{print \"interface \" $1 \" ; no shut\"}' >> ''' + minCfgFileName,\n            'copy bootflash:ef-minimum-config scheduled-config',\n            'guestshell destroy',\n            'write erase',\n        ]\n\n        Wrapper.print(\"%s(): Fabric [%s] Switch [%s] - Capturing minimum config...\" % (funcName, fabricName, devSerial))\n        for cmd in cmdList:\n            cmdOut = getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout)\n            # we may run out of disk space as we append contents.. check for the condition\n            if NO_DISK_SPACE_ERR_MSG in cmdOut.lower():\n                noSwitchDiskSpaceError(devSerial, respObj)\n                return respObj\n\n        Wrapper.print(\"%s(): Fabric [%s] Switch [%s] - Reloading Switch...\" % (funcName, fabricName, devSerial))\n        getSSHCmdOuput(devSerial, sshObj, 'reload', int(1000))\n        Wrapper.print(\"%s(): Fabric [%s] Switch [%s] - Reloading started...\" % (funcName, fabricName, devSerial))\n        t1 = datetime.datetime.now()\n        PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, \"reload\", {\"st1\":str(t1)})\n    except Exception as e:\n        Wrapper.print(\"%s: Fabric [%s] Switch [%s]. Cleaning failed! Exception [%s]\" % (funcName, fabricName, devSerial, traceback.format_exc()))\n        respObj.addErrorReport(devSerial + \"Switch Cleaning\",\n                               \"Error cleaning switch configuration. Please retry Recalculate & Deploy.\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n    finally:\n        Wrapper.print(\"%s(): Fabric [%s] Switch [%s] - END\" % (funcName, fabricName, devSerial))\n    return respObj\n\ndef setFabricSettingValue(fabricSettings, key, value):\n    Wrapper.print(\"setFabricSettingValue: [%s] -> [%s]\" % (key, value))\n    fabricSettings[key] = value\n    return True\n\ndef preUpgradeExt(dictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        global FABRIC_NAME\n\n        FABRIC_NAME = dictObj[\"FABRIC_NAME\"]\n        upgradeFromVersion = dictObj.get('UPGRADE_FROM', \"\")\n        # Note: the backend will provide UPGRADE_FROM = \"\" if the from and to versions are the same\n        isUpgrade = (upgradeFromVersion != \"\")\n\n        Wrapper.print(\"==========%s: Start - Fabric [%s] upgradeFromVersion [%s] isUpgrade [%r]\" % (funcName,\n                                                        FABRIC_NAME, upgradeFromVersion, isUpgrade))\n\n        # get the current fabric settings\n        fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n\n        Wrapper.print(\"%s: Fabric [%s] fabricSettings %s\" % (funcName, FABRIC_NAME, fabricSettings))\n\n        # set/update the fabric settings\n        isSettingChange = False\n\n        # ENABLE_EVPN was introduced in 11.2 and may not be initialized in upgrade from pre-11.2 releases\n        if \"ENABLE_EVPN\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ENABLE_EVPN\", \"true\")\n\n        if fabricSettings[\"LINK_STATE_ROUTING\"] == \"ebgp\":\n            # eBGP fabric template\n            overlayMode = \"config-profile\" if fabricSettings[\"ENABLE_EVPN\"] == \"true\" else \"cli\"\n            if ((\"OVERLAY_MODE\" not in fabricSettings) or (fabricSettings[\"OVERLAY_MODE\"] == \"\")):\n                isSettingChange = setFabricSettingValue(fabricSettings, \"OVERLAY_MODE\", overlayMode)\n            if ((\"OVERLAY_MODE_PREV\" not in fabricSettings) or (fabricSettings[\"OVERLAY_MODE_PREV\"] == \"\")):\n                isSettingChange = setFabricSettingValue(fabricSettings, \"OVERLAY_MODE_PREV\",\n                                                        fabricSettings.get(\"OVERLAY_MODE\", overlayMode))\n\n            if \"UNDERLAY_IS_V6\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"SUPER_SPINE_BGP_AS\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNDERLAY_IS_V6\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNDERLAY_IS_V6_PREV\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"USE_LINK_LOCAL\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"LOOPBACK0_IPV6_RANGE\", \"\")\n\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ROUTE_MAP_TAG\", \"12345\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"DISABLE_ROUTE_MAP_TAG\", \"false\")\n                #isSettingChange = setFabricSettingValue(fabricSettings, \"BFD_IBGP_ENABLE\", \"false\")\n                #isSettingChange = setFabricSettingValue(fabricSettings, \"BFD_AUTH_ENABLE\", \"false\")\n                #isSettingChange = setFabricSettingValue(fabricSettings, \"BFD_AUTH_KEY\", \"\")\n\n                if fabricSettings[\"BGP_AS_MODE\"] == \"Dual-AS\":\n                    isSettingChange = setFabricSettingValue(fabricSettings, \"BGP_AS_MODE\", \"Same-Tier-AS\")\n            else:\n                if \"DISABLE_ROUTE_MAP_TAG\" not in fabricSettings:\n                    if \"ROUTE_MAP_TAG\" in fabricSettings and fabricSettings[\"ROUTE_MAP_TAG\"] == \"\":\n                        isSettingChange = setFabricSettingValue(fabricSettings, \"DISABLE_ROUTE_MAP_TAG\", \"true\")\n                    else:\n                        isSettingChange = setFabricSettingValue(fabricSettings, \"DISABLE_ROUTE_MAP_TAG\", \"false\")\n\n            if \"ALLOW_LEAF_SAME_AS\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ALLOW_LEAF_SAME_AS\", \"false\")\n\n            if \"LOOPBACK1_IPV6_RANGE\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"LOOPBACK1_IPV6_RANGE\", \"\")\n        else:\n            # Easy Fabric template\n            if \"BGP_AS_PREV\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"BGP_AS_PREV\", fabricSettings[\"BGP_AS\"])\n\n            if \"OVERLAY_MODE\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"OVERLAY_MODE\", \"config-profile\")\n            if ((\"OVERLAY_MODE_PREV\" not in fabricSettings) or (fabricSettings[\"OVERLAY_MODE_PREV\"] == \"\")):\n                isSettingChange = setFabricSettingValue(fabricSettings, \"OVERLAY_MODE_PREV\",\n                                                        fabricSettings.get(\"OVERLAY_MODE\", \"config-profile\"))\n\n            if \"PM_ENABLE\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"PM_ENABLE\", \"false\")\n            if ((\"PM_ENABLE_PREV\" not in fabricSettings) or (fabricSettings[\"PM_ENABLE_PREV\"] == \"\")):\n                isSettingChange = setFabricSettingValue(fabricSettings, \"PM_ENABLE_PREV\", \n                                                        fabricSettings.get(\"PM_ENABLE\", \"false\"))\n\n            if fabricSettings[\"LINK_STATE_ROUTING\"] == \"ospf\" and fabricSettings[\"ISIS_P2P_ENABLE\"] == \"false\":\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ISIS_P2P_ENABLE\", \"\")\n\n            if \"ANYCAST_BGW_ADVERTISE_PIP\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ANYCAST_BGW_ADVERTISE_PIP\", \"false\")\n\n            if \"ISIS_OVERLOAD_ENABLE\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ISIS_OVERLOAD_ENABLE\", \"true\")\n            if \"ISIS_OVERLOAD_ELAPSE_TIME\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ISIS_OVERLOAD_ELAPSE_TIME\", \"60\")\n\n            if \"STP_ROOT_OPTION\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"STP_ROOT_OPTION\", \"unmanaged\")\n\n            if \"INBAND_MGMT\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"INBAND_MGMT\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"INBAND_MGMT_PREV\", \"false\")\n\n            if \"BOOTSTRAP_ENABLE_PREV\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"BOOTSTRAP_ENABLE_PREV\", fabricSettings[\"BOOTSTRAP_ENABLE\"])\n\n            if \"SEED_SWITCH_CORE_INTERFACES\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"SEED_SWITCH_CORE_INTERFACES\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"SPINE_SWITCH_CORE_INTERFACES\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNNUM_DHCP_START\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNNUM_DHCP_END\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNNUM_DHCP_START_INTERNAL\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"UNNUM_DHCP_END_INTERNAL\", \"\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"INBAND_DHCP_SERVERS\", \"\")\n\n            if \"EXTRA_CONF_TOR\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"EXTRA_CONF_TOR\", \"\")\n            if \"abstract_extra_config_tor\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"abstract_extra_config_tor\", \"extra_config_tor\")\n            if \"HOST_INTF_ADMIN_STATE\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"HOST_INTF_ADMIN_STATE\", \"true\")\n            if \"BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS\", \"false\")\n\n            if \"AUTO_VRFLITE_IFC_DEFAULT_VRF\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"AUTO_VRFLITE_IFC_DEFAULT_VRF\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"AUTO_SYMMETRIC_DEFAULT_VRF\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"DEFAULT_VRF_REDIS_BGP_RMAP\", \"\")\n\n            if \"VRF_LITE_AUTOCONFIG\" in fabricSettings and \\\n                (fabricSettings[\"VRF_LITE_AUTOCONFIG\"] == \"Back2BackOnly\" or fabricSettings[\"VRF_LITE_AUTOCONFIG\"] == \"ToExternalOnly\"):\n                 isSettingChange = setFabricSettingValue(fabricSettings, \"VRF_LITE_AUTOCONFIG\", \"Back2Back&ToExternal\")\n\n            if \"EXTRA_CONF_AGG\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"EXTRA_CONF_AGG\", \"\")\n            if \"EXTRA_CONF_ACCESS\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"EXTRA_CONF_ACCESS\", \"\")\n\n            # introduced in NDFC 12.1.3\n            if \"ESR_OPTION\" not in fabricSettings:\n                isSettingChange = setFabricSettingValue(fabricSettings, \"ESR_OPTION\", \"PBR\")\n            if \"SLA_ID_RANGE\" not in fabricSettings:\n                defaultRange = \"10000-19999\"\n                isSettingChange = setFabricSettingValue(fabricSettings, \"SLA_ID_RANGE\", defaultRange)\n                Util.processRespObj(respObj, RM.addOrUpdatePoolData(FABRIC_NAME, \"SLA_ID\", defaultRange))\n            if \"OBJECT_TRACKING_NUMBER_RANGE\" not in fabricSettings:\n                defaultRange = \"100-299\"\n                isSettingChange = setFabricSettingValue(fabricSettings, \"OBJECT_TRACKING_NUMBER_RANGE\", defaultRange)\n                Util.processRespObj(respObj, RM.addOrUpdatePoolData(FABRIC_NAME, \"OBJECT_TRACKING_NUMBER_POOL\", defaultRange))\n\n        # # common settings\n        if \"ENABLE_NETFLOW\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ENABLE_NETFLOW\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ENABLE_NETFLOW_PREV\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"NETFLOW_EXPORTER_LIST\", \"\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"NETFLOW_RECORD_LIST\", \"\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"NETFLOW_MONITOR_LIST\", \"\")\n\n        if \"ENABLE_PVLAN\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ENABLE_PVLAN\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ENABLE_PVLAN_PREV\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"default_pvlan_sec_network\", \"\")\n\n        if \"NXAPI_HTTPS_PORT\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"NXAPI_HTTPS_PORT\", \"443\")\n\n        if \"NXAPI_HTTP_PORT\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"NXAPI_HTTP_PORT\", \"80\")\n\n        if \"AUTO_UNIQUE_VRF_LITE_IP_PREFIX\" not in fabricSettings:\n            # added in 12.1.3\n            isSettingChange = setFabricSettingValue(fabricSettings, \"AUTO_UNIQUE_VRF_LITE_IP_PREFIX\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"AUTO_UNIQUE_VRF_LITE_IP_PREFIX_PREV\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"PER_VRF_LOOPBACK_AUTO_PROVISION\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"PER_VRF_LOOPBACK_AUTO_PROVISION_PREV\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"PER_VRF_LOOPBACK_IP_RANGE\", \"\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"BANNER\", \"\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ADVERTISE_PIP_ON_BORDER\", \"false\")\n\n        if \"ALLOW_NXC\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ALLOW_NXC\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"ALLOW_NXC_PREV\", \"false\")\n            isSettingChange = setFabricSettingValue(fabricSettings, \"OVERWRITE_GLOBAL_NXC\", \"false\")\n\n        if fabricSettings[\"abstract_trunk_host\"] == \"int_trunk_host_11_1\":\n            isSettingChange = setFabricSettingValue(fabricSettings, \"abstract_trunk_host\", \"int_trunk_host\")\n        if fabricSettings[\"abstract_routed_host\"] == \"int_routed_host_11_1\":\n            isSettingChange = setFabricSettingValue(fabricSettings, \"abstract_routed_host\", \"int_routed_host\")\n        if fabricSettings[\"temp_vpc_peer_link\"] == \"int_vpc_peer_link_po_11_1\":\n            isSettingChange = setFabricSettingValue(fabricSettings, \"temp_vpc_peer_link\", \"int_vpc_peer_link_po\")\n\n        if \"TOPDOWN_CONFIG_RM_TRACKING\" not in fabricSettings:\n            isSettingChange = setFabricSettingValue(fabricSettings, \"TOPDOWN_CONFIG_RM_TRACKING\", \"\")\n\n        settingsToDelete = None\n        if \"TE_ENABLE\" in fabricSettings:\n            # remove the TE Agent fabric settings parameters\n            settingsToDelete = [\"TE_ENABLE\", \"TE_ACCOUNT_TOKEN\", \"TE_INTERNET_VRF\", \"TE_DNS_DOMAIN\", \n                \"TE_DNS_SERVER_IP_LIST\", \"TE_NTP_SERVER_IP_LIST\", \"TE_PROXY_ENABLE\", \"TE_PROXY_IP\", \"TE_PROXY_BYPASS\"]\n            isSettingChange = True\n\n        if isUpgrade:\n            if upgradeFromVersion in [\"11.5.4\"]:\n                # clear the scheduled fabric backups in settings. Customers must reenable them\n                isSettingChange = setFabricSettingValue(fabricSettings, \"enableRealTimeBackup\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"enableScheduledBackup\", \"false\")\n                isSettingChange = setFabricSettingValue(fabricSettings, \"scheduledTime\", \"\")\n            if fabricSettings[\"LINK_STATE_ROUTING\"] != \"ebgp\" and upgradeFromVersion in [\"11.5.4\", \"12.1.1e\", \"12.1.2e\", \"12.1.2p\"]:\n                topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(FABRIC_NAME)))\n                devices = topologyDataObj.get(TopologyInfoType.SWITCHES)\n                devices = filter(None, devices)\n                if len(devices) > 0:\n                    isSettingChange = setFabricSettingValue(fabricSettings, \"UPGRADE_FROM_VERSION\", upgradeFromVersion)\n\n        if isSettingChange:\n            # we made some changes.. update the fabric settings with the new values\n            Util.processRespObj(respObj, FabricWrapper.update(FABRIC_NAME, fabricSettings, settingsToDelete))\n\n        # PTI regen for devices has been moved to Post Upgrade handling in configSave()\n        if fabricSettings.get(\"UPGRADE_FROM_VERSION\", \"\") != \"\":\n            errorMsg = (\"[%s]: Post Upgrade processing is needed. Please perform Recalculate Config \"\n                        \"after fabric is out of upgrade mode to complete upgrade from %s\" %\n                        (FABRIC_NAME, upgradeFromVersion))\n            Wrapper.print(\"%s: %s\" % (funcName, errorMsg))\n            FabricErrorLogger.error(FABRIC_NAME, Category.Fabric, ET.Fabric, FABRIC_NAME+\":Upgrade\", errorMsg, False, \"\", \"\")\n\n        if (isUpgrade and (upgradeFromVersion in [\"12.1.1e\"])):\n            # special processing for Inband POAP\n            inbandPoapEnabledFlag = isInbandPoapEnabled(fabricSettings)\n            Wrapper.print(\"%s: Inband POAP inbandPoapEnabledFlag [%r]\" % (funcName, inbandPoapEnabledFlag))\n            if (inbandPoapEnabledFlag and (fabricSettings.get(\"FABRIC_INTERFACE_TYPE\", \"p2p\") == \"unnumbered\")):\n                dictObj[\"devices\"] = devices\n                dictObj[\"fabricSettings\"] = fabricSettings\n\n                Util.processRespObj(respObj, PTI.executePyTemplateMethod(\"Easy_Fabric_Extn_11_1\", dictObj, \"handleInbandPoapUpgrade\"))\n\n    except Exception as e:\n        msg = \"Unexpected error during upgrade processing\"\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(FABRIC_NAME + \":UPGRADE\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        Wrapper.print(\"==========%s: End - Fabric [%s] Success = [%r]\" % (funcName, FABRIC_NAME, respObj.isRetCodeSuccess()))\n        respObj.setValue(respObj)\n        return respObj\n\ndef updateBpduGuardinPtis(ptiSerial, templateName):\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(ptiSerial)\n    srchOpt.setTemplateName(templateName)\n    ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    for pti in ptiList:\n        if pti.isDeleted():\n            continue\n\n        origNvPairs = pti.getNvPairs()\n        if origNvPairs.get(\"BPDUGUARD_ENABLED\", \"none\") != \"none\":\n            continue\n\n        # set the value to the expected one and update\n        nvPairs = copy.deepcopy(origNvPairs)\n        nvPairs[\"BPDUGUARD_ENABLED\"] = \"no\"\n        PTIWrapper.updateInstance(pti.getPolicyId(), nvPairs)\n\ndef setSwitchErrorReason(errDevices, errReasonStr, respObj):\n    Wrapper.print(\"setSwitchErrorReason: %s\" % errReasonStr)\n    for deviceSn in errDevices:\n        errDevices[deviceSn] = errReasonStr\n    if respObj.isRetCodeSuccess():\n        respObj.addErrorReport(\"CHANGE_DISCOVERY_IP\", errReasonStr)\n        respObj.setFailureRetCode()\n\n# returns a JSON dump of a dictionary of switches that failed\ndef doPreChangeDiscoveryIP(gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n\n    fabricName = gVarDictObj[\"FABRIC_NAME\"]\n    devices = gVarDictObj[\"serialNumbers\"]\n    isCleanup = gVarDictObj[\"isCleanup\"].lower()\n\n    fabDetails = Util.exe(FabricWrapper.get(fabricName))\n    fabSettings = fabDetails.getNvPairs()\n    fabTech = fabDetails.getFabricTechnology()\n    isFabricMonitorMode = \"true\"\n    if fabTech != \"LANMonitor\":\n        isFabricMonitorMode = gVarDictObj.get(\"IS_READ_ONLY\", \"false\")\n\n    isEasyFabInbandMgmt = fabSettings.get(\"INBAND_MGMT\", \"false\")\n    # dictionary of switch serials that failed.. we will set all to failed to begin with and remove successful ones\n    errDevices = {}\n    for deviceSn in devices:\n        errDevices[deviceSn] = \"Failed - Not processed\"\n    try:\n        Wrapper.print(\"%s : FAB [%s] Template [%s] fabTech [%s] isFabricMonitorMode [%s] isCleanup [%s] devices %s\" % (funcName,\n            fabricName, fabDetails.getTemplateName(), fabTech, isFabricMonitorMode, isCleanup, devices))\n\n        topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(fabricName)))\n        # check to make sure all are Nexus switches\n        for deviceSn in devices:\n            # # support for Cat9K and NXOS\n            devModel = topologyDataObj.getSwitchModel(deviceSn)\n            isNXOS  = Util.isNXOSDevice(deviceSn, devModel)\n\n            # check if the 'import_type' PTI is associated with the switch\n            # Note: will be available for switches in External/LAN_Classic fabric to indicate inband/OOB import\n            # if not present, assume OOB since that is the default\n            importTypePtis = Util.exe(PTIWrapper.get(deviceSn, \"SWITCH\", \"SWITCH\", \"\", \"import_type\"))\n            if len(importTypePtis) > 0:\n                devImpType = importTypePtis[0].getNvPairs()[\"TYPE\"]\n            else:\n                if isEasyFabInbandMgmt == \"true\":\n                    devImpType = \"inband\"\n                else:\n                    # OOB case - N9K (mgmt0) and Cat9K (g0/0) get covered here\n                    devImpType = \"mgmt\"\n\n            migrateMode, migrateModeDetail = Util.getSwitchMigrationModeStr(deviceSn)\n\n            Wrapper.print(\"%s: Switch [%s] devModel [%s] isNXOS [%r] devImpType [%s] migrateMode [%s] \"\n                \"migrateModeDetail [%s]\" % (funcName, deviceSn, devModel, isNXOS, devImpType, migrateMode, migrateModeDetail))\n            \n            if not isNXOS:\n                if fabTech != \"IOS-XE_VXLANFabric\":\n                    errDevices[deviceSn] = \"Cannot change Discovery IP for non Nexus switch.\"\n                    if respObj.isRetCodeSuccess():\n                        respObj.addErrorReport(getFabErrEntity(funcName), \"Failed to change discovery IP\")\n                        respObj.setFailureRetCode()\n                    continue\n\n            if devImpType != \"mgmt\":\n                if fabTech != \"VXLANFabric\":\n                    errDevices[deviceSn] = \"Cannot change discovery IP for switch imported via inband interface\"\n                    if respObj.isRetCodeSuccess():\n                        respObj.addErrorReport(getFabErrEntity(funcName), \"Failed to change discovery IP\")\n                        respObj.setFailureRetCode()\n                    continue\n\n            if migrateMode is None:\n                if isCleanup == \"false\":\n                    if isFabricMonitorMode == \"false\":\n                        putSwitchIntoChangeDiscIPAddressMigrMode(fabricName, deviceSn)\n                        # update switch config status for migration mode\n                        Util.exe(FabricWrapper.updateSwitchCfgStateForMigrationMode(deviceSn))\n\n                del errDevices[deviceSn]\n            elif (migrateMode != \"changeIP\"):\n                if isCleanup == \"false\":\n                    # report error if not in changeIP mode\n                    errDevices[deviceSn] = \"Already in migration mode. Cannot change the Discovery IP address\"\n                    if respObj.isRetCodeSuccess():\n                        respObj.addErrorReport(getFabErrEntity(funcName), \"Failed to change discovery IP\")\n                        respObj.setFailureRetCode()\n                else:\n                    # switch not in change IP migration mode.. we do not care\n                    del errDevices[deviceSn]\n            else:\n                # switch is in change ip migration mode\n                if isCleanup == \"true\":\n                    if isFabricMonitorMode == \"false\":\n                        delMigrationState(fabricName, deviceSn)\n                del errDevices[deviceSn]\n    except Exception as e:\n        Wrapper.print(\"%s: Unexpected Exception. %s\" % (funcName, traceback.format_exc()))\n        if isinstance(e, respObjError):\n            msg = (\"Unexpected error during change discovery IP handling\")\n            respObj.addErrorReport(getFabErrEntity(funcName), msg)\n            respObj.setFailureRetCode()\n            Util.processRespObj(respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        jsonStr = json.dumps(errDevices)\n        respObj.setValue(jsonStr)\n        Wrapper.print(\"FAB [%s] Finish [%s] Success = [%r] errDevices %s\" % (fabricName, funcName, respObj.isRetCodeSuccess(), jsonStr))\n        return respObj\n\ndef preAddExt(gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        devSerial = gVarDictObj[\"deviceSerial\"]\n        devModel = gVarDictObj[\"deviceModel\"]\n        fabricName = gVarDictObj[\"FABRIC_NAME\"]\n        isPreserveConfigSet = gVarDictObj[\"devicePreserveConfig\"]\n        Wrapper.print(\"==========preAddExt: Fabric = %s, Serial [%s], Model [%s], Preserve = %s\" %\n                      (fabricName, devSerial, devModel, isPreserveConfigSet))\n\n        modelCheckPass = True\n        if \"FF\" in gVarDictObj and gVarDictObj[\"FF\"] == \"Easy_Fabric_Classic\":\n            #Allow N7k and N9k devices for Enhanced Classic LAN fabrics\n            if (not devModel.startswith(\"N9K-\")) and (not devModel.startswith(\"N7\")):\n                modelCheckPass = False\n        else:\n            # Allow N9K/N3K devices for Easy fabric\n            if (not devModel.startswith(\"N9K-\")) and (not devModel.startswith(\"N3K-\")):\n                modelCheckPass = False\n                \n        if not modelCheckPass:\n            respObj.addErrorReport(getFabErrEntity(preAddExt.__name__, devSerial),\n                                   \"This fabric does not support model %s.\" % devModel)\n            respObj.setFailureRetCode()\n            return respObj\n\n        #Allow N7k devices for Enhanced Classic LAN fabrics\n        if devModel.startswith(\"N7\"):\n            fabDetails = Util.exe(FabricWrapper.get(fabricName))\n            fabTech = fabDetails.getFabricTechnology()\n            if fabTech == \"VLANFabric\":\n                sshObj = gVarDictObj.get(\"deviceSSHConnObj\")\n                Wrapper.print(\"==========preAddExt: Fabric = %s, Serial [%s], Model [%s], Preserve = [%s], sshObj [%s]\" %\n                                (fabricName, devSerial, devModel, isPreserveConfigSet, sshObj))\n                if \":\" not in devSerial and sshObj:\n                    isAdminVdc = adminVdcCheck(gVarDictObj[\"deviceSSHConnObj\"], devSerial, respObj)\n                    if isAdminVdc:\n                        respObj.addErrorReport(getFabErrEntity(preAddExt.__name__, devSerial),\n                                                \"This fabric doesn't support Nexus 7000 Admin VDC.\")\n                        respObj.setFailureRetCode()\n                        return respObj\n\n                if sshObj:\n                    isFabricPath = getSwitchFPFeatureState(gVarDictObj[\"deviceSSHConnObj\"], devSerial, respObj)\n                    if isFabricPath:\n                        respObj.addErrorReport(getFabErrEntity(preAddExt.__name__, devSerial),\n                                               \"This fabric doesn't support switch with feature-set fabricpath installed in it.\")\n                        respObj.setFailureRetCode()\n                        return respObj\n \n        # check a few things before allowing adding\n        doAddSwitchEntryCheck(gVarDictObj, respObj)\n\n        Wrapper.print(\"Done with preAddExt\")\n        respObj.setValue(respObj)\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef getSwitchCmdOutput(sshObj, devSerial, cmdStr, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n    cmdOut = None\n    try:\n        Wrapper.print(\"%s: [%s] Getting output of cmd [%s]\" % (funcName, devSerial, cmdStr))\n        cmdOut = sshObj.send(cmdStr, sshConnReadTimeout);\n        tmpCmdOut = cmdOut\n        if cmdOut and len(cmdOut) > 80:\n            tmpCmdOut = cmdOut[:80]\n        Wrapper.print(\"%s(): [%s] Attempting to send first command [%s] response %s.\" % (funcName, devSerial, cmdStr, tmpCmdOut))\n        if \"Permission denied\" in cmdOut:\n            errorMsg = (\"Switch [%s]: Insufficient privileges to read switch configuration. \"\n                        \"Please change the discovery user role to have network-admin privileges and \"\n                        \"retry Recalculate & Deploy.\" % devSerial)\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n    except:\n        e = sys.exc_info()[0]\n        Wrapper.print(\"%s: Unexpected error executing CLI [%s] on switch . Exception = [%s]\" % (funcName, cmdStr, traceback.format_exc()))\n        respObj.addErrorReport(funcName,\n            \"Unexpected error executing CLI [%s] on switch. Please check and retry\" % (cmdStr), devSerial)\n        respObj.setFailureRetCode()\n    return cmdOut\n\ndef getSwitchCmdJsonOutput(sshObj, devSerial, cmdStr, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    cmdOut = getSwitchCmdOutput(sshObj, devSerial, cmdStr, respObj)\n    cmdJson = \"\"\n    if cmdOut == None:\n        return cmdJson\n    if ((len(cmdOut) >= 2) and (not cmdOut.startswith(\"Syntax error while parsing\"))):\n        try:\n            # convert to JSON object\n            cmdJson = json.loads(cmdOut)\n            #Wrapper.print(\"%s: JSON obj [%s]\" % (funcName, cmdJson))\n        except:\n            # some invalid JSON syntax\n            e = sys.exc_info()[0]\n            Wrapper.print(\"%s: Unexpected error converting to JSON format . Exception = [%s]\" % (funcName, traceback.format_exc()))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                \"Unexpected JSON content executing CLI [%s] on switch. Received output [%s]. Please check and retry\" % (cmdStr, \n                                        cmdOut), devSerial)\n            respObj.setFailureRetCode()\n            return cmdJson\n    else:\n        if (cmdOut.strip() != \"\"):\n            # we got an unexpected output\n            Wrapper.print(\"%s: Unexpected RAW switch output [%s]\" % (funcName, cmdOut))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                \"Unexpected error executing CLI [%s] on switch. Received output [%s]. Please check and retry\" % (cmdStr, \n                                        cmdOut), devSerial)\n            respObj.setFailureRetCode()\n    return cmdJson\n\ndef processVpcRow(vpcRow, vpcEntries):\n    if type(vpcRow) == list:\n        Wrapper.print(\"processVpcRow: ROW is a list. len = [%d]\" % len(vpcRow))\n        for vpcEntry in vpcRow:\n            #Wrapper.print(\"processVpcRow: adding vpc entry [%s]\" % vpcEntry)\n            vpcEntries.append(vpcEntry)\n    else:\n        vpcEntries.append(vpcRow)\n\n\ndef adminVdcCheck(sshObj, devSerial, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    isAdminVdc = False\n    cmdJson = getSwitchCmdJsonOutput(sshObj, devSerial, \"show vdc detail | json\", respObj)\n    if cmdJson == \"\":\n        Wrapper.print(\"%s: Switch [%s] did not report any feature status\" % (funcName, devSerial))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                               \"Could not get vdc details for the switch. Please resolve and retry\", devSerial)\n        respObj.setFailureRetCode()\n        return isAdminVdc\n    try:\n        vdcDict = cmdJson[\"TABLE_vdc\"][\"ROW_vdc\"]\n        if vdcDict:\n            if isinstance(vdcDict,list):\n                for item in vdcDict:\n                    Wrapper.print(\"%s: Switch [%s] vdcId [%s] vtype = [%s]\" % (funcName, devSerial, item[\"vdc_id\"], item[\"vtype\"].lower()))\n                    if item[\"vdc_id\"] == 1 and item[\"vtype\"].lower() == \"admin\":\n                        isAdminVdc = True\n                        break\n            elif isinstance(vdcDict,dict):\n                Wrapper.print(\"%s: Switch [%s] vdcId [%s] vtype = [%s]\" % (funcName, devSerial, vdcDict[\"vdc_id\"], vdcDict[\"vtype\"].lower()))\n                if vdcDict[\"vdc_id\"] == 1 and vdcDict[\"vtype\"].lower() == \"admin\":\n                    isAdminVdc = True\n            else:\n                Wrapper.print(\"%s: Switch [%s] dict [%s]\" % (funcName, devSerial, vdcDict))\n    except:\n        pass\n    return isAdminVdc\n\n\ndef getSwitchFPFeatureState(sshObj, devSerial, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    isFabricPathEn = False\n    cmdStr = \"show feature-set fabricpath\"\n    cmdOut = getSwitchCmdOutput(sshObj, devSerial, cmdStr, respObj)\n    Wrapper.print(\"%s: Switch [%s] cmdOut [%s]\" % (funcName, devSerial, cmdOut))\n    if (cmdOut != \"\" and \"fabricpath\" in cmdOut.lower() and ((\"installed\" in cmdOut.lower() and \"uninstalled\" not in cmdOut.lower()) or \"enabled\" in cmdOut.lower())):\n        isFabricPathEn = True \n    return isFabricPathEn\n\n\ndef getSwitchVpcFeatureState(sshObj, devSerial, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    isVpc = False\n    cmdJson = getSwitchCmdJsonOutput(sshObj, devSerial, \"show feature | json\", respObj)\n    if cmdJson == \"\":\n        Wrapper.print(\"%s: Switch [%s] did not report any feature status\" % (funcName, devSerial))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n            \"Could not get vPC feature status. Please resolve and retry\", devSerial)\n        respObj.setFailureRetCode()\n        return isVpc\n\n    try:\n        for featureEntry in cmdJson[\"TABLE_cfcFeatureCtrlTable\"][\"ROW_cfcFeatureCtrlTable\"]:\n            if featureEntry[\"cfcFeatureCtrlName2\"].lower() != \"vpc\":\n                continue\n\n            Wrapper.print(\"%s: switch [%s] feature vpc state = [%s]\" % (funcName, devSerial, featureEntry[\"cfcFeatureCtrlOpStatus2\"]))\n            if featureEntry[\"cfcFeatureCtrlOpStatus2\"].lower() == \"enabled\":\n                isVpc = True\n            break\n    except:\n        cmdStr = \"show feature | grep vpc\"\n        cmdOut = getSwitchCmdOutput(sshObj, devSerial, cmdStr, respObj)\n        if cmdOut != \"\" and \"vpc\" in cmdOut.lower() and \"enabled\" in cmdOut.lower():\n            isVpc = True \n    return isVpc\n\ndef getParentFabricName(fabricName, respObj):\n    parentFab = None\n    resp = FabricWrapper.getParentFabricName(fabricName)\n    if resp.isRetCodeSuccess():\n        # it is indeed a member fabric.. get MSD name\n        parentFab = resp.getValue()\n    return parentFab\n\n# invoked from MSD_Fabric fabric template\n# Called during add member fabric to MSD\n# The input dictionary object 'dict', must have the following data:\n#   \"MSD_FABRIC_NAME\" - name of the MSD Fabric\n#   \"FABRIC_NAME\"   - name of the fabric being added as a member\n#\n#   - Do not allow the add if member fabric's routing or nve loopback id is the same as multisite loopback id\n#   - Do not allow the add if there are one or more BF switches already in the fabric pending migration\ndef addFabricAsMemberEntryCheck(dict):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n\n    fabName = dict[\"FABRIC_NAME\"]\n    msdFabName = dict[\"MSD_FABRIC_NAME\"]\n\n    fabricSettings = Util.exe(FabricWrapper.get(fabName)).getNvPairs()\n    msdFabricSettings = Util.exe(FabricWrapper.get(msdFabName)).getNvPairs()\n    bgpLoopbackId = fabricSettings.get(\"BGP_LB_ID\", \"\")\n    nveLoopbackId = fabricSettings.get(\"NVE_LB_ID\", \"\")\n    msLoopbackId = msdFabricSettings.get(\"MS_LOOPBACK_ID\", \"\")\n\n    if msLoopbackId == bgpLoopbackId or msLoopbackId == nveLoopbackId:\n        errorMsg = (\"Cannot add fabric [%s] to the MSD [%s] since '%s Loopback Id' in [%s] is the same as\"\n             \" 'Multi-Site VTEP VIP Loopback Id' %s in [%s]\"\n             % (fabName, msdFabName, \"Routing\" if msLoopbackId==bgpLoopbackId else \"NVE\", fabName, msLoopbackId, msdFabName))\n        respObj.addErrorReport(funcName, errorMsg)\n        respObj.setFailureRetCode()\n        return respObj\n\n    if msdFabricSettings[\"ENABLE_PVLAN\"] == \"false\":\n        # error if new member has ENABLE_PVLAN true\n        if \"ENABLE_PVLAN\" in fabricSettings and fabricSettings[\"ENABLE_PVLAN\"] == \"true\":\n            errorMsg = (\"Cannot add fabric [%s] to the MSD [%s] since 'Private VLAN' is enabled in [%s] while not enabled in %s\"\n                % (fabName, msdFabName, fabName, msdFabName))\n            Wrapper.print(\"%s: %s\" % (funcName, errorMsg))\n            respObj.addErrorReport(funcName, errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n    topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(fabName)))\n    devices = topologyDataObj.get(TopologyInfoType.SWITCHES)\n    devices = filter(None, devices)\n\n    bgw_present = False\n    for deviceSn in devices:\n        migrateMode, migrateModeDetail = Util.getSwitchMigrationModeStr(deviceSn)\n        if migrateMode and (migrateMode == \"brownAdd\"):\n            Wrapper.print(\"%s: %s - Switch [%s] is in BF migration mode\" % (funcName, fabName, deviceSn))\n            # this switch is in migration mode... fail the add of the GF switch\n            errorMsg = (\"Cannot add fabric [%s] to the MSD [%s] since there are some Brownfield switch(es) \"\n                \"pending migration. Please complete the migration and retry.\" % (fabName, msdFabName))\n            respObj.addErrorReport(funcName, errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n        if not bgw_present:\n            switchRole = topologyDataObj.get(TopologyInfoType.GET_SWITCH_ROLE, deviceSn)\n            if \"gateway\" in switchRole:\n                bgw_present = True\n\n    if not bgw_present:\n        fabricType = Util.exe(Helper.getFabricType(fabName))\n        if fabricType == \"Switch_Fabric\":\n            warningMsg = \"Fabric %s does not have any devices with 'border gateway' role. Please go to %s and assign gateway(s) followed by 'Recalculate & Deploy' in %s\" % (fabName, fabName, fabName)\n            Wrapper.print(\"%s: %s\" % (funcName, warningMsg))\n            respObj.setWarningRetCode()\n            respObj.addWarnReport(funcName, warningMsg)\n\n    return respObj\n\n# invoked from Easy_Fabric fabric template\n# Called during add/bootstrap switch into the fabric\n# The input dictionary object 'dict', must have the following data:\n#   \"FABRIC_NAME\"   - name of the fabric\n#   \"devicePreserveConfig\" - \"true\" for BF, \"false\" for GF\n#   \"deviceSerial\"  - serial # of switch being added. If 'devicePreserveConfig' is \"false\", then this\n#                     is optional.\n# GF switch:\n#   - Do not allow the add if there are one or more BF switches already in the fabric pending migration\n# \n# BF switch:\n#   - Do not allow the add under the following conditions:\n#       > current fabric is a member of a MSD\n#       > there is atleast one switch that is not in BF migration mode, i.e, migration has been initiated/completed\n#       > vpc switch that has some inconsistencies\n#\ndef addSwitchEntryCheck(dict):\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    \n    doAddSwitchEntryCheck(dict, respObj)\n    return respObj\n\ndef checkSwitchDiscoveryIntf(devSerial, isPreserveConfigSet, dict, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    # discovery must be over mgmt0 for OOB and BGP loopback intf for inband\n    # check to make sure the discovery IP matches the expected interface\n    # Note: we cannot detect the condition where the discovery IP address on a non mgmt vrf (inband)\n    # is the same as the discovery IP address\n    discoveryIP = dict[\"deviceIPv4\"]\n    sshObj = dict[\"deviceSSHConnObj\"]\n    isV6 = isIpv6Addr(discoveryIP)\n    inbandMgmtFlag = True if (dict.get(\"INBAND_MGMT\", \"false\") == \"true\") else False\n\n    Wrapper.print(\"%s: Switch [%s] discoveryIP [%s] Inband [%r] isV6 [%r]\" % (funcName, devSerial, discoveryIP, inbandMgmtFlag, isV6))\n\n    if isV6:\n        normalizedDiscoveryIP =  Util.exe(FabricWrapper.getNormalizedIPv6(discoveryIP))\n        Wrapper.print(\"%s: After normalization: Switch [%s] normalizedDiscoveryIP [%s]\" %\n                      (funcName, devSerial, normalizedDiscoveryIP))\n        normalizedIpToCheck = normalizedDiscoveryIP + \"/\"\n\n    if inbandMgmtFlag:\n        discoveryIntfName = (\"loopback%s\" % (dict[\"BGP_LB_ID\"]))\n    else:\n        discoveryIntfName = \"mgmt0\"\n    newRespObj = WrappersResp.getRespObj()\n    newRespObj.setSuccessRetCode()\n    cmd = (\"sh running interface %s | section '^interface %s'\" % (discoveryIntfName, discoveryIntfName))\n    cmdOut= getSwitchCmdOutput(sshObj, devSerial, cmd, newRespObj)\n    Wrapper.print(\"%s: Switch [%s] cmd [%s] cmdOut [%s]\" % (funcName, devSerial, cmd, cmdOut))\n    if not newRespObj.isRetCodeSuccess():\n        Util.processRespObj(respObj, newRespObj)\n        return respObj\n\n    ipToCheck = discoveryIP + \"/\"\n    isError = False\n    ipv4AddrList = []\n    ipv6AddrList = []\n    for line in cmdOut.splitlines():\n        stripLine = line.strip()\n        if stripLine.startswith(\"ip address \"):\n            ipv4AddrList.append(stripLine.split()[2])\n        elif stripLine.startswith(\"ipv6 address \"):\n            ipv6AddrList.append(stripLine.split()[2])\n        elif stripLine.startswith(\"shutdown\"):\n            # intf is shutdown, so obvisouly discovery is over some other interface\n            isError = True\n            break\n\n    errMsg = (\"Must be discovered over interface [%s] and discovery IP address [%s] must \"\n                    \"match configuration.\" % (discoveryIntfName, discoveryIP))\n    if not isError:\n        # check further\n        matchFound = False\n        if not isError:\n            if isV6:\n                for ipv6Addr in ipv6AddrList:\n                    if ipv6Addr.startswith(ipToCheck):\n                        matchFound = True\n                    elif ipv6Addr.startswith(normalizedIpToCheck):\n                        matchFound = True\n            else:\n                for ipv4Addr in ipv4AddrList:\n                    if ipv4Addr.startswith(ipToCheck):\n                        matchFound = True\n      \n        if not matchFound:\n            #If no ip addresses match seed IP then its an error case\n            isError = True\n        else:\n            # do not allow v6 inband mgmt\n            if isV6 and inbandMgmtFlag:\n                isError = True\n                errMsg = \"Only IPv4 Inband Management is supported.\"\n\n    if isError:\n        respObj.addErrorReport(funcName, errMsg, devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n\ndef doAddSwitchEntryCheck(dict, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    fabName = dict[\"FABRIC_NAME\"]\n    devSerial = dict.get(\"deviceSerial\", None) # this will be None for bootstrap case\n    isPreserveConfigSet = dict[\"devicePreserveConfig\"]\n\n    if ((isPreserveConfigSet == True) and (devSerial is not None)):\n        checkSwitchDiscoveryIntf(devSerial, isPreserveConfigSet, dict, respObj)\n        if respObj.isRetCodeFailure():\n            return respObj\n\n    topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(fabName)))\n    devices = topologyDataObj.get(TopologyInfoType.SWITCHES)\n    devices = filter(None, devices)\n\n    if isPreserveConfigSet == False:\n        # do not allow GF switch if inband mgmt is enabled\n        if (dict.get(\"INBAND_MGMT\", \"false\") == \"true\") and (devSerial is not None):\n            errorMsg = (\"Cannot add the Greenfield switch(es) to the fabric with Inband Management enabled. Please check and retry.\")\n            respObj.addErrorReport(funcName, errorMsg, devSerial)\n            respObj.setFailureRetCode()\n            return\n\n        # do not allow a GF switch if there are any switches in BF migration mode\n        for deviceSn in devices:\n            migrateMode, migrateModeDetail = Util.getSwitchMigrationModeStr(deviceSn)\n            if migrateMode and (migrateMode == \"brownAdd\"):\n                Wrapper.print(\"%s: %s - Switch [%s] is in BF migration mode\" % (funcName, fabName, deviceSn))\n                # this switch is in migration mode... fail the add of the GF switch\n                errorMsg = (\"Cannot add the Greenfield switch(es) to the fabric since there are some \"\n                           \"Brownfield switches pending migration. Please complete the migration and retry.\")\n                if devSerial:\n                    respObj.addErrorReport(funcName, errorMsg, devSerial)\n                else:\n                    respObj.addErrorReport(funcName, errorMsg)\n                respObj.setFailureRetCode()\n                break\n        return\n\n    # Brownfield checks\n    # do not allow BF switches under the following conditions:\n    #   1. fabric is a member of a MSD\n    #   2. atleast one switch in the fabric is not in the migration mode\n    if devSerial == None:\n        errorMsg = \"Internal Error: The Brownfield switch serial # must be provided.\"\n        respObj.addErrorReport(funcName, errorMsg)\n        return respObj\n\n    # condition #1\n    parentFab = getParentFabricName(fabName, respObj)\n    if parentFab:\n        # it is indeed a member fabric.. report error\n        respObj.addErrorReport(funcName, \"Adding Brownfield switch [%s] to a member fabric is not allowed. \"\n            \"Fabric is a member of MSD [%s]. \" % (devSerial, parentFab))\n        respObj.setFailureRetCode()\n        return respObj\n\n    # condition #2\n    for deviceSn in devices:\n        migrateMode, migrateModeDetail = Util.getSwitchMigrationModeStr(deviceSn)\n        if migrateMode != \"brownAdd\":\n            Wrapper.print(\"%s: %s - Switch [%s] is not in migration mode\" % (funcName, fabName, deviceSn))\n            # this switch is not in migration mode... fail the add of the BF switch\n            errorMsg = (\"Adding a switch [%s] with Preserve-Config=Yes is not supported in a fabric with existing switches. \"\n                        \"Please re-add the switch with Preserve-Config=No.\" % devSerial)\n            respObj.addErrorReport(funcName, errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n    # open connection to switch and check if vPC, if yes, then make sure there are no inconsistencies\n    isVpc = getSwitchVpcFeatureState(dict[\"deviceSSHConnObj\"], devSerial, respObj)\n    if not respObj.isRetCodeSuccess():\n        return\n\n    if not isVpc:\n        return\n    cmdJson = getSwitchCmdJsonOutput(dict[\"deviceSSHConnObj\"], devSerial, \"show vpc | json\", respObj)\n    if cmdJson != \"\":\n        # check to make sure there are no inconsistencies\n        reasonStr = None\n        reportedStr = None\n        \"\"\"\n        if (cmdJson.get(\"virtual-peerlink\") == \"Enabled\"):\n            Wrapper.print(\"%s: [%s] Virtual vPC feature is not supported\"%(funcName, devSerial))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                                   \"Switch [%s]: Virtual vPC feature is not supported with preserved config yes option\" % (devSerial))\n            respObj.setFailureRetCode()\n            return\n        \"\"\"\n        if (cmdJson[\"vpc-peer-status\"] != \"peer-ok\"):\n            reasonStr = \"vPC Peer is not OK\"\n            reportedStr = cmdJson[\"vpc-peer-status\"]\n        elif (cmdJson[\"vpc-peer-keepalive-status\"] != \"peer-alive\"):\n            reasonStr = \"vPC Peer Keep-Alive error\"\n            reportedStr = cmdJson[\"vpc-peer-keepalive-status\"]\n        elif (cmdJson[\"vpc-per-vlan-peer-consistency\"] != \"consistent\"):\n            reasonStr = \"vPC Per VLAN Inconsistency\"\n            reportedStr = cmdJson[\"vpc-per-vlan-peer-consistency\"]\n\n        if reasonStr:\n            Wrapper.print(\"%s: Inconsistent vPC state Reason: [%s]. Reported state [%s]\" % (funcName, reasonStr, reportedStr))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                \"Inconsistent vPC state [%s]. Please resolve the inconsistencies and retry\" % (reasonStr), devSerial)\n            respObj.setFailureRetCode()\n            return\n\n        # now look through all the vpc interface inconsistencies\n        if \"TABLE_vpc\" in cmdJson:\n            reasonStr = \"\"\n            Wrapper.print(\"%s: Number of VPCs : [%s]\" % (funcName, cmdJson[\"num-of-vpcs\"]))\n            vpcEntries = []\n            # 1. list of dictionaries of 'ROW_vpc' if there are > 50 vpcs (this case needs to be handled)\n            #           \"TABLE_vpc\": [\n            #              {\n            #               \"ROW_vpc\": [\n            #                   {}\n            #                ]\n            #              }\n            #             ]\n            # 2. a dictionary of 'ROW_vpc' if are less than 50 vpcs\n            #           \"TABLE_vpc\": {\n            #               \"ROW_vpc\": [\n            #                   {}\n            #                ]\n            # 3. an entry with the vpc details is there is exactly one vpc\n            #           \"TABLE_vpc\": {\n            #               \"ROW_vpc\":\n            #                   {}\n            #            }\n            if type(cmdJson[\"TABLE_vpc\"]) == list:\n                Wrapper.print(\"%s: vPC table is list. len = %d\" % (funcName, len(cmdJson[\"TABLE_vpc\"])))\n                for vpcRow in cmdJson[\"TABLE_vpc\"]:\n                    processVpcRow(vpcRow[\"ROW_vpc\"], vpcEntries)\n            else:\n                processVpcRow(cmdJson[\"TABLE_vpc\"][\"ROW_vpc\"], vpcEntries)\n\n            Wrapper.print(\"%s: # of vPC entries = %d\" % (funcName, len(vpcEntries)))\n            for vpcIntfEntry in vpcEntries:\n                # {\n                #     \"vpc-id\": \"101\",\n                #     \"vpc-ifindex\": \"Po101\",\n                #     \"vpc-port-state\": \"0\",\n                #     \"phy-port-if-removed\": \"disabled\",\n                #     \"vpc-thru-peerlink\": \"1\",\n                #     \"vpc-consistency\": \"inconsistent\",\n                #     \"vpc-consistency-status\": \"SYSERR_MCECM_PEER_NOT_CFG\",\n                #     \"up-vlan-bitset\": \"-\",\n                #     \"es-attr\": \"DF: Invalid\"\n                # }\n                if vpcIntfEntry[\"vpc-consistency\"].lower() == \"inconsistent\":\n                    Wrapper.print(\"%s: inconsistent vpc intf entry: [%s]\" % (funcName, vpcIntfEntry))\n                    reasonStr += (Util.newLine() + (\"vPC [%s] Interface [%s] is in error/inconsistent state.\" % (vpcIntfEntry[\"vpc-id\"], vpcIntfEntry[\"vpc-ifindex\"])))\n\n            if reasonStr != \"\":\n                Wrapper.print(\"%s: Inconsistent vPC interface state. Reason: [%s]\" % (funcName, reasonStr))\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial),\n                    \"Inconsistent vPC interfaces. Please resolve the inconsistencies and retry. Reason [%s]\" % (reasonStr), devSerial)\n                respObj.setFailureRetCode()\n                return\n\ndef getOptSSHConnection(fabricName, devSerial, dcnmUser):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        fabricSettings = Util.exe(FabricWrapper.get(fabricName)).getNvPairs()\n        if fabricSettings.get(\"AAA_REMOTE_IP_ENABLED\") == \"false\":\n            sshObj = Util.exe(InventoryWrapper.getSSHConnection(devSerial, dcnmUser))\n        else:\n            sshObj = Util.exe(InventoryWrapper.getVSHConnection(devSerial, dcnmUser))\n        respObj.setValue(sshObj)\n        return respObj\n    except Exception as e:\n        Wrapper.print(\"%s(): Failed to get SSH connection for : [%s] [%s]. Will skip\" % \n                      (funcName, devSerial, str(e)))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":SSH\"),\n                               \"Failed to get SSH connection. \"\n                               \"Please ensure LAN credentials and retry Recalculate & Deploy\", devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n\ndef isTCAMAllocationEnable(sn, fabricSettings):\n    tcamAllocEn = fabricSettings.get(\"TCAM_ALLOCATION\", \"true\")\n    if tcamAllocEn == \"true\":\n        return True\n    elif tcamAllocEn != \"true\":\n        tcamOvrwtptiList = Util.exe(PTIWrapper.get(sn, \"SWITCH\", \"SWITCH\", \"\", \"tcam_disable_overwrite\"))\n        if len(tcamOvrwtptiList) > 0 and tcamOvrwtptiList[0].isDeleted() == False:\n            return True\n    return False\n\ndef delImportProgressPti(devSerial):\n    ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"import_in_progress\"))\n    for pti in ptiList:\n        PTI.deleteInstance(pti.getPolicyId())\n\ndef postAddExt(gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    devSerial = gVarDictObj[\"deviceSerial\"]\n    fabricName = gVarDictObj[\"FABRIC_NAME\"]\n\n    try:\n        preserveConfig = gVarDictObj[\"devicePreserveConfig\"]\n        Wrapper.print(\"==========%s(): Start. Fabric = [%s], Serial [%s], # keys = [%d] Preserve = %s\" % \n                      (funcName, fabricName, devSerial, len(gVarDictObj), preserveConfig))\n\n        topologyDataObj = TopologyData(Util.exe(TopologyWrapper.get(fabricName)))\n        model = topologyDataObj.get(TopologyInfoType.SWITCH_MODEL, devSerial)\n        hostName = topologyDataObj.get(TopologyInfoType.HOSTNAME, devSerial)\n        mgmtIp = topologyDataObj.get(TopologyInfoType.MGMT_IP, devSerial)\n        isV6 = isIpv6Addr(mgmtIp)\n        fabricSettings = Util.exe(FabricWrapper.get(fabricName)).getNvPairs()\n        ff = fabricSettings.get(\"FF\")\n        inbandMgmtFlag = fabricSettings.get(\"INBAND_MGMT\", \"false\")\n        seedIp = Util.exe(Helper.getSeedIp(devSerial))\n        dcnmUser = gVarDictObj[\"dcnmUser\"]\n        \n        Wrapper.print(\"%s(): FF [%s] User [%s] Switch Serial/Name/Mgmt IP/Seed IP = [%s/%s/%s] InbandMgmt [%s]\" % (funcName,\n                    ff, dcnmUser, devSerial, mgmtIp, seedIp, inbandMgmtFlag))        \n\n        if not preserveConfig:\n            # greenfield\n            # For n7k, if admin/default VDC, then dont do any clean up. For user VDC, always do cleanup without reload.\n            #adminVDC = False\n            #userVDC = False\n            isN7k = True if model.startswith(\"N7\") else False\n                #if \":\" in devSerial:\n                #    Wrapper.print(\"%s(): Detected N7k user VDC %s\" %(funcName, devSerial))\n                #    userVDC = True\n                #else:\n                #    Wrapper.print(\"%s(): Detected N7k admin VDC %s\" %(funcName, devSerial))\n                #    adminVDC = True\n            \n            setMigrationState(fabricName, devSerial, {\"POST_ADD\":\"true\", \"UNDERLAY\" : \"true\"}, \"Greenfield Add\")\n\n            if ff == \"Easy_Fabric_IPFM\":\n                is9300, is9400, is9500, is9800 = Util.isIPFMDevice(topologyDataObj, devSerial)\n                isN9kv = Util.isN9kv(topologyDataObj, devSerial)\n                if not (is9300 or is9400 or is9500 or is9800 or isN9kv):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Import\"),\n                                           \"This is not a supported platform for IPFM. Please delete the switch from the fabric\", devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n\n            ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"import_in_progress\"))\n            if len(ptiList) > 0:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Import\"),\n                                       \"Switch import is not yet completed, please wait for switch import to finish then perform Recalculate & Deploy\", devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n            PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.SIM_PTI, \"import_in_progress\", {})\n\n            #Do clean up only if inband mgmt knob is disabled\n            if inbandMgmtFlag != \"true\":\n              if isN7k:\n                  switchCleanupWithoutReloadN7k(devSerial, dcnmUser)\n              elif gVarDictObj[\"GRFIELD_DEBUG_FLAG\"] == \"Enable\":\n                  t1 = datetime.datetime.now()\n                  respObj = switchCleanupWithoutReload(devSerial, dcnmUser)\n                  t2 = datetime.datetime.now()\n                  if respObj.isRetCodeFailure():\n                      delImportProgressPti(devSerial)\n                      Wrapper.print (\"%s(): *****SWITCH CLEANUP ABORTED***** at %s (took %s)\"% (funcName, t2, (t2-t1)))\n                      return respObj\n                  Wrapper.print (\"%s(): *****SWITCH CLEANUP COMPLETED***** at %s (took %s)\"% (funcName, t2, (t2-t1)))            \n\n            mt1 = datetime.datetime.now()\n            Wrapper.print (\"%s(): ******MIN INTENT LEARNING STARTED***** at %s\"% (funcName, mt1))\n\n            sshObj = None\n            try:\n                sshObj = Util.exe(getOptSSHConnection(fabricName, devSerial, dcnmUser))\n            except Exception as e:\n                delImportProgressPti(devSerial)\n                Wrapper.print(\"%s(): Failed to get SSH connection for : [%s] [%s]. Will skip\" % \n                              (funcName, devSerial, str(e)))\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":SSH\"),\n                                       \"Failed to get SSH connection. \"\n                                       \"Please ensure LAN credentials and retry Recalculate & Deploy\", devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n\n            try:\n                gVarDictObj[\"deviceSSHConnObj\"] = sshObj\n                gVarDictObj[\"deviceSerial\"] = devSerial\n                gVarDictObj[\"IMPORT_FILE_BASE_DIR\"] = Util.getBrownfieldDir()\n                gVarDictObj[\"POLICY_TEMPLATE_BASE_DIR\"] = POLICY_TEMPLATE_BASE_DIR\n                # Wrapper.print(\"%s(): [%s] Getting 'show run'\" % (funcName, devSerial))\n                valid, shRunFileName = createBasicGFIntent(gVarDictObj, False, respObj, inbandMgmtFlag)\n                \n                if not valid:\n                    delImportProgressPti(devSerial)\n                    Wrapper.print(\"%s(): Error creating basic Intent for [%s]\"%(funcName, devSerial))\n                    #respObj.addErrorReport(getFabErrEntity(funcName, devSerial), \n                                            #\"Error while creating the basic intents for device, \"\n                                            #\"Please retry configSave/Deploy\", devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                #Handle scenario for GF add when Inband Mgmt is enabled\n                #Switch can be discovered via mgmt0 or via a front-panel port. So handle both.\n                #Currently inbandMgmt is only for Easy_Fabric\n                if inbandMgmtFlag != \"true\":\n                  #clean switch for non-inband mgmt scenarios\n                  if gVarDictObj[\"GRFIELD_DEBUG_FLAG\"] != \"Enable\" and not isN7k:\n                      t1 = datetime.datetime.now()\n                      respObj = switchCleanupWithReload(gVarDictObj)\n                      t2 = datetime.datetime.now()\n                      if respObj.isRetCodeFailure():\n                          delImportProgressPti(devSerial)\n                          Wrapper.print (\"%s(): *****SWITCH CLEANUP ABORTED***** at %s (took %s)\"% (funcName, t2, (t2-t1)))\n                          return respObj\n                      Wrapper.print (\"%s(): *****SWITCH CLEANUP COMPLETED***** at %s (took %s)\"% (funcName, t2, (t2-t1)))\n            except Exception as e:\n                delImportProgressPti(devSerial)\n                Wrapper.print(\"%s(): Exception matching running: [%s]\" % (funcName, repr(e)))\n                #respObj.addErrorReport(getFabErrEntity(funcName, devSerial), \n                #                       \"Error in older configuration clean up for switch. \"\n                #                       \"Please retry Recalculate & Deploy\", devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n            finally:\n                Wrapper.print(\"%s(): Closing SSH connection\"%(funcName))\n                gVarDictObj[\"deviceSSHConnObj\"].close()\n                del gVarDictObj[\"deviceSSHConnObj\"]\n                sshObj = None\n\n            if ff != \"Easy_Fabric_IPFM\":\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                                   ConfigPriority.CONFIG_PRIO_TOP, \"pre_config\", {}))\n\n                if isTCAMAllocationEnable(devSerial, fabricSettings):\n                    # If the device is a modular switch, its default switch role is spine.\n                    # No need to do tcam carving on a spine until its switch role is changed\n                    # to some other role when the switch is ready for Recalculate & Deploy.\n                    if not Util.isModularN9k(model) and Util.isN9kT2Vtep(topologyDataObj, devSerial):\n                        # Configure the ARP-ETHER TCAM for VxLAN as the device can be a VTEP\n                        # This requires an existing TCAM region to free up space for ARP-ETHER; therefore,\n                        # tcam_pre_config_9300/9500 must be configured before tcam_pre_config_vxlan\n                        #\n                        # Special case for the Nexus 9332PQ as it uses the same default allocation as the Nexus 9500\n                        if \"C9332PQ\" in model:\n                            Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                               ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1,\n                                                               \"tcam_pre_config_9500\", {}))\n                        else:\n                            Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                               ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1,\n                                                               \"tcam_pre_config_9300\", {}))\n                        Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2,\n                                                           \"tcam_pre_config_vxlan\", {}))\n\n            if ff == \"Easy_Fabric_IPFM\":\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                                   ConfigPriority.CONFIG_PRIO_TOP, \"base_feature_ipfm\", {})) \n\n            mt2 = datetime.datetime.now()\n            Wrapper.print (\"%s(): ******MIN INTENT LEARNING AND CREATION COMPLETED for [%s]***** at %s (took %s)\"% (funcName, devSerial, mt2, (mt2-mt1)))\n\n            #TODO: Is this really required. Skipping it for inband mgmt and inband POAP scenarios.\n            if inbandMgmtFlag != \"true\":\n              if gVarDictObj[\"DHCP_ENABLE\"] == \"true\":\n                  DHCPUtil.dhcpDeviceBlock(DHCPUtil.ADD_HOST, fabricName, devSerial, mgmtIp, gVarDictObj[\"MGMT_GW\"])\n\n            # create the jumbo mtu PTI to match the fabric setting and the l2 host intf mtu will be computed correctly\n            mtuVal = gVarDictObj[\"L2_HOST_INTF_MTU\"]\n            Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n                \"system_jumbomtu\", {\"MTU\" : mtuVal}))\n\n            # create the internal PTI to track the switch jumbomtu setting\n            Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n                \"switch_mtu_state\", {\"JUMBO_MTU_VAL\" : mtuVal}))\n\n            dcnmSNMPInfo = Util.exe(FabricWrapper.getSNMPTrapInfo())\n            dictObj = {\"FABRIC_NAME\" : fabricName, \"SERIAL\" : devSerial,\n                        \"FABRIC_SETTINGS\" : fabricSettings, \"SNMP_INFO\" : dcnmSNMPInfo}\n            Util.processRespObj(respObj, PTI.executePyTemplateMethod(\"fabric_utility_11_1\", dictObj, \"manageSnmpTrapHostPolicy\"))\n\n            allPhyInterfaces = Util.exe(IM.get(InterfaceTypeEnum.ALL_PHY, fabricName, devSerial))\n            fexInterfaces = Util.exe(IM.get(InterfaceTypeEnum.ALL_HIF, fabricName, devSerial))\n            subIntf = Util.exe(IM.get(InterfaceTypeEnum.SUBINTF, fabricName, devSerial))\n            hostInterfaces = list(set(allPhyInterfaces) - set(subIntf) - set(fexInterfaces))\n      \n            if ff == \"Easy_Fabric_IPFM\":\n                hostTemplateName = \"int_ipfm_l3_port\"\n                nvPairs = {\n                           \"INTF_VRF\" : \"default\",\n                           \"IP\" : \"\",\n                           \"PREFIX\" : \"\",\n                           \"ROUTING_TAG\" : \"\",\n                           \"MTU\": \"9216\",\n                           \"SPEED\": \"Auto\",\n                           \"PTP\": \"false\",\n                           \"PTP_PROFILE\": \"\",\n                           \"BW_CAPACITY_PERCENT\": \"\",\n                           \"UCAST_BW_PERCENT\": \"\",\n                           \"WAN_LINK\": \"false\",\n                           \"BORDER_ROUTER\": \"false\",\n                           \"DESC\": \"\",\n                           \"CONF\": \"\",\n                           \"ADMIN_STATE\": \"true\",\n                           \"GF\": \"\"\n                          }\n            else:\n                hostTemplateName = \"int_trunk_host\"\n                nvPairs = {\n                           \"BPDUGUARD_ENABLED\": \"no\",\n                           \"PORTTYPE_FAST_ENABLED\": \"true\",\n                           \"MTU\": MTU_STR_JUMBO,\n                           \"SPEED\": \"Auto\",\n                           \"ALLOWED_VLANS\": \"none\",\n                           \"DESC\": \"\",\n                           \"CONF\": \"\",\n                           \"ADMIN_STATE\": fabricSettings.get(\"HOST_INTF_ADMIN_STATE\", \"true\"),\n                           \"GF\":\"\",\n                           \"PTP\":\"false\",\n                           \"ENABLE_NETFLOW\": \"false\",\n                           \"NETFLOW_MONITOR\": \"\"\n                          }\n\n            if ff != \"Easy_Fabric_Classic\":\n                # If fabric is Easy Classic, do not attach interface policies to host interfaces in postAdd().\n                # It's because agg/access has different config for PORTTYPE_FAST_ENABLED.\n                # Let the first R&D take care of the host interface config when switch role is known.\n                for hostIntf in hostInterfaces:\n                    nvPairs.update({\"INTF_NAME\": hostIntf})\n                    Util.exe(PTI.createOrUpdate(devSerial, \"INTERFACE\", hostIntf, \"\",\n                             ConfigPriority.trunk_host, hostTemplateName, nvPairs))\n\n            Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1,\n                                        \"ptp_sim\", {\"FEATURE_PTP\":\"false\"}))\n            delMigrationState(fabricName, devSerial)\n            delImportProgressPti(devSerial)\n        else:\n            putSwitchIntoBfMigrMode(fabricName, devSerial)\n            #TODO: Is this really required. Skipping it for inband mgmt and inband POAP scenarios.\n            if inbandMgmtFlag != \"true\":\n              if gVarDictObj[\"DHCP_ENABLE\"] == \"true\":\n                  DHCPUtil.dhcpDeviceBlock(DHCPUtil.ADD_HOST, fabricName, devSerial, mgmtIp, gVarDictObj[\"MGMT_GW\"])            \n            cleanupBrownfieldImportData(fabricName, devSerial, respObj)\n    except Exception as e:\n        delImportProgressPti(devSerial)\n        Wrapper.print(\"%s(): Fabric = [%s], Serial [%s]. Exception [%s]\" % (funcName, fabricName, devSerial, traceback.format_exc()))\n        msg = (\"Switch [%s]: Unexpected error during post add processing\" % (devSerial))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":POST_ADD\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        Wrapper.print(\"==========%s(): Done. Fabric = [%s], Serial [%s]. Success = [%r]\" % (funcName, fabricName, devSerial, respObj.isRetCodeSuccess()))\n        respObj.setValue(respObj)\n        return respObj\n\ndef getRunConfFileName(isShRunAll):\n    return ('bootflash:EASY-SW-RUNNING-CONFIG_ALL' if isShRunAll else 'bootflash:EASY-SW-RUNNING-CONFIG')\n\ndef getMinRunConfigFileName(isShRunAll):\n    return ('bootflash:ef-minimum-config_all' if isShRunAll else 'bootflash:ef-minimum-config')\n\ndef createMgmtVrfPti(devSerial, cfg):\n    Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_VRF_MANAGEMENT,\n                               \"switch_freeform\", {\"CONF\": cfg}, GF_MGMT_VRF_FF_PTI_DESC))\n\ndef noSwitchDiskSpaceError(devSerial, respObj):\n    errorMsg = (\"Capturing base configuration of the device failed possibly due to not \"\n                \"enough space in bootflash. Please check the bootflash usage and delete unused files. \"\n                \"Once space is freed up, please retry adding the switch to the fabric.\")\n    respObj.addErrorReport(devSerial + \": No Disk Space\", errorMsg, devSerial)\n    respObj.setFailureRetCode()\n\ndef createBasicGFIntent(gVarDictObj, isShRunAll, respObj, inbandMgmtFlag):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = gVarDictObj[\"deviceSerial\"]\n    fabricName = gVarDictObj[\"FABRIC_NAME\"]\n    \n    switchBaseDir = getSwitchBaseDir(devSerial, fabricName, gVarDictObj[\"IMPORT_FILE_BASE_DIR\"])\n    Wrapper.print(\"%s(): START: Fabric [%s] device [%s] switchBaseDir [%s]\" % (funcName, fabricName, devSerial, switchBaseDir))\n\n    if not os.path.exists(switchBaseDir):\n        os.makedirs(switchBaseDir)\n\n    sshObj = gVarDictObj['deviceSSHConnObj']\n\n    fileName = switchBaseDir + \"show_run_all\" if isShRunAll else switchBaseDir + \"show_run\"\n    runCfgFileName = getRunConfFileName(isShRunAll)\n    minCfgFileName = getMinRunConfigFileName(isShRunAll)\n    delRunConfFileCmd = 'delete ' + runCfgFileName + \" no\"\n    delMinConfFileCmd = 'delete ' + minCfgFileName + \" no\"\n    showRunToFileCmd = 'show running-config' + (' all' if isShRunAll else '') + ''' > ''' + runCfgFileName\n    shFile = \"show file \"\n    shCfgFileName = shFile + runCfgFileName\n\n    cmdList1 = [\n                shCfgFileName + ''' | i '^hostname' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | i '^switchname' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | i '^no password strength' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | i '^username' | i password | i role >> ''' + minCfgFileName,\n                shCfgFileName + ''' | i '^ssh key rsa' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | i '^hardware profile portmode' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | section '^feature tacacs' >> ''' + minCfgFileName,\n                shCfgFileName + ''' | section '^interface breakout module' >> ''' + minCfgFileName\n               ]\n    cmdList2 = [\n                shCfgFileName + ''' | section '^radius' ''',\n                shCfgFileName + ''' | section '^ip tacacs' ''',\n                shCfgFileName + ''' | section '^tacacs' ''',\n                shCfgFileName + ''' | section '^aaa' ''',\n                shCfgFileName + ''' | section '^vrf context management' ''',\n                shCfgFileName + ''' | section '^interface mgmt0' ''',\n                ]\n    Wrapper.print(\"%s(): device %s cmdList1 [%s] and cmdList2 [%s]\" % (funcName, devSerial, \",\".join(cmdList1), \",\".join(cmdList2)))\n    cmd = cmdOut1 = cmdOut2 = aaaConfig = \"\"\n    sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n    errorCmd = \"\"\n    try:\n        firstCmdOut = getSSHCmdOuput(devSerial, sshObj, delMinConfFileCmd, sshConnReadTimeout)\n        if \"Permission denied\" in firstCmdOut:\n            errorMsg = (\"Switch [%s]: Insufficient privileges to read switch configuration. \"\n                        \"Please change the discovery user role to have network-admin privileges and \"\n                        \"retry Recalculate & Deploy.\" % devSerial)\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errorMsg)\n            respObj.setFailureRetCode()\n            return respObj\n\n        getSSHCmdOuput(devSerial, sshObj, delRunConfFileCmd, sshConnReadTimeout)\n\n        # save current switch running config to file\n        cmdOut = getSSHCmdOuput(devSerial, sshObj, showRunToFileCmd, sshConnReadTimeout)\n        if NO_DISK_SPACE_ERR_MSG in cmdOut.lower():\n            noSwitchDiskSpaceError(devSerial, respObj)\n            return respObj\n\n        for cmd in cmdList1:\n            errorCmd = cmd\n            cmdOut = getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout)\n\n            # we may run out of disk space as we append contents.. check for the condition\n            if NO_DISK_SPACE_ERR_MSG in cmdOut.lower():\n                noSwitchDiskSpaceError(devSerial, respObj)\n                return respObj\n            \n        cmd = shFile + minCfgFileName \n        errorCmd = cmd\n        cmdOut1 = getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout)\n        minCmdOpList = cmdOut1.splitlines()\n\n        PTI.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"nfm_switch_user\")\n        PTI.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_user_with_expiry\")\n        for op in minCmdOpList:\n            if op.startswith(\"hostname\"):\n                errorCmd = \"hostname\"\n                hostname = op[8:].strip()\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                      ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                      \"host_11_1\", {\"SWITCH_NAME\": hostname}))\n            if op.startswith(\"switchname\"):\n                errorCmd = \"switchname\"\n                switchname = op[10:].strip()\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                   \"switchnm_11_1\", {\"SWITCH_NAME\": switchname}))\n            if op.startswith(\"ssh key rsa\"):\n                errorCmd = \"ssh key rsa\"\n                rsaBits = op.lstrip(\"ssh key rsa \")\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                   \"ssh_key_rsa_force\", {\"BITS\": rsaBits}))\n            if op.startswith(\"hardware profile portmode\"):\n                errorCmd = \"hardware profile mode\"\n                portMode = op.lstrip(\"hardware profile portmode \")\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                   \"hardware_profile_port_mode\", {\"PORT_MODE\": portMode}))\n            if op.startswith(\"no password strength\"):\n                errorCmd = \"no password strength\"\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                   \"password_no_strength\", {}))\n            if op.startswith(\"feature tacacs\"):\n                errorCmd = \"feature tacacs\"\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                                                   \"feature_tacacs\", {}))\n            if op.startswith(\"username\") and \"password\" in op:\n                errorCmd = \"username\"\n                usrNameCmdOut = op\n                usersDict = {}\n                templateName = \"\"\n                isExpirySet = isError = False\n                try:\n                    usrNameCmdList = filter(None, usrNameCmdOut.splitlines())\n                    for cmd in usrNameCmdList:\n                        unameNvPairs = {}\n                        un = filter(None, cmd.split(\" \"))\n                        if \"expire\" not in un and len(un) == 7:\n                            unameNvPairs = {\"USERNAME\": un[1], \"PASSWORD_ENCRYPT\":un[4], \"USER_ROLE\":un[6]}\n                            usersDict.update({un[1]: unameNvPairs})\n                            templateName = \"nfm_switch_user\"\n                        elif len(un) == 9:\n                            unameNvPairs = {\"USERNAME\": un[1], \"PASSWORD_ENCRYPT\":un[4], \"EXPIRE_TIME\":un[6], \"USER_ROLE\":un[8]} \n                            usersDict.update({un[1]: unameNvPairs})\n                        else:\n                            isError = True\n                            break\n                except:\n                    isError = True\n                if isError:\n                    respObj.addErrorReport(funcName + devSerial, \"Error during (%s) intent creation. \"\n                                           \"Please check and correct username configuration on the switch and retry Recalculate & Deploy.\"%(errorCmd), devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                for user in usersDict: \n                    unameNvPairs = usersDict.get(user)\n                    if \"EXPIRE_TIME\" not in unameNvPairs:\n                        templateName = \"nfm_switch_user\"\n                    else:\n                        templateName = \"switch_user_with_expiry\"\n                    Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, templateName, unameNvPairs))\n\n            if op.startswith('interface breakout module'):\n                errorCmd = \"interface breakout module\"\n                brkOutFFCmds = []\n                brkOutCmdList = op.splitlines() \n                for cmd in brkOutCmdList:\n                    breakoutInfoList = cmd.split(\"interface breakout \")[1].split(\" \") \n                    brkoutSlot = brkoutMap = brkoutPorts = \"\"\n                    Wrapper.print(\"%s(): breakoutInfoList [%s]\" % (funcName, breakoutInfoList))\n                    if len(breakoutInfoList) < 6:\n                        # Do not have map and/or ports in the breakout command, capture the command in freeform\n                        # Modular chassis N9K-C950x allows a breakout command without port/map\n                        brkOutFFCmds.append(cmd)\n                        continue\n                    if breakoutInfoList:\n                        brkoutSlot = breakoutInfoList[1]\n                        brkoutMap = breakoutInfoList[5]\n                        brkoutPorts = getIntegerRange(breakoutInfoList[3])\n                        Wrapper.print(\"%s(): brkoutSlot = [%s], brkoutMap = [%s], brkoutPorts = [%s]\" % (funcName, brkoutSlot, brkoutMap, brkoutPorts))\n                    for port in brkoutPorts:\n                        nvPairs = {}\n                        nvPairs.update({\"SLOT\":brkoutSlot})\n                        nvPairs.update({\"MAP\":brkoutMap})\n                        nvPairs.update({\"PORT\":str(port)})\n                        entityName = \"Ethernet\" + nvPairs[\"SLOT\"] + \"/\" + nvPairs[\"PORT\"]\n                        ptiSource = getSrc(\"breakout_interface\")\n                        Wrapper.print(\"%s:() Entity Name [%s] nvPairs [%s]\" % (funcName, entityName, nvPairs))\n                        # create individual PTIs for each port\n                        createPTI(devSerial, nvPairs, \"breakout_interface\", entityName, ptiSource, -1)\n                \n                ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n                for pti in ptiList:\n                    if pti.getDescription() == \"Additional Breakout Configuration\":\n                        PTI.deleteInstance(pti.getPolicyId())\n                if len(brkOutFFCmds) > 0:\n                    Wrapper.print(\"%s(): brkOutFFCmds %s\" % (funcName, brkOutFFCmds))\n                    Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_TOP,\n                                               \"switch_freeform\", {\"CONF\": Util.newLine().join(brkOutFFCmds)},\n                                               \"Additional Breakout Configuration\"))\n                    \n        for cmd in cmdList2:\n            errorCmd = cmd\n            cmdOut2 = getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout)\n            if \"interface mgmt0\" in cmd:\n                if (len(cmdOut2) == 0):\n                    noSwitchDiskSpaceError(devSerial, respObj)\n                    return respObj\n                if cmdOut2 and cmdOut2.startswith(\"interface mgmt0\"):\n                    intfName = \"mgmt0\"\n                    cdpEnable = \"true\"\n                    mgmtCmdList = cmdOut2.split(Util.newLine())\n                    for op in mgmtCmdList:\n                        if \"no cdp enable\" in op.strip():\n                            cdpEnable = \"false\"\n                            break\n                    mgmtCmdList = filter(None, mgmtCmdList)\n                    descCmdList = filter(lambda x: \"description\" in x, mgmtCmdList)\n                    desc = descCmdList[0].strip()[12:].strip() if len(descCmdList) > 0 else \"\"\n                    intFreeFormCmdList = filter(lambda x: \"interface mgmt0\" not in x, mgmtCmdList)\n                    intFreeFormCmdList = filter(lambda x: \"cdp\" not in x, intFreeFormCmdList)\n                    intFreeFormCmdList = filter(lambda x: \"vrf member management\" not in x, intFreeFormCmdList)\n                    intFreeFormCmdList = filter(lambda x: \"description\" not in x, intFreeFormCmdList)\n                    intFreeFormCmdList = filter(lambda x: \"shut\" not in x, intFreeFormCmdList)\n    \n                    Wrapper.print(\"%s(): cdp enable %s for: %s\" % (funcName, cdpEnable, devSerial))\n    \n                    nvPairs = {\"CONF\":\"\"}\n                    nvPairs.update({\"CONF\": Util.newLine().join(intFreeFormCmdList)})\n                    Wrapper.print(\"%s(): NV pairs: %s\" %(funcName, str(nvPairs.get(\"CONF\"))))\n                    Util.exe(PTIWrapper.createOrUpdate(devSerial, \"INTERFACE\", \"mgmt0\", \"\", ConfigPriority.INTF_MGMT, \"int_mgmt\",\n                                                       {\"INTF_NAME\": \"mgmt0\",\n                                                        \"CDP_ENABLE\":cdpEnable, \n                                                        \"ADMIN_STATE\": \"true\", \n                                                        \"DESC\":desc,\n                                                        \"CONF\":nvPairs.get(\"CONF\")}))\n                else:\n                    errString = (\"Error reading the switch configuration for cmd [%s]. Response from switch = [%s], please retry Recalculate & Deploy.\" % (cmd, cmdOut2))\n                    Wrapper.print(errString)\n            if \"vrf context management\" in cmd:\n                if (len(cmdOut2) == 0):\n                    noSwitchDiskSpaceError(devSerial, respObj)\n                    return respObj\n                if cmdOut2 and cmdOut2.startswith(\"vrf context management\"):\n                    Wrapper.print (\"mgmt vrf %s\"%(cmdOut2))\n                    cmdOut2filtered = cmdOut2\n                    vrfMgmtsplit = cmdOut2.splitlines()\n                    dnsServermgmt = \"\"\n                    PTI.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"dns-vrfList\")\n                    for mgmtLine in vrfMgmtsplit:\n                        if mgmtLine.strip().startswith(\"ip name-server\") and not \"use-vrf\" in mgmtLine.strip():\n                            dnsServermgmt = mgmtLine\n                            dnsIPServer = dnsServermgmt[17:].strip()\n                            Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_VRF_MANAGEMENT,\n                                                       \"dns-vrfList\",{\"NAME_SERVER_VRF\":MGMT_VRF_NAME, \"NAME_SERVER_ADDRESSLIST\":dnsIPServer}))\n                    if dnsServermgmt:                   \n                        cmdOut2filtered = Util.newLine().join(list(filter(lambda x: dnsServermgmt not in x, vrfMgmtsplit)))\n                    ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n                    for pti in ptiList:\n                        if pti.getDescription() == GF_MGMT_VRF_FF_PTI_DESC:\n                            PTI.deleteInstance(pti.getPolicyId())\n                    createMgmtVrfPti(devSerial, cmdOut2filtered)\n                else:\n                    errString = (\"Error reading the switch configuration for cmd [%s]. Response from switch = [%s], please retry Recalculate & Deploy.\" % (cmd, cmdOut2))\n                    Wrapper.print(errString)\n\n            if \"ip tacacs\" in cmd and \" ip tacacs\" in cmdOut2:\n                if aaaConfig:\n                    aaaConfig = aaaConfig + Util.newLine() + cmdOut2\n                else:\n                    aaaConfig += cmdOut2\n            if ((\"aaa\" in cmd and \"aaa\" in cmdOut2) or (\"radius\" in cmd and \"radius\" in cmdOut2) or (\"tacacs\" in cmd and \"tacacs\" in cmdOut2)):\n                if aaaConfig:\n                    aaaConfig = aaaConfig + Util.newLine() + cmdOut2\n                else:\n                    aaaConfig += cmdOut2\n        if aaaConfig:\n            errorCmd = \"AAA\"\n            ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n            for pti in ptiList:\n                if pti.getDescription() == \"NDFC AAA extra configuration\":\n                    PTI.deleteInstance(pti.getPolicyId())\n            Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.AAA_SWITCH_FF,\n                                       \"switch_freeform\", {\"CONF\": aaaConfig}, \n                                       \"NDFC AAA extra configuration\"))\n\n        cmdOut = cmdOut1 + cmdOut2\n        Wrapper.print(\"%s(): %s cmdOut [%s].\" % (funcName, devSerial, cmdOut))\n\n        cmdOut += getSSHCmdOuput(devSerial, sshObj, \"echo '!====Show run complete===='\", sshConnReadTimeout)\n        Wrapper.print(\"%s(): [%s] got cmd complete response. cmd out len = [%d]. First Line = [%s]\" %\n                      (funcName, devSerial, len(cmdOut), cmdOut.splitlines()[0]))\n\n    except Exception as e:\n        Wrapper.print(\"%s: [%s] Unexpected error getting switch cmd [%s] output . Exception = [%s]\" % (funcName, devSerial, cmd, traceback.format_exc()))\n        msg = (\"Switch [%s] - Error during configuration read or intent creation. Please resolve the errors and retry Recalculate & Deploy.\" % (devSerial))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":\" + funcName, msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n        return False, None\n\n    errString = None\n    if (len(cmdOut) < 64) or ('!====Show run complete====' not in cmdOut):\n        # unusually small size file.. something is wrong\n        Wrapper.print(\"%s: Possible invalid switch response = [%s] for SN [%s]\" % (funcName, cmdOut, devSerial))\n        errString = (\"Error reading the switch configuration. Response from switch = [%s], please retry Recalculate & Deploy.\" % (cmdOut))\n    else:\n        # check for error strings in the response which indicate an incomplete config\n        errorStrings = [\"did not respond within the expected timeframe\"]\n        for errorStr in errorStrings:\n            if errorStr in cmdOut:\n                errString = (\"Error response [%s] seen in output of command [%s]. Please retry Recalculate & Deploy.\" % (errorStr, cmd))\n                break\n    if errString:\n        respObj.setFailureRetCode()\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errString, devSerial)\n        return False, None\n    return True, fileName\n\ndef getSSHCmdOuput(devSerial, sshObj, cmd, sshConnReadTimeout):\n    funcName = sys._getframe(0).f_code.co_name\n\n    cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n    firstLine = \"\"\n    if len(cmdOut) > 0:\n        firstLine = cmdOut.splitlines()[0]\n    Wrapper.print(\"%s: Switch [%s]: Cmd [%s] Response: len = [%d]. First Line = [%s]\" %\n                  (funcName, devSerial, cmd, len(cmdOut), firstLine))  \n\n    return cmdOut\n\ndef getShowRun(gVarDictObj, fileName, cmd, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = gVarDictObj[\"deviceSerial\"]\n    devModel = gVarDictObj[\"devModel\"]\n\n    sshObj = gVarDictObj['deviceSSHConnObj']\n    sshConnReadTimeout = int(SSH_CONN_READ_TIMEOUT)\n    try:\n        Wrapper.print(\"%s: [%s] Attempting to get [%s] response.\" % (funcName, devSerial, cmd))\n        if devModel.startswith(\"N\") and not devModel.endswith(\"v\"):\n            cmdOut = Util.exe(FabricWrapper.getCmdOutput(devSerial, cmd))\n            Wrapper.print(\"%s: [%s] got cmd [%s] response. cmd out len = [%d], cmd out lines = [%s]. First Line = [%s]\" %\n                      (funcName, devSerial, cmd, len(cmdOut), len(cmdOut.splitlines()), cmdOut.splitlines()[0]))\n            cmdOut += Util.newLine() + \"!====%s complete====\"%(cmd)\n        else:\n            cmdOut = sshObj.send(cmd, sshConnReadTimeout)\n            Wrapper.print(\"%s: [%s] got cmd [%s] response. cmd out len = [%d], cmd out lines = [%s]. First Line = [%s]\" %\n                      (funcName, devSerial, cmd, len(cmdOut), len(cmdOut.splitlines()), cmdOut.splitlines()[0]))\n            cmdOut += sshObj.send(\"echo '!====%s complete===='\"%(cmd), sshConnReadTimeout)\n \n        Wrapper.print(\"%s: [%s] got cmd complete response. cmd out len = [%d]. First Line = [%s]\" %\n                      (funcName, devSerial, len(cmdOut), cmdOut.splitlines()[0]))\n    except Exception as e:\n        Wrapper.print(\"%s: [%s] Unexpected error getting switch cmd [%s] output . Exception = [%s]\" % (funcName, \n            devSerial, cmd, traceback.format_exc()))\n        Util.handleException((\"Switch [%s] - Error collecting [%s]. Please retry.\" % (devSerial, cmd)), e, respObj)\n        return False, None\n    \n    errString = None\n    if (len(cmdOut) < 512) or ('!====%s complete===='%(cmd) not in cmdOut):\n        # unusually small size file.. something is wrong\n        Wrapper.print(\"%s: [%s] Possible invalid switch response = [%s]\" % (funcName, devSerial, cmdOut))\n        errString = (\"Error reading the switch configuration. Please retry! Response from switch = [%s]\" % (cmdOut))\n    else:\n        # check for error strings in the response which indicate an incomplete config\n        errorStrings = [\"did not respond within the expected timeframe\"]\n        for errorStr in errorStrings:\n            if errorStr in cmdOut:\n                errString = (\"Error response [%s] seen in output of command [%s]. Please retry!\" % (errorStr, cmd))\n                break\n\n    if errString:\n        respObj.setFailureRetCode()\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial), errString, devSerial)\n        return False, None\n\n    cfgFile = None\n    try:\n        Wrapper.print(\"%s: [%s] Open file [%s]\" % (funcName, devSerial, fileName))\n        with open(fileName, \"w\") as cfgFile:\n            Wrapper.print(\"%s: [%s] Write to file [%s]\" % (funcName, devSerial, fileName))\n            cfgFile.write(cmdOut);\n            Wrapper.print(\"%s: [%s] Saved config to file [%s]\" % (funcName, devSerial, fileName))\n    except Exception as e:\n        Wrapper.print(\"%s: Unexpected error writing to file [%s]. Exception = [%s]\" % (funcName, fileName, repr(e)))\n        Util.handleException((\"Switch [%s] - Error saving the switch configuration to file [%s]. Please retry.\" % (devSerial, fileName)), e, respObj)\n        return False, None\n    return True, fileName\n\ndef getSwitchBaseDir(devSerial, fabricName, baseDir):\n    return baseDir + fabricName + \"/\" + devSerial + \"/\"\n\ndef writeToFile(fileName, text, respObj):\n    file = None\n    try:\n        file = open(fileName, \"w\")\n        file.write(text) \n    except Exception as e:\n        Wrapper.print(\"writeToFile: Exception. Filename = [%s], Exception [%s]\" % (fileName, traceback.format_exc()))\n        Util.handleException((\"Error writing to file [%s]\" % fileName), e, respObj)\n    finally:\n        if file != None:\n            Wrapper.print(\"writeToFile: closing file = [%s]\" % (fileName))\n            file.close()\n\n# The input files must exist\ndef doMatch(gVarDictObj, shRunFileName, shRunAllFileName, templateList, respObj, fabTech):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = gVarDictObj[\"deviceSerial\"]\n    \n    isShowRunFilePresent = os.path.isfile(shRunFileName)\n    isShowRunAllFilePresent = os.path.isfile(shRunAllFileName)\n    Wrapper.print(\"%s: %s [%s] Present [%s] [%s] Present [%s]\"% (funcName, devSerial,\n        shRunFileName, isShowRunFilePresent, shRunAllFileName, isShowRunAllFilePresent))\n\n    if not isShowRunFilePresent or not isShowRunAllFilePresent:\n        respObj.addErrorReport(funcName, \"One or more switch running config input files for template matching are not \"\n            \"present. Please check and retry.\", devSerial)\n        respObj.setFailureRetCode()\n        return None, None\n\n    #match the 'templateList' with switch config\n    Wrapper.print(\"[%s] : Start Matching %d templates\" % (devSerial, len(templateList)))\n    if fabTech != \"VLANFabric\":\n\t    matchParams = {\"devSerial\" : devSerial, \"runCfg\" : shRunFileName, \"runAllCfg\" : shRunAllFileName,\n\t\t\t   \"tmplBaseDir\" : gVarDictObj[\"POLICY_TEMPLATE_BASE_DIR\"], \"tmplList\" : templateList,\n\t\t\t   \"incIntfRes\" : True, \"incBrownfieldInfo\" : True, \n\t\t\t   \"exclTopCmds\" : ['config terminal', 'vdc','rmon',\n\t\t\t   'feature telemetry', 'feature icam', 'telemetry',\n\t\t\t   'feature analytics', 'flow exporter', 'flow record', 'flow monitor',\n\t\t\t   'flow profile', 'flow filter', 'flow system config', 'flow event'],\n\t\t\t   \"fabricName\" : gVarDictObj[\"FABRIC_NAME\"]\n\t    }\n    else:\n\t    matchParams = {\"devSerial\" : devSerial, \"runCfg\" : shRunFileName, \"runAllCfg\" : shRunAllFileName,\n\t\t\t   \"tmplBaseDir\" : gVarDictObj[\"POLICY_TEMPLATE_BASE_DIR\"], \"tmplList\" : templateList,\n\t\t\t   \"incIntfRes\" : True, \"incBrownfieldInfo\" : True, \n\t\t\t   \"exclTopCmds\" : ['config terminal', 'vdc','rmon',\n\t\t\t   'feature telemetry', 'feature icam', 'telemetry',\n\t\t\t   'feature analytics', \n\t\t\t   'flow profile', 'flow filter', 'flow system config', 'flow event'],\n\t\t\t   \"fabricName\" : gVarDictObj[\"FABRIC_NAME\"]\n\t    }\n\n    startTime = datetime.datetime.now()\n    matchResult = {}\n    interfacesRes = {}\n    try:\n        matchResult, interfacesRes = find_template_match(matchParams)\n    except Exception as e:\n        msg = (\"[%s] - Unexpected error matching templates\" % (devSerial))\n        Util.handleException(msg, e, respObj)\n        return None, None\n\n    endTime = datetime.datetime.now()\n\n    Wrapper.print(\"%s: [%s] Template Matching Results - Total time= %s seconds\" % \n                                (funcName, devSerial, (endTime - startTime)))\n    \"\"\"\n    Wrapper.print(json.dumps(matchResult, indent=4, sort_keys=True))\n    Wrapper.print(\"doMatch: [%s] Template Interface Matching Results:\" % devSerial)\n    Wrapper.print(json.dumps(interfacesRes, indent=4, sort_keys=True))\n    \"\"\"\n\n    return matchResult, interfacesRes\n\ndef updateGblDict(gVarDictObj, varName, varVal):\n    oldVal = gVarDictObj[varName]\n    gVarDictObj[varName] = varVal\n    Wrapper.print(\"updateGblDict: updated variable [%s] Val [%s] -> [%s]\" % (varName, oldVal, gVarDictObj[varName]))\n\ndef redefineGlobals(gVarDictObj):\n    global ACTIVE_MIGRATION\n    global FF, BGP_AS, FABRIC_NAME, ANYCAST_GW_MAC, REPLICATION_MODE, RP_MODE, RP_COUNT\n    global MULTICAST_GROUP_SUBNET, FABRIC_INTERFACE_TYPE, LINK_STATE_ROUTING, LINK_STATE_ROUTING_TAG, OSPF_AREA_ID\n    global ENABLE_FABRIC_VPC_DOMAIN_ID, FABRIC_VPC_DOMAIN_ID, VPC_PEER_LINK_VLAN, ENABLE_VPC_PEER_LINK_NATIVE_VLAN,VPC_PEER_LINK_ALL_VLAN_DISABLE\n    global POWER_REDUNDANCY_MODE, EXTRA_CONF_LEAF, EXTRA_CONF_SPINE, EXTRA_CONF_TOR\n    global BGP_LB_ID, NVE_LB_ID, ANYCAST_LB_ID, RP_LB_ID, PHANTOM_RP_LB_ID1, PHANTOM_RP_LB_ID2\n    global IBGP_PEER_TEMPLATE, IBGP_PEER_TEMPLATE_LEAF, BRFIELD_DEBUG_FLAG, GRFIELD_DEBUG_FLAG, SITE_ID\n    global VPC_ENABLE_IPv6_ND_SYNC, ENABLE_TRM\n    global BGP_AUTH_ENABLE, BGP_AUTH_KEY_TYPE, BGP_AUTH_KEY\n    global OSPF_AUTH_ENABLE, OSPF_AUTH_KEY_ID, OSPF_AUTH_KEY\n    global PIM_HELLO_AUTH_ENABLE, PIM_HELLO_AUTH_KEY\n    global ENABLE_TENANT_DHCP\n    global ISIS_LEVEL, ISIS_P2P_ENABLE, ISIS_AUTH_ENABLE, ISIS_AUTH_KEYCHAIN_NAME, ISIS_AUTH_KEYCHAIN_KEY_ID, ISIS_AUTH_KEY, ISIS_OVERLOAD_ENABLE, ISIS_OVERLOAD_ELAPSE_TIME\n    global BFD_ENABLE, BFD_IBGP_ENABLE, BFD_OSPF_ENABLE, BFD_ISIS_ENABLE, BFD_PIM_ENABLE, BFD_AUTH_ENABLE\n    global BFD_AUTH_KEY_ID, BFD_AUTH_KEY\n    global UNDERLAY_IS_V6, USE_LINK_LOCAL, EXTRA_CONF_INTRA_LINKS, BROWNFIELD_NETWORK_NAME_FORMAT, BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS\n    global FEATURE_PTP, FEATURE_PTP_INTERNAL, PTP_VDC_ID, PTP_DOMAIN_ID \n    global ENABLE_DEFAULT_QUEUING_POLICY, DEAFULT_QUEUING_POLICY_CLOUDSCALE, DEAFULT_QUEUING_POLICY_R_SERIES, DEAFULT_QUEUING_POLICY_OTHER\n    global TCAM_ALLOCATION, OVERLAY_MODE, FHRP_PROTOCOL, VRF_LITE_PROTOCOL\n    global OSPFv3_ROUTING_TAG, OSPFv3_AREA_ID\n\n    ACTIVE_MIGRATION        = gVarDictObj[\"ACTIVE_MIGRATION\"]\n    FF                      = gVarDictObj[\"FF\"]\n    BGP_AS                  = gVarDictObj.get(\"BGP_AS\", \"\")\n    FABRIC_NAME             = gVarDictObj[\"FABRIC_NAME\"]\n    ANYCAST_GW_MAC          = gVarDictObj.get(\"ANYCAST_GW_MAC\", \"\")\n    REPLICATION_MODE        = gVarDictObj.get(\"REPLICATION_MODE\", \"\")\n    RP_MODE                 = gVarDictObj.get(\"RP_MODE\", \"asm\")\n    RP_COUNT                = gVarDictObj.get(\"RP_COUNT\", \"2\")\n    MULTICAST_GROUP_SUBNET  = gVarDictObj.get(\"MULTICAST_GROUP_SUBNET\",\"239.1.1.0/25\")\n    FABRIC_INTERFACE_TYPE   = gVarDictObj.get(\"FABRIC_INTERFACE_TYPE\", \"\")\n    LINK_STATE_ROUTING      = gVarDictObj.get(\"LINK_STATE_ROUTING\", \"\")\n    LINK_STATE_ROUTING_TAG  = gVarDictObj.get(\"LINK_STATE_ROUTING_TAG\", \"\")\n    OSPF_AREA_ID            = gVarDictObj.get(\"OSPF_AREA_ID\", \"0.0.0.0\")\n    ENABLE_TRM              = gVarDictObj.get(\"ENABLE_TRM\", \"false\")\n    VPC_PEER_LINK_VLAN      = gVarDictObj.get(\"VPC_PEER_LINK_VLAN\", \"3600\")\n    ENABLE_VPC_PEER_LINK_NATIVE_VLAN = gVarDictObj.get(\"ENABLE_VPC_PEER_LINK_NATIVE_VLAN\", \"false\")\n    VPC_PEER_KEEP_ALIVE_OPTION =  gVarDictObj.get(\"VPC_PEER_KEEP_ALIVE_OPTION\", MGMT_VRF_NAME)\n    VPC_ENABLE_IPv6_ND_SYNC = gVarDictObj.get(\"VPC_ENABLE_IPv6_ND_SYNC\", \"true\")\n    ENABLE_FABRIC_VPC_DOMAIN_ID = gVarDictObj.get(\"ENABLE_FABRIC_VPC_DOMAIN_ID\", \"false\")\n    FABRIC_VPC_DOMAIN_ID    = gVarDictObj.get(\"FABRIC_VPC_DOMAIN_ID\", \"\")\n    if ENABLE_FABRIC_VPC_DOMAIN_ID == \"false\":\n        FABRIC_VPC_DOMAIN_ID = \"\"\n\n    POWER_REDUNDANCY_MODE   = gVarDictObj[\"POWER_REDUNDANCY_MODE\"]\n    EXTRA_CONF_LEAF         = gVarDictObj.get(\"EXTRA_CONF_LEAF\", \"\")\n    EXTRA_CONF_SPINE        = gVarDictObj.get(\"EXTRA_CONF_SPINE\", \"\")\n    EXTRA_CONF_TOR          = gVarDictObj.get(\"EXTRA_CONF_TOR\", \"\")\n    BGP_LB_ID               = gVarDictObj.get(\"BGP_LB_ID\", \"\")\n    NVE_LB_ID               = gVarDictObj.get(\"NVE_LB_ID\", \"1\")\n    ANYCAST_LB_ID           = gVarDictObj.get(\"ANYCAST_LB_ID\", \"\")\n    RP_LB_ID                = gVarDictObj.get(\"RP_LB_ID\", \"254\")\n    PHANTOM_RP_LB_ID1       = gVarDictObj.get(\"PHANTOM_RP_LB_ID1\", \"2\")\n    PHANTOM_RP_LB_ID2       = gVarDictObj.get(\"PHANTOM_RP_LB_ID2\", \"3\")\n    BRFIELD_DEBUG_FLAG      = gVarDictObj[\"BRFIELD_DEBUG_FLAG\"]\n    GRFIELD_DEBUG_FLAG      = gVarDictObj[\"GRFIELD_DEBUG_FLAG\"]\n    IBGP_PEER_TEMPLATE      = gVarDictObj.get(\"IBGP_PEER_TEMPLATE\", \"\")\n    IBGP_PEER_TEMPLATE_LEAF = gVarDictObj.get(\"IBGP_PEER_TEMPLATE_LEAF\", \"\")\n    UNDERLAY_IS_V6          = gVarDictObj.get(\"UNDERLAY_IS_V6\", \"false\")\n\n    BGP_AUTH_ENABLE         = gVarDictObj.get(\"BGP_AUTH_ENABLE\", \"false\")\n    BGP_AUTH_KEY_TYPE       = gVarDictObj.get(\"BGP_AUTH_KEY_TYPE\", \"3\")\n    OSPF_AUTH_ENABLE        = gVarDictObj.get(\"OSPF_AUTH_ENABLE\", \"false\")\n    OSPF_AUTH_KEY_ID        = gVarDictObj.get(\"OSPF_AUTH_KEY_ID\", \"127\")\n    if BGP_AUTH_ENABLE != \"true\":\n        # ignore the auth key\n        BGP_AUTH_KEY = \"\"\n    else:\n        BGP_AUTH_KEY        = gVarDictObj.get(\"BGP_AUTH_KEY\", \"\")\n\n    if OSPF_AUTH_ENABLE != \"true\":\n        # ignore the auth key\n        OSPF_AUTH_KEY = \"\"\n    else:\n        OSPF_AUTH_KEY       = gVarDictObj.get(\"OSPF_AUTH_KEY\", \"\")\n    \n    if ((REPLICATION_MODE == \"Multicast\") and (UNDERLAY_IS_V6 == \"false\")):\n        PIM_HELLO_AUTH_ENABLE   = gVarDictObj.get(\"PIM_HELLO_AUTH_ENABLE\", \"false\")\n    else:\n        PIM_HELLO_AUTH_ENABLE = \"false\"\n\n    if PIM_HELLO_AUTH_ENABLE == \"true\":\n        PIM_HELLO_AUTH_KEY = gVarDictObj.get(\"PIM_HELLO_AUTH_KEY\", \"\")\n    else:\n        PIM_HELLO_AUTH_KEY = \"\"\n\n    ISIS_LEVEL                  = gVarDictObj.get(\"ISIS_LEVEL\", \"level-2\")\n    ISIS_P2P_ENABLE             = gVarDictObj.get(\"ISIS_P2P_ENABLE\", \"true\")\n    ISIS_AUTH_ENABLE            = gVarDictObj.get(\"ISIS_AUTH_ENABLE\", \"false\")\n    ISIS_AUTH_KEYCHAIN_KEY_ID   = gVarDictObj.get(\"ISIS_AUTH_KEYCHAIN_KEY_ID\", \"127\")\n    if ISIS_AUTH_ENABLE != \"true\":\n        # ignore the auth key\n        ISIS_AUTH_KEY = \"\"\n        ISIS_AUTH_KEYCHAIN_NAME = \"\"\n    else:\n        ISIS_AUTH_KEYCHAIN_NAME = gVarDictObj.get(\"ISIS_AUTH_KEYCHAIN_NAME\", \"\")\n        ISIS_AUTH_KEY           = gVarDictObj.get(\"ISIS_AUTH_KEY\", \"\")\n    ISIS_OVERLOAD_ENABLE        = gVarDictObj.get(\"ISIS_OVERLOAD_ENABLE\", \"true\")\n    ISIS_OVERLOAD_ELAPSE_TIME   = gVarDictObj.get(\"ISIS_OVERLOAD_ELAPSE_TIME\", \"60\")\n\n    if LINK_STATE_ROUTING == \"ospf\":\n        ISIS_AUTH_ENABLE = \"false\"\n    elif LINK_STATE_ROUTING == \"is-is\":\n        OSPF_AUTH_ENABLE = \"false\"\n    \n    ENABLE_TENANT_DHCP          = gVarDictObj.get(\"ENABLE_TENANT_DHCP\", \"true\")\n    USE_LINK_LOCAL              = gVarDictObj.get(\"USE_LINK_LOCAL\", \"true\")\n\n    FEATURE_PTP                 = gVarDictObj.get(\"FEATURE_PTP\", \"false\")\n    FEATURE_PTP_INTERNAL        = gVarDictObj.get(\"FEATURE_PTP_INTERNAL\", \"false\")\n    PTP_LB_ID                   = gVarDictObj.get(\"PTP_LB_ID\", \"\")\n    PTP_DOMAIN_ID               = gVarDictObj.get(\"PTP_DOMAIN_ID\", \"\")\n\n    if UNDERLAY_IS_V6 == \"true\":\n        FABRIC_INTERFACE_TYPE = \"p2p\"\n        REPLICATION_MODE = \"Ingress\"\n        FEATURE_PTP = \"false\"\n\n    bfdDisabled = False\n    if (UNDERLAY_IS_V6 == \"true\"):\n        BFD_ENABLE = \"false\"\n        bfdDisabled = True\n    else:\n        BFD_ENABLE          = gVarDictObj.get(\"BFD_ENABLE\", \"false\")\n        if BFD_ENABLE == \"false\":\n            bfdDisabled = True\n\n    if bfdDisabled:\n        # ignore all the BFD settings... they may be inconsistent based on how the settings are toggled\n        BFD_IBGP_ENABLE = \"false\"\n        BFD_OSPF_ENABLE = \"false\"\n        BFD_ISIS_ENABLE = \"false\"\n        BFD_PIM_ENABLE = \"false\"\n        BFD_AUTH_ENABLE = \"false\"\n        BFD_AUTH_KEY_ID = \"100\"\n        BFD_AUTH_KEY = \"\"\n    else:\n        BFD_IBGP_ENABLE     = gVarDictObj.get(\"BFD_IBGP_ENABLE\", \"false\")\n        BFD_OSPF_ENABLE     = gVarDictObj.get(\"BFD_OSPF_ENABLE\", \"false\")\n        BFD_ISIS_ENABLE     = gVarDictObj.get(\"BFD_ISIS_ENABLE\", \"false\")\n        BFD_PIM_ENABLE      = gVarDictObj.get(\"BFD_PIM_ENABLE\", \"false\")\n        if (FABRIC_INTERFACE_TYPE == \"p2p\"):\n            BFD_AUTH_ENABLE     = gVarDictObj.get(\"BFD_AUTH_ENABLE\", \"false\")\n            BFD_AUTH_KEY_ID     = gVarDictObj.get(\"BFD_AUTH_KEY_ID\", \"100\")\n            BFD_AUTH_KEY        = gVarDictObj.get(\"BFD_AUTH_KEY\", \"\").upper()\n        else:\n            BFD_AUTH_ENABLE = \"false\"\n            BFD_AUTH_KEY_ID = \"100\"\n            BFD_AUTH_KEY    = \"\"\n\n    EXTRA_CONF_INTRA_LINKS  = gVarDictObj.get(\"EXTRA_CONF_INTRA_LINKS\", \"\")\n    BROWNFIELD_NETWORK_NAME_FORMAT  = gVarDictObj.get(\"BROWNFIELD_NETWORK_NAME_FORMAT\", \"Auto_Net_VNI$$VNI$$_VLAN$$VLAN_ID$$\")\n    BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS  = gVarDictObj.get(\"BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS\", \"false\")\n    ENABLE_DEFAULT_QUEUING_POLICY = gVarDictObj.get(\"ENABLE_DEFAULT_QUEUING_POLICY\", \"\")\n    if ENABLE_DEFAULT_QUEUING_POLICY == \"true\":\n        DEAFULT_QUEUING_POLICY_CLOUDSCALE = gVarDictObj.get(\"DEAFULT_QUEUING_POLICY_CLOUDSCALE\", \"\")\n        DEAFULT_QUEUING_POLICY_R_SERIES = gVarDictObj.get(\"DEAFULT_QUEUING_POLICY_R_SERIES\", \"\")\n        DEAFULT_QUEUING_POLICY_OTHER = gVarDictObj.get(\"DEAFULT_QUEUING_POLICY_OTHER\", \"\")\n    else:\n        DEAFULT_QUEUING_POLICY_CLOUDSCALE = \"\"\n        DEAFULT_QUEUING_POLICY_R_SERIES = \"\"\n        DEAFULT_QUEUING_POLICY_OTHER = \"\"\n    OVERLAY_MODE                = gVarDictObj.get(\"OVERLAY_MODE\", \"config-profile\")\n    SITE_ID                     = gVarDictObj.get(\"SITE_ID\", \"\")\n    TCAM_ALLOCATION             = gVarDictObj.get(\"TCAM_ALLOCATION\", \"true\")\n    FHRP_PROTOCOL               = gVarDictObj.get(\"FHRP_PROTOCOL\", \"hsrp\")\n    VRF_LITE_PROTOCOL           = gVarDictObj.get(\"VRF_LITE_PROTOCOL\", \"none\")\n    OSPFv3_ROUTING_TAG          = gVarDictObj.get(\"OSPFv3_ROUTING_TAG\", \"\")\n    OSPFv3_AREA_ID              = gVarDictObj.get(\"OSPFv3_AREA_ID\", \"0.0.0.0\")\n    VPC_PEER_LINK_ALL_VLAN_DISABLE = gVarDictObj.get(\"VPC_PEER_LINK_ALL_VLAN_DISABLE\", \"false\")\n\ndef processUpgradeRespObjWithMsg(entity, message, respObj, newResp):\n    respObj.addErrorReport(entity, message)\n    respObj.setFailureRetCode()\n    Util.processRespObj(respObj, newResp)\n\ndef processThreadStatus(dataDict, switchInfoDict, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    for serial in dataDict:\n        statusDict = dataDict[serial]\n        infoDict = switchInfoDict[serial]\n        swStatus = statusDict[\"Progress\"]\n        if swStatus != \"Complete\":\n            # the operation did not complete successfully and also without an exception being caught/reported\n\n            # the respObj should already have the requried error entry\n            Wrapper.print(\"%s: Switch [%s] Role [%s] Progress [%s]\" % (funcName, infoDict[\"fmtName\"], infoDict[\"switchRole\"], swStatus))\n            respObj.addErrorReport(getFabErrEntity(funcName, serial),\n                \"Role [%s]. Unexpected error encountered processing configuration. Last Status [%s]. \"\n                \"Please review errors and retry Recalculate & Deploy \" % (infoDict[\"switchRole\"], swStatus), serial)\n            respObj.setFailureRetCode()\n\ndef parallelDeviceMatch(devices, globalOverlayInfo, aaaRemoteAuthEn, isExternalFab, dcnmUser, topologyObj):\n    funcName = sys._getframe(0).f_code.co_name\n    try:\n\n        respObj = WrappersResp.getRespObj()\n        respObj.setSuccessRetCode()\n\n        switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"]\n\n        # dictionary to hold processing status of all switches in the fabric\n        switchStatusDict = OrderedDict()\n\n        # parameters that are common for all threads\n        gblParams = {}\n        gblParams[\"IMPORT_FILE_BASE_DIR\"] = Util.getBrownfieldDir()\n        gblParams[\"POLICY_TEMPLATE_BASE_DIR\"] = POLICY_TEMPLATE_BASE_DIR\n        gblParams[\"FABRIC_NAME\"] = FABRIC_NAME\n        gblParams[\"globalOverlayInfo\"] = globalOverlayInfo\n        gblParams[\"aaaRemoteAuthEn\"] = aaaRemoteAuthEn\n        gblParams[\"dcnmUser\"] = dcnmUser\n        gblParams[\"topologyObj\"] = topologyObj\n\n        # range is 10 - 40\n        progressBase = 10\n        threadCount = 10\n        processedDevices = 0\n        outerLoop = 0\n        numDevices = len(devices)\n        while outerLoop < numDevices:\n            devicesThread = []\n            innerLoop = 0\n            numToProcess = (threadCount if (numDevices - processedDevices >= threadCount ) else (numDevices%threadCount))\n            while innerLoop < numToProcess:\n                deviceSn = devices[processedDevices]\n                processedDevices = processedDevices+1\n                infoDict = switchInfoDict[deviceSn]\n\n                \"\"\"\n                sshObj = None\n                try:\n                    sshObj = Util.exe(getOptSSHConnection(FABRIC_NAME, deviceSn, dcnmUser))\n                except Exception as e:\n                    Wrapper.print(\"PDM: Failed to get SSH connection for : [%s] [%s]. Will skip\" %\n                                  (deviceSn, str(e)))\n                    respObj.addErrorReport(getFabErrEntity(\"PDM\", deviceSn+\":SSH\"),\n                                           \"Failed to get SSH connection. \"\n                                           \"Please ensure LAN credentials and retry Recalculate & Deploy\", deviceSn)\n                    respObj.setFailureRetCode()\n                    innerLoop = innerLoop+1\n                    continue\n                \"\"\" \n                if infoDict[\"switchRole\"] == \"tor\" and not isExternalFab:\n                    respObj.addErrorReport(getFabErrEntity(\"PDM\", deviceSn+\":SSH\"),\n                                           \"Brownfield import of a ToR switch is not supported in this release. \"\n                                           \"Please delete the switch from the fabric\", deviceSn)\n                    respObj.setFailureRetCode()\n                    innerLoop = innerLoop+1\n                    continue\n                \n                statusDict = {\"Progress\" : \"Pending\"}\n                switchStatusDict[deviceSn] = statusDict\n\n                switchParams = {}\n                switchParams[\"deviceSerial\"] = deviceSn\n                if globalOverlayInfo[\"fabricTechnology\"] == \"VLANFabric\":\n                    Wrapper.print(\"Getting template list for ECL current Device [%s]\"%(deviceSn))\n                    switchParams[\"templateList\"] = getTemplateList(infoDict[\"migrationMode\"], infoDict.get(\"n9kIsNotTahoe\", None), \n                                                                        isExternalFab, (infoDict[\"switchRole\"] == \"aggregation\"), globalOverlayInfo[\"fabricTechnology\"])\n                else:\n                    switchParams[\"templateList\"] = getTemplateList(infoDict[\"migrationMode\"], infoDict.get(\"n9kIsNotTahoe\", None), \n                                                                        isExternalFab, (infoDict[\"switchRole\"] == \"spine\"), globalOverlayInfo[\"fabricTechnology\"])\n                  \n                #switchParams[\"deviceSSHConnObj\"] = sshObj\n                switchParams[\"processedDevices\"] = processedDevices\n                switchParams[\"statusDict\"] = statusDict\n                switchParams[\"infoDict\"] = infoDict\n                switchParams[\"switchOverlayInfo\"] = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n\n                #showRunAndMatchThread(gblParams, switchParams, respObj)\n\n                thread = threading.Thread(target=showRunAndMatchThread, args=(gblParams, switchParams, respObj))\n                devicesThread.append({\"thread\": thread, \"params\" : switchParams})\n                thread.start()\n                Wrapper.print(\"XXXXXXX PDM:   Thread started     XXXXXXXX [%s] -> %s\" % (infoDict[\"fmtName\"], thread))\n\n                innerLoop = innerLoop+1\n                Wrapper.print(\"Processed devices [%s] numbertoProcess [%s] current Device [%s] i:j [%s]:[%s]\"%\n                              (processedDevices,numToProcess,deviceSn, outerLoop, innerLoop))\n            \n            for info in devicesThread:\n                switchParams = info[\"params\"]\n                deviceSn = switchParams[\"deviceSerial\"]\n                infoDict = switchParams[\"infoDict\"]\n                thread = info[\"thread\"]\n                thread.join()\n\n                Wrapper.print(\"XXXXXXX PDM:   Thread Joined     XXXXXXXX [%s] -> %s\" % (infoDict[\"fmtName\"], thread))\n\n                #if switchParams[\"deviceSSHConnObj\"]:\n                    #Wrapper.print(\"%s: [%s] Closing SSH connection\" % (funcName, deviceSn))\n                    #switchParams[\"deviceSSHConnObj\"].close()\n                # note: progress does not change from the time the thread was started\n                progress = progressBase + int(float(switchParams[\"processedDevices\"])/float(numDevices) * 30)\n                FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"Brownfield - %d of %d - Switch [%s] \"\n                    \"Matched Switch Configuration\" % (switchParams[\"processedDevices\"], numDevices, infoDict[\"fmtName\"])))\n            if respObj.isRetCodeFailure():\n                # do not process additional switches if there are some failures already\n                break\n\n            outerLoop = outerLoop+innerLoop\n        processThreadStatus(switchStatusDict, switchInfoDict, respObj)\n    except Exception as e:\n        msg = (\"Unexpected error during switch configuration collection and policy matching. Please retry Recalculate & Deploy.\")\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"PARALLEL_CONFIG_MATCH\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        return respObj\n        \ndef getFilenameWithIndex(switchBaseDir, filename, index):\n    return (\"%s%s%s\" % (switchBaseDir, filename, (\"\" if index == 0 else (\".\" + str(index)))))\n\ndef getImportFileIndexToUse(switchBaseDir, currentIndex):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: Basedir [%s] currentIndex [%d]\" % (funcName, switchBaseDir, currentIndex))\n\n    # set of import related files to check\n    filesToCheck = [SH_RUN_FILENAME, SH_RUN_ALL_FILENAME, OVERLAY_INFO_FILENAME]\n\n    # check to make sure the index is not in use\n    newIndex = currentIndex\n    while True:\n        fileExists = False\n        for filename in filesToCheck:\n            updFilename = getFilenameWithIndex(switchBaseDir, filename, newIndex)\n            isFilePresent = os.path.isfile(updFilename)\n            if isFilePresent:\n                # since the file is already present.. pick a new index and continue\n                Wrapper.print(\"%s: [%s] is [%spresent]\" % (funcName, updFilename, (\"\" if isFilePresent else \"not \")))\n                newIndex = newIndex + 1\n                fileExists = True\n                break\n        if not fileExists:\n            # we found a good index to use\n            break\n\n    Wrapper.print(\"%s: Return Basedir [%s] newIndex [%d]\" % (funcName, switchBaseDir, newIndex))\n    return newIndex\n\ndef getFormattedSwitchName(serialNum):\n    formattedStr = serialNum if serialNum else \"Uknown\"\n    hostName = None\n    if serialNum:\n        hostName = InventoryWrapper.getHostNameString(serialNum)\n    return (\"%s%s\" % ((hostName+\"/\" if hostName else \"\"), (serialNum if serialNum else \"Unknown\")))\n\n# check if the description has the unique DCNM L4-7 services format\n# fw:inside:ext:SN-1:E1/1:RP-1\n# lb:one:ext:SN-1:E1/1:RP-1\n# <type>:<inside/outside/one/two>:<external fabric name>:<FW device serial in exteral fab>:\n#                               <intf on FW>:<route peering name to provide to services>\ndef getServicesDescParts(formattedStr):\n    funcName = sys._getframe(0).f_code.co_name\n\n    #Wrapper.print(\"%s: processing string [%s]\" % (funcName, formattedStr))\n    parts = formattedStr.split(\":\")\n    if len(parts) != 6:\n        return None\n\n    if ((parts[0] not in [\"fw\", \"lb\", \"vnf\"]) or (parts[1] not in [\"one\", \"two\", \"inside\", \"outside\"])):\n        Wrapper.print(\"%s: Desc [%s] Not a valid service node syntax %s, %s\" % (funcName, formattedStr, parts[0], parts[1]))\n        return None\n\n    return parts\n\ndef showRunAndMatchThread(gblParams, switchParams, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    statusDict = switchParams[\"statusDict\"]\n    infoDict = switchParams[\"infoDict\"]\n    switchOverlayInfo = switchParams[\"switchOverlayInfo\"]\n    statusDict[\"Progress\"] = \"Started\"\n    devSerial = switchParams[\"deviceSerial\"]\n    aaaRemoteAuthEn = gblParams[\"aaaRemoteAuthEn\"]\n    globalOverlayInfo = gblParams[\"globalOverlayInfo\"]\n    fmtName = infoDict[\"fmtName\"]\n    fabricName = gblParams[\"FABRIC_NAME\"]\n    dcnmUser = gblParams[\"dcnmUser\"]\n    topologyObj =  gblParams[\"topologyObj\"] \n    sshObj1 = None\n    sshObj2 = None\n\n    try:\n        templateList = switchParams[\"templateList\"]\n        origTemplateList = copy.deepcopy(templateList)\n        #sshObj = switchParams['deviceSSHConnObj']\n        sshObj1 = None\n        try:\n            sshObj1 = Util.exe(getOptSSHConnection(FABRIC_NAME, devSerial, dcnmUser))\n        except Exception as e:\n            Wrapper.print(\"PDM: Failed to get SSH connection for : [%s] [%s]. Will skip\" % (devSerial, str(e)))\n            respObj.addErrorReport(getFabErrEntity(\"PDM\", devSerial+\":SSH\"),\n                                   \"Failed to get SSH connection. \"\n                                   \"Please ensure LAN credentials and retry Recalculate & Deploy\", devSerial)\n            respObj.setFailureRetCode()\n\n        switchBaseDir = getSwitchBaseDir(devSerial, gblParams[\"FABRIC_NAME\"], gblParams[\"IMPORT_FILE_BASE_DIR\"])\n        if not os.path.exists(switchBaseDir):\n            os.makedirs(switchBaseDir)\n\n        importMetadataFileName = switchBaseDir + IMPORT_METADATA_FILENAME\n        isImportMetadataFilePresent = os.path.isfile(importMetadataFileName)\n        Wrapper.print(\"%s: [%s] metadata file [%s] is [%spresent]\" % (funcName, \n                fmtName, importMetadataFileName, (\"\" if isImportMetadataFilePresent else \"not \")))\n\n        reuseResFilename = switchBaseDir + \".reuseRes\"\n\n        # get the last known switch config 'last-index' data we stored for this switch earlier (if any)\n        statusDict[\"Progress\"] = \"Checking Saved Switch last-index\"\n        importMetadataFromFile = updatedImportMetadata = None\n        reuseResults = forceResueResults = False\n        isReuseFilePresent = os.path.isfile(reuseResFilename)\n        Wrapper.print(\"%s: [%s] Reuse file [%s] is [%spresent]. BRFIELD_DEBUG_FLAG [%s]\" % (funcName, \n                fmtName, reuseResFilename, (\"\" if isReuseFilePresent else \"not \"), BRFIELD_DEBUG_FLAG))\n\n        #Wrapper.print(\"%s: [%s] templates [%d] %s\" % (funcName, devSerial, len(origTemplateList), origTemplateList))\n\n        if isReuseFilePresent or BRFIELD_DEBUG_FLAG == \"Enable\":\n            # force the reuse of earlier results for debug purposes..\n            # the assumption is that the result files exixts from earlier runs.. not having so\n            # will lead to unexpected results\n            Wrapper.print(\"%s: [%s] *** FORCE REUSING MATCH RESULTS ***\" % (funcName, fmtName))\n            forceResueResults = True\n\n        if not forceResueResults:\n            if isImportMetadataFilePresent:\n                newRespObj = getFileContents(importMetadataFileName, True)\n                if newRespObj.isRetCodeSuccess():\n                    importMetadataFromFile = newRespObj.getValue()\n                    #Wrapper.print(\"%s: [%s] metadata [%s]\" % (funcName, importMetadataFileName, importMetadataFromFile))\n                else:\n                    # a file open/read failure.. report error\n                    Util.processRespObj(respObj, newRespObj)\n                    return respObj\n\n            # get the current cfg last-index from switch\n            statusDict[\"Progress\"] = \"Getting Switch last-index\"\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n\n            cmd = \"show accounting log last-index\"\n            cfgLastIndexFromSwitchOut = getSwitchCmdOutput(sshObj1, devSerial, cmd, newRespObj)\n\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj\n\n            lastIndexFromSwitch = cfgLastIndexFromSwitchOut.split(\":\")[1].strip()\n\n            isTemplateListChanged = False\n            updatedImportMetadata = {\"templateList\" : origTemplateList, \n                                     \"last_index\" : lastIndexFromSwitch\n                                    }\n            if not importMetadataFromFile:\n                # init the meta data that we need to save back\n                updatedImportMetadata[\"cfgfile_ext_index\"] = 0\n            else:\n                updatedImportMetadata[\"cfgfile_ext_index\"] = importMetadataFromFile[\"cfgfile_ext_index\"]\n\n            if importMetadataFromFile and cfgLastIndexFromSwitchOut:\n                # check if the template list has changed (could happen if the switch role changes among other things)\n                # if the template list is changed, the earlier results are invalid\n                isTemplateListChanged = (importMetadataFromFile[\"templateList\"] != origTemplateList)\n                Wrapper.print(\"%s: [%s] template list prev [%d] new [%d].. isTemplateListChanged [%r]\" % (funcName,\n                    fmtName, len(importMetadataFromFile[\"templateList\"]), len(origTemplateList), isTemplateListChanged))\n\n                if not isTemplateListChanged:\n                    # check indices and determine if we can reuse the results\n                    cfgLastIndexFile = importMetadataFromFile[\"last_index\"]\n                    cfgLastIndexSwitch = lastIndexFromSwitch\n                    Wrapper.print(\"%s: [%s] cfg last-index file [%s] switch [%s]\" % (funcName, fmtName,\n                        cfgLastIndexFile, cfgLastIndexSwitch))\n\n                    if cfgLastIndexFile == cfgLastIndexSwitch:\n                        # no config changes detected on switch.. we can reuse the earlier results\n                        Wrapper.print(\"%s: [%s] *** REUSING MATCH RESULTS *** No configuration change \"\n                            \"detected\" % (funcName, fmtName))\n                        reuseResults = True\n                    else:\n                        # the 'last-index' is known to change on switch for non config changes also.. check further\n                        # to make sure there are some configuration changes\n                        statusDict[\"Progress\"] = \"Getting Switch Config Change With start-seqnum\"\n                        newRespObj = WrappersResp.getRespObj()\n                        newRespObj.setSuccessRetCode()\n                        cmd = (\"show accounting log start-seqnum %s | include configure | count\" % (cfgLastIndexFile))\n                        cfgCount = getSwitchCmdOutput(sshObj1, devSerial, cmd, newRespObj)\n                        if not newRespObj.isRetCodeSuccess():\n                            Util.processRespObj(respObj, newRespObj)\n                            return respObj\n                        else:\n                            strippedOutput = cfgCount.strip()\n                            Wrapper.print(\"%s: [%s] output of cmd [%s] is [%s]\" % (funcName, fmtName, cmd, strippedOutput))\n                            if strippedOutput == \"0\":\n                                Wrapper.print(\"%s: [%s] *** REUSING MATCH RESULTS *** No real configuration change \"\n                                    \"detected\" % (funcName, fmtName))\n                                reuseResults = True\n\n        # delete the cfg last-index file since we will create it at the end.. this will prevent issues with\n        # stale match results if the current matching does not complete successfully\n        if not forceResueResults and isImportMetadataFilePresent:\n            statusDict[\"Progress\"] = \"Deleting Config last-index file\"\n            os.remove(importMetadataFileName)\n        \n        if not reuseResults:\n            devModel = topologyObj.getSwitchModel(devSerial)\n            combinedDict = {\"deviceSerial\" : devSerial, \"deviceSSHConnObj\" : sshObj1,\n                \"FABRIC_NAME\" : gblParams[\"FABRIC_NAME\"], \"IMPORT_FILE_BASE_DIR\" : gblParams[\"IMPORT_FILE_BASE_DIR\"],\n                \"POLICY_TEMPLATE_BASE_DIR\" : gblParams[\"POLICY_TEMPLATE_BASE_DIR\"], \"devModel\":devModel}\n\n            # get the file index to use for the files we will create now for this run\n            fileIndexToUse = getImportFileIndexToUse(switchBaseDir, updatedImportMetadata[\"cfgfile_ext_index\"])\n\n            # filenames to use to store data\n            shRunFileName = getFilenameWithIndex(switchBaseDir, SH_RUN_FILENAME, fileIndexToUse)\n            shRunAllFileName = getFilenameWithIndex(switchBaseDir, SH_RUN_ALL_FILENAME, fileIndexToUse)\n\n            # update the meta data that we need to save back\n            updatedImportMetadata[\"cfgfile_ext_index\"] = fileIndexToUse\n            updatedImportMetadata[\"last_index\"] = lastIndexFromSwitch\n\n            statusDict[\"Progress\"] = \"Getting Show Running\"\n            Wrapper.print(\"%s: [%s] Getting 'show run'\" % (funcName, fmtName))\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            valid, junk = getShowRun(combinedDict, shRunFileName, \"show running-config\", newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj\n        \n            Wrapper.print(\"%s: [%s] Getting 'show run all'\" % (funcName, fmtName))\n            statusDict[\"Progress\"] = \"Getting Show Running All\"\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            valid, junk = getShowRun(combinedDict, shRunAllFileName, \"show running-config all\", newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj\n        sshObj1.close()\n        sshObj1 = None\n\n        matchResult = interfacesRes = None\n        \n        if not reuseResults:\n            # parse some config blocks from the switch running configs\n            statusDict[\"Progress\"] = \"Gathering config blocks from Show Running\"\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            cfgBlocks = getShowRunConfigBlocks(shRunFileName, newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj\n\n            combinedDict[\"deviceSSHConnObj\"] = None\n\n            statusDict[\"Progress\"] = \"Template Matching\"\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            # the 'templateList' is manipulated inside this API !\n            matchResult, interfacesRes = doMatch(combinedDict, shRunFileName, shRunAllFileName, templateList, newRespObj, globalOverlayInfo[\"fabricTechnology\"])    \n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj\n\n            # save the result files\n            statusDict[\"Progress\"] = \"Saving Match Results Data\"\n            matchResult[\".SH_RUN_CFG_BLOCKS\"] = cfgBlocks\n            matchResultsFileName = getFilenameWithIndex(switchBaseDir, MATCH_RESULT_FILENAME, fileIndexToUse)\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            writeToFile(matchResultsFileName, json.dumps(matchResult, indent=4, sort_keys=True), newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj    \n\n            statusDict[\"Progress\"] = \"Saving Interface Match Results Data\"\n            interfaceMatchResultsFileName = getFilenameWithIndex(switchBaseDir, INTF_MATCH_RESULT_FILENAME, fileIndexToUse)\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            writeToFile(interfaceMatchResultsFileName, json.dumps(interfacesRes, indent=4, sort_keys=True), newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj    \n\n        if not forceResueResults:\n            # create/update the 'cfg_last_index' file with the new data\n            statusDict[\"Progress\"] = \"Saving Metadata\"\n            newRespObj = WrappersResp.getRespObj()\n            newRespObj.setSuccessRetCode()\n            jsonMetadata = json.dumps(updatedImportMetadata, indent=4, sort_keys=True)\n            Wrapper.print(\"%s: Switch [%s] Saving metadata [%s]\" % (funcName, fmtName, importMetadataFileName))\n            writeToFile(importMetadataFileName, jsonMetadata, newRespObj)\n            if not newRespObj.isRetCodeSuccess():\n                Util.processRespObj(respObj, newRespObj)\n                return respObj    \n\n        if infoDict[\"migrationMode\"] == \"brownAdd\":\n            if not matchResult:\n                # we are reusing the earlier result.. open the file\n                matchResultsFileName = getFilenameWithIndex(switchBaseDir, MATCH_RESULT_FILENAME, updatedImportMetadata[\"cfgfile_ext_index\"])            \n                Wrapper.print(\"%s: [%s] Retrieving match results from [%s]\" % (funcName, fmtName, matchResultsFileName))\n                matchResult = Util.exe(getJSONFileContents(matchResultsFileName))\n\n            #DONT NEED TO DO THIS FOR ECL\n            if globalOverlayInfo[\"fabricTechnology\"] != \"VLANFabric\":\n                # get the VXLAN overlay info from switch\n                statusDict[\"Progress\"] = \"Getting VXLAN Information from switch\"\n                newRespObj = WrappersResp.getRespObj()\n                newRespObj.setSuccessRetCode()\n                sshObj2 = None\n                try:\n                    sshObj2 = Util.exe(getOptSSHConnection(FABRIC_NAME, devSerial, dcnmUser))\n                except Exception as e:\n                    Wrapper.print(\"PDM: Failed to get SSH connection for : [%s] [%s]. Will skip\" % (devSerial, str(e)))\n                    respObj.addErrorReport(getFabErrEntity(\"PDM\", devSerial+\":SSH\"),\n                                          \"Failed to get SSH connection. \"\n                                          \"Please ensure LAN credentials and retry Recalculate & Deploy\", devSerial)\n                    respObj.setFailureRetCode()\n                getSwitchVxlanInfo(infoDict, switchOverlayInfo, matchResult, sshObj2, newRespObj)\n                if not newRespObj.isRetCodeSuccess():\n                    Util.processRespObj(respObj, newRespObj)\n                    return respObj    \n                sshObj2.close()\n                sshObj2 = None\n            \n            \"\"\"\n            # Note: Disable support till all the cases are handled\n            #\n            # collect service leaf info\n            fabricSettings = Util.exe(FabricWrapper.get(fabricName)).getNvPairs()\n            swVxlanInfoDict = switchOverlayInfo[\"SWITCH_VXLAN_INFO\"]\n            hasCfgProfiles = True if matchResult[\"FEATURES_INFO\"][\"CFG_PROFILES\"] else False\n            pbrEnabled = False\n            if hasCfgProfiles:\n                nvPairList = getTemplateMatchResults(matchResult, \"feature_pbr\")\n                if (nvPairList != None):\n                    pbrEnabled = True\n            Wrapper.print(\"%s: [%s] pbrEnabled [%s] hasCfgProfiles [%r]\" % (funcName, fmtName, pbrEnabled, hasCfgProfiles))\n            if pbrEnabled and swVxlanInfoDict and hasCfgProfiles:\n                statusDict[\"Progress\"] = \"Getting L4-7 Service Information from switch\"\n                # potential for a service leaf.. check further\n                #   - get all the overlay network svi descriptions\n                overlaySviDescDict = getCfgProfileOverlaySviInfo(devSerial, matchResult)\n                for vlanId in overlaySviDescDict:\n                    sviEntry = overlaySviDescDict[vlanId]\n                    Wrapper.print(\"%s: vlanId [%s] sviEntry [%s] VLANs %s\" % (funcName, vlanId, sviEntry,\n                                        swVxlanInfoDict[\"vlanIdInfo\"][\"VLANS\"]))\n                    if ((vlanId not in swVxlanInfoDict[\"vlanIdInfo\"][\"VLANS\"]) or (\"desc\" not in sviEntry)):\n                        # maybe the profile is not applied.. do not process\n                        continue\n\n                    vniStr = swVxlanInfoDict[\"vlanIdInfo\"][\"VLANS\"][vlanId][\"vni\"]\n                    \n                    # the svi description can have a prefix\n                    descParts = sviEntry[\"desc\"].split(\" \")\n                    Wrapper.print(\"%s: SVI [%s] desc [%s] Num %d parts %s\" % (funcName, vlanId, sviEntry[\"desc\"], len(descParts), descParts))\n                    if len(descParts) == 0:\n                        parts = getServicesDescParts(sviEntry[\"desc\"])\n                    else:\n                        for part in descParts:\n                            # check to see if this part is the formatted services description\n                            parts = getServicesDescParts(part)\n                            if parts:\n                                # we found a valid service svi desc\n                                break\n\n                    if parts == None:\n                        continue\n                    \n                    serviceNodeType = parts[0]\n                    serviceNetworkType = parts[1]\n\n                    # note: the vrf name always be in lower case because that is how configs are deployed\n                    # the real VRF entry could be with different case\n                    vrfName = sviEntry[\"vrfName\"]\n\n                    if globalOverlayInfo[\"SERVICES\"] == None:\n                        globalOverlayInfo[\"SERVICES\"] = {}\n                    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n\n                    if \"serviceSwMaps\" not in servicesInfo:\n                        # first entry.. so create needed stuff\n                        servicesInfo[\"serviceNodes\"] = {}   # key is service node name\n                        servicesInfo[\"serviceNets\"] = {}    # key is vni\n                        servicesInfo[\"serviceAclPrefixStr\"] = []\n                        servicesInfo[\"serviceRmPrefixStr\"] = []\n                        servicesInfo[\"serviceSwMaps\"] = {} # key is service switch serial and value is dict of diff info\n\n                    if devSerial not in servicesInfo[\"serviceSwMaps\"]:\n                        servicesInfo[\"serviceSwMaps\"][devSerial] = {\"nodes\" : [], \"vnis\" : [], \"vrfs\" : [], \"lo\" : []}\n                    \n                    if vniStr not in servicesInfo[\"serviceNets\"]:\n                        ipParts = sviEntry[\"ipv4\"].split(\"/\")\n                        subnetStr = Util.getSubnetStringWithPrefix(ipParts[0], ipParts[1])\n                        servicesInfo[\"serviceNets\"][vniStr] = {\"networkName\" : sviEntry[\"profileName\"], \"vrfName\" : vrfName,\n                            \"ipv4\" : sviEntry[\"ipv4\"], \"mask\" : ipParts[1], \"subnet\" : subnetStr}\n                    \n                    devMapping = servicesInfo[\"serviceSwMaps\"][devSerial]\n                    entitylist = devMapping[\"vnis\"]\n                    if vniStr not in entitylist:\n                        entitylist.append(vniStr)\n\n                    entitylist = devMapping[\"vrfs\"]\n                    if vrfName not in entitylist:\n                        entitylist.append(vrfName)\n\n                    # add a mapping entry from the switch serial -> service node entries\n                    serviceNodeName = parts[3]\n                    entitylist = devMapping[\"nodes\"]\n                    if serviceNodeName not in entitylist:\n                        entitylist.append(serviceNodeName)\n\n                    # add an entry for the service node\n                    serviceNodes = servicesInfo[\"serviceNodes\"]\n                    if serviceNodeName not in serviceNodes:\n                        extFabName = parts[2]\n                        serviceNodeInfo = {\"extFabricName\": extFabName, \"swSerial\": devSerial, \n                                           \"serviceNodeType\" : serviceNodeType, \"snIntf\" : parts[4],\n                                           \"routePeers\" : {}}\n                        serviceNodes[serviceNodeName] = serviceNodeInfo\n                        Wrapper.print(\"%s: Sw [%s] Added Service Node [%s] Entry %s\" % (funcName, devSerial, serviceNodeName,\n                            serviceNodeInfo))\n                    else:\n                        serviceNodeInfo = serviceNodes[serviceNodeName]\n                        if serviceNodeInfo[\"swSerial\"] != devSerial:\n                            # this must be the vPC peer\n                            serviceNodeInfo[\"peerSwSerial\"] = devSerial\n\n                    switchOverlayInfo[\"isServiceLeaf\"] = True\n\n                    serviceNodeInfo = serviceNodes[serviceNodeName]\n                    routePeers = serviceNodeInfo[\"routePeers\"]\n                    routePeerName = parts[5]\n                    if routePeerName not in routePeers:\n                        rmPrefixStr = (\"rm_%s\" % (vrfName))\n                        if rmPrefixStr not in servicesInfo[\"serviceRmPrefixStr\"]:\n                            servicesInfo[\"serviceRmPrefixStr\"].append(rmPrefixStr)\n\n                        routePeers[routePeerName] = {\"nets\" : {}, \"isInter\" : False, \"vrfName\" : vrfName,\n                                                     \"rmPrefix\" : rmPrefixStr, \"peerOption\" : \"none\",\n                                                     \"servicePolicies\" : {}}\n\n                    rpEntry = routePeers[routePeerName]\n                    if serviceNetworkType not in rpEntry[\"nets\"]:\n                        rpEntry[\"nets\"][serviceNetworkType] = {\"vni\" : vniStr}\n                        if (serviceNodeType == \"fw\"):\n                            if (rpEntry[\"vrfName\"] != vrfName):\n                                # this is an inter tenant FW case\n                                rpEntry[\"isInter\"] = True\n                                # this can change once more configs are parsed\n                                rpEntry[\"peerOption\"] = \"static\"\n                                rpEntry[\"vrfName\"] = \"\"\n                                rpEntry[\"rmPrefix\"] = \"\"\n                        else:\n                            # this can change once more configs are parsed\n                            rpEntry[\"peerOption\"] = \"static\"\n\n                # do some final processing of services info found on this switch\n                servicesInfo = globalOverlayInfo[\"SERVICES\"]\n                if (servicesInfo and (devSerial in servicesInfo[\"serviceSwMaps\"])):\n                    for serviceNodeName in servicesInfo[\"serviceSwMaps\"][devSerial][\"nodes\"]:\n                        serviceNodeInfo = servicesInfo[\"serviceNodes\"][serviceNodeName]\n\n                        for rpEntry in serviceNodeInfo[\"routePeers\"].values():\n                            if rpEntry[\"peerOption\"] != \"none\":\n                                for netTypeEntry in rpEntry[\"nets\"].values():\n                                    netTypeEntry[\"ptNvPairs\"] = {}\n                                    #netTypeEntry[\"ptNvPairs\"] = {\"VRF_NAME\" : servicesInfo[\"serviceNets\"][netTypeEntry[\"vni\"]][\"vrfName\"]}\n\n                            # build acl name prefix networks\n                            if \"aclPrefix\" not in rpEntry:\n                                if rpEntry[\"isInter\"]:\n                                    aclStr = \"\"\n                                else:\n                                    aclStr = (\"acl_%s_\" % (rpEntry[\"vrfName\"]))\n                                    if aclStr not in servicesInfo[\"serviceAclPrefixStr\"]:\n                                        servicesInfo[\"serviceAclPrefixStr\"].append(aclStr)\n                                rpEntry[\"aclPrefix\"] = aclStr\n            \"\"\"\n\n        Wrapper.print(\"%s: [%s] Closing SSH connection\" % (funcName, fmtName))\n        #sshObj.close()\n        #switchParams[\"deviceSSHConnObj\"] = None\n\n        statusDict[\"Progress\"] = \"Complete\"\n        return respObj\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error gathering information. Last Status [%s]\" % (fmtName, statusDict[\"Progress\"]))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":INFO_GATHER\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        if sshObj1:\n            sshObj1.close()\n            sshObj1 = None\n        if sshObj2:\n            sshObj2.close()\n            sshObj2 = None\n\n        \n# invoked when switch is being deleted (removed) from the fabric.. cleanup the brownfield data as appropriate\n#  - rename the metadata file so that future BF improt into a fabric of the same name will start fresh\n#  - keep the other show run, matching results etc. for record\ndef cleanupBrownfieldImportData(fabricName, devSerial, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    fmtName = getFormattedSwitchName(devSerial)\n    try:\n        switchBaseDir = getSwitchBaseDir(devSerial, fabricName, Util.getBrownfieldDir())\n        importMetadataFileName = switchBaseDir + IMPORT_METADATA_FILENAME\n        isImportMetadataFilePresent = os.path.isfile(importMetadataFileName)\n        Wrapper.print(\"%s: [%s] BF metadata file [%s] is [%spresent]\" % (funcName, \n                fmtName, importMetadataFileName, (\"\" if isImportMetadataFilePresent else \"not \")))\n        if not isImportMetadataFilePresent:\n            # since the file does not exist.. nothing to do\n            return\n\n        # we need to rename the file so that future BF imports start fresh\n        renameFileName = (\"%s.%s\" % (importMetadataFileName, datetime.datetime.now()))\n        Wrapper.print(\"%s: [%s] Renaming [%s] -> [%s]\" % (funcName, fmtName, importMetadataFileName, renameFileName))\n        os.rename(importMetadataFileName, renameFileName)\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error cleaning up Brownfield data\" % fmtName)\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":CLEANUP\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n\ndef redefineExternalFabGlobals(gVarDictObj):\n    global FABRIC_NAME, BRFIELD_DEBUG_FLAG, BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS\n\n    FABRIC_NAME                     = gVarDictObj[\"FABRIC_NAME\"]\n    BRFIELD_DEBUG_FLAG              = gVarDictObj[\"BRFIELD_DEBUG_FLAG\"]\n    BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS = \"true\"\n\ndef handleUpgradeOrBrownfield(gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    try:\n        respObj = WrappersResp.getRespObj()\n        respObj.setSuccessRetCode()\n\n        isExternalFab = gVarDictObj.get(\"IS_EXTERNAL\", False)\n\n        Wrapper.print(\"%s: isExternalFab [%r]\" % (funcName, isExternalFab))\n        #Wrapper.print(\"%s: gVarDictObj - %s\" % (funcName, json.dumps(gVarDictObj, indent=4, sort_keys=True)))\n        if isExternalFab:\n            redefineExternalFabGlobals(gVarDictObj)\n        else:\n            redefineGlobals(gVarDictObj)\n\n        #Get the fabric technology and pass it down\n        fabDetails = Util.exe(FabricWrapper.get(FABRIC_NAME))\n        fabTech = fabDetails.getFabricTechnology()\n        \n        fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n        numUpg = 0\n        numResync = 0\n        numChangeIP = 0\n        numChangeMgmtMode = 0\n        aggSwitches = []\n        accessSwitches = []        \n        if isExternalFab:\n            # host port resync case only\n            hostPortResyncSwitches = gVarDictObj.get(\"RESYNC_SW_LIST\", None)\n            switchInfoDict = gVarDictObj.get(\"SW_INFO\", None)\n            if ((hostPortResyncSwitches == None) or (switchInfoDict == None)):\n                # bad data\n                pass\n            numResync = len(hostPortResyncSwitches)\n        else:\n            #get the whole topology from topology database\n            topologyDataObj = gVarDictObj[\"topologyObj\"]\n            devices = topologyDataObj.get(TopologyInfoType.SWITCHES)\n            devices = filter(None, devices)\n            devices.sort()\n\n            inbandPoapEnabled = isInbandPoapEnabled(fabricSettings)\n            inbandPoapSeedSwitches = None\n            numInbandPoapSeeds = 0\n\n            # get all the inband POAP seed switches\n            if inbandPoapEnabled == \"true\":\n                inbandPoapSeedSwitches = Util.exe(FabricWrapper.getAllInbandPOAPSeedSwitches())\n\n            upgradeOrBrownfieldSwitches = []\n            greenfieldSwitches = []\n            hostPortResyncSwitches = []\n            changeIPSwitches = []\n            changeMgmtModeSwitches = []\n            switchInfoDict = {}\n            inventoryStrList = []\n            numBrown = 0\n            superSpines = []\n            aggregationSwitches = []\n            fmtStr = \"%-15s %-30s %-15s %-20s %-20s %-25s %-30s %-20s %-s\"\n            inventoryStrList.append(fmtStr %\n                    (\"Serial\", \"Switchname\", \"Role\", \"Version\", \"Model\", \"Migration Mode\", \"vPC Peer\", \"Disc Status\", \"Inband Seed\"))\n\n            for deviceSn in devices:\n                # check if switch is in forced BF mode\n                Wrapper.print(\"%s: Checking Model [%r]\" % (funcName, deviceSn))\n                model = topologyDataObj.getSwitchModel(deviceSn)\n                if model is None:\n                    # something is not right.. \n                    respObj.addErrorReport(getFabErrEntity(funcName, \"ModelCheck:\" + deviceSn),\n                        \"Unable to determine model info. Plese ensure switch discovery is ok and retry.\", deviceSn)\n                    respObj.setFailureRetCode()\n                    continue\n\n                migrateMode, migrateModeDetail = Util.getSwitchMigrationModeStr(deviceSn)\n                formattedName = getFormattedSwitchName(deviceSn)\n                n9kIsNotTahoe = True\n                if Util.isN9kTahoe(topologyDataObj, deviceSn):\n                   n9kIsNotTahoe = False\n\n                swStatus = topologyDataObj.get(TopologyInfoType.SW_STATUS_FROM_SN, deviceSn)\n\n                vpcPeer = None\n                isVPC = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, deviceSn))\n                if isVPC:\n                    vpcPeer = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, FABRIC_NAME, deviceSn))\n\n                seedSwStr = \"N/A\"\n                if inbandPoapSeedSwitches is not None:\n                    if deviceSn in inbandPoapSeedSwitches:\n                        seedSwStr = \"Yes\" \n                        numInbandPoapSeeds += 1\n                    else:\n                        seedSwStr = \"No\"\n\n                dict = {\"deviceSerial\" : deviceSn, \"migrationMode\" : migrateMode, \"detail\" : migrateModeDetail,\n                        \"deviceModel\" : model, \"isN9K\" : True, \"n9kIsNotTahoe\" : n9kIsNotTahoe,\n                        \"switchRole\" : topologyDataObj.getSwitchRole(deviceSn),\n                        \"hostName\" : topologyDataObj.getHostName(deviceSn),\n                        \"fmtName\" : formattedName,\n                        \"imageVer\" : Util.exe(ImageManagementWrapper.getNXOSVersion(deviceSn)),\n                        \"vpcPeer\" : vpcPeer,\n                        \"discStatus\" : swStatus,\n                        \"seedSwitch\" : seedSwStr\n                        }\n                if \"super\" in dict[\"switchRole\"]:\n                    superSpines.append(deviceSn)\n                if \"aggregation\" in dict[\"switchRole\"]:\n                    aggregationSwitches.append(deviceSn)\n \n                switchInfoDict[deviceSn] = dict\n                if migrateMode is not None:\n                    if migrateMode != \"greenAdd\":\n                        if migrateMode == \"reSync\":\n                            hostPortResyncSwitches.append(deviceSn)\n                        elif migrateMode == \"changeIP\":\n                            changeIPSwitches.append(deviceSn)\n                        elif migrateMode == \"mgmtModeChg\":\n                            changeMgmtModeSwitches.append(deviceSn)\n                        else:\n                            upgradeOrBrownfieldSwitches.append(deviceSn)\n                            if migrateMode == \"brownAdd\":\n                                numBrown += 1\n                    else:\n                        greenfieldSwitches.append(deviceSn)\n                migrateModeStr = (\"%s [%s]\" % (dict[\"migrationMode\"], dict[\"detail\"]))\n                vpcPeerStr = \"N/A\" if vpcPeer == None else (\"%s\" % (getFormattedSwitchName(vpcPeer)))\n                inventoryStrList.append(fmtStr % (deviceSn,\n                    dict[\"hostName\"], dict[\"switchRole\"], dict[\"imageVer\"], dict[\"deviceModel\"],\n                    migrateModeStr, vpcPeerStr, dict[\"discStatus\"], dict[\"seedSwitch\"]))\n\n            if respObj.isRetCodeFailure():\n                # we failed quite early.. dump topo info for debug\n                #Wrapper.print(\"%s: Fabric = [%s]. Topology%s%s\" % (funcName, FABRIC_NAME, Util.newLine(),topologyDataObj.getTopoStr()));\n                Wrapper.print(\"%s: Fabric = [%s]. Topology\" % (funcName, FABRIC_NAME))\n                return respObj\n\n            greenfieldSwitches.sort()\n            upgradeOrBrownfieldSwitches.sort()\n            hostPortResyncSwitches.sort()\n\n            numGreen = len(greenfieldSwitches)\n            numUpg = len(upgradeOrBrownfieldSwitches)\n            numResync = len(hostPortResyncSwitches)\n            numChangeIP = len(changeIPSwitches)\n            numChangeMgmtMode = len(changeMgmtModeSwitches)\n            Wrapper.print(\"%s: Fabric [%s]: Num Devices [%d] G [%d] R [%d] B [%d] U [%d] C [%d] M [%d]\" % (funcName,\n                    FABRIC_NAME, len(devices), numGreen, numResync, numBrown, numUpg, numChangeIP, numChangeMgmtMode))\n            Wrapper.print(\"Fabric [%s] Inventory:%s%s\" % (FABRIC_NAME, Util.newLine(), Util.newLine().join(inventoryStrList)))\n\n            if upgradeOrBrownfieldSwitches and inbandPoapSeedSwitches is not None:\n                if numInbandPoapSeeds == 0:\n                    respObj.addErrorReport(getFabErrEntity(funcName, FABRIC_NAME),\n                        \"No Inband POAP seed switches found! Please identify the Inband POAP seed switches and \"\n                        \"retry the Recalculate and Deploy.\")\n                    respObj.setFailureRetCode()\n                    return respObj\n\n            if numGreen > 0:\n                isDeployAllowed = Util.exe(PTIWrapper.checkDeployAllowed(FABRIC_NAME))\n                if not isDeployAllowed:\n                    respObj.addErrorReport(getFabErrEntity(funcName, FABRIC_NAME),\n                            \"Recalculate & Deploy for the fabric cannot be performed, if switches are in migration mode \"\n                            \"and Fabric deployment mode is not enabled and/or dcnm user role is Network-Stager.\")\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                # take greenfield switches out of migration mode (if any)\n                for deviceSn in greenfieldSwitches:\n                    gVarDictObj[\"DICTIONARY_OBJ\"] = switchInfoDict[deviceSn]\n                    #duplicate below two as postAdd doesn't pass \"DICTIONARY_OBJ\" as key\n                    gVarDictObj[\"deviceSerial\"] = deviceSn\n                    gVarDictObj[\"devicePreserveConfig\"] = False\n                    try:\n                        newRespObj = postAddExt(gVarDictObj)\n                        Util.processRespObj(respObj, newRespObj)\n                        if not newRespObj.isRetCodeSuccess():\n                            Wrapper.print(\"Switch [%s]: Greenfield recovery failed\" % deviceSn)\n                    except Exception as e:\n                        Util.handleException((\"Switch [%s]: Greenfield recovery\" % deviceSn), e, respObj)\n\n                for deviceSn in greenfieldSwitches:\n                    if Util.isSwitchInMigrationState(deviceSn):\n                        respObj.addErrorReport(getFabErrEntity(funcName),\n                            \"Still in migration mode. Please resolve all errors and retry Recalculate & Deploy\", deviceSn)\n                        respObj.setFailureRetCode()\n\n                if respObj.isRetCodeFailure():\n                    return respObj\n\n            needToReturn = False\n            vpcSrcToDstMacMap = {}\n            vVpcSpineQos = {}\n            if numUpg > 0:\n                # before proceeding.. report an erorr if the fabric is a MSD member if there are any switches\n                # in BF migration mode\n                parentFab = getParentFabricName(FABRIC_NAME, respObj)\n                if parentFab:\n                    # it is indeed a member fabric.. report error\n                    respObj.addErrorReport(getFabErrEntity(funcName),\n                        \"Fabric is a member of MSD [%s]. Please retry Recalculate & Deploy operation after \"\n                        \"removing the fabric from the MSD and completing the Brownfield migration \"\n                        \"or removing the Brownfield imported switches.\" % (parentFab))\n                    respObj.setFailureRetCode()\n                else:\n                    # either an error occured or not a member.. assume the latter and proceed\n                    pass\n\n                if fabTech == \"VLANFabric\" and len(aggregationSwitches) > 2:\n                    respObj.addErrorReport(getFabErrEntity(funcName, FABRIC_NAME+\":Unsupported topology\"),\n                           \"Only one pair of aggregation switches are supported in this fabric with \"\n                           \"option Preserve Config = Yes.\")\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                for deviceSn in superSpines:\n                    dict = switchInfoDict[deviceSn]\n                    switchRole = dict[\"switchRole\"]\n                    respObj.addErrorReport(getFabErrEntity(funcName, deviceSn+\":Unsupported role\"),\n                           \"[%s] Role is not supported with option Preserve Config = Yes.\" % (switchRole), deviceSn)\n                    respObj.setFailureRetCode()\n                   \n                FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 5, \"Brownfield - Checking vPC pairs in fabric\") \n                for deviceSn in upgradeOrBrownfieldSwitches:\n                    dict = switchInfoDict[deviceSn]\n                    # check to make sure all the vpc pair switches are in the fabric\n                    sshObj = None\n                    try:\n                        # check to make sure discovery status is ok\n                        if dict[\"discStatus\"] != \"ok\":\n                            respObj.addErrorReport(funcName,\n                                \"Discovery state is not ok. Please ensure switch is discovered correctly and retry Recalculate & Deploy.\", deviceSn)\n                            respObj.setFailureRetCode()\n                            continue\n\n                        try:\n                            sshObj = Util.exe(getOptSSHConnection(FABRIC_NAME, deviceSn, gVarDictObj[\"dcnmUser\"]))\n                        except Exception as e:\n                            Wrapper.print(\"%s: Failed to get SSH connection for : [%s] [%s]\" % \n                                          (funcName, deviceSn, str(e)))\n                            respObj.addErrorReport(getFabErrEntity(funcName, deviceSn+\":SSH\"),\n                                   \"Failed to get SSH connection. Please ensure LAN credentials and retry Recalculate & Deploy\", deviceSn)\n                            respObj.setFailureRetCode()\n                            continue\n\n                        isVpc = getSwitchVpcFeatureState(sshObj, deviceSn, respObj)\n                        if isVpc:\n                            cmdJson = getSwitchCmdJsonOutput(sshObj, deviceSn, \"show vpc role | json\", respObj)\n                            if cmdJson != \"\":\n                                if \"vpc-peer-system-mac\" in cmdJson:\n                                    Wrapper.print(\"%s: [%s]: local -> peer mac : [%s] -> [%s]\" % \n                                        (funcName, deviceSn, cmdJson['vpc-local-system-mac'], cmdJson['vpc-peer-system-mac']))\n                                    vpcSrcToDstMacMap[cmdJson['vpc-local-system-mac']] = {'switchSn' : deviceSn, 'peerMac' : cmdJson['vpc-peer-system-mac']}\n                                else:\n                                    # an image version that we cannot do this check.. we will skip\n                                    Wrapper.print(\"%s: [%s]: Skipping Missing vPC Peer check. Cmd Response [%s]\" % \n                                        (funcName, deviceSn, cmdJson))\n                        if fabricSettings.get(\"FABRIC_VPC_QOS\") == \"true\":\n                            dict = switchInfoDict[deviceSn]\n                            switchRole = dict[\"switchRole\"]\n                            if \"spine\" in switchRole:\n                                newRespObj = WrappersResp.getRespObj()\n                                newRespObj.setSuccessRetCode()\n                                qosPolicyName = fabricSettings.get(\"FABRIC_VPC_QOS_POLICY_NAME\", \"spine_qos_for_fabric_vpc_peering\")\n                                cmapCmd = 'show running-config ipqos | section \"^class-map type qos match-all %s\"'%qosPolicyName\n                                cmapCmdOut = getSwitchCmdOutput(sshObj, deviceSn, cmapCmd, newRespObj)\n                                if not newRespObj.isRetCodeSuccess():\n                                    Util.processRespObj(respObj, newRespObj)\n                                    respObj.setFailureRetCode()\n                                pmapCmd = 'show running-config ipqos | section \"^policy-map type qos %s\"'%qosPolicyName\n                                pmapCmdOut = getSwitchCmdOutput(sshObj, deviceSn, pmapCmd, newRespObj)\n                                if not newRespObj.isRetCodeSuccess():\n                                    Util.processRespObj(respObj, newRespObj)\n                                    respObj.setFailureRetCode()\n                                if cmapCmdOut and pmapCmdOut:\n                                    vVpcSpineQos[deviceSn] = {\"classMap\":cmapCmdOut, \"policyMap\":pmapCmdOut}\n                                    Wrapper.print(\"%s: [%s]: vVpcSpineQos [%s]\" % (funcName, deviceSn, vVpcSpineQos))\n                    finally:\n                        if sshObj:\n                            Wrapper.print(\"%s: Closing SSH connection for : [%s]\" %  (funcName, deviceSn))\n                            sshObj.close()\n\n                # look through all vpc switches to make sure the peer is in the fabric\n                Wrapper.print(\"%s: [%s]: vpcSrcToDstMacMap : [%s]\" % (funcName, deviceSn, vpcSrcToDstMacMap))\n                for srcSysMac in vpcSrcToDstMacMap:\n                    entry = vpcSrcToDstMacMap[srcSysMac]\n                    switchSn = entry['switchSn']\n                    if entry['peerMac'] not in vpcSrcToDstMacMap:\n                        Wrapper.print(\"%s: vPC Peer for Switch [%s] with Local System Mac [%s] not found in fabric\" %\n                                      (funcName, switchSn, srcSysMac))\n                        respObj.addErrorReport(getFabErrEntity(funcName, switchSn+\":vPC Peer\"),\n                                       \"vPC Peer not found in fabric. \"\n                                       \"Please add the vPC peer switch to the fabric and retry Recalculate & Deploy\", switchSn)\n                        respObj.setFailureRetCode()\n\n        if respObj.isRetCodeFailure():\n            return respObj\n\n        if numChangeMgmtMode:\n            for deviceSn in changeMgmtModeSwitches:\n                targetMode = None\n                ptiList = Util.exe(PTIWrapper.get(deviceSn, \"SWITCH\", \"SWITCH\", \"\", \"switch_migration_state\"))\n                for pti in ptiList:\n                    if pti.isDeleted():\n                        continue\n                    targetMode = pti.getNvPairs().get(\"TARGET_MGMT_MODE\", None)\n                    break\n\n                Wrapper.print(\"%s: Switch [%s] Target Mgmt Mode [%s]\" % (funcName, deviceSn, targetMode))\n                newDiscIP = None\n                if targetMode == \"OOB\":\n                    newDiscIntf = \"mgmt0\"\n                    intfTmplName = \"int_mgmt\"\n                    newDiscVrf = \"management\"\n                else:\n                    newDiscIntf = \"loopback\" + fabricSettings.get(\"BGP_LB_ID\", \"0\")\n                    intfTmplName = \"int_fabric_loopback_11_1\"\n                    newDiscVrf = \"default\"\n\n                intfPti = None\n                srchOpt = CtrlPolicySearch()\n                srchOpt.setSerialNumber(deviceSn)\n                srchOpt.setEntityName(newDiscIntf)\n                srchOpt.setTemplateName(intfTmplName)\n                srchOpt.setTemplateContentType(\"PYTHON\")\n                intfPtis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                for pti in intfPtis:\n                    if pti.isDeleted():\n                        continue\n                    intfPti = pti\n                    break\n\n                if intfPti is None:\n                    respObj.addErrorReport(getFabErrEntity(funcName, deviceSn+\":DiscoveryIPChange\"),\n                                   \"Interface policy for interface [%s] not found. \"\n                                   \"Please double check and retry Recalculate & Deploy\" % (newDiscIntf), deviceSn)\n                    respObj.setFailureRetCode()\n                    continue\n\n                if targetMode == \"OOB\":\n                    #   - make sure the mgmt0 intf intent is present\n                    #   - get the mgmt0 IP address\n                    intfFF = intfPti.getNvPairs().get(\"CONF\", None)\n                    for line in intfFF.split(Util.newLine()):\n                        stripLine = line.strip()\n                        if stripLine.startswith(\"ip address \"):\n                            parts = stripLine.split(\" \")\n                            newDiscIP = parts[2].split(\"/\")[0]\n                            break\n                else:\n                    #   - make sure the lo0 intf intent is present\n                    #   - get the IP address\n                    newDiscIP = intfPti.getNvPairs().get(\"IP\", None)\n\n                if newDiscIP is None:\n                    respObj.addErrorReport(getFabErrEntity(funcName, deviceSn+\":DiscoveryIPChange\"),\n                                   \"IP address for interface [%s] not found. \"\n                                   \"Please double check and retry Recalculate & Deploy\" % (newDiscIntf), deviceSn)\n                    respObj.setFailureRetCode()\n                    continue\n\n                # do the discovery IP change for the switches\n                Util.exe(InventoryWrapper.changeDiscoveryIP(deviceSn, newDiscIP))\n\n                # update the discovery intf and vrf\n                Util.exe(InventoryWrapper.updateDiscoveryIntfAndVrf(deviceSn, newDiscIntf, newDiscVrf))\n\n                # take switch out of migration mode\n                delMigrationState(FABRIC_NAME, deviceSn)\n\n            if respObj.isRetCodeSuccess():\n                # we successfully updated the mgmt mode, but, discovery may not have completed.\n                # Report error to ask user to retry\n                respObj.addErrorReport(getFabErrEntity(funcName, deviceSn+\":DiscoveryIPChange\"),\n                               \"The discovery mode for switches have been updated, but, discovery may not have completed. \"\n                               \"Please check to make sure Discovery Status is 'Ok' and retry Recalculate & Deploy\")\n                respObj.setFailureRetCode()\n                return respObj\n\n        elif numUpg or numResync or numChangeIP:\n            doPreview = True\n            if numUpg:\n                progressPrefix = \"Brownfield\"\n                if fabTech == \"VLANFabric\":\n                    for deviceSn in upgradeOrBrownfieldSwitches:\n                        dict = switchInfoDict[deviceSn]\n                        #Adding agg switches to be processed first\n                        if \"aggregation\" in dict[\"switchRole\"].lower():\n                            aggSwitches.append(deviceSn)\n                        elif \"access\" in dict[\"switchRole\"].lower():\n                            accessSwitches.append(deviceSn)\n                    Wrapper.print(\"%s: BF: Fabric [%s] aggSwitches %d : %s accessSwitches %d : %s\" % (funcName, FABRIC_NAME, \n                                  len(aggSwitches), aggSwitches, len(accessSwitches), accessSwitches))\n                    switchList = aggSwitches + list(set(upgradeOrBrownfieldSwitches) - set(aggSwitches))\n                else:\n                    # sort the list to process spine role switches first\n                    spineSwitches = []\n                    for deviceSn in upgradeOrBrownfieldSwitches:\n                        dict = switchInfoDict[deviceSn]\n                        if \"spine\" in dict[\"switchRole\"].lower():\n                            spineSwitches.append(deviceSn)\n    \n                    Wrapper.print(\"%s: BF: Fabric [%s] spineSwitches %d : %s\" % (funcName, FABRIC_NAME, len(spineSwitches), spineSwitches))\n                    switchList = spineSwitches + list(set(upgradeOrBrownfieldSwitches) - set(spineSwitches))                    \n                # no need for preview call in normal brownfield cases\n                doPreview = False\n            elif numResync:\n                progressPrefix = \"Host Port Resync\"\n                switchList = hostPortResyncSwitches\n            else:\n                progressPrefix = \"Change Discovery IP\"\n                switchList = changeIPSwitches\n\n            try:\n                if (progressPrefix == \"Brownfield\"):\n                    # check and record that the import process is starting\n                    Util.exe(FabricWrapper.setFabricActivity(FABRIC_NAME, \"Brownfield Import\"))\n\n                if doPreview:\n                    # build a comma separated list of switch serials\n                    swSerialList = \",\".join(switchList)\n                    # trigger a preview to inform CC of the switches in migration mode\n                    newResp = FabricWrapper.configPreview(FABRIC_NAME, swSerialList, True, True, True)\n                    if not newResp.isRetCodeSuccess():\n                        Wrapper.print(\"handleUpgradeOrBrownfield: Switch [%s] Preview call failed\" %  (swSerialList))\n                        Util.processRespObj(respObj, newResp)\n\n                if respObj.isRetCodeFailure():\n                    return respObj\n\n                globalOverlayInfo = {\n                    \"networkProfileName\" : fabricSettings.get(\"default_network\", None) if fabTech != \"VLANFabric\" else fabricSettings.get(\"network_template\", None),\n                    \"networkExtProfileName\" : fabricSettings.get(\"network_extension_template\", None),\n                    \"vrfProfileName\" : fabricSettings.get(\"default_vrf\", None) if fabTech != \"VLANFabric\" else fabricSettings.get(\"vrf_template\", None),\n                    \"vrfExtProfileName\" : fabricSettings.get(\"vrf_extension_template\", None),\n\n                    # parameters for CLI based overlay migrations\n                    \"overlayVlanNameSupported\" : \"true\",\n                    # if this flag is set to \"true\", the overlay NX-OS CLIs will be removed after deploying the\n                    # NDFC overlay profiles. Use case is for config-profile mode\n                    \"cleanupOverlayOrigCliCfg\" : \"true\",\n\n                    # routing loopback name\n                    \"routingLoName\" : \"Loopback\" + fabricSettings.get(\"BGP_LB_ID\", \"\"),\n\n                    # parameters for Cfg Profile based overlay migration\n                    \"cfgProfileInfo\" : {\"hasCfgProfile\" : None, \"refSwitch\" : None},\n\n                    # dictionary of switch related info, key is switch serial\n                    \"SWITCH_INFO\" : switchInfoDict,\n\n                    # dictionary of 'switchOverlayInfo' objects. key is switch serial (string)\n                    \"SWITCH_OVERLAYS\" : {},\n\n                    # overlay LanAttachByVRF object. key is vrf vni id (str)\n                    \"VRF_ATTACH\" : {},\n                    # overlay LanAttachByNetwork object. key is network vni id (str) \n                    \"NETWORK_ATTACH\" : {},\n\n                    # Dictionary holding this info\n                    # switches - data parsed from switches\n                    # vpcHostPairs - data related to vpc pair switches\n                    # networks - overlay network info\n                    \"HOST_PORT_RESYNC\" : None,\n\n                    \"SERVICES\" : None,\n\n                    \"isExternalFab\" : isExternalFab,\n                    \n                    \"fabricTechnology\" : fabTech\n                }\n\n                for deviceSn in switchList:\n                    dict = switchInfoDict[deviceSn]\n\n                    # check to make sure discovery status is ok\n                    if dict[\"discStatus\"] != \"ok\":\n                        respObj.addErrorReport(funcName,\n                            \"Discovery state is not ok. Please ensure switch is discovered correctly and retry Recalculate & Deploy.\", deviceSn)\n                        respObj.setFailureRetCode()\n                        continue\n\n                    # master dictionary of all overlay info on switch\n                    #   SERIAL - serial # of switch\n                    #   SWITCH_VXLAN_INFO - VXLAN info obtained from switch\n                    #   VRFS_NAME2VNI - dictionary of VRF name to vni (string) mapping. Key is the VRF name\n                    #   VRFS_BY_ID - dictionary of VRF. Key is the VRF VNI (string). value is vrfEntry\n                    #   NETWORKS_BY_ID - dictionary of networks. Key is the network vni (string)\n                    #   NETWORKS_VLAN2VNI - dictionary of mapping network vlan id (integer) to vni string. Key is the vlan vni (integer)\n                    #   ALL_VLANS - list of all vlan ids (integers) found on switch\n                    #   OVERLAY_VLANS - list of overlay vlan ids (integers) - this includes network and vrf vlan ids. This will be valid for\n                    #                   both Brownfield\n                    #   PRE_INTF_FF - unaccounted configs that need to show up before interfaces\n                    #   POST_INTF_FF - unaccounted configs that need to show up after interfaces\n                    #   IFCS - list of IFCS found on border switches\n                    #          { \"VRF_LITE\" :\n                    #                       []\n                    #          }\n                    switchOverlayInfo = {\n                                         \"SERIAL\" : deviceSn,\n                                         \"SWITCH_VXLAN_INFO\" : None,\n                                         \"NETWORKS_BY_ID\" : {},\n                                         \"NETWORKS_VLAN2VNI\" : {},\n                                         # key is lower case vrf name, value = {\"origName\" : original vrf name, \"vni\" : vni id string}\n                                         \"VRFS_NAME2VNI\" : {},\n                                         \"VRFS_BY_ID\" : {},\n                                         \"ALL_VLANS\" : [],\n                                         \"OVERLAY_VLANS\" : [],\n                                         \"PRE_INTF_FF\" : [],\n                                         \"POST_INTF_FF\" : [],\n                                         \"BGP_FF\" : [],\n                                         \"switchRole\" : dict[\"switchRole\"],\n                                         \"doOverlayExtn\" : \"false\",\n                                         \"isVpc\" : None,\n                                         \"IFCS\" : {\"VRF_LITE\" : {}},\n                                         \"isServiceLeaf\" : False,\n                                         \"hasServiceAttachment\": False\n                                        }\n\n                    globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn] = switchOverlayInfo\n\n                if respObj.isRetCodeFailure():\n                    return respObj\n\n                isFabricInbandMgmt = True if fabricSettings.get(\"INBAND_MGMT\", \"false\") == \"true\" else False\n\n                doTemplateMatching = False\n                if numUpg or numResync or (numChangeIP and not isFabricInbandMgmt):\n                    # no need for full template matching for inband change IP.. it is just underlay routing looback intf\n                    doTemplateMatching = True\n\n                Wrapper.print (\"%s: FABRIC [%s] isFabricInbandMgmt [%r] doTemplateMatching [%r]\"% (funcName, FABRIC_NAME, isFabricInbandMgmt, doTemplateMatching))\n                if doTemplateMatching:\n                    aaaRemoteAuthEn = (True if fabricSettings.get(\"AAA_REMOTE_IP_ENABLED\", \"false\") == \"true\" else False)\n                    Wrapper.print (\"=========FABRIC [%s] MEASURING TIME START=========== %s\"% (FABRIC_NAME, datetime.datetime.now()))\n                    FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 10, (\"%s - Gathering information from switches\" % (progressPrefix))) \n                    Util.exe(parallelDeviceMatch(switchList, globalOverlayInfo, aaaRemoteAuthEn, isExternalFab, gVarDictObj[\"dcnmUser\"], gVarDictObj[\"topologyObj\"]))\n                    Wrapper.print (\"=========FABRIC [%s] MEASURING TIME END=========== %s\"% (FABRIC_NAME, datetime.datetime.now()))\n\n                if numUpg:\n                    # Handle the Upgrade/Brownfield case\n                    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n                    serviceSwDict = servicesInfo.get(\"serviceSwMaps\", None) if servicesInfo else None\n                    if serviceSwDict:\n                        # check to make sure the required external fabric exist\n                        extFabList = []\n                        for serviceNodeName in servicesInfo[\"serviceNodes\"]:\n                            extFabName = servicesInfo[\"serviceNodes\"][serviceNodeName][\"extFabricName\"]\n                            if extFabName not in extFabList:\n                                extFabList.append(extFabName)\n                                newRespObj = FabricWrapper.get(extFabName)\n                                if newRespObj.isRetCodeFailure():\n                                    # most likely the external fabric does not exist\n                                    msg = (\"L4-7 Services detected in the fabric. Please ensure an External Fabric with name [%s] \"\n                                        \"is created and available for use to hold the service node(s). Please create and retry.\" % (extFabName))\n                                    processUpgradeRespObjWithMsg(\"SERVICES\", msg, respObj, newRespObj)\n\n                        if respObj.isRetCodeFailure():\n                            return respObj\n\n                        swList = serviceSwDict.keys()\n                        # update the switch list to process the service nodes first\n                        switchList = set(switchList) - set(swList)\n                        newSwitchList = swList + list(switchList)\n\n                        switchList = newSwitchList\n                        Wrapper.print(\"%s: Fabric [%s] Updated switch list %s\" % (funcName, FABRIC_NAME, switchList))\n\n                        if servicesInfo:\n                            Wrapper.print(\"%s: Services Info %s\" % (funcName, json.dumps(servicesInfo, indent=4, sort_keys=True)))\n\n                    if fabTech != \"VLANFabric\":\n                        # check all the non-spine switch versions to determine the overlay migration behavior\n                        # relevant for CLI based vxlan config migration only\n                        for deviceSn in switchList:\n                            dict = switchInfoDict[deviceSn]\n                            switchRole = dict[\"switchRole\"]\n                            if switchRole.lower() == \"spine\":\n                                continue\n                            nxosImageVer = dict[\"imageVer\"]\n                            if globalOverlayInfo[\"overlayVlanNameSupported\"] == \"true\":\n                                if nxosImageVer.startswith(\"7.0(3)I4\"):\n                                    globalOverlayInfo[\"overlayVlanNameSupported\"] = \"false\"\n                            if ((fabricSettings.get(\"OVERLAY_MODE\") == \"config-profile\") and \n                                (globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"] == \"true\")):\n                                # 7.0(3)I7(6), 9.2(3) and newer has the fix for CSCvn67117\n                                if ((nxosImageVer in [\"9.2(1)\", \"9.2(2)\"]) or\n                                   (LooseVersion(nxosImageVer) < LooseVersion('7.0(3)I7(6)'))):\n                                    globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"] = \"false\"\n    \n                            if ((globalOverlayInfo[\"overlayVlanNameSupported\"] == \"false\") and (globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"] == \"false\")):\n                                # no need to check further\n                                break\n\n                    Wrapper.print(\"%s: Fabric [%s] networkProfileName [%s] networkExtProfileName [%s] vrfProfileName [%s] \"\n                                \"vrfExtProfileName [%s]\" % (funcName, FABRIC_NAME, globalOverlayInfo[\"networkProfileName\"],\n                                globalOverlayInfo[\"networkExtProfileName\"], globalOverlayInfo[\"vrfProfileName\"],\n                                globalOverlayInfo[\"vrfExtProfileName\"]))\n                    Wrapper.print(\"%s: Fabric [%s] overlayVlanNameSupported [%s] cleanupOverlayOrigCliCfg [%s]\" % \\\n                                (funcName, FABRIC_NAME, globalOverlayInfo[\"overlayVlanNameSupported\"],\n                                globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"]))\n\n                    if inbandPoapEnabled == \"true\":\n                        # save the inband POAP seed switch info to be able to restore back on a failure since PTIs are cleaned\n                        for deviceSn in switchList:\n                            if deviceSn not in inbandPoapSeedSwitches:\n                                continue\n                            switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n                            ptiList = Util.exe(PTI.get(deviceSn, \"SWITCH\", \"SWITCH\", \"\", \"seed_switch\"))\n                            for pti in ptiList:\n                                switchInfo[\"inbandPoapSeedSwitch\"] = pti.getNvPairs()\n                                break\n\n                    # device underlay progress range is 40% - 60%\n                    progressBase = 40\n                    numProcessed = 0\n                    for deviceSn in switchList:\n                        numProcessed += 1\n                        progress = progressBase + int(float(numProcessed)/float(numUpg) * 20)\n                        \n                        dict = switchInfoDict[deviceSn]\n                        # get the file names to be used for the migration\n                        getMigrationFileNames(dict)\n                        # get the matching results\n                        dict[\"matchResult\"] = Util.exe(getJSONFileContents(dict[\"matchResultsFileName\"]))\n                        dict[\"interfacesRes\"] = Util.exe(getJSONFileContents(dict[\"interfaceMatchResultsFileName\"]))\n                        #Initialize agg-access (leaf-tor) or access-agg (tor-leaf) po downlink/uplink interface list\n                        switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n                        switchInfo[\"accessUplinkIntfs\"] = []\n\n                        gVarDictObj[\"DICTIONARY_OBJ\"] = dict\n                        #duplicate below two as postAdd doesn't pass \"DICTIONARY_OBJ\" as key\n                        gVarDictObj[\"deviceSerial\"] = deviceSn\n                        gVarDictObj[\"globalOverlayInfo\"] = globalOverlayInfo\n                        gVarDictObj[\"vpcSrcToDstMacMap\"] = vpcSrcToDstMacMap\n                        gVarDictObj[\"vVpcSpineQos\"] = vVpcSpineQos\n\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                            (\"%s - %d of %d - Switch [%s] Processing Underlay\" % (progressPrefix, numProcessed, numUpg, dict[\"fmtName\"])))\n                        try:\n                            newRespObj = WrappersResp.getRespObj()\n                            newRespObj.setSuccessRetCode()\n                            if fabTech == \"VLANFabric\":\n                                ECLfabricUpgrade(gVarDictObj, newRespObj)\n                            else:\n                                fabricUpgrade(gVarDictObj, newRespObj)\n                            if not newRespObj.isRetCodeSuccess():\n                                Util.processRespObj(respObj, newRespObj)\n                                if newRespObj.isRetCodeFailure():\n                                    Wrapper.print(\"Switch [%s]: Fabric upgrade failed\" % dict[\"fmtName\"])\n                                    # do not go further into the device upgrade if the consistency checks did not pass\n                                    continue\n\n                            newRespObj = WrappersResp.getRespObj()\n                            newRespObj.setSuccessRetCode()\n                            deviceUpgrade(gVarDictObj, newRespObj, not respObj.isRetCodeFailure())\n                            if not newRespObj.isRetCodeSuccess():\n                                Util.processRespObj(respObj, newRespObj)\n                                if newRespObj.isRetCodeFailure():\n                                    Wrapper.print(\"Switch [%s]: Device upgrade failed\" % dict[\"fmtName\"])\n\n                            # clear out the match results to avoid holding large data\n                            dict[\"matchResult\"] = dict[\"interfacesRes\"] = None\n                        except Exception as e:\n                            msg = (\"Switch [%s]: Unexpected error during Brownfield/Upgrade Processing\" % dict[\"fmtName\"])\n                            if isinstance(e, respObjError):\n                                processUpgradeRespObjWithMsg(deviceSn + \":BROWNFIELD\", msg, respObj, e.value)\n                            else:\n                                Util.handleException(msg, e, respObj)\n\n                    if respObj.isRetCodeFailure():\n                        # underlay migration failed\n                        resetSwitchMigration(FABRIC_NAME, switchList, globalOverlayInfo, gVarDictObj)\n\n                        respObj.addErrorReport(funcName,\n                            \"Switches are still in migration mode. Please resolve all errors and retry Recalculate & Deploy.\")\n                        respObj.setFailureRetCode()\n                        return respObj\n\n                    if servicesInfo:\n                        Wrapper.print(\"%s: After Services Info %s\" % (funcName, json.dumps(servicesInfo, indent=4, sort_keys=True)))\n\n                    if fabTech == \"VLANFabric\":\n                        #For ECL BF cases, now discover and set the access-agg pairing \n                        Wrapper.print(\"%s: Performing accessAggPairing accessSwitches %s\" % (funcName, accessSwitches))\n                        Util.exe(accessAggPairingBF(topologyDataObj, respObj))\n\n                        #For each access switch, determine the access-agg connected interfaces and set those\n                        for accessSn in accessSwitches:\n                            Util.exe(Util.validateAccessConnection(FABRIC_NAME, topologyDataObj, accessSn, respObj))\n                            handleTorLeafPairingBF(topologyDataObj, accessSn, respObj, globalOverlayInfo)\n                            if respObj.isRetCodeFailure():\n                                resetSwitchMigration(FABRIC_NAME, switchList, globalOverlayInfo, gVarDictObj)\n                                return respObj\n    \n                        #Print the uplink/download interfaces on access-agg side \n                        for snEntry in switchList:\n                            Wrapper.print(\"%s: Device %s Uplink/Download Interfaces %s\" % \n                                         (funcName, snEntry, globalOverlayInfo[\"SWITCH_INFO\"][snEntry][\"accessUplinkIntfs\"]))\n                        \n                        ECLhandleOverlayMigration(FABRIC_NAME, switchList, globalOverlayInfo, respObj, gVarDictObj, topologyDataObj)\n                    else:\n                        handleOverlayMigration(FABRIC_NAME, switchList, globalOverlayInfo, respObj, gVarDictObj)\n                elif numResync:\n                    # the host interface DB\n                    #   switches - dictionary of interfaces and corresponding info. Key is intf name (vpc key pair for vpcs)\n                    #              value is a dictionary that holds the following:\n                    #                   - current information found in IM\n                    #                   - new info obtained from switch\n                    hostPortResyncDict = {\"switches\" : {}, \"vpcHostPairs\" : {}, \"networks\" : {},\n                                          \"vpcPairMapping\" : {\"swToKp\" : {}, \"kPToSw\" : {}}}\n                    globalOverlayInfo[\"HOST_PORT_RESYNC\"] = hostPortResyncDict\n\n                    # build a dictionary to figure out the vpc pairings\n                    vpcMap = hostPortResyncDict[\"vpcPairMapping\"]\n                    for deviceSn in hostPortResyncSwitches:\n                        dict = switchInfoDict[deviceSn]\n\n                        # get the match related file names to be used for the resync\n                        getMigrationFileNames(dict)\n                        # get the matching results\n                        dict[\"matchResult\"] = Util.exe(getJSONFileContents(dict[\"matchResultsFileName\"]))\n                        dict[\"interfacesRes\"] = Util.exe(getJSONFileContents(dict[\"interfaceMatchResultsFileName\"]))\n\n                        hostPortResyncDict[\"switches\"][deviceSn] = {}\n\n                        if isExternalFab:\n                        #if dict[\"vpcPeer\"] == None: # not paired yet\n                            # check the vpc domain keep alive configs to build the vpc pair mappings that will be used to \n                            # determine the vpc pairings if not done yet\n                            nvPairs = None\n                            templateName = \"vpc_pair_vpc_domain_vrf_mgmt_no_hold\"\n                            nvPairList = getTemplateMatchResults(dict[\"matchResult\"], templateName)\n                            if (nvPairList != None):\n                                nvPairs = copy.deepcopy(nvPairList[0])\n                            if (nvPairs == None):\n                                templateName = \"vpc_pair_vpc_domain_vrf_mgmt\"\n                                nvPairList = getTemplateMatchResults(dict[\"matchResult\"], templateName)\n                                if (nvPairList != None):\n                                    nvPairs = copy.deepcopy(nvPairList[0])\n                            if (nvPairs == None):\n                                templateName = \"vpc_pair_vpc_domain_non_default_vrf_no_hold\"\n                                nvPairList = getTemplateMatchResults(dict[\"matchResult\"], templateName)\n                                if (nvPairList != None):\n                                    nvPairs = copy.deepcopy(nvPairList[0])\n                            if (nvPairs == None):\n                                templateName = \"vpc_pair_vpc_domain_non_default_vrf\"\n                                nvPairList = getTemplateMatchResults(dict[\"matchResult\"], templateName)\n                                if (nvPairList != None):\n                                    nvPairs = copy.deepcopy(nvPairList[0])\n\n                            if nvPairs:\n                                vpcMap[\"kPToSw\"][nvPairs[\"KEEP_ALIVE_LOCAL_IP\"]] = deviceSn\n                                vpcMap[\"swToKp\"][deviceSn] = {\"pairInfo\" : nvPairs}\n\n                    Wrapper.print(\"%s: vpcMap %s\" % (funcName, json.dumps(vpcMap, indent=4, sort_keys=True)))\n                    # check to make sure the vPC pair switches are in the resync list\n                    switchListWithSingleVpcSwitch = []\n                    for deviceSn in hostPortResyncSwitches:\n                        dict = switchInfoDict[deviceSn]\n\n                        if dict[\"vpcPeer\"] == None:\n                            # switch is not paired yet\n                            switchListWithSingleVpcSwitch.append(deviceSn)\n\n                            # do the vpc pair consistency check (both the switches must be in the resync list)\n                            kpEntry = vpcMap[\"swToKp\"].get(deviceSn, None)\n                            if not kpEntry:\n                                # standalone switch\n                                continue\n\n                            kpNvPairs = kpEntry[\"pairInfo\"]\n                            # switch has the keep alive config.. make sure the peer switch is also accounted for\n                            peerSerial = vpcMap[\"kPToSw\"].get(kpNvPairs[\"KEEP_ALIVE_PEER_IP\"], None)\n                            if peerSerial == None:\n                                # error.. the peer switch must be part of the resyn list\n                                respObj.addErrorReport(\"HOST_PORT_RESYNC:VPC_PAIR\",\n                                    \"vPC configuration detected, but, peer switch with keepalive IP [%s] not in the host port resync mode. \"\n                                    \"Please ensure that the vPC peer switch is also in the host port resyn mode and \"\n                                    \"retry Recalculate & Deploy.\" % (kpNvPairs[\"KEEP_ALIVE_PEER_IP\"]), deviceSn)\n                                respObj.setFailureRetCode()\n                                continue\n\n                            # update our peer switch info\n                            #vpcMap[\"swToKp\"][deviceSn][\"peerSw\"] = peerSerial\n\n                            # setting this will indicate that the switch is a vPC switch, but, not yet paired\n                            hostPortResyncDict[\"switches\"][deviceSn][\".vpcPeer\"] = peerSerial\n                        else:\n                            peerSerial = dict[\"vpcPeer\"]\n\n                        vpcPairkey = Util.exe(Helper.getKey(\"DevicePair\", deviceSn, peerSerial))\n                        if vpcPairkey in hostPortResyncDict[\"vpcHostPairs\"]:\n                            continue\n\n                        vpcPeerSwitchDict = switchInfoDict[peerSerial]\n                        vpcPairDict = {\"vpc_pair\" : {\"ptiID\" : None, \"nvPairs\" : None}}\n                        serials = vpcPairkey.split(Helper.DELIMITER)\n                        if serials[0] == deviceSn:\n                            vpcPairDict[\"peer1Sn\"] = deviceSn\n                            vpcPairDict[\"peer2Sn\"] = peerSerial\n                            vpcPairDict[\"fmtName\"] = ((\"%s <-> %s\") % (dict[\"fmtName\"], vpcPeerSwitchDict[\"fmtName\"]))\n                        else:\n                            vpcPairDict[\"peer1Sn\"] = peerSerial\n                            vpcPairDict[\"peer2Sn\"] = deviceSn\n                            vpcPairDict[\"fmtName\"] = ((\"%s <-> %s\") % (vpcPeerSwitchDict[\"fmtName\"], dict[\"fmtName\"]))\n\n                        if isExternalFab:\n                            # check if the vPC pair is paired with vpc_pair policy\n                            srchOpt = CtrlPolicySearch()\n                            srchOpt.setSerialNumber(vpcPairkey)\n                            srchOpt.setTemplateName(\"vpc_pair\")\n                            ptiList = Util.exe(PTI.getPTIs(srchOpt))\n                            for pti in ptiList:\n                                if pti.isDeleted():\n                                    continue\n\n                                vpcPairDict[\"vpc_pair\"][\"ptiID\"] = pti.getPolicyId()\n                                #vpcPairDict[\"vpc_pair\"][\"nvPairs\"] = copy.deepcopy(pti.getNvPairs())\n                                break\n\n                            peer1NvPairs = vpcMap[\"swToKp\"][vpcPairDict[\"peer1Sn\"]][\"pairInfo\"]\n                            peer2NvPairs = vpcMap[\"swToKp\"][vpcPairDict[\"peer2Sn\"]][\"pairInfo\"]\n\n                            kpVrf = peer1NvPairs.get(\"KEEP_ALIVE_VRF\", None)\n                            if kpVrf == None:\n                                kpVrf = MGMT_VRF_NAME\n                            nvpairs = { \"DOMAIN_ID\" : peer1NvPairs[\"DOMAIN_ID\"],\n                                        \"PEER1_KEEP_ALIVE_LOCAL_IP\": peer1NvPairs[\"KEEP_ALIVE_LOCAL_IP\"],\n                                        \"PEER2_KEEP_ALIVE_LOCAL_IP\": peer2NvPairs[\"KEEP_ALIVE_LOCAL_IP\"],\n                                        \"KEEP_ALIVE_VRF\": kpVrf,\n                                        \"KEEP_ALIVE_HOLD_TIMEOUT\": peer1NvPairs.get(\"KEEP_ALIVE_HOLD_TIMEOUT\", \"3\"),\n                                        \"isVpcPlus\": \"false\",\n                                        \"fabricPath_switch_id\": \"\",\n                                        \"isVTEPS\": \"false\",\n                                        \"NVE_INTERFACE\": \"\",\n                                        \"PEER1_SOURCE_LOOPBACK\": \"\",\n                                        \"PEER2_SOURCE_LOOPBACK\": \"\",\n                                        \"PEER1_PRIMARY_IP\": \"\",\n                                        \"PEER2_PRIMARY_IP\": \"\",\n                                        \"LOOPBACK_SECONDARY_IP\": \"\",\n                                        \"PEER1_DOMAIN_CONF\": \"\",\n                                        \"PEER2_DOMAIN_CONF\": \"\"\n                                      }\n\n                            vpcPairDict[\"vpc_pair\"][\"nvPairs\"] = nvpairs\n\n                        # add an entry to our vpc pair dictionary\n                        hostPortResyncDict[\"vpcHostPairs\"][vpcPairkey] = vpcPairDict\n\n                        if deviceSn not in switchListWithSingleVpcSwitch:\n                            switchListWithSingleVpcSwitch.append(deviceSn)\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    if not isExternalFab:\n                        # collect the overlay host port attachment info, so that we know set of overlay vlans etc.\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 50,\n                            (\"%s - Gathering Overlay Network Host Port Attachments\" % (progressPrefix))) \n                        buildSwitchNetworkPortAttachments(FABRIC_NAME, globalOverlayInfo, hostPortResyncSwitches, respObj)\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    # get the current set of interfaces known in DCNM\n                    #Wrapper.print(\"%s: ****** Host Intf DB - vpcHostPairs1 = %s\" % (funcName,\n                    #    json.dumps(hostPortResyncDict[\"vpcHostPairs\"], indent=4, sort_keys=True)))\n                    Wrapper.print(\"%s: switchListWithSingleVpcSwitch %s\" % (funcName, switchListWithSingleVpcSwitch))\n                    for deviceSn in switchListWithSingleVpcSwitch:\n                        dict = switchInfoDict[deviceSn]\n                        gVarDictObj[\"DICTIONARY_OBJ\"] = dict\n                        #duplicate below two as postAdd doesn't pass \"DICTIONARY_OBJ\" as key\n                        gVarDictObj[\"deviceSerial\"] = deviceSn\n                        gVarDictObj[\"globalOverlayInfo\"] = globalOverlayInfo\n                        buildCurrentIntfInfoDb(FABRIC_NAME, gVarDictObj, respObj)\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    \"\"\"\n                    Wrapper.print(\"%s: ****** Host Intf DB - switches = %s\" % (funcName,\n                        json.dumps(hostPortResyncDict[\"switches\"], indent=4, sort_keys=True)))\n                    Wrapper.print(\"%s: ****** Host Intf DB - vpcHostPairs = %s\" % (funcName,\n                        json.dumps(hostPortResyncDict[\"vpcHostPairs\"], indent=4, sort_keys=True)))\n                    \"\"\"\n                    # device underlay progress range is 40% - 60%\n                    progressBase = 50\n                    numProcessed = 0\n                    for deviceSn in hostPortResyncSwitches:\n                        numProcessed += 1\n                        progress = progressBase + int(float(numProcessed)/float(numResync) * 20)\n\n                        dict = switchInfoDict[deviceSn]\n\n                        if not isExternalFab:\n                            utilObj = Util()\n                            allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n                            overlayVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n                            Wrapper.print(\"%s: Switch [%s] ALL_VLANS = [%d][%s] OVERLAY_VLANS = [%d][%s]\" %  (funcName, \n                                    dict[\"fmtName\"],\n                                    len(switchOverlayInfo[\"ALL_VLANS\"]), allVlansOnSwitchStr, \n                                    len(switchOverlayInfo[\"OVERLAY_VLANS\"]), overlayVlansOnSwitchStr))\n\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - %d of %d - Switch [%s] \"\n                            \"Processing Interfaces\" % (progressPrefix, numProcessed, numResync, dict[\"fmtName\"])))\n\n                        gVarDictObj[\"DICTIONARY_OBJ\"] = dict\n                        #duplicate below two as postAdd doesn't pass \"DICTIONARY_OBJ\" as key\n                        gVarDictObj[\"deviceSerial\"] = deviceSn\n                        gVarDictObj[\"globalOverlayInfo\"] = globalOverlayInfo\n\n                        Util.exe(buildHostPortResyncDb(FABRIC_NAME, gVarDictObj))\n\n                        # clear out the match results to avoid holding large data\n                        dict[\"matchResult\"] = dict[\"interfacesRes\"] = None\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    Wrapper.print(\"%s: ****** Host Intf DB - switches = %s\" % (funcName,\n                        json.dumps(hostPortResyncDict[\"switches\"], indent=4, sort_keys=True)))\n                    Wrapper.print(\"%s: ****** Host Intf DB - vpcHostPairs = %s\" % (funcName,\n                        json.dumps(hostPortResyncDict[\"vpcHostPairs\"], indent=4, sort_keys=True)))\n\n                    # validate the changes for unsupported cases\n                    validateOOBChanges(FABRIC_NAME, globalOverlayInfo, respObj)\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    # now that the switch interface DB is built.. do the necessary PTI updates\n                    updateHostPortPolicies(FABRIC_NAME, progressPrefix, 70, 20, globalOverlayInfo, respObj)\n\n                    # do not proceed if there are errors\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    if not isExternalFab:\n                        # update the overlay port attachments\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 90,\n                                (\"%s - Updating Overlay Network Host Port Attachments\" % (progressPrefix))) \n                        updateSwitchNetworkPortAttachments(FABRIC_NAME, progressPrefix, 90, 10, globalOverlayInfo, respObj)\n\n                    if not respObj.isRetCodeFailure():\n                        # the operation completed successfully... take switches out of the resync mode\n                        for devSerial in hostPortResyncSwitches:\n                            Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.SIM_PTI, \"host_syncup_completed\", {}))\n                            ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"host_port_resync\"))\n                            for pti in ptiList:\n                                PTI.deleteInstance(pti.getPolicyId())\n                elif numChangeIP:\n                    # need to update the following intent:\n                    #   1. mgmt0 policy with int_mgmt\n                    #   2. switch_freeform with description \"management vrf configuration\" - Greenfield case\n                    #   3. the contents of vrf context management inside switch_freeform \n                    #       with description \"Pre Interfaces Configuration\" - Brownfield case\n                    #   4. v4_mgmt_default_gateway\n                    #   5. dns-vrfList PTI processing\n                    #   6. vpc domain update\n                    # progress range is 40% - 80%\n                    progressBase = 40\n                    numProcessed = 0\n                    vPcPairsList = []\n                    for deviceSn in switchList:\n                        numProcessed += 1\n                        progress = progressBase + int(float(numProcessed)/float(numChangeIP) * 40)\n                        swInfo = switchInfoDict[deviceSn]\n\n                        Wrapper.print(\"%s: *********** CHANGE IP - START - %d of %d - Switch [%s]\" % (funcName, \n                            numProcessed, numChangeIP, swInfo[\"fmtName\"]))\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - %d of %d - Switch [%s] \"\n                            \"Processing Switch\" % (progressPrefix, numProcessed, numChangeIP, swInfo[\"fmtName\"])))\n\n                        if isFabricInbandMgmt:\n                            seedIP = Util.exe(Helper.getSeedIp(deviceSn))\n                            # get the current PYTHON policy for the routing loopback intf and update with the seed ip\n                            ptiList = Util.exe(PTIWrapper.getPTIs(deviceSn, \"INTERFACE\", getLbIntfName(\"bgp\"), \"PYTHON\"))\n                            for pti in ptiList:\n                                nvPairs = copy.deepcopy(pti.getNvPairs())\n                                nvPairs[\"IP\"] = Util.exe(Helper.getSeedIp(deviceSn))\n                                Util.exe(PTI.updateInstance(pti.getPolicyId(), nvPairs))\n                                break\n                            continue\n\n                        # relevant for OOB mgmt\n                        # get the match related file names to be used\n                        getMigrationFileNames(swInfo)\n                        # get the matching results\n                        swInfo[\"matchResult\"] = Util.exe(getJSONFileContents(swInfo[\"matchResultsFileName\"]))\n                        swInfo[\"interfacesRes\"] = Util.exe(getJSONFileContents(swInfo[\"interfaceMatchResultsFileName\"]))\n            \n                        matchResults = swInfo[\"matchResult\"]\n                        interfacesRes = swInfo[\"interfacesRes\"]\n\n                        intfName = \"mgmt0\"\n                        intfMatchResult = interfacesRes.get(intfName, None)\n                        if intfMatchResult is not None:\n                            templateNameMatches = intfMatchResult[\"matched_templates\"]\n                            matchingNvPairs = getIntfMatchNvPairs(matchResults, intfName, templateNameMatches)\n\n                            nvPairs = getMgmtIntfNvpairs(swInfo, intfName, matchingNvPairs)\n                            PTIWrapper.createOrUpdate(deviceSn, \"INTERFACE\", intfName, \"\", ConfigPriority.INTF_MGMT,\n                                                \"int_mgmt\", nvPairs)\n\n                        mgmtVrfFF = getVrfCfg(MGMT_VRF_NAME, matchResults, False)\n                        if mgmtVrfFF:\n                            # there is some mgmt vrf config that we may need to update\n                            vrfPti = None\n                            ptiList = Util.exe(PTI.get(deviceSn, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n                            for pti in ptiList:\n                                if pti.isDeleted():\n                                    continue\n                                \n                                desc = pti.getDescription()\n                                if desc == GF_MGMT_VRF_FF_PTI_DESC:\n                                    vrfPti = pti\n                                elif desc == BF_PRE_INTF_FF_PTI_DESC:\n                                    vrfPti = pti\n\n                                if vrfPti:\n                                    newNvPairs = copy.deepcopy(vrfPti.getNvPairs())\n                                    updatedCfgList = updateMgmtVrfFF(newNvPairs[\"CONF\"], mgmtVrfFF, respObj)\n                                    if updatedCfgList:\n                                        newNvPairs[\"CONF\"] = Util.newLine().join(updatedCfgList)\n                                        # Wrapper.print(\"%s: Switch [%s] Change IP - new vrf cfg [%s]\" % (funcName, \n                                        #                                     swInfo[\"fmtName\"], newNvPairs[\"CONF\"]))\n                                        Util.exe(PTI.updateInstance(vrfPti.getPolicyId(), newNvPairs))\n                                    break\n                            \n                            if vrfPti is None:\n                                # we did not find a PTI, but, have some new content.. create new PTI\n                                createMgmtVrfPti(deviceSn, mgmtVrfFF)\n\n                        templateName = \"dns-vrfList\"\n                        srchOpt = CtrlPolicySearch()\n                        srchOpt.setSerialNumber(deviceSn)\n                        srchOpt.setTemplateName(templateName)\n                        ptiList = Util.exe(PTI.getPTIs(srchOpt))\n                        for pti in ptiList:\n                            if pti.isDeleted():\n                                continue\n                            \n                            if pti.getNvPairs().get(\"NAME_SERVER_VRF\") == MGMT_VRF_NAME:\n                                continue\n\n                            # delete this one since we will create new ones as needed\n                            PTI.deleteInstance(pti.getPolicyId())\n\n                        nvPairList = getTemplateMatchResults(matchResults, templateName)\n                        if nvPairList is not None:\n                            for nvPairs in nvPairList:\n                                if nvPairs[\"NAME_SERVER_VRF\"] != MGMT_VRF_NAME:\n                                    continue\n                            \n                                Util.exe(PTIWrapper.create(deviceSn, \"SWITCH\", \"SWITCH\", getSrc(templateName), \n                                            getPrio(templateName), templateName, nvPairs))\n\n                        templateName = \"v4_mgmt_default_gateway\"\n                        srchOpt = CtrlPolicySearch()\n                        srchOpt.setSerialNumber(deviceSn)\n                        srchOpt.setTemplateName(templateName)\n                        ptiList = Util.exe(PTI.getPTIs(srchOpt))\n                        for pti in ptiList:\n                            if pti.isDeleted():\n                                continue\n                            # delete this one since we will create new ones as needed\n                            PTI.deleteInstance(pti.getPolicyId())\n\n                        nvPairList = getTemplateMatchResults(matchResults, templateName)\n                        if nvPairList is not None:\n                            for nvPairs in nvPairList:\n                                Util.exe(PTIWrapper.create(deviceSn, \"SWITCH\", \"SWITCH\", getSrc(templateName), \n                                    getPrio(templateName), templateName, nvPairs))\n\n                        # check if the switch is a vPC pair\n                        newRespObj = VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, deviceSn)\n                        if newRespObj.isRetCodeSuccess():\n                            vpcPairKey = newRespObj.getValue()\n                            if vpcPairKey not in vPcPairsList:\n                                # will do additional checks later\n                                vPcPairsList.append(vpcPairKey)\n                        else:\n                            Wrapper.print(\"%s: Switch [%s] is not set as a vPC pair in DCNM\" % (funcName, swInfo[\"fmtName\"]))\n                        \n                        Wrapper.print(\"%s: *********** CHANGE IP - END - %d of %d - Switch [%s]\" % (funcName, \n                            numProcessed, numChangeIP, swInfo[\"fmtName\"]))\n\n                    # update vpc domain policies\n                    # progress range is 80% - 100%\n                    progressBase = 80\n                    numProcessed = 0\n                    numVpc = len(vPcPairsList)\n                    for vpcKeyPair in vPcPairsList:\n                        numProcessed += 1\n                        progress = progressBase + int(float(numProcessed)/float(numVpc) * 20)\n\n                        Wrapper.print(\"%s: *********** CHANGE IP - START vPC PAIR - %d of %d - VPC [%s]\" % (funcName, \n                            numProcessed, numVpc, vpcKeyPair))\n\n                        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - %d of %d - \"\n                            \"Processing vPC pair\" % (progressPrefix, numProcessed, numVpc)))\n\n                        serials = vpcKeyPair.split(Helper.DELIMITER)\n                        peer1Serial = serials[0]\n                        peer2Serial = serials[1]\n\n                        # get the vpc_domain_mgmt PTI for each switch\n                        templateName = 'vpc_domain_mgmt'\n                        srchOpt = CtrlPolicySearch()\n                        srchOpt.setSerialNumber(peer1Serial)\n                        srchOpt.setTemplateName(templateName)\n                        p1PtiList = Util.exe(PTI.getPTIs(srchOpt))\n                        if len(p1PtiList) == 0:\n                            continue\n                        else:\n                            peer1Pti = p1PtiList[0]\n\n                        srchOpt.setSerialNumber(peer2Serial)\n                        p2PtiList = Util.exe(PTI.getPTIs(srchOpt))\n                        if len(p2PtiList) == 0:\n                            continue\n                        else:\n                            peer2Pti = p2PtiList[0]\n\n                        # get the seed IPs\n                        peer1SeedIp = Util.exe(Helper.getSeedIp(peer1Serial))\n                        peer2SeedIp = Util.exe(Helper.getSeedIp(peer2Serial))\n\n                        peer1NvPairs = copy.deepcopy(peer1Pti.getNvPairs())\n                        peer2NvPairs = copy.deepcopy(peer2Pti.getNvPairs())\n\n                        # Wrapper.print(\"%s: Change Discovery IP - VPC - peer1Serial [%s]: IP [%s] -> [%s],\"\n                        #             \"peer2Serial [%s]: IP [%s] -> [%s]\" % (funcName,\n                        #             switchInfoDict[peer1Serial][\"fmtName\"], nvPairs[\"PEER1_KEEP_ALIVE_LOCAL_IP\"], peer1SeedIp,\n                        #             switchInfoDict[peer2Serial][\"fmtName\"], nvPairs[\"PEER2_KEEP_ALIVE_LOCAL_IP\"], peer2SeedIp))\n\n                        peer1NvPairs[\"KEEP_ALIVE_PEER_IP\"]  = peer2SeedIp\n                        peer1NvPairs[\"KEEP_ALIVE_LOCAL_IP\"]  = peer1SeedIp\n                        peer2NvPairs[\"KEEP_ALIVE_PEER_IP\"]  = peer1SeedIp\n                        peer2NvPairs[\"KEEP_ALIVE_LOCAL_IP\"]  = peer2SeedIp\n\n                        Util.exe(PTI.updateInstance(peer1Pti.getPolicyId(), peer1NvPairs))\n                        Util.exe(PTI.updateInstance(peer2Pti.getPolicyId(), peer2NvPairs))\n\n                        Wrapper.print(\"%s: *********** CHANGE IP - END vPC PAIR - %d of %d - VPC [%s]\" % (funcName, \n                            numProcessed, numVpc, vpcKeyPair))\n\n                    # the operation completed successfully... take switches out of the change IP mode\n                    for deviceSn in switchList:\n                        # get switch out of the migration mode\n                        PTI.delete(deviceSn, \"SWITCH\", \"SWITCH\", \"\", \"switch_migration_state\")\n\n                FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 100, (\"%s - Completed\" % (progressPrefix)))\n\n                if (isExternalFab or respObj.isRetCodeFailure()):\n                    return respObj\n\n                for devSerial in devices:\n                    if Util.isSwitchInMigrationState(devSerial):\n                        Wrapper.print(\"%s: Switch [%s] still in migration mode\" % (funcName, devSerial))\n                        respObj.addErrorReport(getFabErrEntity(funcName),\n                            \"Switches are still in migration mode. Please resolve all errors and retry Recalculate & Deploy.\")\n                        respObj.setFailureRetCode()\n                        return respObj\n\n                Wrapper.print(\"%s: Migration is completed, now execute Save\" % funcName)\n                if ACTIVE_MIGRATION == \"true\":\n                    # take the fabric out of migration mode (upgrade case)\n                    FabricWrapper.update(FABRIC_NAME, \"ACTIVE_MIGRATION\", \"false\")\n            finally:\n                if (progressPrefix == \"Brownfield\"):\n                    # clear the BF import activity\n                    Util.exe(FabricWrapper.clearFabricActivity(FABRIC_NAME))\n    except Exception as e:\n        msg = (\"Unexpected error during Brownfield/Upgrade Processing. Please fix errors and retry Recalculate & Deploy\")\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"BROWNFIELD_UPGRADE\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        return respObj\n\ndef updateMgmtVrfFF(ffCfg, newMgmtVrfCfg, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    # Wrapper.print(\"%s: ffCfg [%s]\" % (funcName, ffCfg))\n    # Wrapper.print(\"%s: newMgmtVrfCfg [%s]\" % (funcName, newMgmtVrfCfg))\n    newCfgList = None\n    newMgmtVrfCfgList = newMgmtVrfCfg.splitlines()\n    try:\n        cfgList = []\n        lines = ffCfg.splitlines()\n        saveBlock = True\n        for line in lines:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                # top level CLI\n                # Wrapper.print(\"%s: Line [%s]\" % (funcName, line))\n                if (line.strip() == \"vrf context management\"):\n                    # add in the new config\n                    # Wrapper.print(\"%s: Found vrf mgmt\" % (funcName))\n                    saveBlock = False\n                    cfgList.extend(newMgmtVrfCfgList)\n                    newCfgList = cfgList\n                else:\n                    saveBlock = True\n                \n            if saveBlock:\n                cfgList.append(line)\n        if newCfgList is None:\n            # we did not find any existing config.. so append the new config\n            cfgList.extend(newMgmtVrfCfgList)\n            newCfgList = cfgList\n    except Exception as e:\n        Util.handleException((\"%s: Error processing Mgmt Vrf Config updates\" % (funcName)), e, respObj)\n        newCfgList = None\n    \n    return newCfgList\n\n# returns the following SVI match results for a given vlan id\n#   - the interface result match entry\n#   - the nvPairs for the corresponding 'vlan_interface' policy\n# None indicates that the matching SVI does not exist\n\ndef getSviTemplateMatch(vlanId, matchResult, interfacesRes):\n    sviNvPair = None\n    sviVlanIntfRes = None\n\n    intfName = \"Vlan\" + vlanId\n    # first check if the intf exists\n    if intfName not in interfacesRes:\n        return sviVlanIntfRes, sviNvPair\n\n    intfRes = interfacesRes[intfName]\n    if UNDERLAY_IS_V6 == \"true\":\n        templateName = \"v6_vlan_interface_link_local\" if USE_LINK_LOCAL == \"true\" else \"v6_vlan_interface\"\n    else:\n        templateName = \"vlan_interface\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            if (nvPair[\"INTF_NAME\"] == intfName):\n                sviVlanIntfRes = intfRes\n                sviNvPair = nvPair\n                break\n \n    return sviVlanIntfRes, sviNvPair\n\ndef getFabricIntefaces(topologyDataObj, sn, switchRole):\n    fabricInterfaces = []\n    allFabricInterfaces = topologyDataObj.get(TopologyInfoType.ALL_FABRIC_INTFS, sn)\n    for fabricIntf in allFabricInterfaces:\n        neighborSn = topologyDataObj.get(TopologyInfoType.NEIGHBOR_SN, sn, fabricIntf)\n        if neighborSn:\n            neighborFabricInterface = topologyDataObj.get(TopologyInfoType.NEIGHBOR_INTF, sn, fabricIntf)\n            if neighborSn and neighborFabricInterface:\n                # ignore physical links between switches of same role (ex: links between vpc pairs)\n                peerRole = topologyDataObj.getSwitchRole(neighborSn)\n                if switchRole != peerRole:\n                   fabricInterfaces.append(fabricIntf)\n    return fabricInterfaces\n\ndef getIntfTemplateNvpair(intfName, templateName, matchResult):\n    nvPair = None\n    #Wrapper.print(\"getIntfTemplateNvpair: intf [%s] template [%s]\" % (intfName, templateName))\n    if templateName in matchResult:\n        nvPairs = matchResult[templateName]\n        for entry in nvPairs:\n            if entry[\"INTF_NAME\"] == intfName:\n                nvPair = entry\n                break\n    return nvPair\n\ndef checkBfd(switchInfoDict, devSerial, fabricInterfaces, matchResult, interfacesRes, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    fmtName = switchInfoDict[\"fmtName\"]\n\n    if BFD_ENABLE == \"false\":\n        # do not check further\n        return\n\n    # check BFD feature\n    nvPairList = getTemplateMatchResults(matchResult, \"feature_bfd\")\n    if (nvPairList == None):\n        if BFD_ENABLE == \"true\":\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BFD_ENABLE\"),\n               \"BFD feature not enabled on switch, but, enabled in fabric settings\", devSerial)\n            respObj.setFailureRetCode()\n        \n    # po member policies\n    poMemberPoliciesSet = set([\"port_channel_mode_on\", \"port_channel_mode\"])\n\n    localFabricInterfaces = copy.deepcopy(fabricInterfaces)\n\n    # add the peer link SVI to the list to check\n    sviIntf, sviNvPair = getSviTemplateMatch(switchInfoDict[\"vpcInfo\"][\"peerLinkVlan\"], matchResult, interfacesRes)\n    if sviNvPair:\n        localFabricInterfaces.append(sviNvPair[\"INTF_NAME\"])\n\n    # validate all the expected configs on the fabric interfaces\n    for fabricIntf in localFabricInterfaces:\n        intfMatchEntry = interfacesRes[fabricIntf]\n\n        # skip PO members\n        if poMemberPoliciesSet.intersection(set(intfMatchEntry[\"matched_templates\"])):\n            Wrapper.print(\"%s: Switch [%s] skipping po member fabric interface [%s]\" % (funcName, fmtName, fabricIntf))\n            continue\n\n        # check for bfd auth\n        templateName = \"bfd_interface_auth\"\n        nvPair = getIntfTemplateNvpair(fabricIntf, templateName, matchResult)\n        if BFD_AUTH_ENABLE == \"true\":\n            isError = False\n            if nvPair:\n                if ((nvPair[\"BFD_AUTH_KEY\"] != BFD_AUTH_KEY) or\n                    (nvPair[\"BFD_AUTH_KEY_ID\"] != BFD_AUTH_KEY_ID)):\n                    isError = True\n\n            if isError:\n                params = {\"INTF_NAME\" : fabricIntf, \"BFD_AUTH_KEY\" : BFD_AUTH_KEY, \"BFD_AUTH_KEY_ID\" : BFD_AUTH_KEY_ID}\n                cfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, params, False, None)\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BFD_AUTH\"),\n                   \"Fabric interface [%s]: Required BFD interface authentication configuration mismatch or missing. \"\n                   \"Please configure the following: %s%s\" % (fabricIntf, Util.newLine(), cfg), devSerial)\n                respObj.setFailureRetCode()\n\ndef getShowRunConfigBlocks(fileName, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    configBlocks = {}\n    # open the test file and read line by line\n    file = None\n    try:\n        file = open(fileName, 'r')\n        lines = file.read().splitlines()\n        for line in lines:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                # top level CLIs\n                saveBlock = False\n                sectionKey = None\n                blockKey = None\n                cfgList = None\n                if (line.startswith(\"router ospf \") or line.startswith(\"router ospfv3 \")):\n                    sectionKey = \"ROUTER_OSPF\"\n                    saveBlock = True\n                elif line.startswith(\"router isis \"):\n                    sectionKey = \"ROUTER_ISIS\"\n                    saveBlock = True\n                elif line.startswith(\"key chain \"):\n                    sectionKey = \"KEY_CHAIN\"\n                    saveBlock = True\n                \n                if saveBlock:\n                    if sectionKey not in configBlocks:\n                        configBlocks[sectionKey] = {}\n                    cfgList = []\n                    configBlocks[sectionKey][line] = cfgList\n\n            if saveBlock:\n                cfgList.append(line)\n    except Exception as e:\n        Util.handleException((\"Error reading from file [%s] trying to extract config blocks\" % fileName), e, respObj)\n    finally:\n        if file:\n            file.close()\n        return configBlocks\n\ndef checkAuthAndFabricIntfs(switchInfoDict, devSerial, switchRole, fabricInterfaces, \n                                vpcPeerLinkVlanFound, matchResult, interfacesRes, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    fmtName = switchInfoDict[\"fmtName\"]\n\n    Wrapper.print(\"%s: Switch [%s] fabricInterfaces %s\" % (funcName, fmtName, fabricInterfaces))\n\n    localFabricInterfaces = copy.deepcopy(fabricInterfaces)\n\n    # add the loopback and vpc peer link svi to the list (if present)\n    loInf = getLbIntfName(\"bgp\")\n    if loInf in interfacesRes:\n        localFabricInterfaces.append(loInf)\n\n    if switchRole != \"spine\":\n        loInf = getLbIntfName(\"nve\")\n        if loInf in interfacesRes:\n            localFabricInterfaces.append(loInf)\n    \n    \"\"\"\n    if vpcPeerLinkVlanFound:\n        localFabricInterfaces.append(\"Vlan\" + VPC_PEER_LINK_VLAN)\n    \"\"\"\n\n    # check some global parameters first\n    isisKeychainAuthNvPair = None\n    isisAuthNvPair = None\n    if LINK_STATE_ROUTING == \"is-is\":\n        nvPairList = getTemplateMatchResults(matchResult, \"base_isis_auth\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if (nvPair[\"ISIS_TAG\"] == LINK_STATE_ROUTING_TAG):\n                    isisAuthNvPair = nvPair\n                    break\n            if isisAuthNvPair:\n                if (ISIS_AUTH_ENABLE != \"true\"):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                       \"ISIS Area Authentication found, but, not enabled in fabric settings\", devSerial)\n                    respObj.setFailureRetCode()\n            else:\n                if (ISIS_AUTH_ENABLE == \"true\"):\n                    nvPairs = {\"ISIS_TAG\" : LINK_STATE_ROUTING_TAG, \"IS_TYPE\" : ISIS_LEVEL,\n                               \"ISIS_AUTH_KEYCHAIN_NAME\" : ISIS_AUTH_KEYCHAIN_NAME}\n                    expectedCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(\"base_isis_auth\", nvPairs, False, None)\n\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                       \"ISIS Area Authentication configuration not found, but, enabled in fabric settings. Expected configuration [%s]\" %\n                       (expectedCfg), devSerial)\n                    respObj.setFailureRetCode()\n        else:\n            if (ISIS_AUTH_ENABLE == \"true\"):\n                # switch does not auth configured, but, fabric has configuration\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                   \"ISIS Area Authentication not configured\", devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n        if (ISIS_AUTH_ENABLE == \"true\"):\n            # check the keychain also if ISIS Auth is enabled\n            nvPairList = getTemplateMatchResults(matchResult, \"keychain\")\n            if (nvPairList != None):\n                for nvPair in nvPairList:\n                    #Wrapper.print(\"Switch [%s] Processing keychain [%s, %s]\" %\n                    #    (devSerial, nvPair[\"KEYCHAIN_NAME\"], nvPair[\"KEYCHAIN_ID\"]))\n                    if ((nvPair[\"KEYCHAIN_NAME\"] == ISIS_AUTH_KEYCHAIN_NAME) and\n                        (nvPair[\"KEYCHAIN_ID\"] == ISIS_AUTH_KEYCHAIN_KEY_ID) and (nvPair[\"AUTH_KEY\"] == ISIS_AUTH_KEY)):\n                        # this keychain is what we are looking for\n                        isisKeychainAuthNvPair = nvPair\n                        break\n            if not isisKeychainAuthNvPair:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                   \"ISIS Authentication keychain for Name, Id, Key [%s, %s, %s] not found\" % \n                    (ISIS_AUTH_KEYCHAIN_NAME, ISIS_AUTH_KEYCHAIN_KEY_ID, ISIS_AUTH_KEY), devSerial)\n                respObj.setFailureRetCode()\n            else:\n                if (isisAuthNvPair and (isisAuthNvPair[\"ISIS_AUTH_KEYCHAIN_NAME\"] != isisKeychainAuthNvPair[\"KEYCHAIN_NAME\"])):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                       \"ISIS Area Authentication keychain name [%s] does not match configured keychain name [%s]\" %\n                       (isisAuthNvPair[\"ISIS_AUTH_KEYCHAIN_NAME\"], isisKeychainAuthNvPair[\"KEYCHAIN_NAME\"]), devSerial)\n                    respObj.setFailureRetCode()\n    else:\n        nvPairList = getTemplateMatchResults(matchResult, \"base_ospf_auth\")\n        ospfAuthInstanceNvpair = None\n        if (nvPairList != None):\n            # there could be multiple OSPF instances.. look for the one matching the fabric setting\n            for nvPair in nvPairList:\n                if nvPair[\"OSPF_TAG\"] == LINK_STATE_ROUTING_TAG:\n                    ospfAuthInstanceNvpair = nvPair\n                    break\n\n        if (OSPF_AUTH_ENABLE == \"true\"):\n            if not ospfAuthInstanceNvpair:\n                # switch does not auth configured, but, fabric has configuration\n                nvPairs = {\"OSPF_TAG\" : LINK_STATE_ROUTING_TAG, \"OSPF_AREA_ID\" : OSPF_AREA_ID}\n                expectedCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(\"base_ospf_auth\", nvPairs, False, None)\n\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                   \"OSPF Message Digest Authentication not configured. Expected configuration [%s]\" % (expectedCfg), devSerial)\n                respObj.setFailureRetCode()\n        else:\n            if ospfAuthInstanceNvpair:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                   \"OSPF Message Digest Authentication found, but, not enabled in fabric settings\", devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n    # po member policies\n    poMemberPoliciesSet = set([\"port_channel_mode_on\", \"port_channel_mode\"])\n\n    fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n    inbandPoapEnabled = isInbandPoapEnabled(fabricSettings)\n\n    # validate all the expected configs on the interfaces\n    for fabricIntf in localFabricInterfaces:\n        intfMatchEntry = interfacesRes[fabricIntf]\n        isLoopbackIntf = False\n        if fabricIntf.startswith(\"loopback\"):\n            isLoopbackIntf = True\n\n        # skip PO members\n        if poMemberPoliciesSet.intersection(set(intfMatchEntry[\"matched_templates\"])):\n            Wrapper.print(\"%s: Switch [%s] skipping po member fabric interface [%s]\" %\n                (funcName, fmtName, fabricIntf))\n            continue\n\n        if not isLoopbackIntf:\n            if FABRIC_INTERFACE_TYPE == \"p2p\":\n                if UNDERLAY_IS_V6 == \"false\":\n                    nvPair = getIntfTemplateNvpair(fabricIntf, \"p2p_routed_interface\", matchResult)\n                    if not nvPair:\n                        # check for inband POAP case\n                        if inbandPoapEnabled == \"true\":\n                            nvPair = getIntfTemplateNvpair(fabricIntf, \"p2p_routed_interface_tag\", matchResult)\n                            if not nvPair:\n                                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":P2P\"),\n                                    \"Underlay is V4. Fabric interface [%s]: Required [%s] interface configuration not found with Inband POAP Enabled\" %\n                                    (fabricIntf, FABRIC_INTERFACE_TYPE), devSerial)\n                                respObj.setFailureRetCode()\n                        else:\n                            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":P2P\"),\n                                \"Underlay is V4. Fabric interface [%s]: Required [%s] interface configuration not found.\" %\n                                (fabricIntf, FABRIC_INTERFACE_TYPE), devSerial)\n                            respObj.setFailureRetCode()\n                elif USE_LINK_LOCAL == \"true\":\n                    nvPair = getIntfTemplateNvpair(fabricIntf, \"interface_ipv6_link_local\", matchResult)\n                    if not nvPair:\n                        nvPair = getIntfTemplateNvpair(fabricIntf, \"interface_ipv6_link_local_bia\", matchResult)\n                    if not nvPair:\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":P2P\"),\n                            \"Underlay is V6 and Link-Local is enabled. Fabric interface [%s]: Required [%s + link-local] interface configuration not found\" %\n                           (fabricIntf, FABRIC_INTERFACE_TYPE), devSerial)\n                        respObj.setFailureRetCode()\n                else:\n                    nvPair = getIntfTemplateNvpair(fabricIntf, \"interface_ipv6_11_1\", matchResult)\n                    if not nvPair:\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":P2P\"),\n                            \"Underlay is V6. Fabric interface [%s]: Required [%s + ipv6] interface configuration not found\" %\n                            (fabricIntf, FABRIC_INTERFACE_TYPE), devSerial)\n                        respObj.setFailureRetCode()\n            else:\n                nvPair = getIntfTemplateNvpair(fabricIntf, \"unnumbered_fabric_interface_nov6\", matchResult)\n                if not nvPair:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":UNUMBERED\"),\n                           \"Fabric interface [%s]: Required [%s] interface configuration not found\" %\n                           (fabricIntf, FABRIC_INTERFACE_TYPE), devSerial)\n                    respObj.setFailureRetCode()\n        \n        # check the routing protocol specific parameters\n        if LINK_STATE_ROUTING == \"is-is\":\n            templateName = \"isis_interface\" if UNDERLAY_IS_V6 == \"false\" else \"v6_isis_interface\"\n            nvPair = getIntfTemplateNvpair(fabricIntf, templateName, matchResult)\n            if nvPair:\n                if (nvPair[\"ISIS_TAG\"] != LINK_STATE_ROUTING_TAG):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS\"),\n                        \"Fabric interface [%s]: ISIS related configuration mismatch. Found Process ID [%s], Expected [%s]\" %\n                        (fabricIntf, nvPair[\"ISIS_TAG\"], LINK_STATE_ROUTING_TAG), devSerial)\n                    respObj.setFailureRetCode()\n            else:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS\"),\n                    \"Fabric interface [%s]: Required ISIS interface configuration not found\" % (fabricIntf), devSerial)\n                respObj.setFailureRetCode()\n\n            # skip auth related checks for the loopback interfaces\n            if isLoopbackIntf:\n                continue\n\n            # check network point-to-point. Allow if ISIS_P2P_ENABLE is enabled on fabric, but missing in switch config, not the reverse\n            if (FABRIC_INTERFACE_TYPE == \"p2p\" or UNDERLAY_IS_V6 == \"true\") and ISIS_P2P_ENABLE != \"true\":\n                templateName = \"isis_p2p_interface\"\n                nvPair = getIntfTemplateNvpair(fabricIntf, templateName, matchResult)\n                if nvPair:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                        \"Fabric interface [%s]: ISIS network point-to-point found on switch configuration, but not enabled on fabric.\" %\n                        (fabricIntf), devSerial)\n                    respObj.setFailureRetCode()\n\n            # check the auth related config\n            if FABRIC_INTERFACE_TYPE == \"p2p\":\n                templateName = \"isis_interface_auth\"\n            else:\n                templateName = \"isis_interface_auth_no_lvl\"\n            nvPair = getIntfTemplateNvpair(fabricIntf, templateName, matchResult)\n            if not nvPair and FABRIC_INTERFACE_TYPE == \"p2p\" and ISIS_P2P_ENABLE == \"true\":\n                # ISIS_P2P_ENABLE case can also use auth_no_lvl, as in 11.5(2), matching this is also ok\n                nvPair = getIntfTemplateNvpair(fabricIntf, \"isis_interface_auth_no_lvl\", matchResult)\n            if not nvPair:\n                if (ISIS_AUTH_ENABLE == \"true\"):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                        \"Fabric interface [%s]: Required ISIS interface authentication related configuration not found\" %\n                        (fabricIntf), devSerial)\n                    respObj.setFailureRetCode()\n                    # proceed to next error check\n            else:\n                if (ISIS_AUTH_ENABLE == \"true\"):\n                    if isisKeychainAuthNvPair:\n                        if (nvPair[\"ISIS_AUTH_KEYCHAIN_NAME\"] != ISIS_AUTH_KEYCHAIN_NAME):\n                            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                               \"Fabric Interface [%s] - ISIS Authentication keychain name [%s] does not match fabric setting [%s]\" %\n                                        (fabricIntf, nvPair[\"ISIS_AUTH_KEYCHAIN_NAME\"], ISIS_AUTH_KEYCHAIN_NAME), devSerial)\n                            respObj.setFailureRetCode()\n                else:\n                    # intf has ISIS interface auth configured, but, not enabled in fabric\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS_AUTH\"),\n                        \"Fabric interface [%s]: ISIS interface authentication configuration found, but, not enabled in fabric settings\" %\n                        (fabricIntf), devSerial)\n                    respObj.setFailureRetCode()\n                    # proceed to next error check\n        else:\n            templateName = \"ospf_interface_11_1\" if UNDERLAY_IS_V6 == \"false\" else \"v6_ospf_interface\"\n            nvPair = getIntfTemplateNvpair(fabricIntf, templateName, matchResult)\n            if nvPair:\n                if ((nvPair[\"OSPF_TAG\"] != LINK_STATE_ROUTING_TAG) or (nvPair[\"OSPF_AREA_ID\"] != OSPF_AREA_ID)):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF\"),\n                        \"Fabric interface [%s]: OSPF related configuration mismatch. Found Process ID/Area [%s, %s], Expected [%s, %s]\" %\n                           (fabricIntf, nvPair[\"OSPF_TAG\"], nvPair[\"OSPF_AREA_ID\"], LINK_STATE_ROUTING_TAG, OSPF_AREA_ID), devSerial)\n                    respObj.setFailureRetCode()\n            else:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF\"),\n                   \"Fabric interface [%s]: Required OSPF interface configuration not found\" % (fabricIntf), devSerial)\n\n            # check the auth related config\n            nvPair = getIntfTemplateNvpair(fabricIntf, \"ospf_interface_auth\", matchResult)\n            if nvPair:\n                if (OSPF_AUTH_ENABLE != \"true\"):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                        \"Fabric interface [%s]: OSPF interface authentication configuration found, but, not enabled in fabric settings\" %\n                        (fabricIntf), devSerial)\n                    respObj.setFailureRetCode()\n                    # proceed to next error check\n                else:\n                    if ((nvPair[\"OSPF_AUTH_KEY\"] != OSPF_AUTH_KEY) or (nvPair[\"OSPF_AUTH_KEY_ID\"] != OSPF_AUTH_KEY_ID)):\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                           \"Fabric Interface [%s] - OSPF Authentication (Key ID, Key) [%s, %s]. Fabric setting [%s, %s]\" %\n                                (fabricIntf, nvPair[\"OSPF_AUTH_KEY_ID\"], nvPair[\"OSPF_AUTH_KEY\"], OSPF_AUTH_KEY_ID, OSPF_AUTH_KEY), devSerial)\n                        respObj.setFailureRetCode()\n                        # proceed to next error check\n            elif (OSPF_AUTH_ENABLE == \"true\"):\n                # switch does not auth configured, but, fabric has configuration\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                   \"Fabric interface [%s]: Required OSPF interface authentication configuration not found\" %\n                   (fabricIntf), devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n# returns two variables: hasVpcConfig, vpcDomainId\n#   hasVpcConfig - set to true if atleast some vpc domain config is found\n#   vpcDomainId  - the configured vpc domain id, None if not found\ndef getVpcDomainId(devSerial, matchResult):\n    # init to an invalid number\n    vpcDomainId = None\n    hasVpcConfig = False\n    vpcDomainTemplates = [\"vpc_delay_restore\", \"vpc_domain_autorecovery_default\", \"vpc_domain_virtual_peerlink_dscp\",\n            \"vpc_domain_autorecovery\", \"vpc_domain_default\", \"vpc_domain_ipv6_nd_11_1\", \"vpc_domain_l3_pka_vrf_11_1\",\n            \"vpc_domain_l3_vrf\", \"vpc_domain_mgmt_no_src_11_1\", \"vpc_domain_mgmt\"]\n    for template in vpcDomainTemplates:\n        if template in matchResult:\n            matchRes = matchResult[template]\n            if (len(matchRes) > 0):\n                hasVpcConfig = True\n                for nvPairs in matchRes:\n                    if \"DOMAIN_ID\" in nvPairs:\n                        vpcDomainId = nvPairs[\"DOMAIN_ID\"]\n                        break\n\n    Wrapper.print(\"getVpcDomainId: device [%s] hasVpcConfig [%s] vpcDomainId [%s]\" % (devSerial, hasVpcConfig, vpcDomainId))\n    return hasVpcConfig, vpcDomainId\n\ndef fabricUpgrade(gVarDictObj, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    try:\n        dictionaryObj = gVarDictObj[\"DICTIONARY_OBJ\"]\n        devSerial = dictionaryObj[\"deviceSerial\"]\n        topologyDataObj = gVarDictObj[\"topologyObj\"]\n        matchResult = dictionaryObj[\"matchResult\"]\n        interfacesRes = dictionaryObj[\"interfacesRes\"]\n\n        # build a dictionary of the BGP neighbors so that we can validate only BGP related entries that match our AS#.\n        # Note: this will be used in deviceUpgrade\n        bgpNeighborDict = {}\n        dictionaryObj[\"bgpNeighborDict\"] = bgpNeighborDict\n\n        switchRole = dictionaryObj[\"switchRole\"]\n        hostName = dictionaryObj[\"hostName\"]\n        formattedName = dictionaryObj[\"fmtName\"]\n        model = dictionaryObj[\"deviceModel\"]\n\n        isSpine = False\n        if topologyDataObj.check(TopologyInfoType.IS_SPINE, devSerial):\n            isSpine = True\n        Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s: Switch [%s] Model [%s] Role [%s] isSpine [%r] isN9KTahoe [%r]\" %\n                (FABRIC_NAME, funcName, formattedName, model, switchRole, isSpine, (not dictionaryObj[\"n9kIsNotTahoe\"])))\n\n        # port-profiles are not supported... look for them and report error\n        features_info = matchResult[\"FEATURES_INFO\"]\n        global_unaccounted = features_info[\"GLOBAL_UNACCTED\"][\"unaccounted\"]\n        isCdpError = False\n        isPortProfileFound = False\n        for line in global_unaccounted:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                if (line.startswith(\"port-profile\")):\n                    # port-profiles are not supported\n                    isPortProfileFound = True\n                elif ((line == \"no cdp enable\") or (line.startswith(\"cdp format device-id\"))):\n                    # CDP is disabled or system id is not in expected format\n                    isCdpError = True\n\n        if isPortProfileFound:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":PORT_PROFILE\"),\n                \"Port-Profiles are not supported. Please unconfigure all the port-profiles and retry.\",\n                devSerial)\n            respObj.setFailureRetCode()\n\n        if isCdpError:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial + \":CDP\"),\n                \"CDP is disabled and/or system id is in unexpected format. Please check documentation \"\n                \" for CDP requirements to update the switch configuration and retry.\", devSerial)\n            respObj.setFailureRetCode()\n\n        # vni ranges under 'interface nve1' is not supported\n        nveVnis = features_info[\"NVE_BLOCK\"].get(\"interface nve1\", None)\n        if nveVnis:\n            # look into each 'member vni xxx' config and check if it has a range\n            for nveCmd in nveVnis:\n                if not nveCmd.startswith(\"member vni\"):\n                    continue\n                nveVni = nveCmd.split(\" \")[2]\n                if \"-\" in nveVni:\n                    # we found a vni range.. report an error\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":NVE_VNI_RANGE\"),\n                        \"Unsupported VNI range [%s] under \\'interface nve1\\'. Please have individual \"\n                        \"VNIs and retry Recalculate & Deploy\" % (nveCmd), devSerial)\n                    respObj.setFailureRetCode()\n        vPCInfo = {\"virtualVPC\" : False, \"userPeerLinkVlanPtiId\" : None, \"peerLinkVlan\" : VPC_PEER_LINK_VLAN}\n        vPCInfo[\"hasVpcConfig\"], vPCInfo[\"domainId\"] = getVpcDomainId(devSerial, matchResult)\n        dictionaryObj[\"vpcInfo\"] = vPCInfo\n\n        # check if the user has specified a vpc peer link vlan by creating the 'vpc_peer_link_vlan' PTI\n        srchOpt = CtrlPolicySearch()\n        srchOpt.setSerialNumber(devSerial)\n        srchOpt.setSource(\"\")\n        srchOpt.setTemplateName(\"vpc_peer_link_vlan\")\n        ptis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n        for pti in ptis:\n            if pti.isDeleted():\n                continue\n            vPCInfo[\"userPeerLinkVlanPtiId\"] = pti.getPolicyId()\n            vPCInfo[\"peerLinkVlan\"] = pti.getNvPairs()[\"VLAN\"]\n            Wrapper.print(\"%s: Switch [%s] Found user specified vPC Peer Link Vlan [%s] PTI [%s]\" % (funcName, \n                formattedName, vPCInfo[\"peerLinkVlan\"], vPCInfo[\"userPeerLinkVlanPtiId\"]))\n            break\n        vpcPeerLinkVlanFound = False\n\n        if vPCInfo[\"domainId\"]:\n            # Do some sanity check for the vPC case\n            if ENABLE_FABRIC_VPC_DOMAIN_ID == \"true\":\n                # fabric is using same domain ids on all pairs.. it must match what is on the switch\n                if (vPCInfo[\"domainId\"] != FABRIC_VPC_DOMAIN_ID):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC\"),\n                           \"Please ensure the vPC Domain id on switch [%s] matches the fabric setting of [%s]\" %\n                           (vPCInfo[\"domainId\"], FABRIC_VPC_DOMAIN_ID), devSerial)\n                    respObj.setFailureRetCode()\n\n            sviIntf, sviNvPair = getSviTemplateMatch(vPCInfo[\"peerLinkVlan\"], matchResult, interfacesRes)\n            if sviNvPair:\n                vpcPeerLinkVlanFound = True\n            #   - check to make sure we have atleast one match for each of the vPC related templates\n            vpcTemplates = getVpcMandatoryTemplateList(dictionaryObj[\"n9kIsNotTahoe\"])\n            for templateName in vpcTemplates:\n                if (getTemplateMatchResults(matchResult, templateName) == None):\n                    if ((templateName == \"vpc_nve_loopback\") and \n                        getTemplateMatchResults(matchResult, \"vpc_nve_loopback_with_tag_11_1\") != None):\n                        continue\n                    if (templateName == \"vpc_nve_loopback\") and UNDERLAY_IS_V6 == \"true\":\n                        continue\n                    if ((templateName == \"vpc_peer_link_member_interface\") and \n                        getTemplateMatchResults(matchResult, \"vpc_domain_virtual_peerlink_dscp\") != None):\n                        continue\n                    # did not find any matches... vPC config is inconsistent\n                    Wrapper.print(\"%s: Switch [%s] Did not find a match for vPC template [%s]\" % (funcName, formattedName, templateName))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC\"),\n                               \"Did not find expected vPC configuration for [%s] template.\" % (templateName), devSerial)\n                    respObj.setFailureRetCode()\n                    isValidVPC = False\n            vPCInfo[\"virtualVPC\"] = False\n            nvPairList = getTemplateMatchResults(matchResult, \"vpc_domain_virtual_peerlink_dscp\")\n            if nvPairList:\n                vPCInfo[\"virtualVPC\"] = True\n\n            if not vPCInfo[\"virtualVPC\"] and not vpcPeerLinkVlanFound:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VPC_VLAN\"),\n                       \"vPC Peer Link Vlan/SVI is not matching with Fabric setting [%s]\" % (vPCInfo[\"peerLinkVlan\"]), devSerial)\n                respObj.setFailureRetCode()\n\n            if vPCInfo[\"virtualVPC\"] and vpcPeerLinkVlanFound:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC Virtual Peer link\"),\n                       \"vPC Peer Link Vlan/SVI should not be present with Virtual Peer Link Configuration [%s]\" %\n                       (vPCInfo[\"peerLinkVlan\"]), devSerial)\n                respObj.setFailureRetCode()\n\n            swVersionOk = Util.isSwVersionOk(devSerial, \"10.3.2\")\n            if vPCInfo[\"virtualVPC\"] and UNDERLAY_IS_V6 == \"true\" and not swVersionOk: \n                hostName = Util.exe(InventoryWrapper.getHostName(devSerial))\n                nxosImage = Util.exe(ImageManagementWrapper.getNXOSVersion(devSerial))\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":IPv6 Underlay Fabric Peering\"),\n                       \"vPC Virtual Peer Link with IPv6 Underlay is supported from 10.3.2 onwards, switch %s has %s\"%(hostName, nxosImage), devSerial)\n                respObj.setFailureRetCode()\n        else:\n            if vPCInfo[\"hasVpcConfig\"]:\n                # we did not find the vPC domain config match, report an error\n                templateName = \"base_vpc_domain_11_1\"\n                domainId = \"1000\"\n                if ENABLE_FABRIC_VPC_DOMAIN_ID == \"true\":\n                    domainId = FABRIC_VPC_DOMAIN_ID\n                params = {\"DOMAIN_ID\" : domainId}\n                cfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, params, False, None)\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC\"),\n                       \"Please ensure the following vPC domain configuration exists: %s%s\" % (Util.newLine(), cfg), devSerial)\n                respObj.setFailureRetCode()\n\n        Wrapper.print(\"%s: Switch [%s] vPC Info [%s]\" % (funcName, formattedName, vPCInfo))\n\n        if (not isSpine and not (\"border gateway\" in switchRole.lower())):\n            nvPairList = getTemplateMatchResults(matchResult, \"anycast_gateway\")\n            if (nvPairList != None):\n                configGw = Util.normalizeMac(ANYCAST_GW_MAC)\n                gw = nvPairList[0][\"ANYCAST_MAC\"].lower()\n                if (gw != configGw):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":GW\"),\n                           \"Found anycast-gateway [%s]. Fabric setting [%s]\" % (gw, ANYCAST_GW_MAC), devSerial)\n                    respObj.setFailureRetCode()\n                    # proceed to next error check\n            else:\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":GW\"),\n                                       \"Anycast-gateway not configured\", devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n        # check if the Fabric Settings doesn't match replication # matches the configured value\n        multicastConfigInSwitch = asmConfigInSwitch = asmRPConfigInSwitch = False\n\n        nvPairList = getTemplateMatchResults(matchResult, \"base_pim_asm_11_1\")\n        if (nvPairList != None):\n            multicastConfigInSwitch = asmConfigInSwitch = True\n            if REPLICATION_MODE != \"Multicast\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Ingress Replication Mode\"),\n                       \"Multicast Config Found. Fabric setting [%s]\" % (REPLICATION_MODE), devSerial)\n                respObj.setFailureRetCode()\n            elif RP_MODE != \"asm\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast RP Mode\"),\n                       \"PIM ASM Config Found. Fabric setting [%s]\" % (RP_MODE), devSerial)\n                respObj.setFailureRetCode()\n            else:\n                # there could be multiple matches for base_pim_asm_11_1 policy.. one must match the\n                # fabric setting, or at least a superset of the fabric setting ... error if not\n                foundMatch = False\n                foundMatchSuperset = False\n                warningMsg = \"\"\n                for pimAsmNvpair in nvPairList:\n                    mcastGroupSubnet = pimAsmNvpair[\"RP_GROUP\"].strip()\n                    if (mcastGroupSubnet == MULTICAST_GROUP_SUBNET):\n                        foundMatch = True\n                        break\n                    else:\n                        Wrapper.print(\"[%s] look for mcast group subnet match, mcastGroupSubnet %s\" % (devSerial, mcastGroupSubnet))\n                        switchIP, switchMask = mcastGroupSubnet.split('/')\n                        fabricIP, fabricMask = MULTICAST_GROUP_SUBNET.split('/')\n                        if int(switchMask) < 16 and int(switchMask) < int(fabricMask):\n                            newSubnet = Util.getSubnetStringWithPrefix(fabricIP, switchMask)\n                            if newSubnet == mcastGroupSubnet:\n                                foundMatchSuperset = True\n                                warningMsg += \"Found switch config of Multicast Group Subnet %s different from %s in fabric setting. Switch config will be overwritten by value in fabric setting. \" % (mcastGroupSubnet, MULTICAST_GROUP_SUBNET)\n                                Wrapper.print(\"[%s]: %s\" % (devSerial, warningMsg))\n\n                if not foundMatch:\n                    if not foundMatchSuperset:\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast Group Subnet\"),\n                           \"Missing Multicast ASM Group configuration on switch for the \\'ip pim rp-address\\' CLI. Expected multicast group [%s]\" %\n                           (MULTICAST_GROUP_SUBNET), devSerial)\n                        respObj.setFailureRetCode()\n                        # proceed to next error check\n                    else:\n                        warningMessage = \"[%s/%s]: %s\" % (hostName, devSerial, warningMsg)\n                        respObj.addWarnReport(getFabErrEntity(funcName, devSerial), warningMessage)\n                        respObj.setWarningRetCode()\n\n        nvPairList = getTemplateMatchResults(matchResult, \"base_pim_bidir_11_1\")\n        if (nvPairList != None):\n            multicastConfigInSwitch = True\n            if REPLICATION_MODE != \"Multicast\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Ingress Replication Mode\"),\n                                       \"Multicast Config Found. Fabric setting [%s]\" % (REPLICATION_MODE), devSerial)\n                respObj.setFailureRetCode()\n            elif RP_MODE != \"bidir\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast RP Mode\"),\n                                       \"PIM Bidir Config Found. Fabric setting [%s]\" % (RP_MODE), devSerial)\n                respObj.setFailureRetCode()\n            elif (len(nvPairList) > 2):\n                # Only 2 RPs are supported for bidir in brownfield migration\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast RP Mode\"),\n                                       \"PIM Bidir Config Found. Config indicates that more than 2 RPs are used. \"\n                                       \"Only 2 or less RPs are supported in brownfield migration for Bidir.\", devSerial)\n                respObj.setFailureRetCode()\n            # No need to check mcastGroupSubnet used in the customer config,\n            # any bidir config change after brownfield migration will require manual config\n\n        if REPLICATION_MODE == \"Multicast\" and multicastConfigInSwitch == False:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast Replication Mode\"),\n                                   \"No Multicast Config Found. Fabric setting [%s]\" % (REPLICATION_MODE), devSerial)\n            respObj.setFailureRetCode()\n\n        nvPairList = getTemplateMatchResults(matchResult, \"evpn_multisite\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if nvPair[\"siteId\"] != SITE_ID:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Miltisite ID\"),\n                       \"Found Site Id [%s]. Fabric setting [%s]\" % (nvPair[\"siteId\"], SITE_ID), devSerial)\n                    respObj.setFailureRetCode()\n                    break\n\n        nvPairList = getTemplateMatchResults(matchResult, \"anycast_rp\")\n        if (nvPairList != None):\n            multicastConfigInSwitch = asmRPConfigInSwitch = True\n            if RP_MODE != \"asm\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Multicast RP Mode\"),\n                                       \"PIM ASM Config Found. Fabric setting [%s]\" % (REPLICATION_MODE), devSerial)\n                respObj.setFailureRetCode()\n\n        nvPairList = getTemplateMatchResults(matchResult, \"pim_interface\")\n        if (nvPairList != None):\n            multicastConfigInSwitch = True\n\n        if multicastConfigInSwitch:\n            if REPLICATION_MODE == \"Ingress\":\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Ingress Replication Mode\"),\n                           \"Found Replication Mode # [%s]. Fabric setting [%s]\" % (\"Multicast\", REPLICATION_MODE), devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n        # check if the Fabric Settings of LINK_STATE_ROUTING matches the configured value\n        if LINK_STATE_ROUTING == \"ospf\":\n            ospfInstanceNvpair = None\n            templateName = \"base_ospf\" if UNDERLAY_IS_V6 == \"false\" else \"base_ospfv3\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            if (nvPairList != None):\n                # there could be multiple OSPF instances.. look for the one matching the fabric setting\n                for nvPair in nvPairList:\n                    if nvPair[\"OSPF_TAG\"] == LINK_STATE_ROUTING_TAG:\n                        ospfInstanceNvpair = nvPair\n                        break\n\n            if not ospfInstanceNvpair:\n                # we did not find the expected OSPF instance\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF Routing Tag\"),\n                   \"Did not find OSPF instance [%s]. Please ensure device has expected configuration as defined in the base_ospf policy\" %\n                            (LINK_STATE_ROUTING_TAG), devSerial)\n                respObj.setFailureRetCode()\n        else:\n            isisInstanceNvpair = None\n            nvPairList = getTemplateMatchResults(matchResult, \"base_isis_level2_internal\")\n            if (nvPairList != None):\n                # there could be multiple ISIS instances.. look for the one matching the fabric setting\n                for nvPair in nvPairList:\n                    if LINK_STATE_ROUTING_TAG == nvPair[\"ISIS_TAG\"]:\n                        isisInstanceNvpair = nvPair\n                        if nvPair[\"IS_TYPE\"] != ISIS_LEVEL:\n                            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS Level\"),\n                                \"ISIS Level on the device [%s] does not match fabric setting [%s]\" %\n                                (nvPair[\"IS_TYPE\"], ISIS_LEVEL), devSerial)\n                            respObj.setFailureRetCode()\n                            # proceed to next error check\n                        break\n            if not isisInstanceNvpair:\n                # we did not find the expected ISIS instance\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":ISIS Routing Tag\"),\n                   \"Did not find ISIS instance [%s]. Please ensure device has expected configuration.\" %\n                            (LINK_STATE_ROUTING_TAG), devSerial)\n                respObj.setFailureRetCode()\n\n        # check if the BGP AS # matches the configured value\n        bgpConfigFound = False\n        nvPairList = getTemplateMatchResults(matchResult, \"base_bgp\")\n        if (nvPairList != None):\n            bgpConfigFound = True\n            # we expect only one\n            switchBgpAs = nvPairList[0][\"BGP_AS\"].strip()\n            if (switchBgpAs != BGP_AS):\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AS\"),\n                               \"Found BGP AS # [%s]. Fabric setting [%s]\" % (switchBgpAs, BGP_AS), devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n        else:\n            # no BGP config... error on a leaf\n            if (topologyDataObj.check(TopologyInfoType.IS_LEAF, devSerial) or\n                topologyDataObj.check(TopologyInfoType.IS_BORDER_LEAF, devSerial) or\n                topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_LEAF, devSerial)):\n                Wrapper.print(\"Switch is Leaf from TD, but no BGP config or no BGP router-id configured\")\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AS\"),\n                                     \"BGP not configured or no BGP router-id configured.\", devSerial)\n                respObj.setFailureRetCode()\n                # proceed to next error check\n\n        # look for both rr and non rr neighbor entries... check for the RR entries first\n        templateName = \"evpn_bgp_rr\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            for matchDict in nvPairList:\n                neighborIp = matchDict[\"BGP_NEIGHBOR_IP\"]\n                if (matchDict[\"BGP_AS\"] == BGP_AS):\n                    isInternal = True\n                else:\n                    isInternal = False\n                    matchDict = None\n\n                if neighborIp not in bgpNeighborDict:\n                    bgpNeighborDict[neighborIp] = {\"neighbor\" : matchDict, \"isInternal\" : isInternal}\n\n        templateName = \"evpn_bgp_rr_neighbor\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr_neighbor\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            for matchDict in nvPairList:\n                neighborIp = matchDict[\"BGP_NEIGHBOR_IP\"]\n                if (matchDict[\"BGP_AS\"] == BGP_AS):\n                    isInternal = True\n                else:\n                    isInternal = False\n                    matchDict = None\n\n                if neighborIp not in bgpNeighborDict:\n                    bgpNeighborDict[neighborIp] = {\"neighbor\" : matchDict, \"isInternal\" : isInternal}\n\n        bgpPwNvPairList = getTemplateMatchResults(matchResult, \"evpn_bgp_neighbor_auth\")\n        v6BgpPwNvPairList = getTemplateMatchResults(matchResult, \"v6_evpn_bgp_neighbor_auth\")\n        if v6BgpPwNvPairList != None:\n            if bgpPwNvPairList != None:\n                # merge the lists and process together\n                bgpPwNvPairList += v6BgpPwNvPairList\n            else:\n                bgpPwNvPairList = v6BgpPwNvPairList\n\n        if (bgpPwNvPairList != None):\n            for matchDict in bgpPwNvPairList:\n                neighborIp = matchDict[\"BGP_NEIGHBOR_IP\"]\n                key = \"bgpAuth\"\n                if neighborIp not in bgpNeighborDict:\n                    # we found a BGP password entry that did not match our BGP neighbor policy.. must be for\n                    # an external neighbor entry.. save it so that we can create the entry\n                    # Note: the actual bgp neighbor config will be in the unaccounted config\n                    bgpNeighborDict[matchDict[\"BGP_NEIGHBOR_IP\"]] = {\"neighbor\" : None, \n                                                    \"isInternal\" : False, key : matchDict}\n                    continue\n\n                # a neighbor we need to check against\n                neighborEntry = bgpNeighborDict[neighborIp]\n                if not neighborEntry[\"isInternal\"]:\n                    # update our neighbor dictionary with this info.. nothing more to check\n                    neighborEntry[key] = matchDict\n                    continue\n\n                # additional checks for internal neighbors\n                isBgpAuthMatchFail = ((matchDict[\"BGP_AUTH_KEY\"] != BGP_AUTH_KEY) or \n                    (matchDict[\"BGP_AUTH_KEY_TYPE\"] != BGP_AUTH_KEY_TYPE))\n                if (BGP_AUTH_ENABLE == \"true\"):\n                    if isBgpAuthMatchFail:\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AUTH\"),\n                           \"Found BGP Auth Key [%s, %s] for neighbor [%s]. Fabric setting [%s, %s]\"\n                                % (matchDict[\"BGP_AUTH_KEY_TYPE\"], matchDict[\"BGP_AUTH_KEY\"],\n                                    neighborIp, BGP_AUTH_KEY_TYPE, BGP_AUTH_KEY), devSerial)\n                        respObj.setFailureRetCode()\n                    else:\n                        # update our neighbor dictionary with this info\n                        neighborEntry[key] = matchDict\n                else:\n                    # BGP Auth configured on switch, but, not enabled in the fabric.. do not report\n                    # error.. will let the config get removed to follow setting\n                    pass\n\n        bfdNvPairList = getTemplateMatchResults(matchResult, \"bfd_bgp_neighbor\")\n        if (bfdNvPairList != None):\n            for matchDict in bfdNvPairList:\n                neighborIp = matchDict[\"BGP_NEIGHBOR_IP\"]\n                key = \"bfd\"\n                if neighborIp not in bgpNeighborDict:\n                    # we found a BGP password entry that did not match our BGP neighbor policy.. must be for\n                    # an external neighbor entry.. save it so that we can create the entry\n                    # Note: the actual bgp neighbor config will be in the unaccounted config\n                    bgpNeighborDict[matchDict[\"BGP_NEIGHBOR_IP\"]] = {\"neighbor\" : None, \n                                                    \"isInternal\" : False, key : matchDict}\n                    continue\n\n                # save info.. nothing to check\n                neighborEntry = bgpNeighborDict[neighborIp]\n                neighborEntry[key] = matchDict\n        \n        isBGW = topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_LEAF, devSerial)\n        if (topologyDataObj.check(TopologyInfoType.IS_LEAF, devSerial) or\n            topologyDataObj.check(TopologyInfoType.IS_BORDER_LEAF, devSerial) or isBGW):\n\n            if not isBGW:\n                # do not enforce for BGP role due to special case for EPL\n                templateName = \"evpn_bgp_rr\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr\"\n                nvPairList = getTemplateMatchResults(matchResult, templateName)\n                if (nvPairList != None):\n                    Wrapper.print(\"Switch is Leaf from TD, can not be BGP RR\")\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_RR\"),\n                                           \"Cannot be BGP RR due to its leaf role.\", devSerial)\n                    respObj.setFailureRetCode()\n\n            # TRM check\n            # TBD: Need to support brownfield for border spine and border gateway spine\n            nvPairList = getTemplateMatchResults(matchResult, \"mvpn_bgp_rr_neighbor\")\n            l3trm_nvPairList = getTemplateMatchResults(matchResult, \"l3_trm\")\n            if ENABLE_TRM == \"true\":\n                if nvPairList == None and not IBGP_PEER_TEMPLATE:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":TRM\"),\n                                       \"mvpn_bgp_rr_neighbor config not found while Tenant Routed Multicast is enabled.\", devSerial)\n                    respObj.setFailureRetCode()\n                if l3trm_nvPairList == None:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":TRM\"),\n                                       \"l3_trm config not found while Tenant Routed Multicast is enabled.\", devSerial)\n                    respObj.setFailureRetCode()\n            else:\n                if nvPairList != None:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":TRM\"),\n                                       \"mvpn_bgp_rr_neighbor config found while Tenant Routed Multicast is not enabled.\", devSerial)\n                    respObj.setFailureRetCode()\n                if l3trm_nvPairList != None:\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":TRM\"),\n                                       \"l3_trm config found while Tenant Routed Multicast is not enabled.\", devSerial)\n                    respObj.setFailureRetCode()\n\n        # check BGP peer template consistency\n        global fabric_bgp_tmpl_type, fabric_bgp_tmpl_name\n        if IBGP_PEER_TEMPLATE:\n            if (IBGP_PEER_TEMPLATE_LEAF and\n                (topologyDataObj.check(TopologyInfoType.IS_LEAF, devSerial) or\n                 topologyDataObj.check(TopologyInfoType.IS_BORDER_LEAF, devSerial) or\n                 topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_LEAF, devSerial))):\n                bgp_peer_template = IBGP_PEER_TEMPLATE_LEAF.splitlines()\n            else:\n                bgp_peer_template = IBGP_PEER_TEMPLATE.splitlines()\n            peer_cmd = bgp_peer_template[0].strip().split(\" \")\n            fabric_bgp_tmpl_type = peer_cmd[1]\n            fabric_bgp_tmpl_name = peer_cmd[2]\n            Wrapper.print(\"[%s] IBGP_PEER_TEMPLATE consistency check - peer type: %s, name: %s\" % (devSerial, fabric_bgp_tmpl_type, fabric_bgp_tmpl_name))\n            nvPairList = getTemplateMatchResults(matchResult, \"bgp_peer_template\")\n            matching_peer_template_found = False\n            if nvPairList != None:\n                for nvPair in nvPairList:\n                    if (nvPair[\"BGP_AS\"] == BGP_AS and\n                        nvPair[\"TEMPLATE_TYPE\"] == fabric_bgp_tmpl_type and\n                        nvPair[\"TEMPLATE_NAME\"] == fabric_bgp_tmpl_name):\n                        # can add more check like line by line comparison\n                        matching_peer_template_found = True\n                        break\n                if not matching_peer_template_found:\n                    Wrapper.print(\"matching_peer_template_found NOT found on [%s]\" % devSerial)\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":IBGP PEER TEMPLATE\"),\n                                     \"IBGP Peer [template %s %s] not found on switch config while enabled on fabric setting \" %\n                                     (fabric_bgp_tmpl_type, fabric_bgp_tmpl_name), devSerial)\n                    respObj.setFailureRetCode()\n                    # proceed to next error check\n        else:\n            fabric_bgp_tmpl_type, fabric_bgp_tmpl_name = \"\", \"\"\n            nvPairList = getTemplateMatchResults(matchResult, \"bgp_peer_template\")\n            if nvPairList != None:\n                for nvPair in nvPairList:\n                    peer_template_conf = nvPair[\"CONF\"]\n                    # check template for iBGP evpn\n                    as_check = evpn_check = False\n                    for index, cmd in enumerate(peer_template_conf):\n                        if cmd.strip().startswith('remote-as'):\n                            remote_as = cmd.strip().split(' ')[1]\n                            if remote_as == BGP_AS:\n                                as_check = True\n                        elif cmd.strip().startswith('address-family l2vpn evpn'):\n                            evpn_check = True\n\n                    if as_check and evpn_check:\n                        Wrapper.print(\"%s found iBGP evpn peer-template on device while IBGP_PEER_TEMPLATE not defined in fabric setting\" % devSerial)\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":IBGP PEER TEMPLATE\"),\n                                         \"IBGP EVPN Peer template found on switch config while not defined on fabric setting.\", devSerial)\n                        respObj.setFailureRetCode()\n\n        #check if loopbacks matching with fabric settings are present on the switch\n        bgpLbFound = nveLbFound = anycastLbFound = rpLbFound = False\n\n        templateName = \"loopback_interface\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        templateName = \"loopback_interface_with_tag\"\n        nvPairListTag = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            if (nvPairListTag != None):\n                nvPairList += nvPairListTag\n        elif (nvPairListTag != None):\n            nvPairList = nvPairListTag\n\n        if (nvPairList == None):\n            templateName = \"v6_loopback_interface\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            templateName = \"v6_loopback_interface_with_tag\"\n            nvPairListTag = getTemplateMatchResults(matchResult, templateName)\n            if (nvPairList != None):\n                if (nvPairListTag != None):\n                    nvPairList += nvPairListTag\n            elif (nvPairListTag != None):\n                nvPairList = nvPairListTag\n\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if nvPair.get(\"INTF_NAME\").lower() == getLbIntfName(\"bgp\"):\n                    bgpLbFound = True\n                if nvPair.get(\"INTF_NAME\").lower() == getLbIntfName(\"nve\"): #MANISH revisit after vtep on bspine/bgspine\n                    nveLbFound = True\n                if nvPair.get(\"INTF_NAME\").lower() == getLbIntfName(\"anycast\"):\n                    anycastLbFound = True\n                if nvPair.get(\"INTF_NAME\").lower() == getLbIntfName(\"rp\"):\n                    rpLbFound = True\n \n        isBorderSpine = False\n        if (topologyDataObj.check(TopologyInfoType.IS_BORDER_SPINE, devSerial) or\n            topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_SPINE, devSerial)):\n            Wrapper.print(\"Switch is Border Role from TopologyData\")\n            isBorderSpine = True\n\n        if not bgpLbFound and bgpConfigFound:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Routing loopback\"),\n                                   \"Underlay Routing loopback Interface [%s] not found!!!\" % (getLbIntfName(\"bgp\")), devSerial)\n            respObj.setFailureRetCode()\n        if not nveLbFound and not isSpine:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VTEP loopback\"),\n                                   \"Underlay VTEP loopback Interface [%s] not found!!!\" % (getLbIntfName(\"nve\")), devSerial)\n            respObj.setFailureRetCode()\n        if not anycastLbFound and vPCInfo[\"domainId\"] and UNDERLAY_IS_V6 == \"true\":\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Anycast loopback\"),\n                                   \"Underlay Anycast loopback Interface [%s] not found!!!\" % (getLbIntfName(\"anycast\")), devSerial)\n            respObj.setFailureRetCode()\n        if not rpLbFound and (isSpine or isBorderSpine) and asmRPConfigInSwitch:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":PIM ASM loopback\"),\n                                   \"Underlay RP loopback Interface [%s] not found!!!\" % (getLbIntfName(\"rp\")), devSerial)\n            respObj.setFailureRetCode()\n        \n        fabricInterfaces = getFabricIntefaces(topologyDataObj, devSerial, switchRole)\n        checkAuthAndFabricIntfs(dictionaryObj, devSerial, switchRole, fabricInterfaces,\n                                            vpcPeerLinkVlanFound, matchResult, interfacesRes, respObj)\n        checkBfd(dictionaryObj, devSerial, fabricInterfaces, matchResult, interfacesRes, respObj)\n\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error during configuration consistency check\" % formattedName)\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":CONFIG_CHECK\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Switch [%s]. Success = [%r]\" % (FABRIC_NAME,\n            funcName, formattedName, respObj.isRetCodeSuccess()))\n        return respObj\n\ndef deviceUpgrade(gVarDictObj, respObj, doFullProcessing):\n    funcName = sys._getframe(0).f_code.co_name\n    dictionaryObj = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = dictionaryObj[\"deviceSerial\"]\n    formattedName = getFormattedSwitchName(devSerial)\n    Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s: Switch [%s] doFullProcessing [%r]\" % (FABRIC_NAME,\n        funcName, formattedName, doFullProcessing))\n    try:\n        fabTech = gVarDictObj[\"globalOverlayInfo\"][\"fabricTechnology\"]\n        if fabTech == \"VLANFabric\":\n            ECLdeviceUpgradeExt(gVarDictObj, respObj, doFullProcessing)\n        else:    \n            deviceUpgradeExt(gVarDictObj, respObj, doFullProcessing)\n    except respObjError as e:\n        msg = (\"Switch [%s]: Unexpected error during Underlay migration.\" % formattedName)\n        processUpgradeRespObjWithMsg(devSerial + \":UNDERLAY_MIGRATION\", msg, respObj, e.value)\n    except:\n        exc_type, exc_value, exc_traceback = sys.exc_info()\n        Wrapper.print(\"%s: Unexpected Exception. Message [%s] Exception TB [%s]\" % (funcName, exc_value, traceback.format_tb(exc_traceback, None)))\n        msg = (\"Switch [%s]: Unexpected error during Underlay migration. Detail [%s].\" % (formattedName, exc_value))\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial + \":UNDERLAY_MIGRATION\"), msg)\n        respObj.setFailureRetCode()\n    finally:\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Switch [%s]. Success = [%r]\" % (\n            FABRIC_NAME, funcName, formattedName, respObj.isRetCodeSuccess()))\n        return respObj\n\ndef getFileContents(filename, isJson):\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    file = None\n    buf = \"\"\n    try:\n        file = open(filename, 'r')\n        buf = file.read()\n        if isJson:\n            respObj.setValue(json.loads(buf))\n        else:\n            respObj.setValue(buf)\n    except Exception as e:\n        Wrapper.print(\"getFileContents: buf failure %s\"%(buf))\n        Wrapper.print(\"getFileContents: Exception. Filename = [%s], Exception [%s]\" % (filename, traceback.format_exc()))\n        Util.handleException((\"Error reading from file [%s]\" % filename), e, respObj)\n    finally:\n        if file:\n            file.close()\n\n    return respObj\n\ndef getJSONFileContents(filename):\n    return getFileContents(filename, True)\n\ndef manageBgpRelatedBrownfieldPolicies(devSerial, matchResult, gVarDictObj, bgpFF, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    bgpNeighborDict = gVarDictObj[\"DICTIONARY_OBJ\"][\"bgpNeighborDict\"]\n\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"evpn_bgp_neighbor_auth\")\n    ptis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    srchOpt.setTemplateName(\"v6_evpn_bgp_neighbor_auth\")\n    ptis += Util.exe(PTIWrapper.getPTIs(srchOpt))\n    srchOpt.setTemplateName(\"bfd_bgp_neighbor\")\n    ptis += Util.exe(PTIWrapper.getPTIs(srchOpt))\n    for pti in ptis:\n        PTIWrapper.deleteInstance(pti.getPolicyId())\n\n    #Wrapper.print(\"%s: %s bgpNeighborDict %s\" % (funcName, devSerial, bgpNeighborDict))\n\n    # create the BGP Auth and BFD PTIs\n    for neighborIp in bgpNeighborDict:\n        neighborEntry = bgpNeighborDict[neighborIp]\n        if \"bgpAuth\" in neighborEntry:\n            nvPair = neighborEntry[\"bgpAuth\"]\n            \n            templateName = \"v6_evpn_bgp_neighbor_auth\" if isIpv6Addr(nvPair[\"BGP_NEIGHBOR_IP\"]) else \"evpn_bgp_neighbor_auth\"\n            if not neighborEntry[\"isInternal\"]:\n                genCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, nvPair, False, None)\n                bgpFF.append(genCfg)\n            else:\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", getSrc(templateName), getPrio(templateName), \n                    templateName, nvPair))\n\n        if \"bfd\" in neighborEntry:\n            nvPair = neighborEntry[\"bfd\"]\n            \n            templateName = \"v6_bfd_bgp_neighbor\" if isIpv6Addr(nvPair[\"BGP_NEIGHBOR_IP\"]) else \"bfd_bgp_neighbor\"\n            if not neighborEntry[\"isInternal\"]:\n                genCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, nvPair, False, None)\n                bgpFF.append(genCfg)\n            else:\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", getSrc(templateName), getPrio(templateName), \n                    templateName, nvPair))\n\ndef createTcamPTI(sn, matchResult, templateName, tcamName, prio):\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        tcamSize = nvPairList[0][\"TCAM_SIZE\"]\n        ptiList = Util.exe(PTI.get(sn, \"SWITCH\", \"SWITCH\", \"\", \"tcam_config\"))\n        for pti in ptiList:\n            if pti.nvPairs.get(\"TCAM_NAME\") == tcamName:\n                PTI.deleteInstance(pti.getPolicyId())\n                break\n        #show run all should take care of no diff\n        Util.exe(PTIWrapper.create(sn, \"SWITCH\", \"SWITCH\", \"\", prio, \"tcam_config\", {\"TCAM_NAME\":tcamName, \"TCAM_SIZE\":tcamSize}))\n    return\n\ndef createVirtualPeerLinkPTI(sn, matchResult, vpcPairInfo):\n    nvPairList = getTemplateMatchResults(matchResult, \"vpc_domain_virtual_peerlink_dscp\")\n    if (nvPairList != None):\n        domainId  = nvPairList[0].get(\"DOMAIN_ID\")\n        peerIp    = nvPairList[0].get(\"DST_LB_IP\")\n        localIp   = nvPairList[0].get(\"SRC_LB_IP\")\n        dscpValue = nvPairList[0].get(\"DSCP\") if nvPairList[0].get(\"DSCP\") else \"\"\n        nvPairsVirtualVPC = {\"DOMAIN_ID\": domainId, \"DST_LB_IP\":peerIp, \"SRC_LB_IP\":localIp, \"DSCP\":dscpValue}\n        createPTI(sn, nvPairsVirtualVPC, \"vpc_domain_virtual_peerlink\", \"SWITCH\", \"\", -1)\n        vpcPairInfo.update({\"vpcFabricPair\":True})\n        vpcPairInfo.update({\"SRC_LB_IP\":localIp})\n    return\n\ndef manageIsisBrownfieldPolicies(devSerial, matchResult, gVarDictObj, respObj):\n    if LINK_STATE_ROUTING != \"is-is\":\n        return\n\n    # look for all the possible ISIS related policies\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"base_isis_level2\")\n    ptis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    srchOpt.setTemplateName(\"isis_overload\")\n    ptis += Util.exe(PTIWrapper.getPTIs(srchOpt))\n\n    # delete the existing policies.. we will recreate them in case they do not match the earlier ones\n    for pti in ptis:\n        PTIWrapper.deleteInstance(pti.getPolicyId())\n\n    # create this PTI since we need to honor the existing isis net \n    nvPairList = getTemplateMatchResults(matchResult, \"base_isis_level2_internal\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            templateName = \"base_isis_level2\"\n            if LINK_STATE_ROUTING_TAG == nvPair[\"ISIS_TAG\"]:\n                # this is the underlay instance we are interested in\n                source = getSrc(templateName)\n                ptiPrio = template_metadata[templateName][\"prio\"]\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", source, ptiPrio, templateName, nvPair))\n                break\n\n    templateName = \"isis_overload\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        ptiPrio = template_metadata[templateName][\"prio\"]\n        for nvPair in nvPairList:\n            source = \"\"\n            if nvPair[\"ISIS_TAG\"] == LINK_STATE_ROUTING_TAG:\n                source = getSrc(templateName)\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", source, ptiPrio, templateName, nvPair))\n                break\n\ndef getVPCPeerDeviceSN(devSerial, vpcSrcToDstMacMap):\n    funcName = sys._getframe(0).f_code.co_name\n    #Wrapper.print(\" %s(): devSerial = %s, vpcSrcToDstMacMap = [%s]\" %(funcName, devSerial, vpcSrcToDstMacMap)) \n    srcSysMac = peerSerialNumber = \"\"\n    for sysMac in vpcSrcToDstMacMap:\n        if vpcSrcToDstMacMap[sysMac][\"switchSn\"] ==  devSerial:\n            srcSysMac = sysMac\n            break\n    for sysMac in vpcSrcToDstMacMap:\n        if srcSysMac == vpcSrcToDstMacMap[sysMac][\"peerMac\"]:\n            peerSerialNumber = vpcSrcToDstMacMap[sysMac][\"switchSn\"]\n            break\n    Wrapper.print(\" %s(): devSerial = [%s], peerSerial [%s]\" %(funcName, devSerial, peerSerialNumber)) \n    return peerSerialNumber \n\ndef managePimPolicies(devSerial, matchResult, gVarDictObj, respObj):\n    # look for all the possible existing template matches\n    templateName = \"base_pim_asm_11_1\"\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(templateName)\n    ptis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n\n    # delete the existing policies.. we will recreate new ones later\n    for pti in ptis:\n        PTIWrapper.deleteInstance(pti.getPolicyId())\n\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        # there could be multiple matches for base_pim_asm_11_1 policy.. create all non-matching ones\n        # with empty source\n        for pimAsmNvpair in nvPairList:\n            src = \"\"\n            mcastGroupSubnet = pimAsmNvpair[\"RP_GROUP\"].strip()\n            if (mcastGroupSubnet == gVarDictObj[\"MULTICAST_GROUP_SUBNET\"]):\n                src = getSrc(templateName)\n            else:\n                switchIP, switchMask = mcastGroupSubnet.split('/')\n                fabricIP, fabricMask = MULTICAST_GROUP_SUBNET.split('/')\n                if int(switchMask) < 16 and int(switchMask) < int(fabricMask):\n                    newSubnet = Util.getSubnetStringWithPrefix(fabricIP, switchMask)\n                    if newSubnet == mcastGroupSubnet:\n                        # switch mcast group subnet is a superset of fabric setting. Create pti for\n                        # later markDelete so that it will be replaced with config using fabric setting\n                        src = getSrc(templateName)\n            Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", src,\n                                   getPrio(templateName), templateName, pimAsmNvpair))\n\n    createMatchedPtis(devSerial, matchResult, \"base_multicast_11_1\")\n    createMatchedPtis(devSerial, matchResult, \"base_pim_bidir_11_1\", False)\n\ndef manageNxCloudPolicies(devSerial, matchResult, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n    ALLOW_NXC = fabricSettings.get(\"ALLOW_NXC\", \"false\")\n    if ALLOW_NXC != \"true\":\n        return respObj\n\n    destVrf = srcIntf = proxyServer = proxyPort = \"\"\n    showRunVrfMgmt = \"false\"\n    nvPairList = getTemplateMatchResults(matchResult, \"intersight_use_vrf_internal\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            destVrf = nvPair.get(\"DEST_VRF\")\n            if destVrf == \"management\":\n                showRunVrfMgmt = \"true\"\n    nvPairList = getTemplateMatchResults(matchResult, \"intersight_src_intf_internal\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            srcIntf = nvPair.get(\"SRC_INTF\")\n    nvPairList = getTemplateMatchResults(matchResult, \"intersight_proxy_port_internal\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            proxyServer = nvPair.get(\"PROXY_SERVER\")\n            proxyPort = nvPair.get(\"PROXY_PORT\")\n    else:\n        nvPairList = getTemplateMatchResults(matchResult, \"intersight_proxy_internal\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                proxyServer = nvPair.get(\"PROXY_SERVER\")\n\n    if destVrf == \"\" and srcIntf == \"\" and proxyServer == \"\":\n        return respObj\n\n    OVERWRITE_GLOBAL_NXC = fabricSettings.get(\"OVERWRITE_GLOBAL_NXC\", \"false\")\n    if OVERWRITE_GLOBAL_NXC == \"true\":\n        NXC_DEST_VRF         = fabricSettings.get(\"NXC_DEST_VRF\", \"\")\n        NXC_SRC_INTF         = fabricSettings.get(\"NXC_SRC_INTF\", \"\")\n        NXC_PROXY_SERVER     = fabricSettings.get(\"NXC_PROXY_SERVER\", \"\")\n        NXC_PROXY_PORT       = fabricSettings.get(\"NXC_PROXY_PORT\", \"\")\n    else:\n        nxcGlobalSettings = Util.exe(FabricWrapper.getNXCGlobalSettings())\n        Wrapper.print(\"%s: nxcGlobalSettings %s\" % (funcName, nxcGlobalSettings))\n        NXC_DEST_VRF         = nxcGlobalSettings.get(\"sourceVrf\", \"\")\n        NXC_SRC_INTF         = nxcGlobalSettings.get(\"sourceIntf\", \"\")\n        NXC_PROXY_SERVER     = nxcGlobalSettings.get(\"proxyIp\", \"\")\n        NXC_PROXY_PORT       = nxcGlobalSettings.get(\"proxyPort\", \"\")\n\n    nxcDestVrf = nxcSrcIntf = nxcProxyServer = nxcProxyPort = \"\"\n\n    if NXC_DEST_VRF != \"\":\n        nxcDestVrf = \"default\" if NXC_DEST_VRF.strip().lower() == \"default\" else NXC_DEST_VRF.strip()\n        if nxcDestVrf.lower() == \"management\":\n            nxcDestVrf = \"management\"\n\n    if NXC_SRC_INTF != \"\":\n        nxcSrcIntf = Util.getIntfFullName(NXC_SRC_INTF)\n        intfType = Util.getIntfFullType(NXC_SRC_INTF)\n        if intfType == \"Loopback\" or intfType == \"Port-Channel\":\n            nxcSrcIntf = nxcSrcIntf.lower()\n\n    nxcProxyServer = NXC_PROXY_SERVER.strip() if NXC_PROXY_SERVER != \"\" else \"\"\n\n    errorMsg = \"\"\n    if destVrf != \"\" and destVrf != nxcDestVrf:\n        if nxcDestVrf == \"\":\n            errorMsg += Util.newLine()\n            errorMsg += (\"Intersight Destination VRF setting is missing for Brownfield Import, \"\n                         \"please set the Destination VRF in %s\" %\n                         (\"Global NxCloud Settings\" if OVERWRITE_GLOBAL_NXC != \"true\" else \"Fabric Settings\"))\n        else:\n            errorMsg += Util.newLine() + \"'intersight use-vrf %s' does not match Destination VRF setting [%s]\" % (destVrf, nxcDestVrf)\n    if srcIntf != \"\" and srcIntf != nxcSrcIntf:\n        errorMsg += Util.newLine()\n        if nxcSrcIntf == \"\" and nxcDestVrf != \"\" and nxcDestVrf != \"management\":\n            errorMsg += (\"Intersight Source Interface setting is missing for Brownfield Import, \"\n                         \"please set the Source Interface in %s\" %\n                         (\"Global NxCloud Settings\" if OVERWRITE_GLOBAL_NXC != \"true\" else \"Fabric Settings\"))\n        else:\n            errorMsg += (\"'intersight source-interface %s' does not match Source Interface setting [%s]\" %\n                         (srcIntf, \"Null\" if nxcSrcIntf == \"\" else nxcSrcIntf))\n    if proxyServer != \"\" and proxyPort != \"\":\n        if proxyServer != nxcProxyServer or proxyPort != NXC_PROXY_PORT:\n            errorMsg += Util.newLine()\n            errorMsg += (\"'intersight proxy %s port %s' does not match Proxy Server/Port settings [%s/%s]\" %\n                         (proxyServer, proxyPort,\n                          \"Null\" if nxcProxyServer == \"\" else nxcProxyServer,\n                          \"Null\" if NXC_PROXY_PORT == \"\" else NXC_PROXY_PORT))\n    elif proxyServer != \"\" and proxyServer != nxcProxyServer:\n        errorMsg += Util.newLine()\n        errorMsg += (\"'intersight proxy %s' does not match Proxy Server setting [%s]\" %\n                     (proxyServer, \"Null\" if nxcProxyServer == \"\" else nxcProxyServer))\n    if errorMsg != \"\":\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":NxCloud\"),\n            \"Intersight config on the device does not match %s: %s\" %\n            (\"Global NxCloud Settings\" if OVERWRITE_GLOBAL_NXC != \"true\" else \"Fabric Settings\", errorMsg), devSerial)\n        respObj.setFailureRetCode()\n        return respObj\n\n    Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                       ConfigPriority.CONFIG_PRIO_UNDERLAY_MIDDLE,\n                                       \"nexus_cloud\",\n                                       {\"NXC_SRC_INTF\": srcIntf,\n                                        \"NXC_DEST_VRF\": destVrf,\n                                        \"NXC_PROXY_SERVER\": proxyServer,\n                                        \"NXC_PROXY_PORT\": proxyPort,\n                                        \"SHOW_RUN_VRF_MGMT\": showRunVrfMgmt}))\n    return respObj\n\ndef getNativeVlanAndUpdatedUnacctCfgList(cfgList):\n    funcName = sys._getframe(0).f_code.co_name\n    nativeVlan = \"\"\n    updatedCfgList = []\n\n    for cfg in cfgList:\n        strippedCfg = cfg.strip()\n        if strippedCfg.startswith(\"switchport trunk native vlan \"):\n            parts = strippedCfg.split(\"switchport trunk native vlan \")\n            nativeVlan = parts[1]\n        else:\n            updatedCfgList.append(cfg)\n\n    Wrapper.print(\"%s: nativeVlan [%s] updatedCfgList [%s]\" % (funcName, nativeVlan, updatedCfgList)) \n    return nativeVlan, updatedCfgList\n\n# process the service route map entries found on service leaf\ndef processServiceRouteMapEntries(fabricName, devSerial, serviceRMDict, globalOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    isServiceLeaf = switchOverlayInfo[\"isServiceLeaf\"]\n\n    Wrapper.print(\"%s: Fabric [%s] [%s] isServiceLeaf [%r] Start serviceRMDict %s\" % (funcName, fabricName, devSerial,\n        isServiceLeaf, json.dumps(serviceRMDict, indent=4, sort_keys=True)))\n\n    # set the route map sequence #s in RM\n    for rmLine in serviceRMDict:\n        rmEntry = serviceRMDict[rmLine]\n\n        Wrapper.print(\"--- [%s] Setting RM for acl [%s] with seq # [%s]\" % (devSerial, rmEntry[\"aclName\"], rmEntry[\"seqNum\"]))\n        ignore, rm_id = Util.exeRM(RM.set(fabricName, \"ROUTE_MAP_SEQUENCE_NUMBER_POOL\", \n                                            devSerial, rmEntry[\"aclName\"], rmEntry[\"seqNum\"]))\n\n    if not isServiceLeaf:\n        return\n\n    # get list of service nodes associated with this service switch\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n    serviceNodeList = servicesInfo[\"serviceSwMaps\"][devSerial][\"nodes\"]\n\n    # iterate over the known route peer entries on the serivce leaf\n    for serviceNodeName in serviceNodeList:\n        serviceNodeEntry = servicesInfo[\"serviceNodes\"][serviceNodeName]\n\n        peerSn = serviceNodeEntry.get(\"peerSwSerial\", None)\n        if peerSn == devSerial:\n            Wrapper.print(\"%s: SN [%s] - Skipping updates for vPC peer [%s]\" % (funcName, serviceNodeName, devSerial))\n            continue\n\n        Wrapper.print(\"%s: New SN\" % (funcName))\n        Wrapper.print(\"%s: SN [%s]\" % (funcName, serviceNodeName))\n\n        for routePeerName in serviceNodeEntry[\"routePeers\"]:\n            rpEntry = serviceNodeEntry[\"routePeers\"][routePeerName]\n\n            Wrapper.print(\"%s: New RP\" % (funcName))\n            Wrapper.print(\"%s: SN [%s] RP Name [%s] Route Peer Entry [%s]\" % (funcName, serviceNodeName, routePeerName, rpEntry))\n            # iterate over the route-map entries found on service leaf\n            for rmLine in serviceRMDict:\n                rmEntry = serviceRMDict[rmLine]\n                Wrapper.print(\">>> RM line [%s] rmEntry [%s]\" % (rmLine, rmEntry)) \n                if rmEntry[\"isProcessed\"] or (not rmEntry[\"aclName\"].startswith(rpEntry[\"aclPrefix\"]) or\n                    (not rmLine.startswith(rpEntry[\"rmPrefix\"]))):\n                    continue\n                \n                isReverse = False\n                processRM = False\n                for netType in rpEntry[\"nets\"]:\n                    rpNetEntry = rpEntry[\"nets\"][netType]\n                    Wrapper.print(\"------ %s: netType [%s] rpNetEntry [%s]\" % (funcName, netType, rpNetEntry)) \n                    if (\"vni\" in rpNetEntry):\n                        # check if the next hop is of interest to us\n                        netEntry = servicesInfo[\"serviceNets\"][rpNetEntry[\"vni\"]]\n                        nextHopSubnetStr = Util.getSubnetStringWithPrefix(rmEntry[\"nextHop\"], netEntry[\"mask\"])\n                        Wrapper.print(\"********* nextHopSubnetStr [%s] netEntry Subnet [%s]\" % (nextHopSubnetStr, netEntry[\"subnet\"]))\n                        if nextHopSubnetStr == netEntry[\"subnet\"]:\n                            processRM = True\n                            if \"nextHop\" not in rpNetEntry:\n                                Wrapper.print(\"%s: Route Peer [%s] Adding nextHop [%s] for network [%s] [%s]\" % (funcName,\n                                    routePeerName, rmEntry[\"nextHop\"], netType, netEntry[\"ipv4\"])) \n                                rpNetEntry[\"nextHop\"] = rmEntry[\"nextHop\"]\n                                break\n\n                if not processRM:\n                    continue\n\n                isReverse = False\n                # process the service policies\n                if serviceNodeEntry[\"serviceNodeType\"] == \"fw\":\n                    if \"nextHop\" in rpEntry[\"nets\"][\"outside\"]:\n                        isReverse = True\n                else:\n                    if len(rpEntry[\"nets\"]) == 1:\n                        # one armed\n                        if \"nextHop\" in rpEntry[\"nets\"][\"one\"]:\n                            isReverse = True\n                    else:\n                        if \"nextHop\" in rpEntry[\"nets\"][\"two\"]:\n                            isReverse = True\n\n                aclTuple = rmEntry[\"aclName\"].split(rpEntry[\"aclPrefix\"])[1]\n                aclTupleParts = aclTuple.split(\"_\")\n                Wrapper.print(\"%s: isReverse [%s] aclTuple [%s] aclTupleParts Num %d %s\" % (funcName, isReverse, \n                                                            aclTuple, len(aclTupleParts), aclTupleParts)) \n                if len(aclTupleParts) != 5:\n                    # not sure why\n                    continue\n\n                rpServicesDict = rpEntry[\"servicePolicies\"]\n                aclTupleSet = set(aclTuple)\n                entryFound = False\n                for serviceEntry in rpServicesDict.values():\n                    if aclTupleSet == serviceEntry[\"tupleSet\"]:\n                        serviceEntry[\"isReverse\"] = isReverse\n                        #if serviceNodeEntry[\"serviceNodeType\"] == \"fw\":\n                        #    serviceEntry[\"policyTemplateNvPairs\"][\"ROUTE_MAP_MATCH_SEQUENCE_NUMBER_REVERSE\"] = rmEntry[\"seqNum\"]\n                        entryFound = True\n\n                if not entryFound:\n                    # create a service policy entry\n                    if serviceNodeEntry[\"serviceNodeType\"] == \"fw\":\n                        nvPairs = {\"SRC_NETWORK\" : aclTupleParts[0], \"DEST_NETWORK\" : aclTupleParts[1],\n                                   \"PROTOCOL\" : aclTupleParts[2], \"SRC_PORT\" : aclTupleParts[3], \"DEST_PORT\" : aclTupleParts[4]}\n                        #nvPairs[\"ROUTE_MAP_MATCH_SEQUENCE_NUMBER\"] = rmEntry[\"seqNum\"]\n                    else:\n                        nvPairs = {\"SRC_NETWORK\" : aclTupleParts[1], \"DEST_NETWORK\" : aclTupleParts[0],\n                                   \"PROTOCOL\" : aclTupleParts[2], \"SRC_PORT\" : aclTupleParts[4], \"DEST_PORT\" : aclTupleParts[3]}\n                        #nvPairs[\"ROUTE_MAP_MATCH_SEQUENCE_NUMBER_REVERSE\"] = rmEntry[\"seqNum\"]\n\n                    nvPairs[\"ROUTE_MAP_ACTION\"] = rmEntry[\"action\"]\n                    if \"nextHopOption\" in rmEntry:\n                        nvPairs[\"NEXT_HOP_OPTION\"] = rmEntry[\"nextHopOption\"]\n\n                    rpServicesDict[aclTuple] = {\"tupleSet\" : aclTupleSet, \"policyTemplateNvPairs\" : nvPairs, \"isReverse\" : isReverse}\n                    Wrapper.print(\"%s: RP [%s] Added Service Entry Key [%s] -> [%s] \" % (funcName, routePeerName, aclTuple, nvPairs)) \n\n                    rmEntry[\"isProcessed\"] = True\n\n    for serviceNodeName in serviceNodeList:\n        serviceNodeEntry = servicesInfo[\"serviceNodes\"][serviceNodeName]\n        for routePeerName in serviceNodeEntry[\"routePeers\"]:\n            rpEntry = serviceNodeEntry[\"routePeers\"][routePeerName]\n\n            rpServicesDict = rpEntry[\"servicePolicies\"]\n            for serviceEntry in rpServicesDict.values():\n                # clear out data we do not need anymore\n                if \"tupleSet\" in serviceEntry:\n                    del serviceEntry[\"tupleSet\"]\n    Wrapper.print(\"%s: %s End serviceRMDict %s\" % (funcName, devSerial, json.dumps(serviceRMDict, indent=4, sort_keys=True)))\n\ndef deviceUpgradeExt(gVarDictObj, respObj, doFullProcessing):\n    global ISIS_LEVEL\n\n    funcName = sys._getframe(0).f_code.co_name\n\n    dictionaryObj = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = dictionaryObj[\"deviceSerial\"]\n    migrateMode = dictionaryObj[\"migrationMode\"]\n    topologyDataObj = gVarDictObj[\"topologyObj\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    vpcSrcToDstMacMap = gVarDictObj[\"vpcSrcToDstMacMap\"]\n    vVpcSpineQos = gVarDictObj[\"vVpcSpineQos\"]\n    matchResult = dictionaryObj[\"matchResult\"]\n    interfacesRes = dictionaryObj[\"interfacesRes\"]\n    switchRole = dictionaryObj[\"switchRole\"]\n    hostName = dictionaryObj[\"hostName\"]\n    fmtName = dictionaryObj[\"fmtName\"]\n    model = dictionaryObj[\"deviceModel\"]\n\n    isSpine = False\n    if (topologyDataObj.check(TopologyInfoType.IS_SPINE, devSerial) or\n        topologyDataObj.check(TopologyInfoType.IS_BORDER_SPINE, devSerial) or\n        topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_SPINE, devSerial)):\n        isSpine = True\n    Wrapper.print(\"==========%s: Fabric = %s, Serial [%s] Model [%s] Role [%s] isSpine [%r]\" % \n        (funcName, FABRIC_NAME, devSerial, model, switchRole, isSpine))\n\n    vPCInfo = dictionaryObj[\"vpcInfo\"]\n    isValidVPC = (vPCInfo[\"domainId\"] != None)\n\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    switchOverlayInfo[\"isVpc\"] = \"true\" if isValidVPC else \"false\"\n\n    device_overlay_vlans = {}\n    doOverlayMigr = False\n    if migrateMode == \"brownAdd\":\n        doOverlayMigr = True\n        if \"border\" in switchRole.lower():\n            switchOverlayInfo[\"doOverlayExtn\"] = \"true\"\n        # record state that the switch overlay migration is not completed yet\n        putSwitchIntoOverlayMigrMode(FABRIC_NAME, devSerial)\n    elif migrateMode == \"upgrade\":\n        if switchRole.lower() != \"spine\":\n            doOverlayMigr = True\n            # the switch will be in migration mode from the backend code\n            # get the interface specific network vlan info\n            device_overlay_vlans = TopDownMigrationUtils.getOverlayInterfaceInfo(devSerial)\n            Wrapper.print(\"Fabric upgrade %s device_overlay_vlans %s\" % (devSerial, device_overlay_vlans))\n            for x in device_overlay_vlans.entrySet():\n                Wrapper.print(\" intf %s, %s\" % (x.key, x.value.getVlanList()))\n\n    if doOverlayMigr:\n        # collect all the overlay info for the leaf switch\n        gatherOverlayInfo(topologyDataObj, devSerial, matchResult, interfacesRes, globalOverlayInfo,\n                    switchOverlayInfo, migrateMode, device_overlay_vlans, respObj)\n\n    if respObj.isRetCodeFailure() or (not doFullProcessing):\n        return respObj\n\n    if Util.exe(FabricWrapper.isFeatureEnabled(\"nxcloud\")):\n        manageNxCloudPolicies(devSerial, matchResult, respObj)\n\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    # add the special route-map policy template for the leaf\n    if not isSpine:\n        # do a check first\n        templateName = \"route_map\"\n        if (getTemplateMatchResults(matchResult, templateName) == None):\n            # add the match entry\n            matchResult.update({templateName : [{}]})\n\n    # process common configs\n    if isValidVPC:\n        createPTI(devSerial, {}, \"base_feature_vpc\", \"SWITCH\", \"UNDERLAY\", -1)\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"nfm_switch_user\")\n    createMatchedPtis(devSerial, matchResult, \"password_no_strength\")\n    createMatchedPtis(devSerial, matchResult, \"host_11_1\")\n    createMatchedPtis(devSerial, matchResult, \"switchnm_11_1\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"v4_mgmt_default_gateway\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"v6_mgmt_default_gateway_11_1\")\n    createMatchedPtis(devSerial, matchResult, \"feature_bfd\")\n    createMatchedPtis(devSerial, matchResult, \"feature_nxapi\")\n    createMatchedPtis(devSerial, matchResult, \"nxapi_http_port\")\n    createMatchedPtis(devSerial, matchResult, \"nxapi_https_port\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"banner\")\n    nvPairList = getTemplateMatchResults(matchResult, \"ssh_key_rsa\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            bits = nvPair.get(\"BITS\")\n            if bits != \"1024\" and bits != \"\":\n                rsaNvPair = {\"BITS\":bits}\n                Wrapper.print(\"match ssh_key_rsa %s\" % nvPair)\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n                                           \"ssh_key_rsa_force\", rsaNvPair))\n\n    createMatchedPtis(devSerial, matchResult, \"pre_config\")\n    if Util.isN9kT2Vtep(topologyDataObj, devSerial):\n        createMatchedPtis(devSerial, matchResult, \"tcam_pre_config_vxlan\")\n        # Special case for the Nexus 9332PQ as it uses the same default allocation as the Nexus 9500\n        if Util.isModularN9k(model) or \"C9332PQ\" in model:\n            createMatchedPtis(devSerial, matchResult, \"tcam_pre_config_9500\")\n        else:\n            createMatchedPtis(devSerial, matchResult, \"tcam_pre_config_9300\")\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"base_bgp\")\n    if UNDERLAY_IS_V6 == \"true\":\n        nvPairList = getTemplateMatchResults(matchResult, \"base_bgp\")\n        if nvPairList != None:\n            for nvPair in nvPairList:\n                routerId = nvPair[\"LOOPBACK_IP\"]\n                entityName = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Util.exe(RM.set(FABRIC_NAME, \"ROUTER_ID_POOL\", EntityType.DEVICE, entityName, routerId))\n                break\n    \n    manageBgpRelatedBrownfieldPolicies(devSerial, matchResult, gVarDictObj, switchOverlayInfo[\"BGP_FF\"], respObj)\n    manageIsisBrownfieldPolicies(devSerial, matchResult, gVarDictObj, respObj)\n    managePimPolicies(devSerial, matchResult, gVarDictObj, respObj)\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"ntp_server\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"ntp_prefer_server\")\n    createMatchedPtis(devSerial, matchResult, \"clock_protocol\")\n    createMatchedPtis(devSerial, matchResult, \"clock_timezone\")\n    createMatchedPtis(devSerial, matchResult, \"clock_summertime\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"dnsList\")  #cleanup first since we use create,not update to support multiple dns_vrf\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"dns-vrfList\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_sev\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_vrf\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_vrf_no_sev\")\n    createMatchedPtis(devSerial, matchResult, \"evpn_multisite\")\n    createMatchedPtis(devSerial, matchResult, \"bgp_cluster_id\")\n    createMatchedPtis(devSerial, matchResult, \"feature_isis\")\n\n    ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"base_pim_bidir_11_1\"))\n    if ptiList:\n        Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, \"rp_state\", {}))\n\n    # check system jumbomtu\n    jumboMtuVal = \"9216\"\n    templateName = \"system_jumbomtu\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            jumboMtuVal = nvPair[\"MTU\"]\n\n    Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n        templateName, {\"MTU\" : jumboMtuVal}))\n\n    # create the internal PTI to track the switch jumbomtu setting\n    Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n        \"switch_mtu_state\", {\"JUMBO_MTU_VAL\" : jumboMtuVal}))\n\n    #createTcamPTI(devSerial, matchResult, \"tcam_ing_racl\", \"ing-racl\", 10)\n    #createTcamPTI(devSerial, matchResult, \"tcam_ing_flow_redirect\", \"ing-flow-redirect\", 11)\n\n    global fabric_bgp_tmpl_type, fabric_bgp_tmpl_name\n\n    template_has_mvpn = False\n    if IBGP_PEER_TEMPLATE:\n        if (IBGP_PEER_TEMPLATE_LEAF and\n            (topologyDataObj.check(TopologyInfoType.IS_LEAF, devSerial) or\n             topologyDataObj.check(TopologyInfoType.IS_BORDER_LEAF, devSerial) or\n             topologyDataObj.check(TopologyInfoType.IS_BORDER_GATEWAY_LEAF, devSerial))):\n            bgp_peer_conf = IBGP_PEER_TEMPLATE_LEAF.strip()\n        else:\n            bgp_peer_conf = IBGP_PEER_TEMPLATE.strip()\n        bgp_peer_template = filter(None, map(lambda x: x.strip(), bgp_peer_conf.splitlines()))\n        peer_cmd = bgp_peer_template[0].split(\" \")\n        fabric_bgp_tmpl_type = peer_cmd[1]\n        fabric_bgp_tmpl_name = peer_cmd[2]\n        if \"address-family ipv4 mvpn\" in bgp_peer_template:\n            template_has_mvpn = True\n    else:\n        fabric_bgp_tmpl_type, fabric_bgp_tmpl_name = \"\", \"\"\n    Wrapper.print(\"fabric peer template type %s, name %s\" % (fabric_bgp_tmpl_type, fabric_bgp_tmpl_name))\n\n    PTIWrapper.delete(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", \"bgp_neighbor_inherit\")\n    PTIWrapper.delete(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", \"v6_bgp_neighbor_inherit\")\n    templateName = \"bgp_neighbor_inherit\"\n    bgpInheritNvPairList = getTemplateMatchResults(matchResult, templateName)\n    if bgpInheritNvPairList != None:\n        for nvPair in bgpInheritNvPairList:\n            if isIpv6Addr(nvPair[\"BGP_NEIGHBOR_IP\"]):\n                templateName = \"v6_bgp_neighbor_inherit\"\n                break\n    Wrapper.print(\"%s %s nvPairList %s\" % (funcName, templateName, bgpInheritNvPairList))\n    if IBGP_PEER_TEMPLATE and bgpInheritNvPairList != None:\n        for nvPair in bgpInheritNvPairList[:]:\n            if (nvPair[\"BGP_AS\"] == BGP_AS and\n                nvPair[\"TEMPLATE_TYPE\"] == fabric_bgp_tmpl_type and\n                nvPair[\"TEMPLATE_NAME\"] == fabric_bgp_tmpl_name):\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1,\n                                   templateName, nvPair))\n                bgpInheritNvPairList.remove(nvPair)\n    Wrapper.print(\"%s: %s remaining nvPairList %s\" % (funcName, templateName, bgpInheritNvPairList))\n\n    bgpTmplNvPairList = getTemplateMatchResults(matchResult, \"bgp_peer_template\")\n    Wrapper.print(\"%s: bgp_peer_template nvPairList %s\" % (funcName, bgpTmplNvPairList))\n    if IBGP_PEER_TEMPLATE and bgpTmplNvPairList != None:\n        for nvPair in bgpTmplNvPairList:\n            if (nvPair[\"BGP_AS\"] == BGP_AS and\n                nvPair[\"TEMPLATE_TYPE\"] == fabric_bgp_tmpl_type and\n                nvPair[\"TEMPLATE_NAME\"] == fabric_bgp_tmpl_name):\n                nvPair[\"CONF\"] = Util.newLine().join(nvPair[\"CONF\"])\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                   ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL1,\n                                   \"bgp_peer_template\", nvPair))\n                bgpTmplNvPairList.remove(nvPair)\n                break\n        Wrapper.print(\"%s: bgp_peer_template remaining nvPairList %s\" % (funcName, bgpTmplNvPairList))\n\n    nvPairList = getTemplateMatchResults(matchResult, \"aaa_tacacs\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            if nvPair[\"AAA_TACACS\"] == \"tacacs+\":\n                Wrapper.print(\"match aaa_tacacs, %s\" % nvPair)\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2,\n                                           \"aaa_tacacs\", nvPair))\n\n    nvPairList = getTemplateMatchResults(matchResult, \"aaa_tacacs_use_vrf\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            if nvPair[\"AAA_TACACS\"] == \"tacacs+\":\n                Wrapper.print(\"match aaa_tacacs_use_vrf, %s\" % nvPair)\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2,\n                                           \"aaa_tacacs_use_vrf\", nvPair))\n    if (POWER_REDUNDANCY_MODE == \"combined\"):\n        createPTI(devSerial, {}, \"power_redundancy_combined\", \"SWITCH\", \"\", -1)\n    else:\n        createPTI(devSerial, {\"REDUNDANCY_MODE\": POWER_REDUNDANCY_MODE},\n                                 \"power_redundancy\", \"SWITCH\", \"\", -1)\n\n    # handle pre-interface global unaccounted cmds\n    features_info = matchResult[\"FEATURES_INFO\"]\n    global_unaccounted = features_info[\"GLOBAL_UNACCTED\"][\"unaccounted\"]\n\n    if LINK_STATE_ROUTING == \"ospf\":\n        underlayProtocolCfgLine = \"router \" + (\"ospf \" if UNDERLAY_IS_V6 == \"false\" else \"ospfv3 \") + LINK_STATE_ROUTING_TAG\n    else:\n        underlayProtocolCfgLine = \"router isis \" + LINK_STATE_ROUTING_TAG\n    #Wrapper.print(\"%s: underlayProtocolCfgLine: [%s]\" % (funcName, underlayProtocolCfgLine))\n\n    keyChainLine = \"\"\n    isisKeyId = \"\"\n    if LINK_STATE_ROUTING == \"is-is\":\n        if ISIS_AUTH_ENABLE == \"true\":\n            keyChainLine = (\"key chain %s\" % ISIS_AUTH_KEYCHAIN_NAME)\n            isisKeyId = (\"key %s\" % ISIS_AUTH_KEYCHAIN_KEY_ID) if (ISIS_AUTH_ENABLE == \"true\") else \"\"\n\n    isBorder = (\"border\" in switchRole)\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n    hasServices = True if servicesInfo and len(servicesInfo) else False\n    isServiceLeaf = switchOverlayInfo[\"isServiceLeaf\"]\n    serviceRMDict = {}\n\n    filteredUnaccounted = []\n    feature_unaccounted = []\n\n    templateName = \"feature_pbr\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        feature_unaccounted.append(\"feature pbr\")\n\n    tcamUnaccounted = []\n    AAA_Configs = []\n    global_unaccounted_AAA = []\n    skipAcl = False\n    isAAABlock = False\n    skipRm = False\n    skipMmodeProfile = False\n    keyChainLines = []\n    keepKeyChain = False\n    isKeyChain = False\n    serviceAclparams = None\n    serviceRmKey = None\n    for line in global_unaccounted:\n        depth = (len(line) - len(line.lstrip(' '))) / 2\n        if depth == 0:\n            # top level CLIs\n            isKeyChain = False\n            keepKeyChain = False\n            skipRm = False\n            serviceRmKey = None\n\n            if skipAcl:\n                # we are out of the ACL block\n                skipAcl = False\n            elif isAAABlock:\n                # we are out of the AAA block\n                isAAABlock = False\n            elif skipMmodeProfile:\n                # we are out of the current maintenance mode profile block\n                skipMmodeProfile = False\n                \n            if (line.startswith(\"power redundancy-mode\") or line.startswith(\"version\")):\n                # these should not be captured in the accounted configs\n                continue\n\n            if line.startswith(\"feature \"):\n                if \"tacacs\" not in line:\n                    feature_unaccounted.append(line)\n                else:\n                    AAA_Configs.append(line)\n                continue\n\n            if line.startswith(\"aaa\"):\n                global_unaccounted_AAA.append(line)\n                isAAABlock = True\n                continue\n\n            if line.startswith(\"hardware access-list tcam region\"):\n                tcamUnaccounted.append(line)\n                continue\n\n            aclCmdPrefix = \"ip access-list \"\n            if line.startswith(aclCmdPrefix):\n                aclName = line[len(aclCmdPrefix):].strip()\n                if aclName == \"telemetryipv4acl\":\n                    skipAcl = True\n                elif hasServices:\n                    # need to check further\n                    for aclPrefixStr in servicesInfo[\"serviceAclPrefixStr\"]:\n                        if aclName.startswith(aclPrefixStr):\n                            #ip access-list acl_vrf_50000_10.1.10.1/24_10.1.11.1/24_ip_any_any\n                            #  10 permit ip 10.1.10.1/24 10.1.11.1/24\n                            # the acl name will be processed when the route-map is parsed\n                            skipAcl = True\n                            break\n                if skipAcl:\n                    continue\n\n            # look for telemetry specific ACL that we need to skip\n            if (line == \"ipv6 access-list telemetryipv6acl\"):\n                skipAcl = True\n                continue\n\n            # look for either maintenance mode or normal mode profile and skip it\n            if line.startswith(\"configure maintenance profile \"):\n                skipMmodeProfile = True\n                continue\n\n            rmCmdPrefix = \"route-map \"\n            if hasServices and line.startswith(rmCmdPrefix):\n                rmName = line[len(rmCmdPrefix):].strip()\n                #Wrapper.print(\"%s: rmName [%s]\" % (funcName, rmName))\n\n                for rmNamePrefix in servicesInfo[\"serviceRmPrefixStr\"]:\n                    # on service node\n                    #route-map rm_vrf_50000 permit 1\n                    #  match ip address acl_vrf_50000_10.1.10.1/24_10.1.11.1/24_ip_any_any\n                    #  set ip next-hop 200.200.200.200\n                    #\n                    # on other leaf (we will just skip this in freeform.. no processing)\n                    #route-map rm_vrf_50000_src_30000 permit 1\n                    #  match ip address acl_vrf_50000_10.1.10.1/24_10.1.11.1/24_ip_any_any\n                    #  set ip next-hop 200.200.200.200\n                    if not rmName.startswith(rmNamePrefix):\n                        continue\n\n                    #Wrapper.print(\"%s: isServiceLeaf [%r] rmName [%s] rmNamePrefix [%s]\" % (funcName, isServiceLeaf, rmName, rmNamePrefix))\n                    skipRm = True\n                    parts = rmName.split(\" \")\n                    partsLen = len(parts)\n                    if partsLen != 3 or (parts[1] not in [\"permit\", \"deny\"]):\n                        Wrapper.print(\"%s: Skip RM line [%s] Unrecognized parts len %d %s\" % (funcName, line, partsLen, parts))\n                        continue\n                    \n                    #if (isServiceLeaf and (parts[0] == rmNamePrefix)):\n                    if parts[2] != \"65535\":\n                        serviceRmKey = rmName\n                        # add a new entry\n                        serviceRMDict[serviceRmKey] = {\"action\" : parts[1], \"seqNum\" : parts[2], \"isProcessed\" : False}\n                        #Wrapper.print(\"%s: Added RM Entry [%s] Entry %s\" % (funcName, serviceRmKey, serviceRMDict[serviceRmKey]))\n                    break\n                if skipRm:\n                    continue\n\n            if line.startswith(\"key chain \"):\n                isKeyChain = True\n                if (line == keyChainLine):\n                    keepKeyChain = True\n                    keyChainLines.append(line)\n                    continue\n\n        elif depth == 1:\n            if isBorder and (line == \"  match ip address prefix-list host-route-v6\"):\n                # these should not be captured in the accounted configs\n                continue\n            elif serviceRmKey:\n                strippedLine = line.strip()\n                if strippedLine.startswith(\"match ip address \"):\n                    serviceRMDict[serviceRmKey][\"aclName\"] = strippedLine.split(\"match ip address \")[1]\n                elif strippedLine.startswith(\"set ip next-hop \"):\n                    parts = strippedLine.split(\"set ip next-hop \")[1].split(\" \")\n                    partsLen = len(parts)\n                    Wrapper.print(\"%s: NH line [%s] parts %d %s\" % (funcName, strippedLine, partsLen, parts))\n                    serviceRMDict[serviceRmKey][\"nextHop\"] = parts[0]\n                    if partsLen > 1:\n                        serviceRMDict[serviceRmKey][\"nextHopOption\"] = parts[1]\n\n        if isKeyChain:\n            if keepKeyChain:\n                keyChainLines.append(line)\n            continue\n        if isAAABlock:\n            global_unaccounted_AAA.append(line)\n            continue\n        elif skipAcl or skipRm or skipMmodeProfile:\n            continue\n          \n        filteredUnaccounted.append(line)\n\n    # process the service node RMs\n    #if isServiceLeaf and serviceRMDict:\n    if serviceRMDict:\n        #Wrapper.print(\"%s: %s serviceRMDict %s\" % (funcName, fmtName, json.dumps(serviceRMDict, indent=4, sort_keys=True)))\n        processServiceRouteMapEntries(FABRIC_NAME, devSerial, serviceRMDict, globalOverlayInfo)\n\n    # filter out the unaccounted key chain config specific to out ISIS auth key chain and key id\n    keyChainLinesFiltered = []\n    if keyChainLine != \"\":\n        for line in keyChainLines:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                ourBlock = False\n                if line == keyChainLine:\n                    ourBlock = True\n            elif depth == 1:\n                strippedLine = line.strip()\n                ourBlock = False\n                if strippedLine == isisKeyId:\n                    ourBlock = True\n\n            if ourBlock:\n                keyChainLinesFiltered.append(line)\n\n        if len(keyChainLinesFiltered) == 1:\n            keyChainLinesFiltered.clear()\n\n    Wrapper.print(\"%s: %s filteredUnaccounted %s\" % (funcName, fmtName, filteredUnaccounted))\n    #Wrapper.print(\"%s: keyChainLine [%s] isisKeyId [%s] keyChainLines %s keyChainLinesFiltered %s\" % (funcName, keyChainLine, isisKeyId, keyChainLines, keyChainLinesFiltered))\n\n    # update the 'global_unaccounted' to the filtered list for subsequent use\n    global_unaccounted = (filteredUnaccounted + keyChainLinesFiltered)\n\n    priority = 5\n    for cmd in tcamUnaccounted:\n        tcamInfoList = cmd.split(\"hardware access-list tcam region \")[1].split(\" \")\n        Wrapper.print(\"%s(): Device %s tcam info list: %s\" % (funcName, devSerial, tcamInfoList))\n        tcamName = tcamInfoList[0] if len(tcamInfoList) > 0 else \"\"\n        tcamSize = tcamInfoList[1] if len(tcamInfoList) > 1 else \"\"\n        tcamType = tcamInfoList[2] if len(tcamInfoList) > 2 else \"\"\n        templateName = \"tcam_config\"\n        ptiPrio = priority\n        if tcamName and tcamSize:\n            Wrapper.print(\"%s(): Device %s created tcam pti with name = [%s], size = [%s], type = [%s]\" % (funcName, devSerial, tcamName, tcamSize, tcamType))\n            #PTIWrapper.delete(devSerial, \"SWITCH\", \"SWITCH\", \"\", templateName)\n            Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ptiPrio, templateName, {\"TCAM_NAME\": tcamName, \"TCAM_SIZE\":tcamSize}, \"bf_tcam\"))\n        priority = priority+5\n\n    # look for the vrf references in matches for 'dns_vrf_one' and 'dns_vrf' policies\n    vrfsWithDns = []\n    dnsTemplates = ['dns-vrfList']\n    for templateName in dnsTemplates:\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            getVrfsWithDns(nvPairList, vrfsWithDns)\n\n    vrf_block = features_info[\"VRF_BLOCK\"]\n    for vrfStr in vrf_block.keys():\n        vrfRec = vrf_block[vrfStr]\n        vrfName = vrfStr.split(\" \")[2].strip()\n        Wrapper.print(\"%s: Processing DNS for VRF context [%s]\" % (funcName, vrfName))\n        \n        if vrfName.lower() == MGMT_VRF_NAME:\n            global_unaccounted += vrfRec[\"unaccounted\"]\n        else:\n            if vrfName in vrfsWithDns:\n                continue\n            newCfg = []\n            for line in vrfRec[\"show_run\"]:\n                strippedLine = line.strip()\n                if strippedLine.startswith(\"vrf context\") or strippedLine.startswith(\"ip name-server\"):\n                    newCfg.append(line)\n            if len(newCfg) > 1:\n                Wrapper.print(\"%s: VRF context [%s]. Name server cfg = [%s]\" % (funcName, vrfName, newCfg))\n                global_unaccounted += newCfg\n                #global_unaccounted += Util.newLine().join(newCfg)\n\n    bgp_unaccounted = []\n    routerBgpKey = \"router bgp \" + BGP_AS\n    if routerBgpKey in features_info[\"BGP_BLOCK\"]:\n        bgp_unaccounted = features_info[\"BGP_BLOCK\"][routerBgpKey][\"unaccounted\"]\n\n    # add matched bgp_peer_template and bgp_neighbor_inherit which did not have policy created\n    # may work on the order later\n    if bgpTmplNvPairList == None:\n        bgpTmplNvPairList = []\n    if bgpInheritNvPairList == None:\n        bgpInheritNvPairList = []\n    if len(bgp_unaccounted) == 0 and (len(bgpTmplNvPairList) + len(bgpInheritNvPairList)) != 0:\n        bgp_unaccounted.append(\"router bgp %s\" % BGP_AS)\n\n    for nvPair in bgpTmplNvPairList:\n        bgp_unaccounted.append(\"  template %s %s\" % (nvPair[\"TEMPLATE_TYPE\"],nvPair[\"TEMPLATE_NAME\"]))\n        bgp_unaccounted += nvPair[\"CONF\"]\n\n    for nvPair in bgpInheritNvPairList:\n        bgp_unaccounted.append(\"  neighbor %s\" % nvPair[\"BGP_NEIGHBOR_IP\"])\n        bgp_unaccounted.append(\"    inherit %s %s\" % (nvPair[\"TEMPLATE_TYPE\"], nvPair[\"TEMPLATE_NAME\"]))\n\n    Wrapper.print(\"BGP unaccounted with template: %s\" % bgp_unaccounted)\n\n    cmap = vVpcSpineQos[devSerial].get('classMap') if vVpcSpineQos.has_key(devSerial) else \"\"\n    pmap = vVpcSpineQos[devSerial].get('policyMap') if vVpcSpineQos.has_key(devSerial) else \"\"\n    \n    ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n    for pti in ptiList:\n        Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n\n    if feature_unaccounted:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_TOP,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(feature_unaccounted)}, \"Additional Feature Configuration\"))\n\n    if cmap and pmap:\n        vVpcQosConf = cmap + Util.newLine() + pmap\n        vVpcQosConfList = vVpcQosConf.splitlines()\n        vVpcQosDescription = \"Qos on Spines for fabric vpc peering\"\n        fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n        qosPolicyName = fabricSettings.get(\"FABRIC_VPC_QOS_POLICY_NAME\", \"spine_qos_for_fabric_vpc_peering\")\n        ptiList = Util.getPTIList(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\", \"PYTHON\", vVpcQosDescription)\n        for pti in ptiList:\n            PTI.deleteInstance(pti.getPolicyId())\n        Util.exe(PTI.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP, \n                            \"switch_freeform\", {\"CONF\":vVpcQosConf, \"POLICY_NAME\":qosPolicyName}, vVpcQosDescription))\n        Wrapper.print(\"%s(): global_unaccounted [%s] , vVpcQosConfList [%s]\"%(funcName, global_unaccounted, vVpcQosConfList))\n        globalUnaccountedStr = Util.newLine().join(global_unaccounted)\n        globalUnaccountedStr = globalUnaccountedStr.replace(cmap, '')\n        globalUnaccountedStr = globalUnaccountedStr.replace(pmap, '')\n        global_unaccounted = globalUnaccountedStr.splitlines()\n\n    # need to process the config blocks collected from the 'show run'\n    linkProtoCfgLines = []\n    keyChainCfgLines = []\n    cfgBlocksFromShRun = matchResult.get(\".SH_RUN_CFG_BLOCKS\", {})\n    for key in cfgBlocksFromShRun:\n        instances = cfgBlocksFromShRun[key]\n        if (key in [\"ROUTER_ISIS\", \"ROUTER_OSPF\"]):\n            for instance in instances:\n                if underlayProtocolCfgLine == instance:\n                    # we are not interested in this since the policy matches would have captured the intent\n                    continue\n                else:\n                    linkProtoCfgLines += instances[instance]\n        elif key == \"KEY_CHAIN\":\n            for instance in instances:\n                if keyChainLine == instance:\n                    # look further into the key id of interest.. (will not get here is ISIS and auth is not enabled)\n                    isisKeyLines = []\n                    ourBlock = False\n                    for line in instances[instance]:\n                        depth = (len(line) - len(line.lstrip(' '))) / 2\n\n                        if depth == 1:\n                            strippedLine = line.strip()\n                            ourBlock = False\n                            if strippedLine == isisKeyId:\n                                ourBlock = True\n\n                        if not ourBlock:\n                            isisKeyLines.append(line)\n                    if len(isisKeyLines) > 1:\n                        # the first line is the 'key chain <name>'\n                        keyChainCfgLines += isisKeyLines\n                else:\n                    keyChainCfgLines += instances[instance]\n\n    switchOverlayInfo[\"PRE_INTF_FF\"] = (global_unaccounted + keyChainCfgLines + switchOverlayInfo[\"PRE_INTF_FF\"])\n    if switchOverlayInfo[\"PRE_INTF_FF\"]:\n        # this needs to show up before the interfaces\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(switchOverlayInfo[\"PRE_INTF_FF\"])}, BF_PRE_INTF_FF_PTI_DESC))\n    switchOverlayInfo[\"PRE_INTF_FF\"] = None\n\n    # create the post interface unaccounted config block.. this must show up after the interfaces\n    global_unaccounted_AAA_INTF = []\n    filteredUnaccounted = []\n    if 'GLOBAL_POST_INTF_UNACCTED' in features_info:\n        if features_info[\"GLOBAL_POST_INTF_UNACCTED\"]:\n            global_unaccounted = features_info[\"GLOBAL_POST_INTF_UNACCTED\"][\"unaccounted\"]\n            for line in global_unaccounted:\n                depth = (len(line) - len(line.lstrip(' '))) / 2\n\n                if depth == 0:\n                    # top level config\n                    skipBlock = False\n                    if line.startswith(\"boot\"):\n                        # these should not be captured in the accounted configs\n                        continue\n                    if line.startswith(\"router ospf \") or line.startswith(\"router ospfv3 \") or line.startswith(\"router isis \"):\n                        if line != underlayProtocolCfgLine:\n                            # the entire configs for these will be obtained from the 'show run' already.. remove from here\n                            skipBlock = True\n\n                if skipBlock:\n                    Wrapper.print(\"underlayProtocolCfgLine: skipping line [%s]\" % line)\n                    continue\n\n                if (line.startswith(\"radius\") or line.startswith(\"tacacs\") or\n                    line.startswith(\"aaa\") or line.startswith(\"  server\")):\n                    global_unaccounted_AAA_INTF.append(line)\n                    continue\n\n                filteredUnaccounted.append(line)\n\n    postIntfFF = filteredUnaccounted + linkProtoCfgLines + switchOverlayInfo[\"POST_INTF_FF\"]\n    if postIntfFF:\n        # this needs to show up after the interfaces\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.POST_INTF_SWITCH_FF,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(postIntfFF)}, \"Post Interfaces Configuration\"))\n    switchOverlayInfo[\"POST_INTF_FF\"] = None\n\n    AAA_Configs += global_unaccounted_AAA_INTF\n    AAA_Configs += global_unaccounted_AAA\n    if AAA_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.AAA_SWITCH_FF,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(AAA_Configs)}, \"NDFC AAA extra configuration\")) \n\n    bgpFF = bgp_unaccounted + switchOverlayInfo[\"BGP_FF\"]\n    isBGW = True if \"border gateway\" == switchRole else False\n    if isBGW:\n        # capture any rr client configs that were found\n        templateName = \"evpn_bgp_rr\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            respObj.addWarnReport(\"BGP_RR_ON_BORDER_GATEWAY\",\n                   \"Border Gateway role - found BGP Route Reflector (RR) client configuration which is not \"\n                   \"recommended for this role other than for the Endpoint Locator (EPL) use-case.\", devSerial)\n            if respObj.isRetCodeSuccess():\n                # do not overwrite existing error status if any\n                respObj.setWarningRetCode()\n            for nvPairs in nvPairList:\n                genCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, nvPairs, False, None)\n                bgpFF.append(genCfg)\n\n    if bgpFF:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_BOTTOM,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(bgpFF)}, \"BGP Configuration\"))\n    switchOverlayInfo[\"BGP_FF\"] = None\n\n    # process leaf/spine specific global configs\n    vpcPairInfo = {}\n    if not isSpine:\n        # process leaf specific configs\n\n        # create the base features PTI\n        createPTI(devSerial, {}, \"base_feature_leaf_upg\", \"SWITCH\", getSrc(\"base_feature_leaf_upg\"), -1)\n        templateName = \"feature_ospf\" if UNDERLAY_IS_V6 == \"false\" else \"feature_ospfv3\"\n        createMatchedPtis(devSerial, matchResult, templateName)\n        createMatchedPtis(devSerial, matchResult, \"feature_lacp\")\n        createMatchedPtis(devSerial, matchResult, \"feature_pim\")\n        createMatchedPtis(devSerial, matchResult, \"feature_ngoam\")\n        createMatchedPtis(devSerial, matchResult, \"feature_ngmvpn\")\n        createMatchedPtis(devSerial, matchResult, \"trm_multicast_multipath\")\n        createMatchedPtis(devSerial, matchResult, \"feature_dhcp\")\n        createMatchedPtis(devSerial, matchResult, \"eth_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv4_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv6_cfs\")\n\n        createMatchedPtis(devSerial, matchResult, \"enable_ngoam\")\n        createMatchedPtis(devSerial, matchResult, \"route_map\")\n        createMatchedPtis(devSerial, matchResult, \"anycast_gateway\")\n        createMatchedPtis(devSerial, matchResult, \"evpn_bgp_advertise_pip\")\n        createMatchedPtis(devSerial, matchResult, \"nve_advertise_vmac\")\n        templateName = \"evpn_bgp_rr_neighbor\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr_neighbor\"\n        deleteAndCreateMatchedPtis(devSerial, matchResult, templateName)\n        deleteAndCreateMatchedPtis(devSerial, matchResult, \"mvpn_bgp_rr_neighbor\")\n        createMatchedPtis(devSerial, matchResult, \"l3_trm\")\n        createMatchedPtis(devSerial, matchResult, \"base_dhcp\")\n\n        # check system nve infra vlans\n        # what about resource and what about vlan id\n        templateName = \"system_nve_infra_vlan\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            infraVlans = nvPairList[0].get(\"VLAN\")\n            if infraVlans:\n                infraVlanList = getVlanList(infraVlans)\n                if vPCInfo[\"peerLinkVlan\"] in infraVlanList:\n                    infraVlanList.remove(vPCInfo[\"peerLinkVlan\"])\n                infraVlanPTIs = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"system_nve_infra_vlan\"))\n                for pti in infraVlanPTIs:\n                    PTIWrapper.deleteInstance(pti.getPolicyId())\n                for vlan in infraVlanList:\n                    createPTI(devSerial,{\"VLAN\": vlan}, \"system_nve_infra_vlan\", \"SWITCH\",\"\", -1, False)\n\n\n        # create the extra CLIs PTI (we will not match these from the config)\n        if EXTRA_CONF_LEAF != \"\":\n            createPTI(devSerial, {\"CONF\": EXTRA_CONF_LEAF}, \"extra_config_leaf\",\n                                  \"SWITCH\", \"UNDERLAY\", -1)\n\n        if isValidVPC:\n            vpcPairInfo[\"domainId\"] = vPCInfo[\"domainId\"]\n\n            createMatchedPtis(devSerial, matchResult, \"vpc_domain_mgmt\")\n            createMatchedPtis(devSerial, matchResult, \"vpc_domain_ipv6_nd_11_1\")\n\n            createVirtualPeerLinkPTI(devSerial, matchResult, vpcPairInfo)\n            peerSerial = getVPCPeerDeviceSN(devSerial, vpcSrcToDstMacMap)\n            if peerSerial:\n                if vpcPairInfo.get(\"vpcFabricPair\"):\n                    Util.exe(VpcWrapper.create(devSerial, peerSerial, \"true\"))\n                else:\n                    Util.exe(VpcWrapper.create(devSerial, peerSerial))\n\n            \"\"\"\n            no need to create policies below since we will take it from fabric setting. TBD on warning\n            templateName = \"vpc_domain_autorecovery\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            if (nvPairList != None):\n                if nvPairList[0][\"AUTO_RECOVERY\"] != \"240\":\n                    # save the info (we expect a single entry)\n                    vpcPairInfo.update({\"autoRecoveryTime\" : nvPairList[0][\"AUTO_RECOVERY\"]})\n                    createMatchedPtis(devSerial, matchResult, \"vpc_domain_autorecovery\")\n                else:\n                    createMatchedPtis(devSerial, matchResult, \"vpc_domain_autorecovery_default\")\n\n            templateName = \"vpc_delay_restore\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            if (nvPairList != None):\n                if nvPairList[0][\"DELAY_RESTORE\"] != \"30\":\n                    # save the info (we expect a single entry)\n                    vpcPairInfo.update({\"delayRestore\" : nvPairList[0][\"DELAY_RESTORE\"]})\n                    createMatchedPtis(devSerial, matchResult, \"vpc_delay_restore\")\n            \"\"\"\n    \n            templateName = \"vpc_nve_loopback\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            templateName = \"vpc_nve_loopback_with_tag_11_1\"\n            nvPairListWithTag = getTemplateMatchResults(matchResult, templateName)\n\n            if (nvPairList != None):\n                # save the info (we expect a single entry)\n                vpcPairInfo.update({\"nveSecondaryLoopbackIntf\" : nvPairList[0][\"INTF_NAME\"]})\n                vpcPairInfo.update({\"nveSecondaryIp\" : nvPairList[0][\"SECONDARY_IP\"]})\n                #createMatchedPtis(devSerial, matchResult, \"vpc_nve_loopback\")\n            elif nvPairListWithTag != None:\n                vpcPairInfo.update({\"nveSecondaryLoopbackIntf\" : nvPairListWithTag[0][\"INTF_NAME\"]})\n                vpcPairInfo.update({\"nveSecondaryIp\" : nvPairListWithTag[0][\"SECONDARY_IP\"]})\n                vpcPairInfo.update({\"ROUTE_MAP_TAG\" : nvPairListWithTag[0][\"ROUTE_MAP_TAG\"]})\n                #createMatchedPtis(devSerial, matchResult, \"vpc_nve_loopback_with_tag_11_1\")\n\n            # process the vPC peer link SVI\n            sviIntf, nvPair = getSviTemplateMatch(vPCInfo[\"peerLinkVlan\"], matchResult, interfacesRes)\n            if nvPair:\n                intfName = nvPair[\"INTF_NAME\"]\n                vpcPeerLinkSviNvPairs = {\"FABRIC_NAME\" : FABRIC_NAME,\n                                         \"INTF_NAME\" : \"\",\n                                         \"IP\" : \"\",\n                                         \"PREFIX\" : \"\",\n                                         \"V6IP\" : \"\",\n                                         \"V6PREFIX\" : \"\",\n                                         \"LINK_STATE_ROUTING\": LINK_STATE_ROUTING,\n                                         \"LINK_STATE_ROUTING_TAG\": \"\",\n                                         \"OSPF_AREA_ID\": OSPF_AREA_ID,\n                                         \"REPLICATION_MODE\":REPLICATION_MODE,\n                                         \"MTU\":\"\",\n                                         \"DESC\" : \"\",\n                                         \"CONF\" : \"\",\n                                         \"ADMIN_STATE\" : \"true\",\n                                         \"BFD_ENABLE\" : BFD_ENABLE,\n                                         \"BFD_ECHO_DISABLE\" : \"false\"\n                                        }\n\n                if (len(sviIntf[\"unaccounted_cmds\"]) > 0):\n                    vpcPeerLinkSviNvPairs.update({\"CONF\": Util.newLine().join(sviIntf[\"unaccounted_cmds\"])}) \n                if UNDERLAY_IS_V6 == \"false\":\n                    # Underlay is V4, treat ipv6 address config as unaccounted\n                    templateList = [\"interface_ipv6_11_1\"]\n                else:\n                    # Underlay is V6, treat ip address config as unaccounted\n                    templateList = [\"interface_ipv4_11_1\"]\n                configList = unaccCfgFromTemplates(intfName, templateList, sviIntf, matchResult)\n                if vpcPeerLinkSviNvPairs[\"CONF\"] and configList:\n                    vpcPeerLinkSviNvPairs[\"CONF\"] = vpcPeerLinkSviNvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                elif configList:\n                    vpcPeerLinkSviNvPairs[\"CONF\"] = Util.newLine().join(configList)\n                Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"%(devSerial, intfName, vpcPeerLinkSviNvPairs.get(\"CONF\")))\n                \n                # save the vPC peer link vlan id\n                vpcPairInfo.update({\"peerLinkVlanIntf\" : nvPair[\"INTF_NAME\"]})\n                vpcPairInfo.update({\"peerLinkVlan\" : nvPair[\"INTF_NAME\"].lstrip(\"Vlan\")})\n                if UNDERLAY_IS_V6 == \"false\":\n                    vpcPairInfo.update({\"peerLinkVlanIp\" : nvPair[\"IP\"]})\n                    vpcPairInfo.update({\"peerLinkVlanIpPrefix\" : nvPair[\"PREFIX\"]})\n                    vpcPeerLinkSviNvPairs[\"IP\"] = nvPair[\"IP\"]\n                    vpcPeerLinkSviNvPairs[\"PREFIX\"] = nvPair[\"PREFIX\"]\n                elif USE_LINK_LOCAL == \"false\":\n                    vpcPairInfo.update({\"peerLinkVlanIp\" : nvPair[\"IP\"]})\n                    vpcPairInfo.update({\"peerLinkVlanIpPrefix\" : nvPair[\"PREFIX\"]})\n                    vpcPeerLinkSviNvPairs[\"V6IP\"] = nvPair[\"IP\"]\n                    vpcPeerLinkSviNvPairs[\"V6PREFIX\"] = nvPair[\"PREFIX\"]\n                else:\n                    vpcPairInfo.update({\"peerLinkVlanIp\" : \"\"})\n                    vpcPairInfo.update({\"peerLinkVlanIpPrefix\" : \"\"})\n\n                vpcPeerLinkSviNvPairs[\"INTF_NAME\"] = nvPair[\"INTF_NAME\"]\n\n                # mark the interface as being processed\n                sviIntf.update({\"isProcessed\" : True})\n                Wrapper.print(\"%s: Interface [%s] is marked as processed at line [%s]\"%(funcName, intfName, sys._getframe().f_lineno))\n\n                templateNameMatches = sviIntf[\"matched_templates\"]\n                matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n                for templateName in matchingNvPairs:\n                    if (\"interface_desc\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n                    if (\"interface_mtu\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"MTU\"] = matchingNvPairs[templateName][\"MTU\"]\n                    elif (\"ospf_interface_11_1\" == templateName or \"v6_ospf_interface\" == templateName):\n                        vpcPeerLinkSviNvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"OSPF_TAG\"]})\n                        vpcPeerLinkSviNvPairs.update({\"OSPF_AREA_ID\" : matchingNvPairs[templateName][\"OSPF_AREA_ID\"]})\n                    elif (\"isis_interface\" == templateName or \"v6_isis_interface\" == templateName):\n                        vpcPeerLinkSviNvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"ISIS_TAG\"]})\n                    elif (\"shut_interface\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"ADMIN_STATE\"] = \"false\"\n                    elif (\"ospf_interface_auth\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"OSPF_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY_ID\"]\n                        vpcPeerLinkSviNvPairs[\"OSPF_AUTH_KEY\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY\"]\n                    elif (\"pim_interface_hello_auth\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"PIM_HELLO_AUTH_KEY\"] = matchingNvPairs[templateName][\"AUTH_KEY\"]\n                    elif (\"isis_interface_auth\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"ISIS_AUTH_KEYCHAIN_NAME\"] = matchingNvPairs[templateName][\"ISIS_AUTH_KEYCHAIN_NAME\"]\n                        vpcPeerLinkSviNvPairs[\"IS_TYPE\"] = matchingNvPairs[templateName][\"IS_TYPE\"]\n                    elif (\"bfd_interface_auth\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"BFD_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"BFD_AUTH_KEY_ID\"]\n                        vpcPeerLinkSviNvPairs[\"BFD_AUTH_KEY\"] = matchingNvPairs[templateName][\"BFD_AUTH_KEY\"]\n                    elif (\"bfd_no_echo_interface\" == templateName):\n                        vpcPeerLinkSviNvPairs[\"BFD_ECHO_DISABLE\"] = \"true\"\n\n                if \"BFD_AUTH_KEY\" not in vpcPeerLinkSviNvPairs:\n                    vpcPeerLinkSviNvPairs[\"BFD_AUTH_KEY\"] = BFD_AUTH_KEY\n                    vpcPeerLinkSviNvPairs[\"BFD_AUTH_KEY_ID\"] = BFD_AUTH_KEY_ID\n                if \"OSPF_AUTH_KEY\" not in vpcPeerLinkSviNvPairs:\n                    vpcPeerLinkSviNvPairs[\"OSPF_AUTH_KEY\"] = OSPF_AUTH_KEY\n                    vpcPeerLinkSviNvPairs[\"OSPF_AUTH_KEY_ID\"] = OSPF_AUTH_KEY_ID\n                if \"ISIS_AUTH_KEYCHAIN_NAME\" not in vpcPeerLinkSviNvPairs:\n                    vpcPeerLinkSviNvPairs[\"ISIS_AUTH_KEYCHAIN_NAME\"] = ISIS_AUTH_KEYCHAIN_NAME\n                    vpcPeerLinkSviNvPairs[\"IS_TYPE\"] = ISIS_LEVEL\n                vpcPeerLinkSviNvPairs[\"ISIS_P2P_ENABLE\"] = ISIS_P2P_ENABLE\n\n                # create the vPC peer link SVI jython policy\n                Wrapper.print(\"%s: Creating peer link SVI [%s] policy. BFD_ENABLE [%s], nvPairs [%s]\" % \n                    (funcName, intfName, BFD_ENABLE, vpcPeerLinkSviNvPairs))\n                createPTI(devSerial, vpcPeerLinkSviNvPairs, \"int_fabric_vlan_11_1\", intfName, \"UNDERLAY\", -1)\n\n                # create PTI for the peer link vlan also\n                templateName = \"vpc_peer_link_vlan\"\n                asicType = getHwAsicType(topologyDataObj, devSerial)\n                if asicType != \"CLOUDSCALE\":\n                    # this template is good for T2, Fretta, N9kv and white box\n                    templateName = \"vpc_peer_link_vlan_9300PX\"\n                createPTI(devSerial, {\"VLAN\" : vPCInfo[\"peerLinkVlan\"]}, templateName, \"SWITCH\", \"UNDERLAY\", -1)\n\n                # create the PTI for the peer link vlan name if we do find one\n                templateName = \"vlan_name_11_1\"\n                nvPairList = getTemplateMatchResults(matchResult, templateName)\n                if (nvPairList != None):\n                    for nvPair in nvPairList:\n                        if (nvPair[\"VLAN\"] == vPCInfo[\"peerLinkVlan\"]):\n                            # create the PTI with an empty source to allow user to change the name is needed\n                            createPTI(devSerial, nvPair, templateName, \"SWITCH\", \"\", -1)\n\n            vpcPeerLinkPoNvPairs = { \"PO_ID\" : \"\",\n                                     \"NATIVE_VLAN\" : \"\",\n                                     \"DESC\" : \"\",\n                                     \"MEMBER_DESC\":\"\",\n                                     \"ADMIN_STATE\" : \"true\",\n                                     \"MEMBER_INTERFACES\":\"\",\n                                     \"CONF\":\"\"\n                                   }\n\n            # lookup the vpc peer link PO\n            vpcMCTPoId = \"\"\n            pcRmId = -1\n            templateName = \"vpc_peer_link_po_interface\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            if (nvPairList != None):\n                # we expect only one nv pair\n                entityType = getEType(templateName)\n                entityName = getEntityName(devSerial, entityType, nvPairList[0], templateName)\n                intfMatchResult = interfacesRes[entityName]\n\n                vpcPeerLinkPoNvPairs.update({\"PO_ID\" : entityName})\n\n                # mark the interface as being processed\n                intfMatchResult.update({\"isProcessed\" : True})\n                Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(entityName, sys._getframe().f_lineno))\n\n                # set the PO id resource\n                portChannelIntf = entityName.lower()\n                pc, vpcMCTPoId = portChannelIntf.split(\"port-channel\")\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC Peer-Link PO: PORT_CHANNEL_ID [%s]\"%\n                              (FABRIC_NAME, key, vpcMCTPoId))\n                ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, entityName, vpcMCTPoId))\n\n                # get the interface template results to get additional info\n                templateNameMatches = intfMatchResult[\"matched_templates\"]\n                templateList = [\"interface_desc\"]\n                matchingNvPairs = getIntfMatchNvPairs(matchResult, entityName, templateList)\n                if matchingNvPairs:\n                    vpcPeerLinkPoNvPairs.update({\"DESC\" : matchingNvPairs[\"interface_desc\"][\"DESC\"]})\n\n                if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                    Wrapper.print(\"Device [%s] Found unaccounted cfg for portchannel intf [%s]\" % (devSerial, portChannelIntf))\n\n                    # we need to scan and extract the trunk native vlan from the unaccounted config\n                    vpcPeerLinkPoNvPairs[\"NATIVE_VLAN\"], updatedFFCfgList = getNativeVlanAndUpdatedUnacctCfgList(\n                                            intfMatchResult[\"unaccounted_cmds\"])\n\n                    # set the updated extra config\n                    vpcPeerLinkPoNvPairs.update({\"CONF\": Util.newLine().join(updatedFFCfgList)}) \n\n                templateList = [\n                                \"interface_speed\",\n                                \"interface_no_nego_auto\",\n                                \"bpduguard_disable\", \n                                \"bpduguard_enable\", \n                                \"porttype_fast_trunk\",\n                                \"porttype_fast_enable\",\n                                \"access_vlan\",\n                                \"cdp_disable_interface_11_1\"\n                               ]\n\n                configList = unaccCfgFromTemplates(portChannelIntf, templateList, intfMatchResult, matchResult)\n                if vpcPeerLinkPoNvPairs[\"CONF\"] and configList:\n                    vpcPeerLinkPoNvPairs[\"CONF\"] = vpcPeerLinkPoNvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                elif configList:\n                    vpcPeerLinkPoNvPairs[\"CONF\"] = Util.newLine().join(configList)\n                Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"% \n                             (devSerial, portChannelIntf, vpcPeerLinkPoNvPairs.get(\"CONF\")))\n\n             # lookup the vpc peer link peer members\n            templateName = \"vpc_peer_link_member_interface\"\n            nvPairList = getTemplateMatchResults(matchResult, templateName)\n            vpcPeerLinkMemberInterfaces = []\n            if (nvPairList != None):\n                for memberNvPair in nvPairList:\n                    if (vpcMCTPoId != memberNvPair[\"PCID\"]):\n                        # this interface does not belong to the MCT\n                        continue\n\n                    entityType = getEType(templateName)\n                    entityName = getEntityName(devSerial, entityType, memberNvPair, templateName)\n                    intfMatchResult = interfacesRes[entityName]\n\n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(entityName, sys._getframe().f_lineno))\n\n                    vpcPeerLinkMemberInterfaces.append(entityName)\n                \n                    # check to see if we need the peer serial\n                    try:\n                        if (vpcPairInfo[\"peerSerialNum\"] != None):\n                            # we have the info already... skip\n                            continue\n                    except:\n                        # the 'peerSerialNum' key does not exist.. \n                        peerSerial = topologyDataObj.getNeighborDeviceSN(devSerial, entityName)\n                        if not (peerSerial == \"\" or peerSerial == 0):\n                            # we have a valid peer... check if it's state is complete\n                            if not isSwitchInUnderlayMigration(peerSerial):\n                                # the expected PTIs should be in place\n                                Wrapper.print(\"vPC: peer serial %s\" % peerSerial)\n                                vpcPairInfo.update({\"peerSerialNum\" : peerSerial})\n                            else:\n                                Wrapper.print(\"vPC: Found peer [%s], but, not migrated\" % peerSerial)\n\n                vpcPeerLinkPoNvPairs.update({\"MEMBER_INTERFACES\" : \",\".join(vpcPeerLinkMemberInterfaces)})\n            if vpcPairInfo.get(\"vpcFabricPair\"):\n                peerSerial = getVPCPeerDeviceSN(devSerial, vpcSrcToDstMacMap)\n                if not (peerSerial == \"\" or peerSerial == 0):\n                    # we have a valid peer... check if it's state is complete\n                    if not isSwitchInUnderlayMigration(peerSerial):\n                        # the expected PTIs should be in place\n                        Wrapper.print(\"vPC: peer serial %s\" % peerSerial)\n                        vpcPairInfo.update({\"peerSerialNum\" : peerSerial})\n                    else:\n                        Wrapper.print(\"vPC: Found peer [%s], but, not migrated\" % peerSerial)\n                vpcPeerLinkPoNvPairs.update({\"MEMBER_INTERFACES\" : \"\"})\n                \n            # we will go ahead and create the vpc peer link PO policy\n            createPTI(devSerial, vpcPeerLinkPoNvPairs, \"int_vpc_peer_link_po\", \n                      vpcPeerLinkPoNvPairs[\"PO_ID\"], \"\", pcRmId)\n            ptiTemplate = \"int_vpc_peer_link_po_member_11_1\"\n            poMemberDescAndFFUpd(devSerial, vpcPeerLinkMemberInterfaces, ptiTemplate, \n                                 vpcMCTPoId, matchResult, interfacesRes, portChannelIntf)\n\n            # take care of setting the vPC related resouces in RM\n            # check if we have the peer serial number\n            peerSerial = \"\"\n            try:\n                peerSerial = vpcPairInfo[\"peerSerialNum\"]\n            except:\n                Wrapper.print(\"vPC: peer serial # does not exist.. skip setting up resources\")\n\n            if (peerSerial != \"\"):\n\n                if not vpcPairInfo.get(\"vpcFabricPair\"):\n                    localIntfIp = vpcPairInfo[\"peerLinkVlanIp\"]\n                \n                # check that the roles of the two peers are consistent before making them a vpcPair\n                peerSwitchRole = topologyDataObj.getSwitchRole(peerSerial)\n                if switchRole != peerSwitchRole:\n                    respObj.addErrorReport(getFabErrEntity(funcName, \"VPC_PAIR_ROLE\"),\n                        \"Inconsistent Role [%s] with vPC Peer switch [%s] Role [%s]. Please set roles correctly and \"\n                        \"retry.\" % (switchRole, getFormattedSwitchName(peerSerial), peerSwitchRole), devSerial)\n                    respObj.setFailureRetCode()\n                else:\n                    # mark the pair as a vPC\n                    Wrapper.print(\"vPC: Marking [%s:%s] a pair\" % (devSerial, peerSerial))\n                    if vpcPairInfo.get(\"vpcFabricPair\"):\n                        Util.exe(VpcWrapper.create(devSerial, peerSerial, \"true\"))\n                    else:\n                        Util.exe(VpcWrapper.create(devSerial, peerSerial))\n\n                    vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n                    serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n                    if ENABLE_FABRIC_VPC_DOMAIN_ID == \"false\":\n                        # Fabric setting is for unique vpc domain ids.. set the vPC domain ID in RM\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: VPC_DOMAIN_ID [%s]\"% \n                                      (FABRIC_NAME, vpcPairSerialKey, vpcPairInfo[\"domainId\"]))\n                        Util.exe(RM.set(FABRIC_NAME, \"VPC_DOMAIN_ID\", vpcPairSerialKey, vpcPairInfo[\"domainId\"]))\n\n                    if not vpcPairInfo.get(\"vpcFabricPair\"):\n                        # set the vPC peer link vlan in RM\n                        ignore, vlanRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_PEER_LINK_VLAN\",\n                                            devSerial, vpcPairSerialKey, vpcPairInfo[\"peerLinkVlan\"]))\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: VPC_PEER_LINK_VLAN [%s], rmId %s - %s\"%\n                                      (FABRIC_NAME, vpcPairSerialKey, vpcPairInfo[\"peerLinkVlan\"], vlanRmId, devSerial))\n\n                        templateName = \"vpc_peer_link_vlan\"\n                        asicType = getHwAsicType(topologyDataObj, devSerial)\n                        if asicType != \"CLOUDSCALE\":\n                            templateName = \"vpc_peer_link_vlan_9300PX\"\n\n                        peerVlanPTIs = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\",\n                                                               \"UNDERLAY\", templateName))\n                        for pti in peerVlanPTIs:\n                            if pti.isDeleted():\n                                continue\n\n                            Wrapper.print(\"Update %s policy %s with rmId %s\" % (templateName, pti.getPolicyId(), vlanRmId))\n                            Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), devSerial, \"SWITCH\", \"SWITCH\",\n                                                        pti.getSource(), pti.getPriority(),\n                                                        vlanRmId, templateName, pti.getNvPairs()))\n                            break\n\n                        ignore, vlanRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_PEER_LINK_VLAN\",\n                                            peerSerial, vpcPairSerialKey, vpcPairInfo[\"peerLinkVlan\"]))\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: VPC_PEER_LINK_VLAN [%s], rmId %s - %s\"%\n                                      (FABRIC_NAME, vpcPairSerialKey, vpcPairInfo[\"peerLinkVlan\"], vlanRmId, peerSerial))\n\n                        templateName = \"vpc_peer_link_vlan\"\n                        asicType = getHwAsicType(topologyDataObj, peerSerial)\n                        if asicType != \"CLOUDSCALE\":\n                            templateName = \"vpc_peer_link_vlan_9300PX\"\n\n                        peerVlanPTIs = Util.exe(PTIWrapper.get(peerSerial, \"SWITCH\", \"SWITCH\",\n                                                               \"UNDERLAY\", templateName))\n                        for pti in peerVlanPTIs:\n                            if pti.isDeleted():\n                                continue\n\n                            Wrapper.print(\"Update %s policy %s with rmId %s\" % (templateName, pti.getPolicyId(), vlanRmId))\n                            Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), peerSerial, \"SWITCH\", \"SWITCH\",\n                                                        pti.getSource(), pti.getPriority(),\n                                                        vlanRmId, templateName, pti.getNvPairs()))\n                            break\n\n                        # generate the key to associate the vPC peer link subnet pool with\n                        peerLinkVlanIntf = vpcPairInfo[\"peerLinkVlanIntf\"]\n                        linkKey = Util.exe(Helper.getKey(\"Link\", serials[0], peerLinkVlanIntf, serials[1], peerLinkVlanIntf))\n\n                        subnetStr = \"\"\n                        if UNDERLAY_IS_V6 == \"false\":\n                            subnetStr = Util.getSubnetStringWithPrefix(localIntfIp, vpcPairInfo[\"peerLinkVlanIpPrefix\"])\n                        elif USE_LINK_LOCAL == \"false\":\n                            subnetStr = Util.getV6SubnetStringWithPrefix(localIntfIp, vpcPairInfo[\"peerLinkVlanIpPrefix\"])\n                        if subnetStr != \"\":\n                            # set the subnet pool in RM\n                            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: Peer Link SUBNET [%s]\" % (FABRIC_NAME, linkKey, subnetStr))\n                            ignore, subnetRmId = Util.exeRM(RM.set(FABRIC_NAME, PoolName.SUBNET, EntityType.LINK, linkKey, subnetStr))\n                            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: Peer Link SUBNET [%s], rmId [%s]\" % (FABRIC_NAME, linkKey, subnetStr, subnetRmId))\n                            #simulated PTI to delete subnet resource along with PTI\n                            Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, subnetRmId, \"link_subnet_simulated\", {}))\n                            Util.exe(PTI.createOrUpdate(peerSerial, \"SWITCH\", \"SWITCH\", \"\", 10, subnetRmId, \"link_subnet_simulated\", {}))\n\n                            # set the local vPC Vlan interface IP in RM\n                            key = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, peerLinkVlanIntf))\n                            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: Peer Link SUBNET [%s] IP [%s]\"%\n                                          (FABRIC_NAME, key, subnetStr, localIntfIp))\n                            ignore, rmId1 = Util.exeRM(RM.set(FABRIC_NAME, subnetStr, EntityType.INTERFACE, key, localIntfIp))\n\n                            peerVlanPTIs = Util.exe(PTIWrapper.get(devSerial, \"INTERFACE\",\n                                                    peerLinkVlanIntf, \"UNDERLAY\", \"int_fabric_vlan_11_1\"))\n                            for pti in peerVlanPTIs:\n                                if pti.isDeleted():\n                                    continue\n\n                                Wrapper.print(\"Update int_fabric_vlan_11_1 policy %s with rmId %s for IP %s\" % (pti.getPolicyId(), rmId1, localIntfIp))\n                                Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), devSerial, \"INTERFACE\", peerLinkVlanIntf,\n                                                            pti.getSource(), pti.getPriority(),\n                                                            rmId1, \"int_fabric_vlan_11_1\", pti.getNvPairs()))\n                                break\n        \n                        # we also need to get the vPC Peer Link Vlan intf IP of the peer\n                        peerIntfPTIs = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\",\n                                                peerLinkVlanIntf, \"UNDERLAY\", \"int_fabric_vlan_11_1\"))\n                        peerIntfIp = \"\"\n                        for pti in peerIntfPTIs:\n                            if UNDERLAY_IS_V6 == \"false\":\n                                peerIntfIp = pti.nvPairs[\"IP\"]\n                            elif USE_LINK_LOCAL == \"false\":\n                                peerIntfIp = pti.nvPairs[\"V6IP\"]\n                            Wrapper.print(\"vPC Peer Link Vlan intf intf [%s]. IP = [%s]\" %\n                                          (peerLinkVlanIntf, peerIntfIp))\n        \n                            if peerIntfIp != \"\":\n                                # set the peer vPC Vlan interface IP in RM\n                                key = Util.exe(Helper.getKey(\"DeviceInterface\", peerSerial, peerLinkVlanIntf))\n                                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: Peer Link SUBNET [%s] IP [%s]\" %\n                                              (FABRIC_NAME, key, subnetStr, peerIntfIp))\n                                ignore, rmId2 = Util.exeRM(RM.set(FABRIC_NAME, subnetStr, EntityType.INTERFACE, key, peerIntfIp))\n                                Wrapper.print(\"update int_fabric_vlan_11_1 peer policy %s with rmId %s for IP %s\" % (pti.getPolicyId(), rmId2, peerIntfIp))\n                                Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), peerSerial, \"INTERFACE\", peerLinkVlanIntf,\n                                                            pti.getSource(), pti.getPriority(),\n                                                            rmId2, \"int_fabric_vlan_11_1\", pti.getNvPairs()))\n                                break\n\n                    if UNDERLAY_IS_V6 == \"false\":\n                        key = Util.exe(Helper.getKey(\"DeviceInterface\",\n                                       devSerial, peerSerial, vpcPairInfo[\"nveSecondaryLoopbackIntf\"]))\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: NVE Secondary IP [%s]\" % \n                                      (FABRIC_NAME, key, vpcPairInfo[\"nveSecondaryIp\"]))\n                        Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK1_IP_POOL\", EntityType.INTERFACE,\n                                        key, vpcPairInfo[\"nveSecondaryIp\"]))\n\n                    \n                    # dummy PTIs to check in easy fabric\n                    createPTI(devSerial, {\"VPC_SERIAL\":vpcPairSerialKey}, \"vpc_serial_simulated\", \"SWITCH\", \"\" , -1)\n                    createPTI(peerSerial, {\"VPC_SERIAL\":vpcPairSerialKey}, \"vpc_serial_simulated\", \"SWITCH\", \"\" , -1)\n    else:\n        # process spine specific policies\n        createPTI(devSerial, {}, \"base_feature_spine_upg\", \"SWITCH\", \"UNDERLAY\", -1)\n\n        templateName = \"feature_ospf\" if UNDERLAY_IS_V6 == \"false\" else \"feature_ospfv3\"\n        createMatchedPtis(devSerial, matchResult, templateName)\n        createMatchedPtis(devSerial, matchResult, \"feature_pim\")\n        createMatchedPtis(devSerial, matchResult, \"feature_ngoam\")\n        createMatchedPtis(devSerial, matchResult, \"feature_nv_overlay\")\n        createMatchedPtis(devSerial, matchResult, \"feature_vlan_based_vnsegment_11_1\")\n        createMatchedPtis(devSerial, matchResult, \"feature_interface_vlan_11_1\")\n\n        templateName = \"evpn_bgp_rr\" if UNDERLAY_IS_V6 == \"false\" else \"v6_evpn_bgp_rr\"\n        deleteAndCreateMatchedPtis(devSerial, matchResult, templateName)\n        deleteAndCreateMatchedPtis(devSerial, matchResult, \"mvpn_bgp_rr_11_1\")\n        createMatchedPtis(devSerial, matchResult, \"mvpn_bgp\")\n\n        createMatchedPtis(devSerial, matchResult, \"anycast_rp\")\n        createMatchedPtis(devSerial, matchResult, \"evpn_bgp_advertise_pip\")\n\n        # create the DHCP related PTIs with empty src so that they can be be removed by user\n        templateName = \"feature_dhcp\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            for nvPairs in nvPairList:\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", getPrio(templateName),\n                        templateName, nvPairs))\n        templateName = \"base_dhcp\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            for nvPairs in nvPairList:\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", getPrio(templateName),\n                        templateName, nvPairs))\n\n        templateName = \"anycast_rp\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if nvPairList:\n            for nvPairs in nvPairList:\n                anycastRPIPAddress = nvPairs.get(\"ANYCAST_RP_IP\")\n                Wrapper.print(\"%s: Device [%s]. Setting ANYCAST_RP to [%s]\" % (funcName, \n                                            getFormattedSwitchName(devSerial), anycastRPIPAddress))\n                Util.exe(RM.set(FABRIC_NAME, \"ANYCAST_RP_IP_POOL\", EntityType.FABRIC, \"ANYCAST_RP\", anycastRPIPAddress))\n                break\n\n        if EXTRA_CONF_SPINE != \"\":\n            createPTI(devSerial, {\"CONF\": EXTRA_CONF_SPINE}, \"extra_config_spine\", \"SWITCH\", \"UNDERLAY\", -1)\n    try:\n        deviceUpgradeIntf(gVarDictObj, matchResult, interfacesRes, isValidVPC, device_overlay_vlans, vpcPairInfo, respObj)\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error during interface migration\" % getFormattedSwitchName(devSerial))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":INTERFACE_MIGRATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n\n    if not respObj.isRetCodeFailure():\n        # create the IFCs\n        createIFCs(dictionaryObj, switchOverlayInfo, interfacesRes, respObj)\n\n    if not respObj.isRetCodeFailure():\n        if (doOverlayMigr and (migrateMode == \"brownAdd\")):\n            # save the switch overlay info to a file\n            writeToFile(dictionaryObj[\"overlayInfoFileName\"], json.dumps(switchOverlayInfo, indent=4, sort_keys=True), respObj)\n\n        takeSwitchOutOfUnderlayMigrMode(FABRIC_NAME, devSerial)\n\n    Wrapper.print(\"%s: Device [%s]. Success = [%r]\" % (funcName, devSerial, respObj.isRetCodeSuccess()))\n    return respObj\n\ndef createIFCs(switchInfo, switchOverlayInfo, interfacesRes, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    fmtName = switchInfo[\"fmtName\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n\n    Wrapper.print(\"%s: [%s] - Number of IFCs [%d]\" % (funcName, fmtName, len(switchOverlayInfo[\"IFCS\"]['VRF_LITE'])))\n\n    if len(switchOverlayInfo[\"IFCS\"]['VRF_LITE']) == 0:\n        return\n\n    for ifName in switchOverlayInfo[\"IFCS\"]['VRF_LITE']:\n        ifcEntry = switchOverlayInfo[\"IFCS\"]['VRF_LITE'][ifName]\n        vrfLiteIFCNvPairs = ifcEntry[\"nvPairs\"]\n\n        # get these from the interface policy associated with the interface\n        srchOpt = CtrlPolicySearch()\n        srchOpt.setSerialNumber(devSerial)\n        srchOpt.setTemplateContentType(\"PYTHON\")\n        srchOpt.setEntityName(ifName)\n        ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n        ifPolicy = None\n        for pti in ptiList:\n            if pti.isDeleted():\n                continue\n            ifPolicy = pti\n\n        if ifPolicy == None:\n            # we did not find any interface policy associated with the interface.. report an error\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRFLITE_IFC\"),\n                \"Could not locate the VRF-Lite parent interface policy for [%s]\" % (ifName), devSerial)\n            respObj.setFailureRetCode()\n            continue\n\n        ifNvPairs = ifPolicy.getNvPairs()\n        ifFreeformList = ifNvPairs.get(\"CONF\", \"\").splitlines(False)\n\n        # pickup the IP address from the parent intf if this is a cfg profile based import\n        if ifName in interfacesRes:\n            intfMatchResult = interfacesRes[ifName]\n\n            # scan the running config and extract the ip address\n            for cmd in intfMatchResult[\"show_run_cmds\"]:\n                if cmd.strip().startswith(\"ip address \"):\n                    ifFreeformList.append(cmd)\n                    break\n\n        ifFreeform = Util.newLine().join(ifFreeformList) \n        Wrapper.print(\"%s: switch [%s], parent VRF-Lite intf [%s] policy [%s/%s] nvPairs = [%s] ifFreeform [%s]\" % (funcName, \n            fmtName, ifName, ifPolicy.getTemplateName(), ifPolicy.getPolicyId(), ifNvPairs, ifFreeform))\n\n        vrfLiteIFCNvPairs['MTU'] = ifNvPairs.get(\"MTU\", \"9216\")\n        if vrfLiteIFCNvPairs[\"SOURCE_SERIAL_NUMBER\"] == devSerial:\n            vrfLiteIFCNvPairs['PEER1_DESC'] = ifNvPairs.get(\"DESC\", \"\")\n            vrfLiteIFCNvPairs['PEER1_CONF'] = ifFreeform\n        else:\n            vrfLiteIFCNvPairs['PEER2_DESC'] = ifNvPairs.get(\"DESC\", \"\")\n            vrfLiteIFCNvPairs['PEER2_CONF'] = ifFreeform\n\n        \"\"\"\n        # how do we get the DESC and CONF for the peer?\n        vrfLiteIFCNvPairs['PEER2_DESC'] = \"\"\n        vrfLiteIFCNvPairs['PEER2_CONF'] = \"\"\n        \"\"\"\n\n        # create the IFC\n        Util.exe(PTIWrapper.createOrUpdate(ifcEntry[\"LINK_UUID\"], \"LINK\",\n            ifcEntry[\"entityName\"], \"\", 500, \"ext_fabric_setup\", vrfLiteIFCNvPairs))\n\ndef deviceUpgradeIntf(gVarDictObj, matchResult, interfacesRes, isValidVPC, device_overlay_vlans, vpcPairInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    topologyDataObj = gVarDictObj[\"topologyObj\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    switchInfo = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n    migrateMode = switchInfo[\"migrationMode\"]\n    fmtName = switchInfo[\"fmtName\"]\n    fabricName = FABRIC_NAME\n\n    allFabricInterfaces = topologyDataObj.get(TopologyInfoType.ALL_FABRIC_INTFS, devSerial)\n    Wrapper.print(\"%s: [%s] all Fabric intf %s\" % (funcName, fmtName, allFabricInterfaces))\n\n    linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, devSerial,  Helper.getNbrTypeInternal()))\n    # collect the FEX IDs info\n    fexList = {}\n    nvPairList = getTemplateMatchResults(matchResult, \"base_fex\")\n    if (nvPairList != None):\n        # build the FEX dictionary\n        for nvPair in nvPairList:\n            fexList[nvPair[\"FEX_ID\"]] = nvPair\n\n\n    vpcLinkMemberInterfaces = []\n    isVPC = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, devSerial))\n    vpcPairSerialKey = \"\"\n    if isVPC:\n        vpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, devSerial))\n        Wrapper.print(\"%s(): vPC: pair [%s]\" % (funcName, vpcPairSerialKey))\n        serials = vpcPairSerialKey.split(Helper.DELIMITER)\n        vpcSn = devSerial\n        vpcPeerSn = serials[1] if vpcSn == serials[0] else serials[0]\n        vpcLinkMemberInterfaces = topologyDataObj.get(TopologyInfoType.VPC_PEER_LINK_MEMBERS, vpcSn, vpcPeerSn)\n    Wrapper.print(\"%s: [%s] - vpc Link members [%s]\" % (funcName, fmtName, vpcLinkMemberInterfaces))\n\n    # special handling for breakout interfaces\n    templateName = \"breakout_interface\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        ptiSource = getSrc(templateName)\n        for nvPair in nvPairList:\n            Wrapper.print(\"Breakout: slot [%s], ports [%s]\" % (nvPair[\"SLOT\"], nvPair[\"PORT\"]))\n\n            # if the PORT is a range, then we need to unroll it into individual PTIs\n            ports = getIntegerRange(nvPair[\"PORT\"])\n\n            # create individual PTIs for each port\n            for port in ports:\n                # update the 'PORT' key value in the policy instance\n                nvPair[\"PORT\"] = str(port)\n                entityName = \"Ethernet\" + nvPair[\"SLOT\"] + \"/\" + nvPair[\"PORT\"]\n                createPTI(devSerial, nvPair, templateName, entityName, ptiSource, -1)\n\n    # process PO and vPC host ports\n    poInterfaces = {}\n\n    # gather the PO and vPC info in two passes\n    # pass 1: the main PO interfaces list\n    # pass 2: the corresponding members\n    for roundNum in range(1,3):\n        for intfName in sorted(interfacesRes.keys()):\n            # get the interface match results\n            intfMatchResult = interfacesRes[intfName]\n\n            # skip interfaces that have been processed\n            if isIntfProcessed(intfMatchResult):\n                continue\n\n            templateNameMatches = intfMatchResult[\"matched_templates\"]\n\n            if roundNum == 1:\n                # Pass 1 - gather the parent PO entries\n                if (intfName.lower().startswith(\"port-channel\")):\n                    isAccessPort = False\n                    isDot1qTunnel = False\n                    isFexPo = False\n                    if (\"fex_port_channel_interface\" in templateNameMatches):\n                        # this is a FEX PO\n                        isFexPo = True\n                    elif((\"access_interface\" in templateNameMatches) or \n                         (\"access_interface_fex\" in templateNameMatches) or \n                         (\"port_channel_access_interface\" in templateNameMatches) or\n                         (\"port_channel_dot1q_tunnel_interface\" in templateNameMatches) or\n                         (\"dot1q_tunnel_interface\" in templateNameMatches)):\n                        # treat dot1q tunnel port as access\n                        isAccessPort = True\n\n                        if ((\"port_channel_dot1q_tunnel_interface\" in templateNameMatches) or\n                            (\"dot1q_tunnel_interface\" in templateNameMatches)):\n                            isDot1qTunnel = True\n                    elif not (\"port_channel_trunk_interface_11_1\" in templateNameMatches):\n                        # not a normal PO we understand\n                        Wrapper.print(\"Incomplete policy match - PO [%s]\" % intfName)\n                        continue\n                    \n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n                    Wrapper.print(\"Switch [%s] : Found PO [%s] isFexPo [%r] isAccessPort [%r] isDot1qTunnel [%r] \" % (devSerial,\n                            intfName, isFexPo, isAccessPort, isDot1qTunnel))\n\n                    # record this PO, with the key as the PO id\n                    # extract the id\n                    portChannelIntf = intfName.lower()\n                    pc, pcid = portChannelIntf.split(\"port-channel\")\n\n                    poMtu = \"1500\"\n                    poSpeed = \"auto\"\n                    poAdminState = \"true\"\n                    poDesc = \"\"\n                    orphanPort = \"false\"\n                    bpduGuardState = \"no\"\n                    porttype_fast_enable = \"false\"\n                    porttype_fast_trunk = \"false\"\n                    vpcId = \"\"\n                    fexId = \"\"\n                    access_vlan = \"\"\n                    native_vlan = \"\"\n\n                    if (\"interface_mtu\" in templateNameMatches):\n                        poMtu = matchingNvPairs[\"interface_mtu\"][\"MTU\"]\n                    if (\"interface_speed\" in templateNameMatches):\n                        poSpeed = matchingNvPairs[\"interface_speed\"][\"SPEED\"]\n                    if isFexPo:\n                        fexId = matchingNvPairs[\"fex_port_channel_interface\"][\"FEX_ID\"]\n                    if (\"shut_interface\" in templateNameMatches):\n                        poAdminState = \"false\"\n                    if (\"interface_desc\" in templateNameMatches):\n                        poDesc = matchingNvPairs[\"interface_desc\"][\"DESC\"]\n                    if (\"interface_orphan_port\" in templateNameMatches):\n                        orphanPort = \"true\"\n                    if (\"bpduguard_enable\" in templateNameMatches):\n                        bpduGuardState = \"true\"\n                    if (\"bpduguard_disable\" in templateNameMatches):\n                        bpduGuardState = \"false\"\n                    if (\"porttype_fast_trunk\" in templateNameMatches):\n                        porttype_fast_trunk = \"true\"\n                    if (\"porttype_fast_enable\" in templateNameMatches):\n                        porttype_fast_enable = \"true\"\n                    if (\"port_channel_vpc_id_11_1\" in templateNameMatches):\n                        vpcId = matchingNvPairs[\"port_channel_vpc_id_11_1\"][\"VPC_ID\"]\n                        Wrapper.print(\"Found vpcId [%s]\" % vpcId)\n                    if (\"access_vlan\" in templateNameMatches and matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"] != 1):\n                        access_vlan = processAccessIntfOverlayInfo(devSerial, migrateMode, \n                            intfName, matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"],\n                            globalOverlayInfo, device_overlay_vlans)\n                    if (\"native_vlan\" in templateNameMatches):\n                        native_vlan = matchingNvPairs[\"native_vlan\"][\"NATIVE_VLAN\"]\n\n                    allowed_vlans = \"none\"\n                    allowed_vlan_orig = \"none\"\n                    if (\"port_channel_trunk_interface_11_1\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"port_channel_trunk_interface_11_1\"][\"ALLOWED_VLANS\"]\n                    elif (\"trunk_interface\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"trunk_interface\"][\"ALLOWED_VLANS\"]\n                    elif (\"trunk_interface_fex\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"trunk_interface_fex\"][\"ALLOWED_VLANS\"]\n\n                    if not isAccessPort:\n                        allowed_vlans = processTrunkIntfOverlayInfo(devSerial, migrateMode, intfName,\n                                    allowed_vlan_orig, globalOverlayInfo, device_overlay_vlans)\n                    unaccCfg = \"\"\n                    if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                        Wrapper.print(\"Device [%s]: Found unaccounted cfg for portchannel intf [%s]\" % (devSerial, intfName))\n                        unaccCfg = Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"]) \n\n                    templateList = [\n                                    \"bfd_interface_auth\",\n                                    \"bfd_no_echo_interface\", \n                                    \"ospf_p2p_interface\",\n                                    \"ospf_interface_auth\",\n                                    \"isis_p2p_inteface\",\n                                    \"isis_interface_auth\",\n                                    \"isis_interface_auth_no_lvl\",\n                                    \"vlan_interface_fwd_mode_11_1\",\n                                    \"interface_ipv6_11_1\",\n                                    \"interface_ipv6_tag_11_1\",\n                                    \"cdp_disable_interface_11_1\"\n                                   ]\n                    if isAccessPort:\n                        templateList.append(\"porttype_fast_trunk\")\n                    else:\n                        templateList.append(\"access_vlan\")\n                        templateList.append(\"porttype_fast_enable\")\n                    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n                    if unaccCfg and configList:\n                        unaccCfg = unaccCfg + Util.newLine() + Util.newLine().join(configList)\n                    elif configList:\n                        unaccCfg = Util.newLine().join(configList)\n\n                    poInterfaces.update({pcid : {\"name\" : intfName,\n                                                 \"mtu\" : poMtu,\n                                                 \"speed\" : poSpeed,\n                                                 \"vpcId\" : vpcId,\n                                                 \"poMode\" : \"active\",\n                                                 \"poDesc\" : poDesc,\n                                                 \"orphanPort\" : orphanPort,\n                                                 \"adminState\" : poAdminState,\n                                                 \"bpduguard\" : bpduGuardState,\n                                                 \"porttype_fast_enable\" : porttype_fast_enable,\n                                                 \"porttype_fast_trunk\" : porttype_fast_trunk,\n                                                 \"fexId\" : fexId,\n                                                 \"allowed_vlans\": allowed_vlans,\n                                                 \"access_vlan\": access_vlan,\n                                                 \"native_vlan\": native_vlan,\n                                                 \"access_port\": isAccessPort,\n                                                 \"dot1q_tunnel\" : isDot1qTunnel,\n                                                 \"members\" : [],\n                                                 \"poConf\" : unaccCfg\n                                                }\n                                            })\n                    Wrapper.print(\"Switch [%s] : Added entry for PO [%s] id [%s]\" % (devSerial, intfName, pcid))\n            else:\n                # Pass 2 - gather the PO/vPC member entries\n                if ((\"port_channel_mode_on\" in templateNameMatches) or\n                    (\"port_channel_mode\" in templateNameMatches)):\n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    # TODO: check if this a host vPC or regular PO based on the 'vpc' config\n                    templatesToCheck = [\"port_channel_mode_on\",\n                                        \"port_channel_mode\"\n                                       ]\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templatesToCheck)\n\n                    pcid = \"\"\n                    mode = \"\"\n                    for templateName in matchingNvPairs:\n                        if (\"port_channel_mode_on\" == templateName):\n                            # record the PO mode\n                            pcid = matchingNvPairs[templateName][\"PCID\"]\n                            mode = \"on\"\n                            break\n                        elif (\"port_channel_mode\" == templateName):\n                            # record the PO mode\n                            pcid = matchingNvPairs[templateName][\"PCID\"]\n                            mode = matchingNvPairs[templateName][\"PC_MODE\"]\n                            break\n\n                    Wrapper.print(\"Switch [%s] - Found PO member intf [%s] mode [%s] parent PO id [%s]\" %\n                        (devSerial, intfName, mode, pcid))\n                    # lookup the main PO dictionary object\n                    try:\n                        parentPo = poInterfaces[pcid]\n                        # update the PO mode\n                        parentPo[\"poMode\"] = mode\n                        # add this interface as a member\n                        parentPo[\"members\"].append(intfName)\n                    except:\n                        intfMatchResult.update({\"isProcessed\" : False})\n                        Wrapper.print(\"ERROR: Switch [%s] Did not find parent PO for intf [%s] id [%s]\" % \n                                                    (devSerial, intfName, pcid))\n                elif (\"fex_po_member_interface\" in templateNameMatches):\n                    Wrapper.print(\"Found FEX member [%s]\" % intfName)\n                    #Wrapper.print(str(templateNameMatches))\n\n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, [\"fex_po_member_interface\"])\n\n                    # lookup the main PO dictionary object\n                    pcid = matchingNvPairs[\"fex_po_member_interface\"][\"PCID\"]\n                    try:\n                        parentPo = poInterfaces[pcid]\n                        Wrapper.print(\"PO: [%s]. adding fex member [%s]\" % (pcid, intfName))\n\n                        # add this interface as a member\n                        parentPo[\"members\"].append(intfName)\n                    except:\n                        intfMatchResult.update({\"isProcessed\" : False})\n                        Wrapper.print(\"ERROR: Did not find parent FEX PO for intf [%s] id [%s]\" % \n                                                (intfName, pcid))\n\n    # create the host PO and VPCs\n    for pcid in poInterfaces:\n        poEntry = poInterfaces[pcid]\n        poName = poEntry[\"name\"]\n        vpcIntfName = \"vPC\" + poEntry[\"vpcId\"]\n\n        intfMatchResult = interfacesRes[poName]\n        if (poEntry[\"fexId\"] != \"\"):\n            if (poEntry[\"vpcId\"] != \"\"):\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: VPC_ID [%s] FEX_ID :[%s]\" % (FABRIC_NAME, key, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n\n                # check if we have the peer serial number\n                peerSerial = \"\"\n                try:\n                    peerSerial = vpcPairInfo[\"peerSerialNum\"]\n                    Wrapper.print(\"AAFEX: peer device [%s] is found for device[%s].\"%(peerSerial, devSerial))\n                except:\n                    Wrapper.print(\"AAFEX: peer serial # is empty. create PTIs to save vpc host info for later use\")\n                    \"\"\"\n                    memberIntfParams = {}\n                    for member in poEntry[\"members\"]:\n                        templatesToCheck = [\"interface_desc\"]\n                        matchingNvPairs = getIntfMatchNvPairs(matchResult, member, templatesToCheck)\n                        if \"interface_desc\" in matchingNvPairs:\n                            desc = matchingNvPairs[\"interface_desc\"][\"DESC\"]\n                        else:\n                            desc = \"\"\n                        if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                            Wrapper.print(\"AAFEX: Device [%s]: Found unaccounted cfg for aa fex po intf [%s]\" % (devSerial, member))\n                            unaccCfgMember = Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"])\n                        else:\n                            unaccCfgMember = \"\"\n                        memberIntfParams.update({member: {\"SN\": devSerial, \"DESC\": desc, \"CONF\": unaccCfgMember}}) \n                    \"\"\"\n\n                    nvPairs = {\"PO_ID\": poName,\n                               \"FEX_ID\" : poEntry[\"fexId\"],\n                               \"MTU\": Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                               \"PO_DESC\": poEntry[\"poDesc\"],\n                               \"ADMIN_STATE\": poEntry[\"adminState\"],\n                               \"DESC\": fexList[poEntry[\"fexId\"]][\"DESC\"],\n                               \"MEMBER_INTERFACES\": \",\".join(poEntry[\"members\"]),\n                               \"INTF_NAME\": vpcIntfName,\n                               \"PO_CONF\":poEntry[\"poConf\"]\n                              }\n                    templateList = [\n                                    \"access_vlan\", \n                                    \"porttype_fast_enable\",\n                                    \"porttype_fast_trunk\",\n                                    \"interface_ipv4_tag_11_1\"\n                                    ]\n                    configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n                    if nvPairs[\"PO_CONF\"] and configList:\n                        nvPairs[\"PO_CONF\"] = nvPairs[\"PO_CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                    elif configList:\n                        nvPairs[\"PO_CONF\"] = Util.newLine().join(configList)\n\n                    # create the vpc host PO trunk jython policy\n                    Wrapper.print(\"Creating standalone fex host PO [%s] vpc [%s] fexid [%s] policy\" % (poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                    createPTI(devSerial, nvPairs, \"int_aa_fex_standalone_11_1\", vpcIntfName, \"temp\", -1)\n                    #need to delete PTI if peer not found in the end\n                    continue\n\n                # vpc host case\n                Wrapper.print(\"AAFEX: Creating AA host PO [%s] vpc [%s] fexid [%s] policy\" %(poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                # we also need to get the vPC trunk host intf info of the peer\n                peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\",\n                                                          vpcIntfName, \"temp\",\n                                                          \"int_aa_fex_standalone_11_1\"))\n\n                peer_member_intfs = \"\"\n                peer_po_desc = \"\"\n                peer_po_conf = \"\"\n                peer_pcid = \"\"\n                peer_fex_desc = \"\"\n                peer_fex_id = \"\"\n                for peervPCpti in peerIntfvPCPTIs:\n                    peer_member_intfs = peervPCpti.getNvPairs()[\"MEMBER_INTERFACES\"]\n                    peer_fex_desc = peervPCpti.getNvPairs()[\"DESC\"]\n                    peer_fex_id =  peervPCpti.getNvPairs()[\"FEX_ID\"]\n                    peer_po_desc = peervPCpti.getNvPairs()[\"PO_DESC\"]\n                    peer_po_conf = peervPCpti.getNvPairs()[\"PO_CONF\"]\n                    discard, peer_pcid = peervPCpti.getNvPairs()[\"PO_ID\"].split(\"port-channel\")\n                    Wrapper.print(\"Deleting peer fex intf [%s] PTIs\" % peer_member_intfs)\n                    Wrapper.print(\"peer fex_desc:[%s], fex_id:[%s], po_desc:[%s], po_id:[%s]\" %\n                                  (peer_fex_desc, peer_fex_id, peer_po_desc, peer_pcid))\n                    Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n                    break\n\n                # get the vPC pair key with the internal serial1:serial2 format\n                vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n                Wrapper.print(\"AA Host PO: pair string [%s]\" % (vpcPairSerialKey))\n                serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n                nvPairs = {\"INTF_NAME\" : vpcIntfName,\n                           \"ADMIN_STATE\": poEntry[\"adminState\"],\n                           \"PEER1_PCID\": \"\",\n                           \"PEER2_PCID\": \"\",\n                           \"PEER1_MEMBER_INTERFACES\": \"\",\n                           \"PEER2_MEMBER_INTERFACES\": \"\",\n                           \"DESC\": \"\",\n                           \"PC_MODE\" : poEntry[\"poMode\"],\n                           \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"PEER1_PO_DESC\": \"\",\n                           \"PEER2_PO_DESC\": \"\",\n                           \"PEER1_PO_CONF\": \"\",\n                           \"PEER2_PO_CONF\": \"\",\n                           \"createVpc\" : \"true\",\n                           \"FEX_ID\" : \"\",\n                           \"FABRIC_NAME\" : FABRIC_NAME\n                          }\n\n                nvPairs[\"FEX_ID\"] = poEntry[\"fexId\"]\n                nvPairs[\"DESC\"] = fexList[poEntry[\"fexId\"]][\"DESC\"]\n                if (serials[0] == devSerial):\n                    nvPairs[\"PEER1_SN\"] = devSerial\n                    nvPairs[\"PEER1_PCID\"] = pcid\n                    nvPairs[\"PEER1_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                    nvPairs[\"PEER1_PO_DESC\"] = poEntry[\"poDesc\"]\n                    nvPairs[\"PEER1_PO_CONF\"] = poEntry[\"poConf\"]\n\n                    nvPairs[\"PEER2_SN\"] = peerSerial\n                    nvPairs[\"PEER2_PCID\"] = peer_pcid\n                    nvPairs[\"PEER2_MEMBER_INTERFACES\"] = peer_member_intfs\n                    nvPairs[\"PEER2_PO_DESC\"] = peer_po_desc\n                    nvPairs[\"PEER2_PO_CONF\"] = peer_po_conf\n\n                else:\n                    nvPairs[\"PEER1_SN\"] = peerSerial\n                    nvPairs[\"PEER1_PCID\"] = peer_pcid\n                    nvPairs[\"PEER1_MEMBER_INTERFACES\"] = peer_member_intfs\n                    nvPairs[\"PEER1_PO_DESC\"] = peer_po_desc\n                    nvPairs[\"PEER1_PO_CONF\"] = peer_po_conf\n\n                    nvPairs[\"PEER2_SN\"] = devSerial\n                    nvPairs[\"PEER2_PCID\"] = pcid\n                    nvPairs[\"PEER2_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                    nvPairs[\"PEER2_PO_DESC\"] = poEntry[\"poDesc\"]\n                    nvPairs[\"PEER2_PO_CONF\"] = poEntry[\"poConf\"]\n\n                Wrapper.print(\"SN:[%s] PEER_SN:[%s] - AA host nvPairs [%s]\"% (devSerial, peerSerial, nvPairs))\n\n                #Sanity to ensure valid AA fex config\n                if (nvPairs[\"PEER1_PCID\"] == \"\" or\n                    nvPairs[\"PEER2_PCID\"] == \"\" or\n                    nvPairs[\"FEX_ID\"] == \"\" ):\n                    Wrapper.print(\"Orphan AA!!! bail out\")\n                    \"\"\"\n                    respObj.setWarningRetCode()\n                    respObj.addWarnReport(getFabErrEntity(unaccountedConfigError.__name__, devSerial+ \":vpc \" +poEntry[\"vpcId\"]),\n                                  \"SN: [%s] FEX with vPC ID [%s] configuration is not correct !!! Either vPC po on Peer or FEX_ID [%s] is missing\"%\n                                  (devSerial, poEntry[\"vpcId\"], nvPairs[\"FEX_ID\"]))\n                    \"\"\"\n                    intfMatchResult.update({\"isProcessed\" : False})\n                    continue\n\n                key = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, peerSerial, vpcIntfName))\n                ignore, vpcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", devSerial, key, poEntry[\"vpcId\"]))\n                ignore, vpcRmId2 = Util.exeRM(RM.findRMDetails(FABRIC_NAME, \"VPC_ID\", key, peerSerial, poEntry[\"vpcId\"]))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s]: VPC_ID [%s] rmId [%s], peer rmId [%s]\" % (FABRIC_NAME, key, poEntry[\"vpcId\"], vpcRmId1, vpcRmId2))\n\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                ignore, pcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+pcid, pcid))\n                ignore, fexRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s] FEX_ID [%s] fexRmId [%s]\"\n                              % (FABRIC_NAME, key, pcid, \"port-channel\"+pcid, pcRmId1, poEntry[\"fexId\"], fexRmId1))\n\n                key = Util.exe(Helper.getKey(\"Device\", peerSerial))\n                ignore, pcRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+peer_pcid, peer_pcid))\n                ignore, fexRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                #Wrapper.print(\"FAB [%s] RM SET: Key [%s]: PORT_CHANNEL_ID [%s] rmId [%s] FEX_ID [%s] fexRmId [%s]\" % (FABRIC_NAME, key, peer_pcid, pcRmId2, poEntry[\"fexId\"], fexRmId2))\n\n                rmIds = [vpcRmId1] + [vpcRmId2] + [fexRmId1] + [fexRmId2]+ [pcRmId1] + [pcRmId2]\n\n                # create the AA fex vpc host PO trunk jython policy\n                Wrapper.print(\"Creating AA FEX vpc host PO [%s] vpc [%s] fexid [%s] policy\" % (poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                createPTI(vpcPairSerialKey, nvPairs, \"int_port_channel_aa_fex\", vpcIntfName,\n                          getSrc(\"int_port_channel_aa_fex\"), rmIds)\n\n                sn1 = sn2 = memberIntfsPeer1 = memberIntfsPeer2 =  poPCIdPeer1 = poPCIdPeer2 = \"\"\n                if nvPairs[\"PEER1_SN\"] == devSerial:\n                    sn1 = devSerial\n                    sn2 = peerSerial\n                    memberIntfsPeer1 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                    memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                    memberIntfsPeer2 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                    memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                    poPCIdPeer1 = nvPairs[\"PEER1_PCID\"]\n                    poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n                elif nvPairs[\"PEER2_SN\"] == devSerial:\n                    sn1 = devSerial\n                    sn2 = peerSerial\n                    memberIntfsPeer1 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                    memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                    memberIntfsPeer2 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                    memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                    poPCIdPeer1 = nvPairs[\"PEER2_PCID\"]\n                    poPCIdPeer2 = nvPairs[\"PEER1_PCID\"]\n                ptiTemplate = \"int_fex_po_member_11_1\"\n                peerMatchResult, peerInterfacesRes = getSwitchMatchResults(peerSerial)\n                poMemberDescAndFFUpd(sn1, memberIntfsPeer1List, ptiTemplate, \n                                     poPCIdPeer1, matchResult, interfacesRes, vpcIntfName)\n                poMemberDescAndFFUpd(sn2, memberIntfsPeer2List, ptiTemplate,\n                                     poPCIdPeer2, peerMatchResult, peerInterfacesRes, vpcIntfName)\n            else:\n                # standalone fex\n                nvPairs = {\"PO_ID\" : poName,\n                           \"FEX_ID\" : poEntry[\"fexId\"],\n                           \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"PO_DESC\" : poEntry[\"poDesc\"],\n                           \"ADMIN_STATE\" : poEntry[\"adminState\"],\n                           \"DESC\" : fexList[poEntry[\"fexId\"]][\"DESC\"],\n                           \"CONF\" : poEntry[\"poConf\"],\n                           \"MEMBER_INTERFACES\" : \",\".join(poEntry[\"members\"]),\n                           \"FABRIC_NAME\" : FABRIC_NAME\n                          }\n\n                templateList = [\n                                \"access_vlan\", \n                                \"porttype_fast_enable\",\n                                \"porttype_fast_trunk\",\n                                \"interface_ipv4_tag_11_1\"\n                               ]\n                configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n                if nvPairs[\"CONF\"] and configList:\n                    nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                elif configList:\n                    nvPairs[\"CONF\"] = Util.newLine().join(configList)\n\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]: FEX_ID [%s]\" % (FABRIC_NAME, key, pcid, poEntry[\"fexId\"]))\n                ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n                ignore, fexRmId = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                rmIds = [pcRmId] + [fexRmId]\n                # create the FEX PO policy\n                Wrapper.print(\"Creating FEX [%s] policy\" % poName)\n                createPTI(devSerial, nvPairs, \"int_port_channel_fex\", poName, \"\", rmIds)\n\n                memberIntfs = nvPairs.get(\"MEMBER_INTERFACES\")\n                memberIntfsList = memberIntfs.split(\",\") if memberIntfs else []\n                ignore, poPCId = poName.split(\"port-channel\")\n                ptiTemplate = \"int_fex_po_member_11_1\"\n                poMemberDescAndFFUpd(devSerial, memberIntfsList, ptiTemplate, \n                                     poPCId, matchResult, interfacesRes, poName)\n        elif (poEntry[\"vpcId\"] != \"\"):\n\n            # check if we have the peer serial number\n            peerSerial = \"\"\n            try:\n                peerSerial = vpcPairInfo[\"peerSerialNum\"]\n            except:\n                Wrapper.print(\"vPC: peer serial # is empty. create PTIs to save vpc host info for later use\")\n                nvPairs = {\"INTF_NAME\": vpcIntfName,\n                           \"ADMIN_STATE\": poEntry[\"adminState\"],\n                           \"PEER1_MEMBER_INTERFACES\": \"\" if (len(poEntry[\"members\"]) == 0) else (\",\".join(poEntry[\"members\"])),\n                           \"PC_MODE\": poEntry[\"poMode\"],\n                           \"BPDUGUARD_ENABLED\": poEntry[\"bpduguard\"],\n                           \"MTU\": Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"SPEED\": Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]),\n                           \"PO_ID\": poName,\n                           \"PO_DESC\": poEntry[\"poDesc\"],\n                           \"PO_CONF\":poEntry[\"poConf\"],\n                           \"ALLOWED_VLANS\" : poEntry[\"allowed_vlans\"],\n                           \"ACCESS_VLAN\" : poEntry[\"access_vlan\"],\n                           \"NATIVE_VLAN\" : poEntry[\"native_vlan\"],\n                           \"createVpc\": \"true\"\n                           }\n                # create the vpc host PO trunk jython policy\n                Wrapper.print(\"Creating standalone vpc host PO [%s] vpc [%s] policy\" % (poName, poEntry[\"vpcId\"]))\n                if poEntry[\"access_port\"]:\n                    templateName = \"int_vpc_access_host_standalone_11_1\"\n                else:\n                    nvPairs[\"NATIVE_VLAN\"] = poEntry[\"native_vlan\"] if poEntry[\"native_vlan\"] != \"\" else \"1\"\n                    templateName = \"int_vpc_trunk_host_standalone_11_1\"\n                createPTI(devSerial, nvPairs, templateName, vpcIntfName, \"temp\", -1)\n                #need to delete PTI if peer not found in the end\n                continue\n\n            # vpc host case\n            Wrapper.print(\"Switch [%s] : vPC: Creating vpc host PO [%s] vpc [%s] policy\" % (devSerial, poName, poEntry[\"vpcId\"]))\n            # we also need to get the vPC host intf info of the peer\n            if poEntry[\"access_port\"]:\n                templateName = \"int_vpc_access_host_standalone_11_1\"\n            else:\n                templateName = \"int_vpc_trunk_host_standalone_11_1\"\n            peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\", vpcIntfName, \"temp\", templateName))\n\n            peer_member_intfs = \"\"\n            peer_po_desc = \"\"\n            peer_po_conf = \"\"\n            peer_pcid = \"\"\n            peer_po_mtu = \"\"\n            peer_po_speed = \"Auto\"\n            peer_allowed_vlan = \"all\"\n            peer_access_vlan = \"\"\n            peer_native_vlan = \"\"\n            po_mode = poEntry[\"poMode\"]\n            for peervPCpti in peerIntfvPCPTIs:\n                peerNvPairs = peervPCpti.getNvPairs()\n                peer_member_intfs = peerNvPairs[\"PEER1_MEMBER_INTERFACES\"]\n                if len(peer_member_intfs) > 0:\n                    # the po mode must be valid on the peer.. use that\n                    po_mode = peerNvPairs[\"PC_MODE\"]\n                peer_po_desc = peerNvPairs[\"PO_DESC\"]\n                peer_po_conf = peerNvPairs[\"PO_CONF\"]\n                peer_po_mtu = peerNvPairs[\"MTU\"]\n                peer_po_speed = peerNvPairs[\"SPEED\"]\n                discard, peer_pcid = peerNvPairs[\"PO_ID\"].split(\"port-channel\")\n                peer_allowed_vlan = peerNvPairs[\"ALLOWED_VLANS\"]\n                peer_access_vlan = peerNvPairs[\"ACCESS_VLAN\"]\n                peer_native_vlan = peerNvPairs[\"NATIVE_VLAN\"]\n                Wrapper.print(\"Deleting peer vpc intf [%s] PTIs\" % peer_member_intfs)\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n                break\n\n            # get the vPC pair key with the internal serial1:serial2 format\n            vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n            Wrapper.print(\"vPC Host PO: pair string [%s]\" % (vpcPairSerialKey))\n            serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n            # Check the vPC port-channel speed config between the vPC peers.\n            # If not the same, add the speed config to the interface freeform and let users fix the config.\n            # Set the SPEED param to \"Auto\" so that no interface_speed policy will be created for the po.\n            addSpeedConfig = []\n            peerAddSpeedConfig = []\n            if Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]) == peer_po_speed:\n                vpcSpeed = peer_po_speed\n            else:\n                vpcSpeed = \"Auto\"\n                if poEntry[\"speed\"] != \"auto\":\n                    addSpeedConfig.append(\"%sspeed %s\" %(INTF_FIRST_LVL_SPACING, poEntry[\"speed\"]))\n                if peer_po_speed != \"Auto\":\n                    peerAddSpeedConfig.append(\"%sspeed %s\" %(INTF_FIRST_LVL_SPACING, Util.mapEnumToSwitchSpeed(peer_po_speed)))\n            \n            nvPairs = {\"INTF_NAME\" : vpcIntfName,\n                       \"ENABLE_MIRROR_CONFIG\": \"false\",\n                       \"ADMIN_STATE\": poEntry[\"adminState\"],\n                       \"PEER1_PCID\": \"\",\n                       \"PEER2_PCID\": \"\",\n                       \"PEER1_MEMBER_INTERFACES\": \"\",\n                       \"PEER2_MEMBER_INTERFACES\": \"\",\n                       \"PEER1_PO_DESC\": \"\",\n                       \"PEER2_PO_DESC\": \"\",\n                       \"PEER1_PO_CONF\": \"\",\n                       \"PEER2_PO_CONF\": \"\",\n                       \"PC_MODE\" : po_mode,\n                       \"BPDUGUARD_ENABLED\": poEntry[\"bpduguard\"],\n                       \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                       \"SPEED\": vpcSpeed,\n                       \"createVpc\" : \"true\"\n                      }\n\n            if (serials[0] == devSerial):\n                nvPairs[\"PEER1_SN\"] = devSerial\n                nvPairs[\"PEER1_PCID\"] = pcid\n                nvPairs[\"PEER1_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                nvPairs[\"PEER1_PO_DESC\"] = poEntry[\"poDesc\"]\n                nvPairs[\"PEER1_ALLOWED_VLANS\"] = poEntry[\"allowed_vlans\"]\n                nvPairs[\"PEER1_ACCESS_VLAN\"] = poEntry[\"access_vlan\"]\n                nvPairs[\"PEER1_NATIVE_VLAN\"] = \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"]\n                nvPairs[\"PEER1_PO_CONF\"] = poEntry[\"poConf\"] \n                if addSpeedConfig:\n                    nvPairs[\"PEER1_PO_CONF\"] = nvPairs[\"PEER1_PO_CONF\"] + Util.newLine() + Util.newLine().join(addSpeedConfig)\n\n                nvPairs[\"PEER2_SN\"] = peerSerial\n                nvPairs[\"PEER2_PCID\"] = peer_pcid\n                nvPairs[\"PEER2_MEMBER_INTERFACES\"] = peer_member_intfs\n                nvPairs[\"PEER2_PO_DESC\"] = peer_po_desc\n                nvPairs[\"PEER2_ALLOWED_VLANS\"] = peer_allowed_vlan\n                nvPairs[\"PEER2_ACCESS_VLAN\"] = peer_access_vlan\n                nvPairs[\"PEER2_NATIVE_VLAN\"] = \"\" if peer_native_vlan == \"1\" else peer_native_vlan\n                nvPairs[\"PEER2_PO_CONF\"] = peer_po_conf\n                if peerAddSpeedConfig:\n                    nvPairs[\"PEER2_PO_CONF\"] = nvPairs[\"PEER2_PO_CONF\"] + Util.newLine() + Util.newLine().join(peerAddSpeedConfig)\n            else:\n                nvPairs[\"PEER1_SN\"] = peerSerial\n                nvPairs[\"PEER1_PCID\"] = peer_pcid\n                nvPairs[\"PEER1_MEMBER_INTERFACES\"] = peer_member_intfs\n                nvPairs[\"PEER1_PO_DESC\"] = peer_po_desc\n                nvPairs[\"PEER1_ALLOWED_VLANS\"] = peer_allowed_vlan\n                nvPairs[\"PEER1_ACCESS_VLAN\"] = peer_access_vlan\n                nvPairs[\"PEER1_NATIVE_VLAN\"] = \"\" if peer_native_vlan == \"1\" else peer_native_vlan\n                nvPairs[\"PEER1_PO_CONF\"] = peer_po_conf\n                if peerAddSpeedConfig:\n                    nvPairs[\"PEER1_PO_CONF\"] = nvPairs[\"PEER1_PO_CONF\"] + Util.newLine() + Util.newLine().join(peerAddSpeedConfig)\n\n                nvPairs[\"PEER2_SN\"] = devSerial\n                nvPairs[\"PEER2_PCID\"] = pcid\n                nvPairs[\"PEER2_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                nvPairs[\"PEER2_PO_DESC\"] = poEntry[\"poDesc\"]\n                nvPairs[\"PEER2_ALLOWED_VLANS\"] = poEntry[\"allowed_vlans\"]\n                nvPairs[\"PEER2_ACCESS_VLAN\"] = poEntry[\"access_vlan\"]\n                nvPairs[\"PEER2_NATIVE_VLAN\"] = \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"]\n                nvPairs[\"PEER2_PO_CONF\"] = poEntry[\"poConf\"] \n                if addSpeedConfig:\n                    nvPairs[\"PEER2_PO_CONF\"] = nvPairs[\"PEER2_PO_CONF\"] + Util.newLine() + Util.newLine().join(addSpeedConfig)\n            Wrapper.print(\"SN:[%s] PEER_SN:[%s] - vPC host nvPairs [%s]\"% (devSerial, peerSerial, nvPairs))\n\n            #Sanity to ensure valid vPC host config\n            if (nvPairs[\"PEER1_PCID\"] == \"\" or\n                nvPairs[\"PEER2_PCID\"] == \"\" ):\n                Wrapper.print(\"Orphan vPC host!!! bail out\")\n                \"\"\"\n                respObj.setWarningRetCode()\n                respObj.addWarnReport(getFabErrEntity(unaccountedConfigError.__name__, devSerial+ \":vpc \" +poEntry[\"vpcId\"]),\n                                      \"SN: [%s] vpc [%s] configuration is not correct !!! peer vpc po is missing\"%\n                                      (devSerial, poEntry[\"vpcId\"]))\n                \"\"\"\n                intfMatchResult.update({\"isProcessed\" : False})\n                continue\n\n            entityName = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, peerSerial, vpcIntfName))\n            ignore, vpcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", devSerial, entityName, poEntry[\"vpcId\"]))\n            ignore, vpcRmId2 = Util.exeRM(RM.findRMDetails(FABRIC_NAME, \"VPC_ID\", entityName, peerSerial, poEntry[\"vpcId\"]))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s]: VPC_ID [%s] rmId [%s] peer rmId [%s]\" % (FABRIC_NAME, entityName, poEntry[\"vpcId\"], vpcRmId1, vpcRmId2))\n\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            ignore, pcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s]\" % (FABRIC_NAME, key, pcid, poName, pcRmId1))\n\n            key = Util.exe(Helper.getKey(\"Device\", peerSerial))\n            ignore, pcRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+peer_pcid, peer_pcid))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s]\" % (FABRIC_NAME, key, pcid, \"port-channel\"+peer_pcid, pcRmId2))\n\n            rmIds = [vpcRmId1] + [vpcRmId2] + [pcRmId1] + [pcRmId2]\n            \n            # create the vpc host PO trunk jython policy\n            #Wrapper.print(\"Creating vpc host PO [%s] vpc [%s] policy\" % (poName, poEntry[\"vpcId\"]))\n            if poEntry[\"access_port\"]:\n                if poEntry[\"dot1q_tunnel\"]:\n                    templateName = \"int_vpc_dot1q_tunnel\"\n                    ptiTemplate = \"int_vpc_dot1q_tunnel_po_member_11_1\"\n                else:\n                    templateName = \"int_vpc_access_host\"\n                    ptiTemplate = \"int_vpc_access_po_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_enable\"]\n            else:\n                templateName = \"int_vpc_trunk_host\"\n                ptiTemplate = \"int_vpc_trunk_po_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_trunk\"]\n            \n            createPTI(vpcPairSerialKey, nvPairs, templateName, vpcIntfName, getSrc(templateName), rmIds)\n\n            sn1 = sn2 = memberIntfsPeer1 = memberIntfsPeer2 =  poPCIdPeer1 = poPCIdPeer2 = \"\"\n            if nvPairs[\"PEER1_SN\"] == devSerial:\n                sn1 = devSerial\n                sn2 = peerSerial\n                memberIntfsPeer1 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                memberIntfsPeer2 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                poPCIdPeer1 = nvPairs[\"PEER1_PCID\"]\n                poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n            elif nvPairs[\"PEER2_SN\"] == devSerial:\n                sn1 = devSerial\n                sn2 = peerSerial\n                memberIntfsPeer1 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                memberIntfsPeer2 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n                poPCIdPeer2 = nvPairs[\"PEER1_PCID\"]\n            \n            peerMatchResult, peerInterfacesRes = getSwitchMatchResults(peerSerial)\n            poMemberDescAndFFUpd(sn1, memberIntfsPeer1List, ptiTemplate, \n                                 poPCIdPeer1, matchResult, interfacesRes, vpcIntfName)\n            poMemberDescAndFFUpd(sn2, memberIntfsPeer2List, ptiTemplate, \n                                 poPCIdPeer2, peerMatchResult, peerInterfacesRes, vpcIntfName)\n        else:\n            # regular PO case\n            nvPairs = {\"PO_ID\" : poName, \"PC_MODE\" : poEntry[\"poMode\"],\n                       \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                       \"SPEED\": Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]),\n                       \"DESC\" : poEntry[\"poDesc\"],\n                       \"ENABLE_ORPHAN_PORT\" : poEntry[\"orphanPort\"],\n                       \"ADMIN_STATE\" : poEntry[\"adminState\"],\n                       \"BPDUGUARD_ENABLED\" : poEntry[\"bpduguard\"],\n                       \"ALLOWED_VLANS\" : poEntry[\"allowed_vlans\"],\n                       \"PORTTYPE_FAST_ENABLED\": poEntry[\"porttype_fast_enable\"],\n                       \"ACCESS_VLAN\" : poEntry[\"access_vlan\"],\n                       \"NATIVE_VLAN\" : \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"],\n                       \"CONF\" : poEntry[\"poConf\"],\n                       \"MEMBER_INTERFACES\" : \",\".join(poEntry[\"members\"])\n                      }\n\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]\" % (FABRIC_NAME, key, pcid))\n            ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]: rmId [%s]\" % (FABRIC_NAME, key, pcid, pcRmId))\n\n            # create the host PO trunk jython policy\n            Wrapper.print(\"Creating PO [%s] policy\" % poName)\n            templateList = [\n                            \"interface_ipv4_tag_11_1\",\n                           ]\n            if poEntry[\"access_port\"]:\n                templateList.append(\"porttype_fast_trunk\")\n                if poEntry[\"dot1q_tunnel\"]:\n                    templateName = \"int_port_channel_dot1q_tunnel_host\"\n                    ptiTemplate = \"int_port_channel_dot1q_tunnel_member_11_1\"\n                else:\n                    templateName = \"int_port_channel_access_host\"\n                    ptiTemplate = \"int_port_channel_access_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_enable\"]\n            else:\n                templateList.append(\"access_vlan\") \n                templateList.append(\"porttype_fast_enable\")\n                templateName = \"int_port_channel_trunk_host\"\n                ptiTemplate = \"int_port_channel_trunk_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_trunk\"]\n                \n            configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n            Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"%(devSerial, poName, nvPairs.get(\"CONF\")))\n            createPTI(devSerial, nvPairs, templateName, poName, getSrc(templateName), pcRmId)\n\n            memberIntfs = nvPairs.get(\"MEMBER_INTERFACES\")\n            memberIntfsList = memberIntfs.split(\",\") if memberIntfs else []\n            ignore, poPCId = poName.split(\"port-channel\")\n            poMemberDescAndFFUpd(devSerial, memberIntfsList, ptiTemplate, \n                                 poPCId, matchResult, interfacesRes, poName)\n    # delete dangling standalone vpc PTI.\n    peerSerial = \"\"\n    try:\n        peerSerial = vpcPairInfo[\"peerSerialNum\"]\n    except:\n        pass\n    if peerSerial:\n        peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"temp\"))\n        for peervPCpti in peerIntfvPCPTIs:\n            vpcIntf = peervPCpti.getEntityName()\n            Wrapper.print(\"Standalone AA/vPC host policy found with %s\"%(vpcIntf))\n            if vpcIntf:\n                ptiListPeer1 = Util.exe(PTIWrapper.get(devSerial, \"INTERFACE\", vpcIntf))\n                ptiListPeer2 = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\", vpcIntf))\n                po1 = ptiListPeer1[0].nvPairs.get(\"PO_ID\") if ptiListPeer1 else \"\"\n                po2 = ptiListPeer2[0].nvPairs.get(\"PO_ID\") if ptiListPeer2 else \"\"\n                Wrapper.print(\"vpc [%s] with po1 [%s] and po2 [%s]\"%(vpcIntf, po1, po2))\n                if not ptiListPeer1 or not ptiListPeer2:\n                    errorEntity = getFabErrEntity(funcName, devSerial+ \":vpc \" + peerSerial)\n                    Wrapper.print(\"vpcPair %s:%s - doesn't have proper vpc id %s or port-channel configuration \"\n                                  \"for interface %s,%s \"%(devSerial, peerSerial, vpcIntf.strip(\"vPC\"), po1, po2))\n                    #respObj.setWarningRetCode()\n                    #respObj.addWarnReport(errorEntity, \"vpcPair %s:%s - doesn't have proper vpc id %s or port-channel configuration \"\n            if peervPCpti.getTemplateName() == \"int_aa_fex_standalone_11_1\":\n                Wrapper.print(\"deleting AA standalone host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n            if peervPCpti.getTemplateName() == \"int_vpc_trunk_host_standalone_11_1\":\n                Wrapper.print(\"deleting vPC standalone trunk host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n            if peervPCpti.getTemplateName() == \"int_vpc_access_host_standalone_11_1\":\n                Wrapper.print(\"deleting vPC standalone access host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n    bidirConfigInSwitch = False\n    nvPairList = getTemplateMatchResults(matchResult, \"base_pim_bidir_11_1\")\n    if (nvPairList != None):\n        bidirConfigInSwitch = True\n\n    # process rest of the interfaces\n    for intfName in sorted(interfacesRes.keys()):\n        lowerIntfName = intfName.lower()\n        intfMatchResult = interfacesRes[intfName]\n        Wrapper.print(\"Processing intf [%s]. Processed = %r\" % \n                      (intfName, isIntfProcessed(intfMatchResult)))\n\n        if isIntfProcessed(intfMatchResult):\n            continue\n\n        templateNameMatches = intfMatchResult[\"matched_templates\"]\n        # remove some mutually exclusive matches\n        if (\"trunk_interface\" in templateNameMatches):\n            if (\"trunk_interface_fex\" in templateNameMatches):\n                # we will delete this since it is redundant\n                templateNameMatches.remove(\"trunk_interface\")\n\n        #Wrapper.print(\"%s(): Matched templates [%s]\"%(funcName, templateNameMatches))\n        matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n        if ((intfName in allFabricInterfaces) and (intfName not in vpcLinkMemberInterfaces)):\n            # processs the fabric interfaces\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is fabric interface, marked as processed at line [%s]\"%(intfName,\n                sys._getframe().f_lineno))\n\n            # check if any of these are PO members, then capture them as int_routed_host\n            if (('port_channel_mode' in templateNameMatches) or \n                ('port_channel_mode_on' in templateNameMatches)):\n                # include the po member inherited configs to avoid CC flagging them as diffs since it does\n                # not find the expected parent PO policy\n                createRoutedIntf(switchInfo, intfName, matchingNvPairs, True)\n                continue\n\n            nvPairs = getFabricIntfNvPairs(FABRIC_NAME, devSerial, intfName, matchingNvPairs, \n                                           LINK_STATE_ROUTING, REPLICATION_MODE, \n                                           intfMatchResult, matchResult, False)\n            nvPairs[\"IS_COMPLETE\"] = \"false\"\n            nvPairs[\"RMID_LIST\"] = \"\"\n            # check to see if the peer device is in the topology and get its details\n            peerIntf, peerSerialNum = getPoPeerDeviceSN(topologyDataObj, devSerial, intfName)\n            dictObj = {}\n            dictObj[\"FABRIC_NAME\"] = FABRIC_NAME\n            dictObj[\"FABRIC_INTERFACE\"] = FABRIC_NAME\n            dictObj[\"localSerialNum\"] = devSerial\n            dictObj[\"localNvPairs\"] = nvPairs\n            dictObj[\"localIntfName\"] = intfName\n            dictObj[\"peerSerialNum\"] = peerSerialNum\n            dictObj[\"peerIntfName\"] = peerIntf\n            dictObj[\"localHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, devSerial)\n            dictObj[\"peerHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, peerSerialNum)\n            dictObj[\"linkNbrList\"] = linkNbrList\n            Util.exe(manageFabricIntf(dictObj))\n            continue\n\n        ptiSource = \"UNDERLAY\"\n        if (lowerIntfName.startswith(\"vlan\")):\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n            # do not process any SVIs.. they are either overlays or local and are already captured in the freeforms\n            continue\n        elif (intfName.startswith(\"mgmt\")):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getMgmtIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n            PTIWrapper.createOrUpdate(devSerial, \"INTERFACE\", intfName, \"\", ConfigPriority.INTF_MGMT,\n                                \"int_mgmt\", nvPairs)\n            continue\n        elif (\"nve_interface\" in templateNameMatches or \"nve_anycast_interface\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getNveIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n            Wrapper.print(\"Creating NVE interface [%s] policy\" % intfName)\n            createPTI(devSerial, nvPairs, \"int_nve\", intfName, getSrc(\"int_nve\"), -1)\n            continue\n        elif ((\"p2p_routed_interface\" in templateNameMatches or \"interface_ipv6_11_1\" in templateNameMatches) and\n              (intfName in vpcLinkMemberInterfaces)):\n            # this is a vpc peer keep alive interface\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is vpc peer keep alive interface, marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getFabricIntfNvPairs(FABRIC_NAME, devSerial, intfName, matchingNvPairs, \n                                           LINK_STATE_ROUTING, REPLICATION_MODE, \n                                           intfMatchResult, matchResult, True)\n            nvPairs[\"IS_COMPLETE\"] = \"false\"\n            nvPairs[\"RMID_LIST\"] = \"\"\n            # check to see if the peer device is in the topology and get its details\n            peerIntf, peerSerialNum = getPoPeerDeviceSN(topologyDataObj, devSerial, intfName)\n            dictObj = {}\n            dictObj[\"FABRIC_NAME\"] = FABRIC_NAME\n            dictObj[\"FABRIC_INTERFACE\"] = FABRIC_NAME\n            dictObj[\"localSerialNum\"] = devSerial\n            dictObj[\"localIntfName\"] = intfName\n            dictObj[\"peerSerialNum\"] = peerSerialNum\n            dictObj[\"peerIntfName\"] = peerIntf\n            dictObj[\"localHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, devSerial)\n            dictObj[\"peerHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, peerSerialNum)\n            dictObj[\"linkNbrList\"] = linkNbrList\n\n            templateList = [\n                        \"bfd_interface_auth\",\n                        \"bfd_no_echo_interface\", \n                        \"ospf_interface_11_1\",\n                        \"v6_ospf_interface\",\n                        \"ospf_p2p_interface\",\n                        \"ospf_interface_auth\",\n                        \"pim_interface_hello_auth\",\n                        \"isis_p2p_interface\",\n                        \"isis_interface_auth\",\n                        \"isis_interface_auth_no_lvl\",\n                        \"pim_interface\",\n                        \"isis_interface\",\n                        \"v6_isis_interface\",\n                        \"bpduguard_disable\", \n                        \"bpduguard_enable\", \n                        \"interface_speed\",\n                        \"interface_no_nego_auto\",\n                        \"porttype_fast_enable\",\n                        \"porttype_fast_trunk\",\n                        \"vlan_interface_fwd_mode_11_1\",\n                        \"interface_ipv4_tag_11_1\",\n                        \"interface_ipv6_tag_11_1\",\n                        \"cdp_disable_interface_11_1\",\n                        \"routed_interface_no_ip_redirects\"\n                        ]\n            configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n\n            dictObj[\"localNvPairs\"] = nvPairs\n            Util.exe(manageVPCPKAIntf(dictObj))\n            continue\n        elif (intfName.startswith(\"loopback\")):\n            # this is a loopback port\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # get the id\n            loopbackId = intfName[8:]\n            #Wrapper.print(\"Found loopback ID: [%s]\" % loopbackId)\n\n            localIp = loopbackIp = \"\"\n            for templateName in matchingNvPairs:\n                if (\"loopback_interface\" == templateName or\n                    \"loopback_interface_with_tag\" == templateName):\n                    loopbackIp = matchingNvPairs[templateName][\"IP\"]\n                    break\n               \n            if vpcPairInfo.get(\"vpcFabricPair\"):\n                localIp = vpcPairInfo.get(\"SRC_LB_IP\")\n\n            if localIp and localIp == loopbackIp:\n                if lowerIntfName == getLbIntfName(\"nve\") or lowerIntfName == getLbIntfName(\"rp\"):\n                    errorMsg = (\"Interface %s, Ip %s should not same vPC virtual peer link source ip !!!. \"\n                                \"RP or NVE loopback should not be used with vpc virtual peer link configuration.\"%\n                                (lowerIntfName, loopbackIp))\n                    respObj.addErrorReport((funcName+lowerIntfName+\":\"+loopbackIp), errorMsg, devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n                if lowerIntfName != getLbIntfName(\"bgp\"):\n                    vpcPairInfo.update({\"virtualVPCLoopback\":loopbackId})\n\n            if (lowerIntfName != getLbIntfName(\"bgp\") and\n                lowerIntfName != getLbIntfName(\"nve\") and\n                lowerIntfName != getLbIntfName(\"anycast\") and\n                lowerIntfName != getLbIntfName(\"rp\") and \n                not vpcPairInfo.get(\"virtualVPCLoopback\")):\n\n                if not handleServiceLoopback(FABRIC_NAME, devSerial, intfName, loopbackId, matchingNvPairs, globalOverlayInfo):\n                    # not a service related loopback\n                    setRmResource = True\n                    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n                    for cfg in intfMatchResult[\"show_run_cmds\"]:\n                        lowerStr = cfg.lower()\n                        if (lowerStr.strip().startswith(\"vrf member \")):\n                            setRmResource = False\n                            Wrapper.print(\"FAB [%s]: Skip setting RM ID for intfName [%s]\" % (FABRIC_NAME, intfName))\n                            break\n\n                    rmId = -1\n                    if setRmResource:\n                        key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                        ignore, rmId = Util.exeRM(RM.set(FABRIC_NAME, \"LOOPBACK_ID\", key, intfName, loopbackId))\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s] rmId [%s]\" %\n                                      (FABRIC_NAME, key, loopbackId, intfName, rmId))\n                    createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME, rmId)\n                continue\n\n            nvPairs = {\"INTF_NAME\" : intfName,\n                       \"IP\" : \"\",\n                       \"SECONDARY_IP\" : \"\",\n                       \"V6IP\" : \"\",\n                       \"DESC\" : \"\",\n                       \"REPLICATION_MODE\" : REPLICATION_MODE,\n                       \"LINK_STATE_ROUTING_TAG\" : LINK_STATE_ROUTING_TAG,\n                       \"ROUTE_MAP_TAG\" : \"\",\n                       \"FABRIC_NAME\" : FABRIC_NAME,\n                       \"ADMIN_STATE\" : \"true\",\n                       \"CONF\" :\"\"\n                      }\n\n            if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                nvPairs.update({\"CONF\": Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"])})\n            templateList = [\n                            \"access_vlan\", \n                            \"bpduguard_disable\", \n                            \"bpduguard_enable\", \n                            \"interface_speed\",\n                            \"ospf_p2p_interface\",\n                            \"ospf_interface_auth\",\n                            \"pim_interface_hello_auth\",\n                            \"isis_p2p_interface\",\n                            \"isis_interface_auth\",\n                            \"isis_interface_auth_no_lvl\",\n                            \"porttype_fast_enable\",\n                            \"porttype_fast_trunk\",\n                            \"vlan_interface_fwd_mode_11_1\",\n                            \"cdp_disable_interface_11_1\"\n                            ]\n\n            if UNDERLAY_IS_V6 == \"false\":\n                # Underlay is V4, treat ipv6 address config as unaccounted\n                templateList.append(\"interface_ipv6_11_1\")\n            else:\n                # Underlay is V6, treat ip address config as unaccounted\n                templateList.append(\"interface_ipv4_11_1\")\n\n            configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n            Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"%(devSerial, intfName, nvPairs.get(\"CONF\")))\n\n            for templateName in matchingNvPairs:\n                if (\"loopback_interface\" == templateName or \n                    \"loopback_interface_with_tag\" == templateName):\n                    nvPairs.update({\"IP\" : matchingNvPairs[templateName][\"IP\"]})\n\n                    nvPair = matchingNvPairs[templateName]\n\n                    # record resources in RM\n                    key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s]\" %\n                                  (FABRIC_NAME, key, loopbackId, intfName))\n                    #Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK_ID\", key, intfName, loopbackId))\n\n                    # set the loopback IP resource\n                    loopbackIP = nvPair[\"IP\"]\n                    Wrapper.print(\"loopback IP [%s] from nvPair and loopback IP [%s] from matchnvPair\"%\n                                  (loopbackIP, matchingNvPairs[templateName][\"IP\"]))\n                    key = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, intfName))\n\n                    # get the PTI for the anycast RP IP\n                    anycastRPIP = \"\"\n                    ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", \"anycast_rp\"))\n                    for pti in ptiList:\n                        anycastRPIP = pti.getNvPairs()[\"ANYCAST_RP_IP\"]\n                        Wrapper.print(\"SN [%s]. ANYCAST_RP_IP = [%s]\" % (devSerial, anycastRPIP))\n                        break\n\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK IP: [%s] ANYCAST_RP_IP: [%s]\" %\n                                  (FABRIC_NAME, key, loopbackIP, anycastRPIP))\n                    if loopbackIP != anycastRPIP:\n                        poolName = \"\"\n                        if (lowerIntfName == getLbIntfName(\"bgp\")):\n                            poolName = \"LOOPBACK0_IP_POOL\"\n                        elif (lowerIntfName == getLbIntfName(\"nve\")):\n                            poolName = \"LOOPBACK1_IP_POOL\"\n                        elif (lowerIntfName == getLbIntfName(\"rp\")): # revisit\n                            poolName = \"ANYCAST_RP_IP_POOL\"\n                        elif vpcPairInfo.get(\"virtualVPCLoopback\"):\n                            poolName = \"LOOPBACK0_IP_POOL\"\n                        else:\n                            #user loopback case\n                            Wrapper.print(\"No fabric loopback\")\n                            continue\n                        Util.exe(RM.set(FABRIC_NAME, poolName, EntityType.INTERFACE, key, loopbackIP))\n                elif (\"v6_loopback_interface\" == templateName or \n                      \"v6_loopback_interface_with_tag\" == templateName):\n                    nvPairs.update({\"V6IP\" : matchingNvPairs[templateName][\"IP\"]})\n\n                    nvPair = matchingNvPairs[templateName]\n\n                    # record resources in RM\n                    key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s]\" %\n                                  (FABRIC_NAME, key, loopbackId, intfName))\n                    #Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK_ID\", key, intfName, loopbackId))\n\n                    # set the loopback IP resource\n                    loopbackIP = nvPair[\"IP\"]\n                    Wrapper.print(\"loopback IP [%s] from nvPair and loopback IP [%s] from matchnvPair\"%\n                                  (loopbackIP, matchingNvPairs[templateName][\"IP\"]))\n                    key = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, intfName))\n\n                    poolName = \"\"\n                    if (lowerIntfName == getLbIntfName(\"bgp\")):\n                        poolName = \"LOOPBACK0_IP_POOL\"\n                    elif (lowerIntfName == getLbIntfName(\"nve\")):\n                        poolName = \"LOOPBACK1_IP_POOL\"\n                    elif (lowerIntfName == getLbIntfName(\"anycast\")):\n                        poolName = \"LOOPBACK1_IP_POOL\"\n                    else:\n                        # user loopback case\n                        Wrapper.print(\"No fabric loopback for V6\")\n                        continue\n\n                    if isVPC and (lowerIntfName == getLbIntfName(\"anycast\")):\n                        key = Util.exe(Helper.getKey(\"DeviceInterface\", vpcSn, vpcPeerSn, intfName))\n                        Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK1_IP_POOL\", EntityType.INTERFACE, key, loopbackIP))\n                        continue\n                        \n                    Util.exe(RM.set(FABRIC_NAME, poolName, EntityType.INTERFACE, key, loopbackIP))\n                elif (\"ospf_interface_11_1\" == templateName or \"v6_ospf_interface\" == templateName):\n                    nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"OSPF_TAG\"]})\n                    nvPairs.update({\"OSPF_AREA_ID\" : matchingNvPairs[templateName][\"OSPF_AREA_ID\"]})\n                elif (\"ospf_interface_auth\" == templateName):\n                    nvPairs[\"OSPF_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY_ID\"]\n                    nvPairs[\"OSPF_AUTH_KEY\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY\"]\n                elif (\"isis_interface\" == templateName or \"v6_isis_interface\" == templateName):\n                    nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"ISIS_TAG\"]})\n                elif (\"shut_interface\" == templateName):\n                    nvPairs[\"ADMIN_STATE\"] = \"false\"\n                elif (\"interface_desc\" == templateName):\n                    nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n            if isValidVPC:\n                # check for the vPC NVE secondary IP\n                templateName = \"vpc_nve_loopback\"\n                secIp = \"\"\n                nvPairList = getTemplateMatchResults(matchResult, templateName)\n                if (nvPairList != None):\n                    if (nvPairList[0][\"INTF_NAME\"] == intfName):\n                        nvPairs[\"SECONDARY_IP\"] = \"0.0.0.0\"#matchingNvPairs[templateName][\"SECONDARY_IP\"]\n                        secIp = matchingNvPairs[templateName][\"SECONDARY_IP\"]\n                templateName = \"vpc_nve_loopback_with_tag_11_1\"\n                nvPairList = getTemplateMatchResults(matchResult, templateName)\n                if (nvPairList != None):\n                    if (nvPairList[0][\"INTF_NAME\"] == intfName):\n                        nvPairs[\"SECONDARY_IP\"] = \"0.0.0.0\"#matchingNvPairs[templateName][\"SECONDARY_IP\"]\n                        secIp = matchingNvPairs[templateName][\"SECONDARY_IP\"]\n                Wrapper.print(\"%s: RM Set# Secondary IP %s\"%(devSerial, secIp))\n                if secIp and vpcPairSerialKey and lowerIntfName == getLbIntfName(\"nve\"):\n                    tmpSerials = vpcPairSerialKey.split(Helper.DELIMITER)\n                    tmpVpcSn = devSerial\n                    tmpVpcPeerSn = tmpSerials[1] if tmpVpcSn == tmpSerials[0] else tmpSerials[0]\n                    key = Util.exe(Helper.getKey(\"DeviceInterface\", tmpVpcSn, tmpVpcPeerSn, lowerIntfName))\n                    Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK1_IP_POOL\", EntityType.INTERFACE, key, secIp))\n\n            if \"OSPF_AUTH_KEY\" not in nvPairs:\n                nvPairs[\"OSPF_AUTH_KEY\"] = OSPF_AUTH_KEY\n                nvPairs[\"OSPF_AUTH_KEY_ID\"] = OSPF_AUTH_KEY_ID\n\n            # create the loopback port jython policy\n            # need to handle it properly\n            nvPairs[\"ROUTE_MAP_TAG\"] = \"\"\n            if UNDERLAY_IS_V6 == \"false\":\n                srcTemplateName = \"loopback_interface\"\n                for templateName in matchingNvPairs:\n                    if \"loopback_interface_with_tag\" == templateName:\n                        nvPairs.update({\"ROUTE_MAP_TAG\" : matchingNvPairs[templateName][\"ROUTE_MAP_TAG\"]})\n                        srcTemplateName = \"loopback_interface_with_tag\"\n                        break\n            else:\n                srcTemplateName = \"v6_loopback_interface\"\n                for templateName in matchingNvPairs:\n                    if \"v6_loopback_interface_with_tag\" == templateName:\n                        nvPairs.update({\"ROUTE_MAP_TAG\" : matchingNvPairs[templateName][\"ROUTE_MAP_TAG\"]})\n                        srcTemplateName = \"v6_loopback_interface_with_tag\"\n                        break\n\n            if lowerIntfName == getLbIntfName(\"rp\"):\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   10, \"rp_lb_id\", {\"id\": loopbackId}))\n\n            if vpcPairInfo.get(\"virtualVPCLoopback\"):\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                                   10, \"vpc_fabric_pair_lb_id\", {\"id\": loopbackId}))\n            \n            src = getSrc(srcTemplateName)\n            if bidirConfigInSwitch:\n                # Customer config of bidir is used in the fabric,\n                # create the RP loopback using empty source\n                src = \"\"\n            createPTI(devSerial, nvPairs, \"int_fabric_loopback_11_1\", intfName, src, -1)\n            continue\n        elif (\"phantom_loopback_interface_11_1\" in templateNameMatches):\n            # this is a loopback port for phantom RP\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # get the id\n            loopbackId = intfName[8:]\n            Wrapper.print(\"Found phantom RP loopback ID: [%s]\" % loopbackId)\n\n            # Do not create phantom RP loopback if the switch is not using bidir nor a spine\n            if not bidirConfigInSwitch or not isSpine:\n                createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME)\n                continue\n\n            # Only 2 RPs are supported for bidir in brownfield migration\n            if (lowerIntfName != getLbIntfName(\"phantom_rp1\") and\n                lowerIntfName != getLbIntfName(\"phantom_rp2\")):\n                createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME)\n                continue\n\n            nvPairs = {\"INTF_NAME\": intfName,\n                       \"IP\": \"\",\n                       \"PREFIX\": \"\",\n                       \"LINK_STATE_ROUTING\": LINK_STATE_ROUTING,\n                       \"LINK_STATE_ROUTING_TAG\": \"\",\n                       \"OSPF_AREA_ID\": OSPF_AREA_ID,\n                       \"DESC\": \"\",\n                       \"CONF\" :\"\",\n                       \"ADMIN_STATE\" : \"true\"\n                      }\n\n            if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                Wrapper.print(\"Device [%s]: Found unaccounted cfg for loopback intf [%s]\" % (devSerial, intfName))\n                nvPairs.update({\"CONF\": Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"])})\n\n            for templateName in matchingNvPairs:\n                if (\"phantom_loopback_interface_11_1\" == templateName):\n                    nvPairs.update({\"IP\" : matchingNvPairs[templateName][\"IP\"]})\n                    nvPairs.update({\"PREFIX\" : matchingNvPairs[templateName][\"PREFIX\"]})\n\n                    nvPair = matchingNvPairs[templateName]\n\n                    # record resources in RM\n                    key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s]\" %\n                                  (FABRIC_NAME, key, loopbackId, intfName))\n                    #Util.exe(RM.set(FABRIC_NAME, \"LOOPBACK_ID\", key, intfName, loopbackId))\n\n                    # TBD: set the loopback IP resource when RM supports management of subnets\n                elif (\"ospf_interface_11_1\" == templateName):\n                    nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"OSPF_TAG\"]})\n                    nvPairs.update({\"OSPF_AREA_ID\" : matchingNvPairs[templateName][\"OSPF_AREA_ID\"]})\n                elif (\"isis_interface\" == templateName):\n                    nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"ISIS_TAG\"]})\n                elif (\"shut_interface\" == templateName):\n                    nvPairs[\"ADMIN_STATE\"] = \"false\"\n                elif (\"interface_desc\" == templateName):\n                    nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n                elif (\"ospf_interface_auth\" == templateName):\n                    nvPairs[\"OSPF_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY_ID\"]\n                    nvPairs[\"OSPF_AUTH_KEY\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY\"]\n\n            if \"OSPF_AUTH_KEY\" not in nvPairs:\n                nvPairs[\"OSPF_AUTH_KEY\"] = OSPF_AUTH_KEY\n                nvPairs[\"OSPF_AUTH_KEY_ID\"] = OSPF_AUTH_KEY_ID\n\n            # create the loopback port jython policy\n            Wrapper.print(\"Creating phantom RP loopback port [%s] policy\" % intfName)\n            createPTI(devSerial, nvPairs, \"int_fabric_phantom_rp_loopback_11_1\", intfName, \"\", -1)\n            if loopbackId == PHANTOM_RP_LB_ID1:\n                templateName = \"phantom_rp_lb_id1\"\n            elif loopbackId == PHANTOM_RP_LB_ID2:\n                templateName = \"phantom_rp_lb_id2\"\n            Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", 10, templateName, {\"id\": loopbackId}))\n            continue\n        elif (\"access_interface\" in templateNameMatches or \n              \"access_interface_fex\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the host port jython policy\n            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            templateName = \"int_access_host\"\n            createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n            continue\n        elif (\"dot1q_tunnel_interface\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the host port jython policy\n            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            templateName = \"int_dot1q_tunnel_host\"\n            createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n            continue\n        elif ((\"trunk_interface\" in templateNameMatches) or\n              (\"trunk_interface_fex\" in templateNameMatches)):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getTrunkIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            createPTI(devSerial, nvPairs, \"int_trunk_host\", intfName, getSrc(\"int_trunk_host\"), -1)\n            continue\n        elif (\"routed_interface\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Routed Intf: [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n            createRoutedIntf(switchInfo, intfName, matchingNvPairs, True)\n            continue\n        elif ((\"eth_sub_interface\" in templateNameMatches) or\n              (\"eth_sub_interface_tag\" in templateNameMatches)):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the sub-interface jython policy\n            Wrapper.print(\"Creating Sub-interface policy for [%s]\" % intfName)\n            dot1qID, nvPairs = getSubIntfNvPairs(switchInfo, intfName, matchingNvPairs)\n            createPTI(devSerial, nvPairs, \"int_subif\", intfName, getSrc(\"int_subif\"), -1)\n            continue\n        else:\n            createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME)\n\n        # mark the interface as being processed\n        intfMatchResult.update({\"isProcessed\" : True})\n        Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n    Wrapper.print(\"%s: [%s] Success = [%r]\" % (funcName, fmtName, respObj.isRetCodeSuccess()))\n    return respObj\n\n# API to process the provided freeform for a po member port\n# if includeMemberInheritedCfg is true, all the CLIs that are inherited from the parent PO are removed from the FF\ndef getPoMemberFF(currentFF, intfName, includeMemberInheritedCfg=False):\n    funcName = sys._getframe(0).f_code.co_name\n\n    if includeMemberInheritedCfg:\n        return False, currentFF\n    \n    filteredFF = []\n    # filter out inherited CLIs\n    for line in currentFF:\n        strippedLine = line.strip().lower()\n\n        #Wrapper.print(\"%s: Intf [%s] strippedLine [%s] Line [%s]\" % (funcName, intfName, strippedLine, line))\n\n        # set of commands that are configurable on the member interfaces\n        filterCmdList = ['beacon', 'cdp', 'channel-group', 'description', 'dfe-tuning-delay', 'fec',\n                         'ip', 'ipv6','link', 'lacp', 'lldp', 'logging', 'mdix', 'no', 'power', 'ptp', 'rate-limit',\n                         'service-policy', 'snmp', 'spanning-tree', 'speed-group', 'switchport host', 'unidirectional']\n        intfCmdList = filter(lambda x: strippedLine.startswith(x), filterCmdList)\n\n        if intfCmdList:\n            filteredFF.append(line)\n\n    isUpdated = False\n    if len(currentFF) != len(filteredFF):\n        isUpdated = True\n\n    return isUpdated, filteredFF\n\ndef createLoopbackIntf(fabricName, switchInfo, intfName, matchingNvPairs):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = switchInfo[\"deviceSerial\"]\n\n    # create the host port jython policy\n    templateName = \"int_loopback\"\n    nvPairs = getLoopbackIntfNvpairs(fabricName, switchInfo, intfName, matchingNvPairs)\n    createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n\ndef createRoutedIntf(switchInfo, intfName, matchingNvPairs, includeMemberInheritedCfg):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = switchInfo[\"deviceSerial\"]\n\n    # create the host port jython policy\n    templateName = \"int_routed_host\"\n    nvPairs = getRoutedIntfNvpairs(switchInfo, intfName, matchingNvPairs, includeMemberInheritedCfg)\n    createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n\ndef getLinkInfo(sn1, sn2, intf1, intf2, linkNbrList):\n    uuid = linkType = entityName = \"\"\n    Wrapper.print(\"===Upgrade: getLinkInfo-Start===\")\n    Wrapper.print(\"===Upgrade: getLinkInfo-for [%s/%s/%s/%s]\"%(sn1,sn2,intf1,intf2))\n    for linkNbr in linkNbrList:\n        sw1Info = json.loads(linkNbr.get(\"sw2-info\"))\n        sw2Info = json.loads(linkNbr.get(\"sw1-info\"))\n        Wrapper.print(\"==SWITCH1 INFO==[%s]\"%(sw1Info))\n        Wrapper.print(\"==SWITCH2 INFO==[%s]\"%(sw2Info))\n        Wrapper.print (\"SN1/SN2/IFNAME1/IFNAME2 [%s:%s-%s:%s]\" %\n                       (sw1Info.get(\"sw-serial-number\"), sw2Info.get(\"sw-serial-number\"),\n                        sw1Info.get(\"if-name\"), sw2Info.get(\"if-name\")))\n        if (((sw1Info.get(\"sw-serial-number\") == sn1 and sw2Info.get(\"sw-serial-number\") == sn2) or\n             (sw1Info.get(\"sw-serial-number\") == sn2 and sw2Info.get(\"sw-serial-number\") == sn1)) and\n            ((sw1Info.get(\"if-name\") == intf1 and sw2Info.get(\"if-name\") == intf2) or\n             (sw1Info.get(\"if-name\") == intf2 and sw2Info.get(\"if-name\") == intf1))):\n            uuid = linkNbr.get(\"link-uuid\")\n            linkType = linkNbr.get(\"link-type\")\n            pairSerial = Util.exe(Helper.getLinkOrderByLinkUUid(uuid)) if uuid else \"\"\n            if pairSerial[\"sw1-serial-number\"] == sw2Info.get(\"sw-serial-number\"):\n                entityName = (sw2Info.get(\"sw-serial-number\") + \"~\" + sw2Info.get(\"if-name\") + \"~\" +\n                              sw1Info.get(\"sw-serial-number\") + \"~\" + sw1Info.get(\"if-name\"))\n            else:\n                entityName = (sw1Info.get(\"sw-serial-number\") + \"~\" + sw1Info.get(\"if-name\") + \"~\" +\n                              sw2Info.get(\"sw-serial-number\") + \"~\" + sw2Info.get(\"if-name\"))\n            break\n    Wrapper.print(\"===Upgrade: LINK_UUID [%s] linkType [%s] entityName [%s]===\"%(uuid, linkType, entityName))\n    Wrapper.print(\"===Upgrade: getLinkInfo-End===\")\n    return (uuid, linkType, entityName)\n\ndef manageVPCPKAIntf(dictObj):\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    funcName = sys._getframe(0).f_code.co_name\n    try:\n        FABRIC_NAME = dictObj[\"FABRIC_NAME\"]\n        localSerialNum = dictObj[\"localSerialNum\"]\n        localNvPairs = dictObj[\"localNvPairs\"]\n        localIntfName = dictObj[\"localIntfName\"]\n        peerSerialNum = dictObj[\"peerSerialNum\"]\n        peerIntfName = dictObj[\"peerIntfName\"]\n        localHostName = dictObj[\"localHostName\"]\n        peerHostName = dictObj[\"peerHostName\"]\n        linkNbrList = dictObj[\"linkNbrList\"]\n        templateName = \"int_vpc_peer_keep_alive_11_1\"\n\n        Wrapper.print(\"%s(): Local [%s/%s] <-> Peer [%s/%s]\" %\n                        (funcName, localSerialNum, localIntfName, peerSerialNum, peerIntfName))\n        if (peerIntfName != \"\"):\n            # get the PTI for the peer fabric interface (we need the IP addr on peer intf)\n            srchOpt = CtrlPolicySearch()\n            srchOpt.setSerialNumber(peerSerialNum)\n            srchOpt.setTemplateName(templateName)\n            srchOpt.setEntityName(peerIntfName)\n\n            peerIntfPTIs = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            peerIntfPti = None\n            for pti in peerIntfPTIs:\n                peerIntfPti = pti\n                break\n            \n            localIntfIp4 = localIntfIp6 = \"\"\n            peerIntfIp4 = peerIntfIp6 = \"\"\n            prefix4 = prefix6 = \"\"\n            subnetStr4 = subnetStr6 = \"\" \n\n            if (peerIntfPti != None):\n                isIp4Present = False\n                isIp6Present = False\n                # generate the key to associate the subnet pool with\n                linkKey = Util.exe(Helper.getKey(\"Link\", localSerialNum, localIntfName, peerSerialNum, peerIntfName))\n    \n                peerIntfNvPairs = copy.deepcopy(peerIntfPti.getNvPairs())\n\n                peerIntfIp4 = peerIntfNvPairs[\"IP\"]\n                isIp4Present = True if peerIntfIp4 else False\n                peerIntfIp6 = peerIntfNvPairs[\"V6IP\"]\n                isIp6Present = True if peerIntfIp6 else False\n \n                if isIp4Present:\n                    peerIntfIp4 = peerIntfNvPairs[\"IP\"]\n                    Wrapper.print(\"%s(): Peer intf [%s]. IP = [%s]\" % (funcName, peerIntfName, peerIntfIp4))\n    \n                    # save local intf IP\n                    localIntfIp4 = localNvPairs[\"IP\"]\n    \n                    subnetStr1 = Util.getSubnetStringWithPrefix(localNvPairs[\"IP\"], localNvPairs[\"PREFIX\"])\n                    subnetStr2 = Util.getSubnetStringWithPrefix(peerIntfNvPairs[\"IP\"], peerIntfNvPairs[\"PREFIX\"])\n                    if subnetStr1 != subnetStr2:\n                        errorMsg = (\"SN1:SN2 %s:%s link %s:%s IPs %s:%s are not in same subnet %s:%s. \"\n                                    \"Please correct [%s] Interface [%s] IP [%s/%s] \"%\n                                    (localSerialNum, peerSerialNum, localIntfName, peerIntfName, \n                                     localIntfIp4, peerIntfIp4, subnetStr1, subnetStr2, \n                                     localSerialNum, localIntfName, localIntfIp4, localNvPairs[\"PREFIX\"]))\n                        respObj.addErrorReport((funcName+localIntfName+\":\"+peerIntfName), errorMsg)\n                        respObj.setFailureRetCode()\n                        return respObj\n    \n                    prefix4 = localNvPairs[\"PREFIX\"] if localNvPairs[\"PREFIX\"] < peerIntfNvPairs[\"PREFIX\"] else peerIntfNvPairs[\"PREFIX\"]\n    \n                    # set the subnet pool in RM\n                    subnetStr4 = Util.getSubnetStringWithPrefix(localIntfIp4, localNvPairs[\"PREFIX\"])\n                    Wrapper.print(\"%s(): RM OPER: FAB [%s]: SET:[%s] Key [%s]: Link SUBNET [%s]\" %\n                                  (funcName, FABRIC_NAME, funcName, linkKey, subnetStr4))\n                if isIp6Present:\n                    peerIntfIp6 = peerIntfNvPairs[\"V6IP\"]\n                    Wrapper.print(\"%s(): Peer intf [%s]. V6IP = [%s]\" % (funcName, peerIntfName, peerIntfIp6))\n    \n                    # save local intf IP\n                    localIntfIp6 = localNvPairs[\"V6IP\"]\n    \n                    subnetStr1 = Util.getV6SubnetStringWithPrefix(localNvPairs[\"V6IP\"], localNvPairs[\"V6PREFIX\"])\n                    subnetStr2 = Util.getV6SubnetStringWithPrefix(peerIntfNvPairs[\"V6IP\"], peerIntfNvPairs[\"V6PREFIX\"])\n                    if subnetStr1 != subnetStr2:\n                        errorMsg = (\"SN1:SN2 %s:%s link %s:%s IPs %s:%s are not in same subnet %s:%s. \"\n                                    \"Please correct [%s] Interface [%s] IP [%s/%s] \"%\n                                    (localSerialNum, peerSerialNum, localIntfName, peerIntfName, \n                                     localIntfIp6, peerIntfIp6, subnetStr1, subnetStr2, \n                                     localSerialNum, localIntfName, localIntfIp6, localNvPairs[\"V6PREFIX\"]))\n                        respObj.addErrorReport((funcName+localIntfName+\":\"+peerIntfName), errorMsg)\n                        respObj.setFailureRetCode()\n                        return respObj\n    \n                    prefix6 = localNvPairs[\"V6PREFIX\"] if localNvPairs[\"V6PREFIX\"] < peerIntfNvPairs[\"V6PREFIX\"] else peerIntfNvPairs[\"V6PREFIX\"]\n    \n                    # set the subnet pool in RM\n                    subnetStr6 = Util.getV6SubnetStringWithPrefix(localIntfIp6, localNvPairs[\"V6PREFIX\"])\n                    Wrapper.print(\"%s(): RM OPER: FAB [%s]: SET:[%s] Key [%s]: Link SUBNET [%s]\" %\n                                  (funcName, FABRIC_NAME, funcName, linkKey, subnetStr6))\n\n                # set the local interface IP in RM\n                key = Util.exe(Helper.getKey(\"DeviceInterface\", localSerialNum, localIntfName))\n                Wrapper.print(\"%s(): RM OPER: FAB [%s]: SET:[%s] Key [%s]: Link local (SUBNET4 [%s], IP4 [%s]) (SUBNET6 [%s], IP6 [%s])\" %\n                              (funcName, FABRIC_NAME, funcName, key, subnetStr4, localIntfIp4, subnetStr6, localIntfIp6))\n\n                # set the peer interface IP in RM\n                key = Util.exe(Helper.getKey(\"DeviceInterface\", peerSerialNum, peerIntfName))\n                Wrapper.print(\"%s(): RM OPER: FAB [%s]: SET:[%s] Key [%s]: Link peer (SUBNET4 [%s], IP4 [%s]) (SUBNET6 [%s], IP6 [%s])\" %\n                              (funcName, FABRIC_NAME, funcName, key, subnetStr4, peerIntfIp4, subnetStr6, peerIntfIp6))\n\n                #don't delete before responding about error\n                PTIWrapper.delete(peerSerialNum, \"INTERFACE\", peerIntfName)\n                \n                intfVRF = \"\"\n                if localNvPairs.get(\"INTF_VRF\"):\n                    intfVRF = localNvPairs[\"INTF_VRF\"]\n                nvPairs = {\n                           \"FABRIC1\":FABRIC_NAME, \n                           \"FABRIC2\":FABRIC_NAME,\n                           \"INTF_VRF\":intfVRF,\n                           \"MTU\": localNvPairs[\"MTU\"],\n                           \"ADMIN_STATE\": \"true\",\n                           \"GUI_EDIT\":\"\"\n                          }\n                \n                linkUUID, ignore, entityName = getLinkInfo(localSerialNum, peerSerialNum, localIntfName, peerIntfName, linkNbrList)\n                peer1Sn = entityName.split(\"~\")[0]\n                peer2Sn = entityName.split(\"~\")[2]\n                if peer1Sn == localSerialNum:\n                    nvPairs.update({\"HOSTNAME1\":localHostName, \"HOSTNAME2\":peerHostName,\n                                    \"PEER1_SN\":localSerialNum, \"PEER2_SN\":peerSerialNum, \n                                    \"PEER1_INTF\":localIntfName, \"PEER2_INTF\":peerIntfName,\n                                    \"PEER1_DESC\": localNvPairs[\"DESC\"], \"PEER2_DESC\":peerIntfNvPairs[\"DESC\"], \n                                    \"PEER1_CONF\":localNvPairs[\"CONF\"], \"PEER2_CONF\":peerIntfNvPairs[\"CONF\"]})\n                else:\n                    nvPairs.update({\"HOSTNAME1\":peerHostName, \"HOSTNAME2\":localHostName,\n                                    \"PEER1_SN\":peerSerialNum, \"PEER2_SN\":localSerialNum,\n                                    \"PEER1_INTF\":peerIntfName, \"PEER2_INTF\":localIntfName,\n                                    \"PEER1_DESC\": peerIntfNvPairs[\"DESC\"], \"PEER2_DESC\":localNvPairs[\"DESC\"],\n                                    \"PEER1_CONF\":peerIntfNvPairs[\"CONF\"], \"PEER2_CONF\":localNvPairs[\"CONF\"]})\n\n                ptiTemplateName = \"int_intra_vpc_peer_keep_alive_link\"\n                nvPairs.update({\"PEER1_IP\":\"\", \"PEER2_IP\":\"\", \"PREFIX\":prefix4})\n                nvPairs.update({\"PEER1_V6IP\":\"\", \"PEER2_V6IP\":\"\", \"V6PREFIX\":prefix6})\n                if peer1Sn == localSerialNum:\n                    if isIp4Present:\n                        nvPairs.update({\"PEER1_IP\":localIntfIp4, \"PEER2_IP\":peerIntfIp4})\n                    if isIp6Present:\n                        nvPairs.update({\"PEER1_V6IP\":localIntfIp6, \"PEER2_V6IP\":peerIntfIp6})\n                else:\n                    if isIp4Present:\n                        nvPairs.update({\"PEER1_IP\":peerIntfIp4, \"PEER2_IP\":localIntfIp4})\n                    if isIp6Present:\n                        nvPairs.update({\"PEER1_V6IP\":peerIntfIp6, \"PEER2_V6IP\":localIntfIp6})\n                Util.exe(PTIWrapper.createOrUpdate(linkUUID, \"LINK\", entityName, \"\", 500, ptiTemplateName, nvPairs))\n            else:\n                Wrapper.print(\"%s(): vpc peer keep alive [%s] PTI not found\" % (funcName, peerIntfName))\n        else:\n            Wrapper.print(\"manageVPCPKAIntf: Peer not found. Creating incomplete VPCPKA interface [%s] policy\" % localIntfName)\n            localNvPairs[\"GUI_EDIT\"] = \"\"\n            localNvPairs[\"FABRIC_NAME\"] = FABRIC_NAME\n            localNvPairs[\"IP_RM_ID\"] = \"-1\"\n            localNvPairs[\"SUBNET_RM_ID\"] = \"-1\"\n            createPTI(localSerialNum, localNvPairs, templateName, localIntfName, \"LINK\", -1)\n        Wrapper.print(\"==========%s done==========\"%(funcName))\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef isVirtualVPCSwitch(FABRIC_NAME, sn):\n    isSwitchVPC = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, sn))\n    if isSwitchVPC:\n        try:\n            vpcType = Util.exe(VpcWrapper.get(VPCMetaDataType.PEERLINK_TYPE, \"\", sn))\n            if vpcType == VPCMetaDataType.VIRTUAL_PEERLINK:\n                return True\n        except:\n            Wrapper.print(\"%s() template [%s] Seems Upgrade path :\"%(funcName, \"Easy_Fabric_Extn\"))\n    return False\n\ndef manageFabricIntf(dictObj):\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        FABRIC_NAME = dictObj[\"FABRIC_NAME\"]\n        localSerialNum = dictObj[\"localSerialNum\"]\n        localNvPairs = dictObj[\"localNvPairs\"]\n        localIntfName = dictObj[\"localIntfName\"]\n        peerSerialNum = dictObj[\"peerSerialNum\"]\n        peerIntfName = dictObj[\"peerIntfName\"]\n        localHostName = dictObj[\"localHostName\"]\n        peerHostName = dictObj[\"peerHostName\"]\n        linkNbrList = dictObj[\"linkNbrList\"]\n        templateName = \"int_fabric_unnum_11_1\" if FABRIC_INTERFACE_TYPE == \"unnumbered\" else \"int_fabric_num_11_1\"\n        if UNDERLAY_IS_V6 == \"true\" and USE_LINK_LOCAL == \"true\":\n            templateName = \"int_fabric_ipv6_link_local\"\n\n        Wrapper.print(\"manageFabricIntf: Local [%s/%s] <-> Peer [%s/%s]\" %\n                        (localSerialNum, localIntfName, peerSerialNum, peerIntfName))\n        if (peerIntfName != \"\"):\n            # get the PTI for the peer fabric interface (we need the IP addr on peer intf)\n            srchOpt = CtrlPolicySearch()\n            srchOpt.setSerialNumber(peerSerialNum)\n            srchOpt.setTemplateName(templateName)\n            srchOpt.setEntityName(peerIntfName)\n\n            peerIntfPTIs = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            peerIntfPti = None\n            for pti in peerIntfPTIs:\n                peerIntfPti = pti\n                break\n            \n            localIntfIp = peerIntfIp = \"\"\n            if (peerIntfPti != None):\n                peerIntfNvPairs = copy.deepcopy(peerIntfPti.getNvPairs())\n                prefix = \"\"\n                if FABRIC_INTERFACE_TYPE == \"p2p\" and templateName != \"int_fabric_ipv6_link_local\":\n                    if UNDERLAY_IS_V6 == \"false\":\n                        localIntfIp = localNvPairs[\"IP\"]\n                        localIntfPrefix = localNvPairs[\"PREFIX\"]\n                        peerIntfIp = peerIntfNvPairs[\"IP\"]\n                        peerIntfPrefix = peerIntfNvPairs[\"PREFIX\"]\n                    else:\n                        localIntfIp = localNvPairs[\"V6IP\"]\n                        localIntfPrefix = localNvPairs[\"V6PREFIX\"]\n                        peerIntfIp = peerIntfNvPairs[\"V6IP\"]\n                        peerIntfPrefix = peerIntfNvPairs[\"V6PREFIX\"]\n                     \n                    if localIntfIp == \"\" or peerIntfIp == \"\":\n                        errorMsg = (\"SN1:SN2 %s:%s link %s:%s IPs %s:%s are not configured. \"%\n                                    (localSerialNum, peerSerialNum, localIntfName, peerIntfName, \n                                     localIntfIp, peerIntfIp))\n                        respObj.addErrorReport((\"manageFabricIntf\"+localIntfName+\":\"+peerIntfName), errorMsg)\n                        respObj.setFailureRetCode()\n                    else:\n                        if UNDERLAY_IS_V6 == \"false\":\n                            subnetStr1 = Util.getSubnetStringWithPrefix(localIntfIp, localIntfPrefix)\n                            subnetStr2 = Util.getSubnetStringWithPrefix(peerIntfIp, peerIntfPrefix)\n                        else:\n                            subnetStr1 = Util.getV6SubnetStringWithPrefix(localIntfIp, localIntfPrefix)\n                            subnetStr2 = Util.getV6SubnetStringWithPrefix(peerIntfIp, peerIntfPrefix)\n                        if subnetStr1 != subnetStr2:\n                            errorMsg = (\"SN1:SN2 %s:%s link %s:%s IPs %s:%s are not in same subnet %s:%s. \"\n                                        \"Please correct [%s] Interface [%s] IP [%s]/[%s] \"%\n                                        (localSerialNum, peerSerialNum, localIntfName, peerIntfName, \n                                         localIntfIp, peerIntfIp, subnetStr1, subnetStr2, \n                                         localSerialNum, localIntfName, localIntfIp, localIntfPrefix))\n                            respObj.addErrorReport((\"manageFabricIntf\"+localIntfName+\":\"+peerIntfName), errorMsg)\n                            respObj.setFailureRetCode()\n\n                    if respObj.isRetCodeFailure():\n                        return respObj\n\n                    prefix = localIntfPrefix if localIntfPrefix < peerIntfPrefix else peerIntfPrefix\n\n                    # generate the key to associate the subnet pool with\n                    linkKey = Util.exe(Helper.getKey(\"Link\", localSerialNum, localIntfName, peerSerialNum, peerIntfName))\n\n                    # set the subnet pool in RM\n                    Wrapper.print(\"RM OPER: FAB [%s]: SET:[manageFabricIntf] Key [%s]: Link SUBNET [%s]\" %\n                                  (FABRIC_NAME, linkKey, subnetStr1))\n                    #ignore, subnetPoolRmId = Util.exeRM(RM.set(FABRIC_NAME, PoolName.SUBNET, EntityType.LINK, linkKey, subnetStr1))\n\n                    # set the local interface IP in RM\n                    key = Util.exe(Helper.getKey(\"DeviceInterface\", localSerialNum, localIntfName))\n                    Wrapper.print(\"RM OPER: FAB [%s]: SET:[manageFabricIntf] Key [%s]: Link SUBNET [%s] IP [%s]\" %\n                                  (FABRIC_NAME, key, subnetStr1, localIntfIp))\n                    #ignore, localIpRmId = Util.exeRM(RM.set(FABRIC_NAME, subnetStr1, EntityType.INTERFACE, key, localIntfIp))\n\n                    # set the peer interface IP in RM\n                    key = Util.exe(Helper.getKey(\"DeviceInterface\", peerSerialNum, peerIntfName))\n                    Wrapper.print(\"RM OPER: FAB [%s]: SET:[manageFabricIntf] Key [%s]: Link SUBNET [%s] IP [%s]\" %\n                                  (FABRIC_NAME, key, subnetStr2, peerIntfIp))\n                    #ignore, peerIpRmId = Util.exeRM(RM.set(FABRIC_NAME, subnetStr2, EntityType.INTERFACE, key, peerIntfIp))\n\n                    #don't delete before responding about error\n                    PTIWrapper.delete(peerSerialNum, \"INTERFACE\", peerIntfName)\n\n                nvPairs = {\n                           \"FABRIC1\":FABRIC_NAME, \n                           \"FABRIC2\":FABRIC_NAME,\n                           \"MTU\": localNvPairs[\"MTU\"],\n                           \"SPEED\": localNvPairs[\"SPEED\"],\n                           \"ADMIN_STATE\": \"true\",\n                           \"OSPF_AREA_ID\":OSPF_AREA_ID,\n                           \"REPLICATION_MODE\":REPLICATION_MODE,\n                           \"GUI_EDIT\":\"\",\n                           \"EXTRA_CONF_INTRA_LINKS\" : EXTRA_CONF_INTRA_LINKS,\n                           \"LINK_STATE_ROUTING_TAG\" : LINK_STATE_ROUTING_TAG\n                          }\n                \n                linkUUID, ignore, entityName = getLinkInfo(localSerialNum, peerSerialNum, localIntfName, peerIntfName, linkNbrList)\n                peer1Sn = entityName.split(\"~\")[0]\n                peer2Sn = entityName.split(\"~\")[2]\n\n                localPTFabric = localNvPairs.get(\"PORTTYPE_FABRIC\", \"false\") \n                peerPTFabric = peerIntfNvPairs.get(\"PORTTYPE_FABRIC\", \"false\")\n                \n                nvPairs[\"FABRIC_VPC_QOS\"] = \"false\"\n                fabricSettings = Util.exe(FabricWrapper.get(FABRIC_NAME)).getNvPairs()\n                if fabricSettings.get(\"FABRIC_VPC_QOS\") == \"true\":\n                    qosPolicyName = fabricSettings.get(\"FABRIC_VPC_QOS_POLICY_NAME\", \"spine_qos_for_fabric_vpc_peering\")\n                    if qosPolicyName in localNvPairs[\"CONF\"]:  \n                        nvPairs[\"FABRIC_VPC_QOS\"] = \"true\"\n                        localNvPairs[\"CONF\"] = Util.newLine().join(line for line in localNvPairs[\"CONF\"].split(Util.newLine()) if qosPolicyName not in line)\n                    if qosPolicyName in peerIntfNvPairs[\"CONF\"]:\n                        nvPairs[\"FABRIC_VPC_QOS\"] = \"true\"\n                        peerIntfNvPairs[\"CONF\"] = Util.newLine().join(line for line in peerIntfNvPairs[\"CONF\"].split(Util.newLine()) if qosPolicyName not in line)\n\n                if peer1Sn == localSerialNum:\n                    nvPairs.update({\"HOSTNAME1\":localHostName, \"HOSTNAME2\":peerHostName,\n                                    \"PEER1_SN\":localSerialNum, \"PEER2_SN\":peerSerialNum, \n                                    \"PEER1_INTF\":localIntfName, \"PEER2_INTF\":peerIntfName,\n                                    \"PEER1_DESC\": localNvPairs[\"DESC\"], \"PEER2_DESC\":peerIntfNvPairs[\"DESC\"], \n                                    \"PEER1_CONF\":localNvPairs[\"CONF\"], \"PEER2_CONF\":peerIntfNvPairs[\"CONF\"],\n                                    \"PEER1_PORTTYPE_FABRIC\":localPTFabric, \"PEER2_PORTTYPE_FABRIC\":peerPTFabric})\n                else:\n                    nvPairs.update({\"HOSTNAME1\":peerHostName, \"HOSTNAME2\":localHostName,\n                                    \"PEER1_SN\":peerSerialNum, \"PEER2_SN\":localSerialNum,\n                                    \"PEER1_INTF\":peerIntfName, \"PEER2_INTF\":localIntfName,\n                                    \"PEER1_DESC\": peerIntfNvPairs[\"DESC\"], \"PEER2_DESC\":localNvPairs[\"DESC\"],\n                                    \"PEER1_CONF\":peerIntfNvPairs[\"CONF\"], \"PEER2_CONF\":localNvPairs[\"CONF\"],\n                                    \"PEER1_PORTTYPE_FABRIC\":peerPTFabric, \"PEER2_PORTTYPE_FABRIC\":localPTFabric})\n\n                ptiTemplateName = \"int_intra_fabric_unnum_link\" if FABRIC_INTERFACE_TYPE == \"unnumbered\" else \"int_intra_fabric_num_link\"\n                if UNDERLAY_IS_V6 == \"true\" and USE_LINK_LOCAL == \"true\":\n                    ptiTemplateName = \"int_intra_fabric_ipv6_link_local\"\n                if FABRIC_INTERFACE_TYPE == \"p2p\" and ptiTemplateName != \"int_intra_fabric_ipv6_link_local\":\n                    ptiTemplateName = \"int_intra_fabric_num_link\"\n                    localBfdEchoDisable = localNvPairs.get(\"BFD_ECHO_DISABLE\", \"false\")\n                    peerBfdEchoDisable = peerIntfNvPairs.get(\"BFD_ECHO_DISABLE\", \"false\")\n                    nvPairs[\"BFD_ENABLE\"] = BFD_ENABLE\n                    nvPairs[\"BFD_AUTH_KEY_ID\"] = BFD_AUTH_KEY_ID\n                    nvPairs[\"BFD_AUTH_KEY\"] = BFD_AUTH_KEY\n                    nvPairs.update({\"PEER1_IP\":\"\", \"PEER2_IP\":\"\", \"PREFIX\":prefix})\n                    nvPairs.update({\"PEER1_V6IP\":\"\", \"PEER2_V6IP\":\"\", \"V6PREFIX\":prefix})\n                    if peer1Sn == localSerialNum:\n                        if UNDERLAY_IS_V6 == \"false\":\n                            nvPairs.update({\"PEER1_IP\":localIntfIp, \"PEER2_IP\":peerIntfIp})\n                        else:\n                            nvPairs.update({\"PEER1_V6IP\":localIntfIp, \"PEER2_V6IP\":peerIntfIp})\n                        nvPairs[\"PEER1_BFD_ECHO_DISABLE\"] = localBfdEchoDisable\n                        nvPairs[\"PEER2_BFD_ECHO_DISABLE\"] = peerBfdEchoDisable\n                    else:\n                        if UNDERLAY_IS_V6 == \"false\":\n                            nvPairs.update({\"PEER1_IP\":peerIntfIp, \"PEER2_IP\":localIntfIp})\n                        else:\n                            nvPairs.update({\"PEER1_V6IP\":peerIntfIp, \"PEER2_V6IP\":localIntfIp})\n                        nvPairs[\"PEER1_BFD_ECHO_DISABLE\"] = peerBfdEchoDisable\n                        nvPairs[\"PEER2_BFD_ECHO_DISABLE\"] = localBfdEchoDisable\n                nvPairs[\"ENABLE_MACSEC\"] = \"false\"\n                nvPairs[\"ISIS_P2P_ENABLE\"] = ISIS_P2P_ENABLE\n\n                processInbandPOAPLinkFF(fabricSettings, nvPairs)\n\n                PTIWrapper.createOrUpdate(linkUUID, \"LINK\", entityName, \"\", 500, ptiTemplateName, nvPairs)\n                #createPTI(localSerialNum, localNvPairs, templateName, localIntfName, getSrc(templateName), -1)\n            else:\n                Wrapper.print(\"Peer Fabric intf [%s] PTI not found\" % peerIntfName)\n        else:\n            Wrapper.print(\"manageFabricIntf: Peer not found. Creating incomplete fabric interface [%s] policy\" % localIntfName)\n            localNvPairs[\"GUI_EDIT\"] = \"\"\n            localNvPairs[\"FABRIC_NAME\"] = FABRIC_NAME\n            localNvPairs[\"IP_RM_ID\"] = \"-1\"\n            localNvPairs[\"SUBNET_RM_ID\"] = \"-1\"\n            createPTI(localSerialNum, localNvPairs, templateName, localIntfName, \"LINK\", -1)\n        Wrapper.print(\"==========manageFabricIntf done==========\")\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef removeInbandPOAPDhcpConfigs(isUnnum, freeform):\n    ffLines = freeform.split(Util.newLine())\n    newFF = []\n    for line in ffLines:\n        stripLine = line.strip()\n        if stripLine == \"ip proxy-arp\":\n            if not isUnnum:\n                newFF.append(line)\n        elif stripLine.startswith(\"ip dhcp relay address \"):\n            continue\n        elif stripLine.startswith(\"ip dhcp relay source-interface \"):\n            continue\n        else:\n            newFF.append(line)\n\n    return Util.newLine().join(newFF)\n\ndef isInbandPoapEnabled(dictObj):\n    inbandMgmt = dictObj.get(\"INBAND_MGMT\", \"false\")\n    bootstrapPOAPEnable = dictObj.get(\"BOOTSTRAP_ENABLE\", \"false\")\n    return (\"true\" if (inbandMgmt == \"true\" and bootstrapPOAPEnable == \"true\") else \"false\")\n\ndef processInbandPOAPLinkFF(fabricSettings, nvPairs):\n    if isInbandPoapEnabled(fabricSettings) != \"true\":\n        # no changes\n        return\n\n    # additional processing for Inband POAP cases\n    #   - remove the DHCP relay related configs. The correct ones will get added from the regular configSave\n    isUnnum = True if fabricSettings.get(\"FABRIC_INTERFACE_TYPE\", \"unnumbered\") == \"unnumbered\" else False\n    if len(nvPairs[\"PEER1_CONF\"]):\n        nvPairs[\"PEER1_CONF\"] = removeInbandPOAPDhcpConfigs(isUnnum, nvPairs[\"PEER1_CONF\"])\n    if len(nvPairs[\"PEER2_CONF\"]):\n        nvPairs[\"PEER2_CONF\"] = removeInbandPOAPDhcpConfigs(isUnnum, nvPairs[\"PEER2_CONF\"])\n\ndef getMigrationFileNames(dictObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    devSerial = dictObj[\"deviceSerial\"]\n    switchBaseDir = getSwitchBaseDir(devSerial, FABRIC_NAME, Util.getBrownfieldDir())\n\n    # get the cuurent file index to use\n    importMetadataFileName = switchBaseDir + IMPORT_METADATA_FILENAME\n    importMetaData = Util.exe(getJSONFileContents(importMetadataFileName))\n    fileIndexToUse = importMetaData[\"cfgfile_ext_index\"]\n    Wrapper.print(\"%s: [%s] importMetaData fileIndexToUse [%d]\" % (funcName, devSerial, fileIndexToUse))\n\n    dictObj[\"matchResultsFileName\"] = getFilenameWithIndex(switchBaseDir, MATCH_RESULT_FILENAME, fileIndexToUse)\n    dictObj[\"interfaceMatchResultsFileName\"] = getFilenameWithIndex(switchBaseDir, INTF_MATCH_RESULT_FILENAME, fileIndexToUse)\n    dictObj[\"overlayInfoFileName\"] = getFilenameWithIndex(switchBaseDir, OVERLAY_INFO_FILENAME, fileIndexToUse)\n    Wrapper.print(\"%s: [%s] matchResultsFileName [%s] interfaceMatchResultsFileName [%s] overlayInfoFileName[%s]\" % (funcName,\n        devSerial, dictObj[\"matchResultsFileName\"], dictObj[\"interfaceMatchResultsFileName\"], dictObj[\"overlayInfoFileName\"]))\n\ndef getSwitchMatchResults(sn):\n    funcName = sys._getframe(0).f_code.co_name\n    switchBaseDir = getSwitchBaseDir(sn, FABRIC_NAME, Util.getBrownfieldDir())\n\n    # get the cuurent file index to use\n    importMetadataFileName = switchBaseDir + IMPORT_METADATA_FILENAME\n    importMetaData = Util.exe(getJSONFileContents(importMetadataFileName))\n    fileIndexToUse = importMetaData[\"cfgfile_ext_index\"]\n\n    matchResultsFileName = getFilenameWithIndex(switchBaseDir, MATCH_RESULT_FILENAME, fileIndexToUse)\n    interfaceMatchResultsFileName = getFilenameWithIndex(switchBaseDir, INTF_MATCH_RESULT_FILENAME, fileIndexToUse)\n\n    Wrapper.print(\"%s: [%s] fileIndexToUse [%d] matchResultsFileName [%s] interfaceMatchResultsFileName [%s]\" % (funcName,\n        sn, fileIndexToUse, matchResultsFileName, interfaceMatchResultsFileName))\n\n    Wrapper.print(\"%s: [%s] Retrieving match results\" % (funcName, sn))\n    matchResult = Util.exe(getJSONFileContents(matchResultsFileName))\n    interfacesRes = Util.exe(getJSONFileContents(interfaceMatchResultsFileName))\n\n    return (matchResult, interfacesRes)\n\ndef unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult):\n    unaccountedConfigList = []\n    templateNameMatches = intfMatchResult[\"matched_templates\"]\n    #Wrapper.print(\"unaccCfgFromTemplates: interface [%s] with template list %s\"%(intfName, \",\".join(templateList)))\n    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateList)\n    for templateName in matchingNvPairs:\n        if (\"interface_vrf\" == templateName):\n            param = matchingNvPairs[templateName].get(\"INTF_VRF\")\n            if param:\n                unaccountedConfigList.append(\"%svrf member %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"interface_mtu\" == templateName):\n            param = matchingNvPairs[templateName].get(\"MTU\")\n            if param:\n                unaccountedConfigList.append(\"%smtu %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"port_channel_mode\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"PCID\")\n            param2 = matchingNvPairs[templateName].get(\"PC_MODE\")\n            if param1 and param2:\n                unaccountedConfigList.append(\"%schannel-group %s force mode %s\"%(INTF_FIRST_LVL_SPACING, param1,param2))\n        elif (\"port_channel_mode_on\" == templateName):\n            param = matchingNvPairs[templateName].get(\"PCID\")\n            if param:\n                unaccountedConfigList.append(\"%schannel-group %s force\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"cdp_disable_interface_11_1\" == templateName):\n            unaccountedConfigList.append(\"%sno cdp enable\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"access_vlan\" == templateName):\n            param = matchingNvPairs[templateName].get(\"ACCESS_VLAN\")\n            if param and param != \"1\":\n                unaccountedConfigList.append(\"%sswitchport access vlan %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"native_vlan\" == templateName):\n            param = matchingNvPairs[templateName].get(\"NATIVE_VLAN\")\n            if param and param != \"1\":\n                unaccountedConfigList.append(\"%sswitchport trunk native vlan %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"bfd_no_echo_interface\" == templateName):\n            unaccountedConfigList.append(\"%sno bfd echo\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"bpduguard_disable\" == templateName):\n            unaccountedConfigList.append(\"%sspanning-tree bpduguard disable\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"bpduguard_enable\" == templateName):\n            unaccountedConfigList.append(\"%sspanning-tree bpduguard enable\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"interface_speed\" == templateName):\n            swSpeed = matchingNvPairs[templateName].get(\"SPEED\")\n            if swSpeed and swSpeed != \"auto\":\n                #param = Util.mapSwitchSpeedToEnum(swSpeed)\n                unaccountedConfigList.append(\"%sspeed %s\"%(INTF_FIRST_LVL_SPACING, swSpeed))\n        elif (\"interface_no_nego_auto\" == templateName):\n            unaccountedConfigList.append(\"%sno negotiate auto\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"isis_interface\" == templateName):\n            param = matchingNvPairs[templateName].get(\"ISIS_TAG\")\n            if param:\n                unaccountedConfigList.append(\"%sip router isis %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"v6_isis_interface\" == templateName):\n            param = matchingNvPairs[templateName].get(\"ISIS_TAG\")\n            if param:\n                unaccountedConfigList.append(\"%sipv6 router isis %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"ospf_interface_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"OSPF_TAG\")\n            param2 = matchingNvPairs[templateName].get(\"OSPF_AREA_ID\")\n            if param1 and param2:\n                unaccountedConfigList.append(\"%sip router ospf %s area %s\"%(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"v6_ospf_interface\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"OSPF_TAG\")\n            param2 = matchingNvPairs[templateName].get(\"OSPF_AREA_ID\")\n            if param1 and param2:\n                unaccountedConfigList.append(\"%sipv6 router ospfv3 %s area %s\"%(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"ospf_p2p_interface\" == templateName):\n            unaccountedConfigList.append(\"%sip ospf network point-to-point\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"isis_p2p_interface\" == templateName):\n            unaccountedConfigList.append(\"%sisis network point-to-point\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"pim_interface\" == templateName):\n            unaccountedConfigList.append(\"%sip pim sparse-mode\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"porttype_fast_enable\" == templateName):\n            unaccountedConfigList.append(\"%sspanning-tree port type edge\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"porttype_fast_trunk\" == templateName):\n            unaccountedConfigList.append(\"%sspanning-tree port type edge trunk\" % (INTF_FIRST_LVL_SPACING))\n        elif (\"interface_ipv4_tag_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"IP\")\n            param2 = matchingNvPairs[templateName].get(\"PREFIX\")\n            param3 = matchingNvPairs[templateName].get(\"TAG\")\n            unaccountedConfigList.append(\"%sip address %s/%s tag %s\"%(INTF_FIRST_LVL_SPACING, param1, param2, param3))\n        elif (\"interface_ipv4_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"IP\")\n            param2 = matchingNvPairs[templateName].get(\"PREFIX\")\n            unaccountedConfigList.append(\"%sip address %s/%s\"%(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"interface_ipv6_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"IP\")\n            param2 = matchingNvPairs[templateName].get(\"PREFIX\")\n            unaccountedConfigList.append(\"%sipv6 address %s/%s\"%(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"interface_ipv6_tag_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"IP\")\n            param2 = matchingNvPairs[templateName].get(\"PREFIX\")\n            param3 = matchingNvPairs[templateName].get(\"TAG\")\n            unaccountedConfigList.append(\"%sipv6 address %s/%s tag %s\"%(INTF_FIRST_LVL_SPACING, param1, param2, param3))\n        elif (\"vlan_interface_fwd_mode_11_1\" == templateName):\n            param = matchingNvPairs[templateName].get(\"MODE\")\n            unaccountedConfigList.append(\"%sfabric forwarding mode %s\"%(INTF_FIRST_LVL_SPACING, param))\n        elif (\"ospf_interface_auth\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"OSPF_AUTH_KEY_ID\")\n            param2 = matchingNvPairs[templateName].get(\"OSPF_AUTH_KEY\")\n            unaccountedConfigList.append(\"%sip ospf message-digest-key %s md5 3 %s\" %(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"pim_interface_hello_auth\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"AUTH_KEY\")\n            unaccountedConfigList.append(\"%sip pim hello-authentication ah-md5 3 %s\" %(INTF_FIRST_LVL_SPACING, param1))\n        elif (\"isis_interface_auth\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"IS_TYPE\")\n            param2 = matchingNvPairs[templateName].get(\"ISIS_AUTH_KEYCHAIN_NAME\")\n            unaccountedConfigList.append(\"%sisis authentication-type md5 %s\" %(INTF_FIRST_LVL_SPACING, param1))\n            unaccountedConfigList.append(\"%sisis authentication key-chain %s %s\" %(INTF_FIRST_LVL_SPACING, param2, param1))\n        elif (\"isis_interface_auth_no_lvl\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"ISIS_AUTH_KEYCHAIN_NAME\")\n            unaccountedConfigList.append(\"%sisis authentication-type md5\" %(INTF_FIRST_LVL_SPACING))\n            unaccountedConfigList.append(\"%sisis authentication key-chain %s\" %(INTF_FIRST_LVL_SPACING, param1))\n        elif (\"routed_interface_no_ip_redirects\" == templateName):\n            unaccountedConfigList.append(\"%sno ip redirects%s%sno ipv6 redirects\" %\n                (INTF_FIRST_LVL_SPACING, Util.newLine(), INTF_FIRST_LVL_SPACING))\n        elif (\"bfd_interface_auth\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"BFD_AUTH_KEY_ID\")\n            param2 = matchingNvPairs[templateName].get(\"BFD_AUTH_KEY\")\n            unaccountedConfigList.append(\"%sbfd authentication Keyed-SHA1 key-id %s hex-key %s\" %(INTF_FIRST_LVL_SPACING, param1, param2))\n        elif (\"port_channel_vpc_id_11_1\" == templateName):\n            param1 = matchingNvPairs[templateName].get(\"VPC_ID\")\n            unaccountedConfigList.append(\"%svpc %s\" %(INTF_FIRST_LVL_SPACING, param1))\n\n    #Wrapper.print(\"unaccCfgFromTemplates: interface [%s] with unaccounted commands [%s]\"%(intfName, \",\".join(unaccountedConfigList)))\n    return unaccountedConfigList\n\ndef getPoMemberIntfNvpairs(sn, intfName, isTrunk, poPCId, matchResult, interfacesRes, getPTINvpairs):\n    funcName = sys._getframe(0).f_code.co_name\n    #Wrapper.print(\"%s: SN [%s], PO [%s] intfName [%s] getPTINvpairs [%r]\"% (funcName, sn, poPCId, intfName, getPTINvpairs))\n\n    entityName = intfName\n    nvPairs = None\n    update = False\n\n    if getPTINvpairs:\n        ptiList = Util.exe(PTI.getPTIs(sn, \"INTERFACE\", entityName, \"PYTHON\"))\n        #only one PTI so access it\n        if ptiList:\n            nvPairs = copy.deepcopy(ptiList[0].getNvPairs())\n        else:\n            Wrapper.print(\"Something wrong with intfName [%s] of [%s]\"%(intfName, poPCId))\n            return\n    else:\n        nvPairs = {}\n    Wrapper.print(\"%s: SN [%s], PO [%s] intfName [%s] nvPairs [%r]\"% (funcName, sn, poPCId, intfName, nvPairs))\n\n    intfMatchResult = interfacesRes[intfName]\n    templateNameMatches = intfMatchResult[\"matched_templates\"]\n    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n    for templateName in matchingNvPairs:\n        if (templateName == \"shut_interface\"):\n            currVal = nvPairs.get(\"ADMIN_STATE\", \"true\")\n            newVal = \"false\"\n            if currVal != newVal:\n                nvPairs[\"ADMIN_STATE\"] = newVal\n                update = True\n        elif (templateName == \"interface_desc\"):\n            currVal = nvPairs.get(\"DESC\", \"\")\n            newVal = matchingNvPairs[templateName][\"DESC\"]\n            if currVal != newVal:\n                nvPairs[\"DESC\"] = newVal\n                update = True\n\n    poMemberFF = intfMatchResult[\"unaccounted_cmds\"]\n\n    templateList = [\n                \"porttype_fast_trunk\",\n                \"vlan_interface_fwd_mode_11_1\",\n                \"interface_ipv4_tag_11_1\",\n                \"interface_ipv6_11_1\",\n                \"interface_ipv6_tag_11_1\",\n                \"bpduguard_disable\",\n                \"bpduguard_enable\",\n                \"cdp_disable_interface_11_1\"\n                ]\n    if isTrunk:\n        templateList.append(\"access_vlan\")\n        if not Util.isFexHIF(intfName):\n            templateList.append(\"porttype_fast_enable\")\n\n    combinedFF = poMemberFF + unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n\n    # get the final FF\n    if combinedFF:\n        isUpdated, newFF = getPoMemberFF(combinedFF, intfName)\n        #Wrapper.print(\"%s: PO [%s] Member Intf [%s]. isUpdated [%r] Original FF %s Filtered FF %s\" % (funcName,\n        #    poPCId, intfName, isUpdated, combinedFF, newFF))\n        if newFF:\n            currVal = nvPairs.get(\"CONF\", \"\")\n            newVal = Util.newLine().join(newFF)\n            if currVal != newVal:\n                nvPairs[\"CONF\"] = newVal\n                update = True\n\n    Wrapper.print(\"%s: SN [%s] PO [%s] intfName [%s] update [%r] nvPairs [%s]\"% (funcName, sn, poPCId, intfName, update, nvPairs))\n    return update, nvPairs\n\ndef poMemberDescAndFFUpd(sn, memberIntfList, ptiTemplate, poPCId, matchResult, interfacesRes, source):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: SN [%s], PO [%s] Member interfaces [%s]\"% (funcName, sn, poPCId, \",\".join(memberIntfList)))\n    for intfName in memberIntfList:\n        Wrapper.print(\"%s: Sn [%s] processing [%s] of [%s] for template [%s] and source [%s]\"%\n                      (funcName, sn, intfName, poPCId, ptiTemplate, source))\n\n        update, poMemberNvPairs = getPoMemberIntfNvpairs(sn, intfName, True if \"trunk\" in ptiTemplate else False, poPCId,\n            matchResult, interfacesRes, True)\n        if update:\n            createPTI(sn, poMemberNvPairs, ptiTemplate, intfName, source, -1)\n    Wrapper.print(\"%s: SN [%s] Exiting with intfName interfaces [%s]\"% (funcName, sn, \",\".join(memberIntfList)))\n\ndef getPoPeerDeviceSN(topologyDataObj, devSerial, intfName):\n    switchName = topologyDataObj.getHostName(devSerial)\n    Wrapper.print(\"getPoPeerDeviceSN: Input: [%s(%s)/%s]\" % (devSerial, switchName, intfName))\n    peerSerial = \"\"\n    peerName = \"\"\n    peerIntf = topologyDataObj.getNeighborIntf(devSerial, intfName)\n    if (peerIntf != \"\"):\n        peerSerial = topologyDataObj.getNeighborDeviceSN(devSerial, intfName)\n        Wrapper.print(\"getPoPeerDeviceSN: [%s/%s] peer -> [%s/%s]\" % (devSerial, intfName, peerSerial, peerIntf))\n        if (peerSerial != \"\"):\n            # we have a valid peer... check if it's migration state\n            if not isSwitchInUnderlayMigration(peerSerial):\n                # the expected PTIs should be in place\n                peerName = topologyDataObj.getHostName(peerSerial)\n                Wrapper.print(\"getPoPeerDeviceSN: peer serial [%s] is MIGRATED\" % peerSerial)\n            else:\n                peerIntf = \"\"\n                peerSerial = \"\"\n    Wrapper.print(\"getPoPeerDeviceSN: Returning [%s(%s)/%s]\" % (peerSerial, peerName, peerIntf))\n    return peerIntf, peerSerial\n\ndef getFabricIntfNvPairs(fabricName, devSerial, intfName, matchingNvPairs, \n                         LINK_STATE_ROUTING, REPLICATION_MODE, \n                         intfMatchResult, matchResult, vpcPKALink):\n    unnumberedIntf = False\n    Wrapper.print(\"getFabricIntfNvPairs: [%s/%s/%s]\" % (fabricName, devSerial, intfName))\n    nvPairs = {\"INTF_NAME\" : intfName,\n               \"IP\" : \"\",\n               \"PREFIX\" : \"\",\n               \"V6IP\" : \"\",\n               \"V6PREFIX\" : \"\",\n               \"LINK_STATE_ROUTING\":LINK_STATE_ROUTING,\n               \"OSPF_AREA_ID\" : OSPF_AREA_ID,\n               \"REPLICATION_MODE\":REPLICATION_MODE,\n               \"MTU\":\"\",\n               \"SPEED\":\"Auto\",\n               \"DESC\" : \"\",\n               \"ADMIN_STATE\" : \"true\",\n               \"PORTTYPE_FABRIC\" : \"false\",\n               \"CLASS_MAP\": \"\",\n               \"CONF\" : \"\"\n              }\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n            nvPairs[\"MTU\"] = matchingNvPairs[templateName][\"MTU\"]\n        elif (\"interface_speed\" == templateName):\n            nvPairs[\"SPEED\"] = Util.mapSwitchSpeedToEnum(matchingNvPairs[templateName][\"SPEED\"])\n        elif ((\"p2p_routed_interface\" == templateName) or (\"p2p_routed_interface_tag\" == templateName)):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n        elif (\"interface_ipv6_11_1\" == templateName):\n            nvPairs[\"V6IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"V6PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n        elif (\"ospf_interface_11_1\" == templateName or \"v6_ospf_interface\" == templateName):\n            nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"OSPF_TAG\"]})\n            nvPairs.update({\"OSPF_AREA_ID\" : matchingNvPairs[templateName][\"OSPF_AREA_ID\"]})\n        elif (\"isis_interface\" == templateName or \"v6_isis_interface\" == templateName):\n            nvPairs.update({\"LINK_STATE_ROUTING_TAG\" : matchingNvPairs[templateName][\"ISIS_TAG\"]})\n        elif (\"shut_interface\" == templateName):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (templateName == \"interface_desc\"):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"unnumbered_fabric_interface\" == templateName or \"unnumbered_fabric_interface_nov6\" == templateName):\n            unnumberedIntf = True\n            nvPairs.update({\"LOOPBACK_NAME\" : matchingNvPairs[templateName][\"LOOPBACK_NAME\"]})\n        elif (\"interface_vrf\" == templateName and vpcPKALink):\n            nvPairs[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n        elif (\"ospf_interface_auth\" == templateName):\n            nvPairs[\"OSPF_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY_ID\"]\n            nvPairs[\"OSPF_AUTH_KEY\"] = matchingNvPairs[templateName][\"OSPF_AUTH_KEY\"]\n        elif (\"pim_interface_hello_auth\" == templateName):\n            nvPairs[\"PIM_HELLO_AUTH_KEY\"] = matchingNvPairs[templateName][\"AUTH_KEY\"]\n        elif (\"isis_interface_auth\" == templateName):\n            nvPairs[\"ISIS_AUTH_KEYCHAIN_NAME\"] = matchingNvPairs[templateName][\"ISIS_AUTH_KEYCHAIN_NAME\"]\n            nvPairs[\"IS_TYPE\"] = matchingNvPairs[templateName][\"IS_TYPE\"]\n        elif (\"isis_interface_auth_no_lvl\" == templateName):\n            nvPairs[\"ISIS_AUTH_KEYCHAIN_NAME\"] = matchingNvPairs[templateName][\"ISIS_AUTH_KEYCHAIN_NAME\"]\n            nvPairs[\"IS_TYPE\"] = ISIS_LEVEL\n        elif (\"bfd_no_echo_interface\" == templateName):\n            nvPairs[\"BFD_ECHO_DISABLE\"] = \"true\"\n        elif (\"interface_port_type_fabric\" == templateName):\n            nvPairs[\"PORTTYPE_FABRIC\"] = \"true\"\n        elif (\"bfd_interface_auth\" == templateName):\n            nvPairs[\"BFD_AUTH_KEY_ID\"] = matchingNvPairs[templateName][\"BFD_AUTH_KEY_ID\"]\n            nvPairs[\"BFD_AUTH_KEY\"] = matchingNvPairs[templateName][\"BFD_AUTH_KEY\"]\n\n    if \"BFD_AUTH_KEY\" not in nvPairs:\n        nvPairs[\"BFD_AUTH_KEY\"] = BFD_AUTH_KEY\n        nvPairs[\"BFD_AUTH_KEY_ID\"] = BFD_AUTH_KEY_ID\n    if \"OSPF_AUTH_KEY\" not in nvPairs:\n        nvPairs[\"OSPF_AUTH_KEY\"] = OSPF_AUTH_KEY\n        nvPairs[\"OSPF_AUTH_KEY_ID\"] = OSPF_AUTH_KEY_ID\n    if \"ISIS_AUTH_KEYCHAIN_NAME\" not in nvPairs:\n        nvPairs[\"ISIS_AUTH_KEYCHAIN_NAME\"] = ISIS_AUTH_KEYCHAIN_NAME\n        nvPairs[\"IS_TYPE\"] = ISIS_LEVEL\n\n    if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n        Wrapper.print(\"Device [%s]: Found unaccounted cfg for numbered intf [%s]\" % (devSerial, intfName))\n        nvPairs.update({\"CONF\": Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"])})\n\n    templateList = [\n                    \"access_vlan\", \n                    \"bpduguard_disable\", \n                    \"bpduguard_enable\", \n                    \"interface_no_nego_auto\",\n                    \"porttype_fast_enable\",\n                    \"porttype_fast_trunk\",\n                    \"vlan_interface_fwd_mode_11_1\",\n                    \"interface_ipv4_tag_11_1\",\n                    \"interface_ipv6_tag_11_1\",\n                    \"cdp_disable_interface_11_1\"\n                    ]\n    if unnumberedIntf:\n        templateList.append(\"ospf_p2p_interface\")\n    if not vpcPKALink:\n        templateList.append(\"interface_vrf\")\n    if not vpcPKALink:\n        if UNDERLAY_IS_V6 == \"false\":\n            # Underlay is V4, treat ipv6 address config as unaccounted\n            templateList.append(\"interface_ipv6_11_1\")\n        else:\n            # Underlay is V6, treat ip address config as unaccounted\n            templateList.append(\"interface_ipv4_11_1\")\n\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    if nvPairs[\"CONF\"] and configList:\n        nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n    elif configList:\n        nvPairs[\"CONF\"] = Util.newLine().join(configList)\n    Wrapper.print(\"getFabricIntfNvPairs: nvPairs [%s]\" % str(nvPairs))\n    return nvPairs\n\ndef setDot1qRMResource(fabricName, devSerial, intfName, dot1qID):\n    normalizedIntfName = intfName.capitalize() if intfName.lower().startswith(\"port-channel\") else intfName\n    key = Util.exe(Helper.getKey(\"Device\", devSerial))\n    ignore, rmId = Util.exeRM(RM.set(fabricName, \"TOP_DOWN_L3_DOT1Q\", key, normalizedIntfName, normalizedIntfName, dot1qID))\n    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: TOP_DOWN_L3_DOT1Q for [%s(%s)], dot1q [%s]: rmId [%s]\"%\n                  (fabricName, key, normalizedIntfName, intfName, dot1qID, rmId))\n    return rmId\n\ndef createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, fabricName, rmId = -1):\n    devSerial = switchInfo[\"deviceSerial\"]\n    dot1qID, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n    if dot1qID:\n        rmId = setDot1qRMResource(fabricName, devSerial, intfName, dot1qID)\n\n    # the \"catch all\" interface template\n    templateName = \"int_freeform\"\n    createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), rmId)\n\ndef get_user_allowed_vlan(intfName, allowed_vlan_orig, device_overlay_vlans):\n    if allowed_vlan_orig == \"none\":\n        return \"none\"\n\n    if allowed_vlan_orig == \"all\" or allowed_vlan_orig == \"1-4094\":\n        Wrapper.print(\"get_user_allowed_vlan %s: allowed vlan (all) %s\" % (intfName, allowed_vlan_orig))\n        return allowed_vlan_orig\n\n    top_down_vlan_list = []\n    allowed_vlan_str = allowed_vlan_orig\n\n    try:\n        interface_name = intfName.capitalize()\n        top_down_vlans = device_overlay_vlans[interface_name].getVlanList()\n        Wrapper.print(\"%s top_down_vlans %s\" % (interface_name, top_down_vlans))\n        for vlan in top_down_vlans:\n            top_down_vlan_list.append(vlan)\n        utilObj = Util()\n        allowed_vlan_orig_list = utilObj.getIntegerRange(allowed_vlan_orig)\n        allowed_vlans = set(allowed_vlan_orig_list) - set(top_down_vlan_list)\n        if not allowed_vlans:\n            Wrapper.print(\"get_user_allowed_vlan %s all topdown vlans: allowed_vlan_orig %s, top_down_vlan_list %s\" % (intfName, allowed_vlan_orig, top_down_vlan_list))\n            return \"none\"\n\n        allowed_vlan_str = utilObj.vlanStrFromList(allowed_vlans)\n    except Exception as e:\n        Wrapper.print(\"get_user_allowed_vlan exception %s on access device_overlay_vlans[%s]\" % (e, interface_name))\n\n    Wrapper.print(\"get_user_allowed_vlan %s, allowed_vlan_orig %s - top_down_vlan_list %s => allowed_vlan_str %s\" % (intfName, allowed_vlan_orig, top_down_vlan_list, allowed_vlan_str))\n    return allowed_vlan_str\n\ndef is_top_down_vlan(intfName, vlan_str, device_overlay_vlans):\n    try:\n        interface_name = intfName.capitalize()\n        top_down_vlans = device_overlay_vlans[interface_name].getVlanList()\n        Wrapper.print(\"%s config vlan %s top_down_vlans %s\" % (interface_name, vlan_str, top_down_vlans))\n        top_down_vlan_list = []\n        for vlan in top_down_vlans:\n            top_down_vlan_list.append(vlan)\n        if int(vlan_str) in top_down_vlan_list:\n            return True\n    except Exception as e:\n        Wrapper.print(\"is_vlan_top_down exception %s on access device_overlay_vlans[%s]\" % (e, interface_name))\n\n    return False\n\n# returns the access vlan if not an overlay vlan, else return \"\"\ndef processAccessIntfOverlayInfo(devSerial, migrationMode, intfName, accessVlanStr, globalOverlayInfo, device_overlay_vlans):\n    funcName = sys._getframe(0).f_code.co_name\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    reSyncAttachEntries = None\n    Wrapper.print(\"%s: Switch [%s] Mode [%s]. Intf [%s] Skip [%s] accessVlanStr = [%s] overlayVlans = [%s]\" % (funcName, devSerial,\n       migrationMode, intfName, BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS, accessVlanStr,\n       switchOverlayInfo[\"OVERLAY_VLANS\"] if switchOverlayInfo else \"N/A\"))\n    \n    if (accessVlanStr == \"1\"):\n        # default access vlan is 1 which is not an overlay vlan\n        return accessVlanStr;\n\n    if migrationMode == \"upgrade\":\n        # upgrade case\n        return \"\" if is_top_down_vlan(intfName, accessVlanStr, device_overlay_vlans) else accessVlanStr\n    else:\n        # reSync or brownAdd case\n        if ((BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS == \"true\") or (len(switchOverlayInfo[\"NETWORKS_VLAN2VNI\"]) == 0)):\n            # no overlays to process.. return the str as-is\n            return accessVlanStr\n        \n        if migrationMode == \"reSync\":\n            reSyncAttachEntries = globalOverlayInfo[\"HOST_PORT_RESYNC\"][\"networks\"][\"attachEntries\"]\n\n    vlanId = int(accessVlanStr)\n    #Wrapper.print(\"%s [%s]: Vlan [%d] Overlay Vlans [%s]\" % (funcName, intfName, vlanId, switchOverlayInfo[\"OVERLAY_VLANS\"]))\n\n    # get the network entry for this vlan\n    vniStr = switchOverlayInfo[\"NETWORKS_VLAN2VNI\"].get(vlanId, None)\n    if vniStr:\n        adjIntfname = intfName\n        if intfName.lower().startswith(\"port-channel\"):\n            # Topdown code expects the PO name to be capitalized\n            adjIntfname = intfName.capitalize()\n\n        if migrationMode == \"brownAdd\":\n            portList = switchOverlayInfo[\"NETWORKS_BY_ID\"][vniStr][\"attachInfo\"]\n        else:\n            # host port resync case\n            portList = reSyncAttachEntries[vniStr][devSerial][\"portList\"]\n\n        # add the interface to the list\n        #Wrapper.print(\"%s: Switch [%s] Adding intf [%s] to Network [VNI:%s VLAN:%d]\" % (funcName,\n        #                                    devSerial, adjIntfname, vniStr, vlanId))\n        portList.append(adjIntfname)\n        returnStr = \"\"\n    else:\n        returnStr = accessVlanStr\n\n    return returnStr\n\n# returns the trunk allowed vlan string excluding the overlay vlans\ndef processTrunkIntfOverlayInfo(devSerial, migrationMode, intfName, allowed_vlans, globalOverlayInfo, device_overlay_vlans):\n    funcName = sys._getframe(0).f_code.co_name\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n    isServiceLeaf = switchOverlayInfo[\"isServiceLeaf\"]\n\n    reSyncAttachEntries = None\n    Wrapper.print(\"%s: Switch [%s] Mode [%s]. Intf [%s] Skip [%s] allowed_vlans = [%s] overlayVlans = [%s]\" % (funcName, devSerial,\n       migrationMode, intfName, BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS, allowed_vlans,\n       switchOverlayInfo[\"OVERLAY_VLANS\"] if switchOverlayInfo else \"N/A\"))\n    \n    if migrationMode == \"upgrade\":\n        # upgrade case\n        return get_user_allowed_vlan(intfName, allowed_vlans, device_overlay_vlans)\n    else:\n        # reSync or brownAdd case\n        if ((BROWNFIELD_SKIP_OVERLAY_NETWORK_ATTACHMENTS == \"true\") or (len(switchOverlayInfo[\"NETWORKS_VLAN2VNI\"]) == 0)):\n            # no overlays to process.. return the str as-is\n            return allowed_vlans\n        \n        if migrationMode == \"reSync\":\n            reSyncAttachEntries = globalOverlayInfo[\"HOST_PORT_RESYNC\"][\"networks\"][\"attachEntries\"]\n\n    if allowed_vlans in [\"none\", \"all\", \"1-4094\"]:\n        return allowed_vlans\n\n    utilObj = Util()\n    vlanList = utilObj.getIntegerRange(allowed_vlans)\n    #vlansToCheck = list(set(vlanList) & set(switchOverlayInfo[\"OVERLAY_VLANS\"])) \n    localVlans = []\n    for vlanId in vlanList:\n        vniStr = switchOverlayInfo[\"NETWORKS_VLAN2VNI\"].get(vlanId, None)\n        if vniStr:\n            portList = None\n            adjIntfname = intfName\n            if intfName.lower().startswith(\"port-channel\"):\n                # Topdown code expects the PO name to be capitalized\n                adjIntfname = intfName.capitalize()\n\n            if migrationMode == \"brownAdd\":\n                isServiceVlan = False\n                if isServiceLeaf:\n                    # check if the vlan maps to a service vlans... if yes.. do not add the post list\n                    # instead update the attached sw port\n                    if vniStr in servicesInfo[\"serviceSwMaps\"][devSerial][\"vnis\"]:\n                        isServiceVlan = True\n                        for serviceNodeName in servicesInfo[\"serviceSwMaps\"][devSerial][\"nodes\"]:\n                            srvcEntry = servicesInfo[\"serviceNodes\"][serviceNodeName]\n                            if \"swIntf\" in srvcEntry:\n                                continue\n\n                            # check each route peer entry for the matching vni\n                            for routePeerName in srvcEntry[\"routePeers\"]:\n                                rpEntry = srvcEntry[\"routePeers\"][routePeerName]\n                                for netType in rpEntry[\"nets\"]:\n                                    rpNetEntry = rpEntry[\"nets\"][netType]\n                                    if \"vni\" in rpNetEntry and rpNetEntry[\"vni\"] == vniStr:\n                                        Wrapper.print(\"%s: Service Switch [%s] Adding intf [%s] to Network [VNI:%s VLAN:%d]\" % (funcName,\n                                                                            devSerial, adjIntfname, vniStr, vlanId))\n                                        srvcEntry[\"swIntf\"] = intfName\n                if not isServiceVlan:\n                    portList = switchOverlayInfo[\"NETWORKS_BY_ID\"][vniStr][\"attachInfo\"]\n            else:\n                # host port resync case\n                #Wrapper.print(\"%s: Switch [%s] vniStr [%s]\" % (funcName, devSerial, vniStr))\n                portList = reSyncAttachEntries[vniStr][devSerial][\"portList\"]\n\n            if portList != None:\n                # add the interface to the list\n                Wrapper.print(\"%s: Switch [%s] Adding intf [%s] to Network [VNI:%s VLAN:%d]\" % (funcName,\n                                                    devSerial, adjIntfname, vniStr, vlanId))\n                portList.append(adjIntfname)\n        else:\n            # non overlay vlan\n            localVlans.append(vlanId)\n\n    if len(localVlans) > 0:\n        allowed_vlan_str = utilObj.vlanStrFromList(localVlans)\n    else:\n        allowed_vlan_str = \"none\"\n    #Wrapper.print(\"%s: Switch [%s] Intf [%s] Final allowed vlans [%s]\" % (funcName, devSerial, intfName, allowed_vlan_str))\n    return allowed_vlan_str\n\ndef isOverlaySvi(vlanId, switchOverlayInfo):\n    retVal = False\n    if vlanId in switchOverlayInfo[\"OVERLAY_VLANS\"]:\n        # check the network entry to make sure it is not a Layer2Only\n        #Wrapper.print(\"isOverlaySvi: vlan [%d]\" % (vlanId))\n        if vlanId in switchOverlayInfo[\"NETWORKS_VLAN2VNI\"]:\n            vniStr = switchOverlayInfo[\"NETWORKS_VLAN2VNI\"][vlanId]\n            if vniStr in switchOverlayInfo[\"NETWORKS_BY_ID\"]:\n                #Wrapper.print(\"isOverlaySvi: vni = [%s] vlan [%d]\" % (vniStr, vlanId))\n                if switchOverlayInfo[\"NETWORKS_BY_ID\"][vniStr][\"netTemplateParams\"][\"isLayer2Only\"] == \"false\":\n                    # the SVI exists, but, the network itself is a L2 only\n                    retVal = True\n        else:\n            Wrapper.print(\"isOverlaySvi: not a network vlan [%d]\" % (vlanId))\n            retVal = True\n    return retVal\n\ndef getVniTypeAndVlanId(vniTypeStr):\n    #Wrapper.print(\"getVniTypeAndVlanId: type [%s]\" % vniTypeStr)\n    entries = vniTypeStr.split(\"[\")\n    netType = entries[0].strip()\n    vlanOrvrfName = entries[1].split(\"]\")[0].strip()\n    #Wrapper.print(\"getVniTypeAndVlanId: type [%s], vlan or VRF Name [%s]\" % \n    #              (netType, vlanOrvrfName))\n    return netType, vlanOrvrfName\n\ndef getMatchingResultVlan(vlanIdStr, matchResults):\n    vlanKey = 'vlan ' + vlanIdStr\n    if vlanKey in matchResults[\"FEATURES_INFO\"][\"VLAN_BLOCK\"]:\n        return matchResults[\"FEATURES_INFO\"][\"VLAN_BLOCK\"][vlanKey]\n\n    return None\n\n# get a list of all the existing DCNM topdown network and vrf vlan ids (integers)\ndef getAllTopDownVlans(devSerial, device_overlay_vlans):\n    all_overlay_vlan_list = []\n    for x in device_overlay_vlans.entrySet():\n        all_overlay_vlan_list = list(set(all_overlay_vlan_list) | set(x.value.getVlanList()))\n\n    # get the vrf vlans also\n    all_overlay_vlan_list = list(set(all_overlay_vlan_list) | set(TopDownMigrationUtils.getOverlayVrfVlans(devSerial))) \n    Wrapper.print(\"getAllTopDownVlans: Switch [%s] all intf overlay vlans [%d][%s]\" % (devSerial, len(all_overlay_vlan_list), all_overlay_vlan_list))\n    Wrapper.print(\"getAllTopDownVlans: Switch [%s] VRF overlay vlans [%d][%s]\" % (devSerial, len(TopDownMigrationUtils.getOverlayVrfVlans(devSerial)), TopDownMigrationUtils.getOverlayVrfVlans(devSerial)))\n    Wrapper.print(\"getAllTopDownVlans: Switch [%s] Final all intf overlay vlans [%d][%s]\" % (devSerial, len(all_overlay_vlan_list), all_overlay_vlan_list))\n    return all_overlay_vlan_list\n\ndef getVrfsWithDns(nvPairsList, vrfsList):\n    for nvPair in nvPairsList:\n        if \"NAME_SERVER_VRF\" in nvPair:\n            vrfName = nvPair[\"NAME_SERVER_VRF\"]\n            if vrfName not in vrfsList:\n                vrfsList.append(vrfName)\n\ndef getNetworkSviOverlayParams(interfacesRes, sviName, netEntry, switchOverlayInfo, overlayVrfMisconfigList, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = switchOverlayInfo[\"SERIAL\"]\n    switchRole = switchOverlayInfo[\"switchRole\"]\n\n    intfMatchResult = interfacesRes.get(sviName)\n    Wrapper.print(\"%s: Switch [%s] Role [%s] SVI [%s] Exists [%r] doOverlayExtn [%s]\" %\n            (funcName, devSerial, switchRole, sviName, (True if intfMatchResult else False), switchOverlayInfo[\"doOverlayExtn\"]))\n    if intfMatchResult == None:\n        return\n\n    overlayVrfsNameToVni = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n    netTemplateParams = netEntry[\"netTemplateParams\"]\n\n    vrfName = \"\"\n    vrfVniStr = None\n\n    params = {}\n\n    # SVI exists.. need to check further\n    #   - must be in anycast-gw fwd mode\n    #   - must belong to a non-default VRF\n\n    isValidOverlaySvi = False\n    dhcpServerList = []\n    ipAddrSecCount = 1\n    for line in intfMatchResult[\"show_run_cmds\"]:\n        line = line.rstrip()\n        depth = (len(line) - len(line.lstrip(' '))) / 2\n\n        cmd = line.strip()\n        tokens = cmd.split()\n\n        if depth == 1:\n            # look for the expected top level commands\n            if cmd.startswith('vrf member '):\n                vrfName = tokens[2]\n                if vrfName.lower() not in overlayVrfsNameToVni:\n                    # invalid vrf??\n                    Wrapper.print(\"%s: ERROR - SVI [%s] Belongs to non-existent VRF [%s]\" % (funcName, sviName, vrfName))\n                    # check to ensure we report the error for the vrf only once\n                    if vrfName not in overlayVrfMisconfigList:\n                        isValidOverlaySvi = False\n                        overlayVrfMisconfigList.append(vrfName)\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"),\n                           \"Possible missing configuration(s) for Overlay VRF [%s]. Please resolve and retry Recalculate & Deploy\" %\n                           (vrfName), devSerial)\n                        respObj.setFailureRetCode()\n                    return\n                else:\n                    vrfVniStr = overlayVrfsNameToVni[vrfName.lower()][\"vni\"]\n            elif cmd == \"fabric forwarding mode anycast-gateway\":\n                isValidOverlaySvi = True\n            elif cmd.startswith('ip address '):\n                if \"secondary\" in cmd:\n                    if ipAddrSecCount > 4:\n                        # we have accounted for what we can handle.. push this to unaccounted config\n                        intfMatchResult[\"unaccounted_cmds\"].append(line)\n                        continue\n                    secGwParamName = (\"secondaryGW%d\" % ipAddrSecCount)\n                    params[secGwParamName] = tokens[2]\n                    if \"tag\" in cmd:\n                        params['tag'] = tokens[5]\n                    ipAddrSecCount += 1\n                else:\n                    # primary IPv4 address with prefix\n                    params['gatewayIpAddress'] = tokens[2]\n                    if \"tag\" in cmd:\n                        params['tag'] = tokens[4]\n            elif cmd.startswith('ipv6 address '):\n                # primary IPv6 address with prefix\n                if 'gatewayIpV6Address' in params and params['gatewayIpV6Address'] != \"\":\n                    params['gatewayIpV6Address'] = params['gatewayIpV6Address'] + \",\" + tokens[2]\n                else:\n                    params['gatewayIpV6Address'] = tokens[2]\n                if \"tag\" in cmd:\n                    params['tag'] = tokens[4]\n            elif cmd.startswith('ip dhcp relay address '):\n                if len(dhcpServerList) >= NET_PROFILE_DHCP_SERVERS_MAX:\n                    intfMatchResult[\"unaccounted_cmds\"].append(line)\n                    continue\n\n                dhcpServerList.append({\"srvrAddr\" : tokens[4], \"srvrVrf\" : (tokens[6] if (\"use-vrf\" in cmd) else \"\")})\n            elif cmd.startswith('ip dhcp relay source-interface '):\n                if tokens[4].lower().startswith(\"loopback\"):\n                    params['loopbackId'] = tokens[4][8:]\n            elif cmd.startswith('description '):\n                params['intfDescription'] = cmd[len('description '):]\n            elif cmd.startswith('mtu '):\n                params['mtu'] = cmd[len('mtu '):]\n\n    if isValidOverlaySvi:\n        if vrfName == \"\":\n            return\n\n        params[\"vrfName\"] = vrfName\n        params[NET_PROFILE_DHCP_SERVERS_VAR] = buildOverlayNetDhcpStructString(dhcpServerList, vrfName)\n\n        # move the params to the network template params\n        for paramName in params.keys():\n            netTemplateParams[paramName] = params[paramName]\n\n        netEntry[\"vrfName\"] = netTemplateParams[\"vrfName\"]\n        netTemplateParams[\"isLayer2Only\"] = \"false\"\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            netTemplateParams[\"enableL3OnBorder\"] = \"true\"\n\n        # add this network to the VRF network membership list\n        overlayVrfsInfoById[vrfVniStr][\"networks\"].append(str(netEntry[\"vni\"]))\n\ndef gatherCliOverlays(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, switchOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchRole = switchOverlayInfo[\"switchRole\"]\n    vlanNameSupported = (globalOverlayInfo[\"overlayVlanNameSupported\"] == \"true\")\n    includeAllCfg = (globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"] == \"false\")\n    \n    Wrapper.print(\"%s: Switch [%s] Role [%s] vlanNameSupported [%r], includeAllCfg [%r]\" % \n        (funcName, devSerial, switchRole, vlanNameSupported, includeAllCfg))\n\n    switchVxlanInfo = switchOverlayInfo[\"SWITCH_VXLAN_INFO\"]\n    vlanIdInfo = switchVxlanInfo[\"vlanIdInfo\"]\n    vrfVnis = switchVxlanInfo[\"vrfVnis\"]\n    networkVnis = switchVxlanInfo[\"networkVnis\"]\n\n    for vniStr in vlanIdInfo[\"VNIS\"]:\n        vlanIdStr = vlanIdInfo[\"VNIS\"][vniStr]\n        matchingVlanEntry = getMatchingResultVlan(vlanIdStr, matchResults)\n        if not matchingVlanEntry:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRF VLAN\"),\n                \"Overlay VNI [%s]. Did not find vlan configuration for [%s]. Please resolve and retry 'Recalculate & Deploy'\" %\n                (vniStr, vlanIdStr), devSerial)\n            respObj.setFailureRetCode()\n            return\n        else:\n            for vlanCmd in matchingVlanEntry[\"show_run\"]:\n                if \"private-vlan\" in vlanCmd:\n                    Wrapper.print(\"%s: vlan [%s] has unsupported pvlan cmd: %s\" % (funcName, vlanIdStr, vlanCmd))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OVERLAY\"),\n                        \"Cannot have private-vlan config on VNI VLANs.\", devSerial)\n                    respObj.setFailureRetCode()\n                    return\n\n    nvPairList = getTemplateMatchResults(matchResults, \"vlan_name_11_1\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            # check to make sure the name is not the default\n            vlanIdInt = int(nvPair[\"VLAN\"])\n            vlanName = nvPair[\"NAME\"]\n            if vlanName == (\"VLAN%04d\" % vlanIdInt):\n                vlanName = \"\"\n            vlanIdInfo[\"VLANS\"].update({nvPair[\"VLAN\"] : {\"name\" : vlanName}})\n\n    # dictionary of vrf name (key) and its description (value)\n    vrfDescInfo = {}\n    nvPairList = getTemplateMatchResults(matchResults, \"vrf_desc_11_1\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            vrfDescInfo.update({nvPair[\"VRF_NAME\"] : nvPair[\"DESC\"]})\n\n    overlayVrfsNameToVni = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n\n    # process the VRFs first\n    Wrapper.print(\"%s: **** Processing VRFs\" % (funcName))\n    for vniEntry in vrfVnis:\n        # parse the type field\n        vniStr = vniEntry[\"vni\"]\n        Wrapper.print(\"%s: VRF VNI [%s]\" % (funcName, vniStr))\n\n        netType, vrfName = getVniTypeAndVlanId(vniEntry[\"type\"])\n\n        # get the VRF Vlan info from the switch\n        vrfAttachVlan = int(vlanIdInfo[\"VNIS\"][vniStr] if vlanIdInfo[\"VNIS\"].get(vniStr) else 0)\n        if vrfAttachVlan == 0:\n            # could not find the VLAN for the VRF VNI\n            Wrapper.print(\"%s: Switch [%s]. Did not find the Vlan Id for the VRF VNI [%s] [%s]\" % (funcName, devSerial, vniStr, vrfName))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRF VLAN\"),\n                    \"Did not find the Vlan Id for the VRF VNI [%s] [%s]. Please resolve and retry 'Recalculate & Deploy'\" %\n                    (vniStr, vrfName), devSerial)\n            respObj.setFailureRetCode()\n            continue\n        elif vrfAttachVlan == 1:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VLAN 1 VXLAN\"), \"VRF Vlan 1, VNI %s VXLAN overlay is \"\n                \"not supported. Please resolve and retry 'Recalculate & Deploy'\" % (vniStr), devSerial)\n            respObj.setFailureRetCode()\n            continue\n\n        switchOverlayInfo[\"OVERLAY_VLANS\"].append(vrfAttachVlan)\n\n        vrfAttachVlanStr = str(vrfAttachVlan)\n\n        if vlanNameSupported:\n            vrfVlanNameStr = vlanIdInfo[\"VLANS\"][vrfAttachVlanStr][\"name\"] if vlanIdInfo[\"VLANS\"].get(vrfAttachVlanStr) else \"\"\n        else:\n            vrfVlanNameStr = \"\"\n\n        # parameters used during VRF create\n        vrfTemplateParams = {\n            \"vrfVlanId\" : vrfAttachVlanStr,\n            \"vrfName\": vrfName,\n            \"vrfSegmentId\": vniStr,\n            \"nveId\" : \"1\",\n            \"vrfVlanName\" : vrfVlanNameStr,\n            \"vrfIntfDescription\" : \"\",\n            \"vrfDescription\" : vrfDescInfo[vrfName] if vrfDescInfo.get(vrfName) else \"\",\n            \"vrfRouteMap\" : \"\",\n            \"maxBgpPaths\" : \"1\",\n            \"maxIbgpPaths\" : \"1\",\n            \"asn\" : BGP_AS,\n            \"tag\" : \"\",\n            \"isRPExternal\" : \"false\",\n            \"trmBGWMSiteEnabled\" : \"false\",\n            \"trmEnabled\" : \"false\",\n            \"advertiseHostRouteFlag\" : \"true\",\n            \"advertiseDefaultRouteFlag\" : \"true\",\n            \"configureStaticDefaultRouteFlag\" : \"true\",\n            \"ipv6LinkLocalFlag\" : \"false\"\n        }\n\n        vrfEntry = {\n                    'name' : vrfName,\n                    'vni' : vniStr,\n                    # this is the local vlan that the VRF is attached to\n                    'vlanId' : vrfAttachVlan,\n                    'vrfTemplateParams' : vrfTemplateParams,\n                    # list of network VNIs (integer) associated with this VRF\n                    'networks' : [],\n                    # VRF attach extension values\n                    'extensionVals' : \"\",\n                    # VRF attach instance values\n                    'instanceVals' : \"\",\n                    # the additional configuration that could not be accounted for in the config profile\n                    'freeformCfg' : None,\n                   }\n\n        nvPairList = getTemplateMatchResults(matchResults, \"bgp_overlay_vrf_ipv4_redist_rmap_11_1\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if nvPair[\"VRF_NAME\"] == vrfName:\n                    vrfTemplateParams[\"vrfRouteMap\"] = nvPair[\"RMAP\"] \n                    break\n        nvPairList = getTemplateMatchResults(matchResults, \"bgp_overlay_vrf_ipv4_max_bgp_paths_11_1\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if nvPair[\"VRF_NAME\"] == vrfName:\n                    vrfTemplateParams[\"maxBgpPaths\"] = nvPair[\"MAX_PATHS\"]\n                    break\n        nvPairList = getTemplateMatchResults(matchResults, \"bgp_overlay_vrf_ipv4_max_ibgp_paths_11_1\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if nvPair[\"VRF_NAME\"] == vrfName:\n                    vrfTemplateParams[\"maxIbgpPaths\"] = nvPair[\"MAX_PATHS\"]\n                    break\n\n        # need to check if a SVI exists for the locally attached vlan\n        sviName = 'Vlan'+ str(vrfAttachVlan)\n        intfMatchResult = interfacesRes.get(sviName)\n        if intfMatchResult != None:\n            Wrapper.print(\"%s: Found SVI [%s] for VRF [%s]\" % (funcName, sviName, vrfName))\n            templates = [\"interface_desc\", \"vlan_interface_ipv6_link_local_11_1\", \"interface_mtu\"]\n            matchingNvPairs = getIntfMatchNvPairs(matchResults, sviName, templates)\n            for templateName in templates:\n                if templateName in matchingNvPairs:\n                    nvPair = matchingNvPairs[templateName]\n                    if (templateName == \"interface_desc\"):\n                        vrfTemplateParams[\"vrfIntfDescription\"] = nvPair[\"DESC\"]\n                    elif (templateName == \"vlan_interface_ipv6_link_local_11_1\"):\n                        vrfTemplateParams[\"ipv6LinkLocalFlag\"] = \"true\"\n                    elif (templateName == \"interface_mtu\"):\n                        vrfTemplateParams[\"mtu\"] = nvPair[\"MTU\"]\n\n        vrfEntry[\"freeformCfg\"] = getVrfFreeformCfg(devSerial, vrfName, vniStr, vrfAttachVlanStr, \n                                                    matchResults, interfacesRes, includeAllCfg, switchOverlayInfo, None)\n\n        overlayVrfsNameToVni[vrfEntry[\"name\"].lower()] = {\"origName\" : vrfEntry[\"name\"], \"vni\" : vniStr}\n        overlayVrfsInfoById[vrfEntry[\"vni\"]] = vrfEntry\n        Wrapper.print(\"%s: Switch [%s]. VRF VNI [%s] [%s]. Entry %s\" % (funcName, devSerial, vniStr, vrfName, vrfEntry))\n\n    # process the network VNIs\n    Wrapper.print(\"%s: **** Processing Networks\" % (funcName))\n    networksInfo = switchOverlayInfo[\"NETWORKS_BY_ID\"]\n    overlayVrfMisconfigList = []\n    for vniEntry in networkVnis:\n        vniStr = vniEntry[\"vni\"]\n        Wrapper.print(\"%s: Network VNI [%s]\" % (funcName, vniStr))\n        # do some validation checks\n        errMsg = None\n        if vniEntry[\"mcast\"] == \"UnicastBGP\":\n            # not a ingress replication VNI.. check against fabric setting\n            if REPLICATION_MODE != \"Ingress\":\n                errMsg = (\"VXLAN network VNI [%s] setup for Ingress Replication while Fabric Replication Setting is [%s]\" % \n                    (vniStr, REPLICATION_MODE))\n        else:\n            if REPLICATION_MODE == \"Ingress\":\n                errMsg = (\"VXLAN network VNI [%s] setup for Multicast Replication while Fabric Replication Setting is [%s]\" % \n                    (vniStr, REPLICATION_MODE))\n        if errMsg:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"), errMsg, devSerial)\n            respObj.setFailureRetCode()\n            continue\n\n        # parse the type field\n        netType, vlanId = getVniTypeAndVlanId(vniEntry[\"type\"])\n        if vlanId == \"1\":\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VLAN 1 VXLAN\"), \"Network Vlan 1, VNI %s VXLAN overlay is \"\n                \"not supported. Please resolve and retry 'Recalculate & Deploy'\" % (vniStr), devSerial)\n            respObj.setFailureRetCode()\n            continue\n\n        switchOverlayInfo[\"OVERLAY_VLANS\"].append(int(vlanId))\n        if vlanNameSupported:\n            vlanNameStr = vlanIdInfo[\"VLANS\"][vlanId][\"name\"] if vlanIdInfo[\"VLANS\"].get(vlanId) else \"\"\n        else:\n            vlanNameStr = \"\"\n\n        vniFlags = vniEntry[\"flags\"] if \"flags\" in vniEntry else vniEntry[\"vni-flags\"]\n        netTemplateParams = {\n            # mandatory parameters\n            'vlanId' : \"\",\n            'vlanName' : vlanNameStr,\n            'segmentId' : vniStr,\n            'tag' : \"\",\n            'vrfName' : \"NA\",\n\n            # non-mandatory parameters\n            'isLayer2Only' : \"true\",\n            'suppressArp' : \"true\" if (vniFlags and (\"SA\" in vniFlags)) else \"false\",\n            'mcastGroup' : vniEntry[\"mcast\"] if (vniEntry[\"mcast\"] != \"UnicastBGP\") else \"\",\n            'enableIR' : \"true\" if (vniEntry[\"mcast\"] == \"UnicastBGP\") else \"false\",\n            'nveId' : \"1\",\n            'rtBothAuto' : \"false\",\n            # set to 'true' if the border role switches have the svi (for a L3 network)\n            'enableL3OnBorder' : \"false\"\n            }\n\n        netEntry = {\n            # the 'overlayNetName' will be set later \n            'vni': int(vniStr),\n            'vlanId' : int(vlanId),\n            'vlanName' : netTemplateParams[\"vlanName\"],\n            \"netTemplateParams\" : netTemplateParams,\n            'vrfName' : \"NA\",\n            # Network attach extension values\n            'extensionVals' : \"\",\n            # the additional configuration that could not be accounted for in the config profile\n            'freeformCfg' : \"\",\n            # list of interface names. Collected from trunk and access host interfaces where the vlan is enabled explictly,\n            'attachInfo' : []\n        }\n\n        nvPairList = getTemplateMatchResults(matchResults, \"evpn_vni_rt_both_11_1\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                if (nvPair[\"VNSEG\"] == vniStr):\n                    netTemplateParams[\"rtBothAuto\"] = \"true\"\n                    break\n\n        # need to check if a SVI exists for this vlan\n        sviName = 'Vlan'+ vlanId\n        intfMatchResult = interfacesRes.get(sviName)\n        getNetworkSviOverlayParams(interfacesRes, sviName, netEntry, switchOverlayInfo, overlayVrfMisconfigList, respObj)\n\n        if (netTemplateParams[\"vlanId\"] == \"\"):\n            # this is the first time we are initializing... set it to the vlan we find. Most likely the same vlan\n            # will be used in all switches. Note that the attach will be for the exact vlan found on the switches\n            netTemplateParams[\"vlanId\"] = netEntry[\"vlanId\"]\n        netEntry[\"freeformCfg\"] = getNetworkFreeformCfg(vniStr, vlanId, matchResults, interfacesRes, includeAllCfg)\n        networksInfo[vniStr] = netEntry\n        switchOverlayInfo[\"NETWORKS_VLAN2VNI\"][netEntry[\"vlanId\"]] = vniStr\n\ndef getAdjustedLinkSerial(nbrSwInfo):\n    serialNum = nbrSwInfo[\"sw-serial-number\"]\n    if ((\"is-vdc\" in nbrSwInfo) and (nbrSwInfo[\"is-vdc\"] == \"true\")):\n        vdc_id = int(nbrSwInfo[\"vdc-id\"])\n        if vdc_id != 1:\n            serialNum = (\"%s:%s\" % (serialNum, nbrSwInfo[\"sw-vdc-name\"]))\n\n    return serialNum\n\ndef getIPAndPrefix(ipAddrWithMask):\n    parts = ipAddrWithMask.split(\"/\")\n    return parts[0], parts[1]\n\ndef buildVrfLiteIFCEntry(ifcEntry, vrfLiteEntry, weAreSrc, srcInfo, dstInfo):\n    funcName = sys._getframe(0).f_code.co_name\n\n    Wrapper.print(\"****%s: SRC: sw-serial-number [%s] if-name [%s] fabric-name [%s]. srcInfo: [%s]\" % (funcName,\n        srcInfo.get(\"sw-serial-number\"), srcInfo.get(\"if-name\"), srcInfo.get(\"fabric-name\"), srcInfo))\n    Wrapper.print(\"****%s: DST: sw-serial-number [%s] if-name [%s] fabric-name [%s]. dstInfo: [%s]\" % (funcName,\n        dstInfo.get(\"sw-serial-number\"), dstInfo.get(\"if-name\"), dstInfo.get(\"fabric-name\"), dstInfo))\n\n    nvPairs = {\"MTU\" : \"\", \"PEER1_DESC\" : \"\", \"PEER2_DESC\": \"\", \"PEER1_CONF\" : \"\", \"PEER2_CONF\" : \"\",\n               \"PEER_VRF_NAME\" : \"\", \"AUTO_VRF_LITE_FLAG\" : \"false\",\n               'VRF_LITE_JYTHON_TEMPLATE' : VRF_LITE_IFC_PYTHON_POLICY\n              }\n\n    # need to extract the IPv4 and IPv6 prefix\n    localV4IP = \"\"\n    localV4Prefix = \"\"\n    if vrfLiteEntry[\"IP_MASK\"] != \"\":\n        localV4IP, localV4Prefix = getIPAndPrefix(vrfLiteEntry[\"IP_MASK\"])\n\n    localV6IP = \"\"\n    localV6Prefix = \"\"\n    if vrfLiteEntry[\"IPV6_MASK\"] != \"\":\n        localV6IP, localV6Prefix = getIPAndPrefix(vrfLiteEntry[\"IPV6_MASK\"])\n\n    # for the IFC, the src and dst must be built depending on whether we are the source or not\n    if weAreSrc:\n        nvPairs[\"asn\"] = BGP_AS\n        nvPairs[\"NEIGHBOR_ASN\"] = vrfLiteEntry['NEIGHBOR_ASN']\n\n        nvPairs[\"IP_MASK\"] = vrfLiteEntry['IP_MASK']\n        nvPairs[\"NEIGHBOR_IP\"] = vrfLiteEntry['NEIGHBOR_IP']\n\n        nvPairs[\"IPV6_MASK\"] = vrfLiteEntry['IPV6_MASK']\n        nvPairs[\"IPV6_NEIGHBOR\"] = vrfLiteEntry['IPV6_NEIGHBOR']\n    else:\n        nvPairs[\"asn\"] = vrfLiteEntry['NEIGHBOR_ASN']\n        nvPairs[\"NEIGHBOR_ASN\"] = BGP_AS\n\n        nvPairs[\"IP_MASK\"] = vrfLiteEntry['NEIGHBOR_IP'] + \"/\" + localV4Prefix\n        nvPairs[\"NEIGHBOR_IP\"] = localV4IP\n\n        if vrfLiteEntry[\"IPV6_MASK\"] != \"\":\n            nvPairs[\"IPV6_MASK\"] = vrfLiteEntry['IPV6_NEIGHBOR'] + \"/\" + localV6Prefix\n            nvPairs[\"IPV6_NEIGHBOR\"] = localV6IP\n        else:\n            nvPairs[\"IPV6_MASK\"] = \"\"\n            nvPairs[\"IPV6_NEIGHBOR\"] = \"\"\n\n    nvPairs['LINK_UUID'] = ifcEntry[\"LINK_UUID\"]\n    nvPairs['SOURCE_FABRIC_NAME'] = srcInfo['fabric-name']\n    nvPairs['SOURCE_SERIAL_NUMBER'] = getAdjustedLinkSerial(srcInfo)\n    nvPairs['SOURCE_SWITCH_NAME'] = srcInfo['sw-sys-name']\n    nvPairs['SOURCE_IF_NAME'] = srcInfo['if-name']\n    nvPairs['DEST_FABRIC_NAME'] = dstInfo['fabric-name']\n    nvPairs['DEST_SERIAL_NUMBER'] = getAdjustedLinkSerial(dstInfo)\n    nvPairs['DEST_SWITCH_NAME'] = dstInfo['sw-sys-name']\n    nvPairs['DEST_IF_NAME'] = dstInfo['if-name']\n\n    ifcEntry[\"nvPairs\"] = nvPairs\n    ifcEntry[\"entityName\"] = (nvPairs['SOURCE_SERIAL_NUMBER'] + Helper.DELIMITER + srcInfo.get(\"if-name\") +\n          Helper.DELIMITER + nvPairs['DEST_SERIAL_NUMBER'] + Helper.DELIMITER + dstInfo.get(\"if-name\"))\n\ndef createVrfLiteIFCEntry(switchInfo, switchOverlayInfo, vrfLiteEntry, linkNbrList, vrfLiteMissingParentIntfs, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    fmtName = switchInfo[\"fmtName\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n\n    # vrfLiteEntry = {\"IF_NAME\" : vrfLiteIntfIfName,\n    #          \"DOT1Q_ID\" : vrfLiteIntfEntry[\"DOT1Q_ID\"],\n    #          \"IP_MASK\" : vrfLiteIntfEntry[\"IP_MASK\"] if \"IP_MASK\" in vrfLiteIntfEntry else \"\",\n    #          \"IPV6_MASK\" : vrfLiteIntfEntry[\"IPV6_MASK\"] if \"IPV6_MASK\" in vrfLiteIntfEntry else \"\",\n    #          \"NEIGHBOR_IP\" : \"\",\n    #          \"IPV6_NEIGHBOR\" : \"\",\n    #          \"NEIGHBOR_ASN\" : \"\",\n    #          \"AUTO_VRF_LITE_FLAG\" : \"false\", \"PEER_VRF_NAME\" : \"\",\n    #          \"VRF_LITE_JYTHON_TEMPLATE\" : \"Ext_VRF_Lite_Jython\"}\n    #\n    # ifcEntry = { \"linkUUID\" : \"\", entityName\" = \"\",\n    #              nvPairs = { \"LINK_UUID\": linkUUID, \"SOURCE_FABRIC_NAME\" : \"\", DEST_FABRIC_NAME': \"\", \"SOURCE_SERIAL_NUMBER\": \"\", \n    #                           \"DEST_SERIAL_NUMBER\" : \"\",\n    #                           \"SOURCE_SWITCH_NAME\"  : \"\", \"DEST_SWITCH_NAME\" : \"\", \"SOURCE_IF_NAME\" : \"\"\n    #                           \"DEST_IF_NAME\", \"\", \"asn\" : \"\", \"IP_MASK\" : \"\", \"NEIGHBOR_IP\" : \"\", 'NEIGHBOR_ASN' : \"\",\n    #                           \"DOT1Q_ID\" : \"\", \"IPV6_MASK\" : \"\", \"IPV6_NEIGHBOR\" : \"\", \"MTU\" : \"\", \"PEER1_DESC\" : \"\"\n    #                           \"PEER2_DESC\",  \"\", \"PEER1_CONF\" : \"\", \"PEER2_CONF\" : \"\", \"AUTO_VRF_LITE_FLAG\" : \"\",\n    #                           \"PEER_VRF_NAME\" : \"\", 'VRF_LITE_JYTHON_TEMPLATE' : \"\"\n    #                        }\n    #            }\n\n    # this is the subif parent interface name. it is assumed to be a routed interface\n    ifName = vrfLiteEntry['IF_NAME']\n\n    Wrapper.print(\"%s: [%s], parent VRF-Lite intf [%s]\" % (funcName, fmtName, ifName))\n    if ifName in switchOverlayInfo[\"IFCS\"][\"VRF_LITE\"]:\n        # parent entry exists.. nothing more to do\n        Wrapper.print(\"****%s: IFC entry exists for [%s] existing entry [%s]\" % (funcName, ifName,\n            switchOverlayInfo[\"IFCS\"][\"VRF_LITE\"][ifName]))\n        return\n\n    # need to create a new IFC entry\n    entryFound = False\n\n    # look for a matching link\n    lowerIntfName = ifName.lower()\n    for linkNbr in linkNbrList:\n        # SWITCH2 INFO==[{u'sw-UUID-ID': 3000, u'sw-model-name': u'N9K-C9396PX', u'ethsw-DBID': 3050, u'fabric-name': u'easy', \n        # u'is-vdc': u'false', u'switch-role': u'leaf', u'if-admin-status': u'Up', u'if-name': u'Ethernet1/1', \n        # u'sw-serial-number': u'SAL1833YM64', u'if-op-reason': u'none', u'if-op-status': u'Up', u'fabric-id': u'3', \n        # u'vdc-id': u'0', u'sw-UUID': u'DCNM-UUID-3000', u'sw-sys-name': u'n9k7_bp2-lfsw04-l001'}]\n\n        sw1Info = json.loads(linkNbr.get(\"sw1-info\"))\n        sw2Info = json.loads(linkNbr.get(\"sw2-info\"))\n\n        if ((sw1Info.get(\"sw-serial-number\") == devSerial) and (sw1Info.get(\"if-name\").lower() == lowerIntfName) and\n            (sw1Info.get(\"fabric-name\") == FABRIC_NAME)):\n            entryFound = True\n        elif ((sw2Info.get(\"sw-serial-number\") == devSerial) and (sw2Info.get(\"if-name\").lower() == lowerIntfName) and\n              (sw2Info.get(\"fabric-name\") == FABRIC_NAME)):\n            entryFound = True\n\n        if not entryFound:\n            continue\n\n        Wrapper.print(\"%s: [%s] VRF-Lite entry [%s]\" % (funcName, fmtName, vrfLiteEntry))\n\n        ifcEntry = {\"LINK_UUID\" : linkNbr.get(\"link-uuid\")}\n\n        pairSerial = Util.exe(Helper.getLinkOrderByLinkUUid(linkNbr.get(\"link-uuid\")))\n        if pairSerial[\"sw1-serial-number\"] == sw1Info.get(\"sw-serial-number\"):\n            # we are the source for the IFC\n            buildVrfLiteIFCEntry(ifcEntry, vrfLiteEntry, True, sw1Info, sw2Info)\n        else:\n            buildVrfLiteIFCEntry(ifcEntry, vrfLiteEntry, False, sw2Info, sw1Info)\n\n        Wrapper.print(\"****%s: pairSerial [%s], ifname [%s] ifcEntry [%s]\" % (funcName, pairSerial, ifName, ifcEntry))\n        switchOverlayInfo[\"IFCS\"][\"VRF_LITE\"][ifName] = ifcEntry\n        break\n    \n    if ((not entryFound) and (ifName not in vrfLiteMissingParentIntfs)):\n        # report error.. our local link must be connected to another fabric\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRFLITE_IFC\"),\n            \"Could not locate the peer interface for VRF-Lite parent interface [%s]. Please ensure that the link \"\n            \"is correctly discovered or add the VRF-Lite IFC for a meta device\" % (ifName), devSerial)\n        respObj.setFailureRetCode()\n\n        vrfLiteMissingParentIntfs.append(ifName)\n\n# parse and return the over network svis only (must have 'fabric forwarding mode anycast-gateway')\ndef getCfgProfileOverlaySviInfo(devSerial, matchResults):\n    funcName = sys._getframe(0).f_code.co_name\n\n    cfgProfiles = matchResults[\"FEATURES_INFO\"][\"CFG_PROFILES\"]\n\n    sviInfo = {}\n\n    # dictionary of valid profiles to process. .key is the actual profile name; ex: MyNetwork_30000\n    profilesToProcess = {}\n\n    # gather all the applied profiles on the switch\n    appliedProfiles = getTemplateMatchResults(matchResults, \"apply_profile\")\n    if appliedProfiles:\n        for profileNvPair in appliedProfiles:\n            # add a dummy dictionary entry\n            profilesToProcess[profileNvPair[\"PROFILE_NAME\"]] = None\n\n    for profileCmd in cfgProfiles:\n        profileName = profileCmd.split()[2]\n\n        if profileName in profilesToProcess:\n            # update the dictionary entry with the match entry\n            profilesToProcess[profileName] = cfgProfiles[profileCmd]\n\n    # process each config profile\n    for profileName in profilesToProcess:\n        profileEntry = profilesToProcess[profileName]\n        if profileEntry == None:\n            # not possible, but, better be safe\n            continue\n\n        context = None\n        vlanId = None\n        sviParams = {}\n        for line in profileEntry['show_run']:\n            line = line.rstrip()\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                # skip the 'configure profile xxxx' line\n                continue\n\n            cmd = line.strip()\n            tokens = cmd.split()\n\n            #Wrapper.print(\"%s: Line [%s], depth [%d], cmd [%s] tokens [%s]\" %  (funcName, line, depth, cmd, tokens))\n\n            if depth == 1:\n                # look for the expected top level commands\n                if cmd.startswith('interface '):\n                    lowerIntfName = tokens[1].lower().strip()\n                    if lowerIntfName.startswith(\"vlan\"):\n                        context = \"svi\"\n                        sviParams[\"vlanId\"] = lowerIntfName[4:]\n            elif depth == 2:\n                if context == \"svi\":\n                    if cmd.startswith('description '):\n                        sviParams[\"desc\"] = cmd[len('description '):]\n                    elif cmd.startswith('vrf member '):\n                        sviParams['vrfName'] = tokens[2]\n                    elif cmd == ('fabric forwarding mode anycast-gateway'):\n                        sviParams['isNetSvi'] = True\n                    elif cmd.startswith('ip address '):\n                        if \"secondary\" not in cmd:\n                            # primary IP address\n                            sviParams['ipv4'] = tokens[2]\n                            if \"tag\" in cmd:\n                                sviParams[\"tag\"] = tokens[4]\n\n        if (('isNetSvi' in sviParams) and (\"vlanId\" in sviParams)):\n            sviParams[\"profileName\"] = profileName\n            sviInfo[sviParams[\"vlanId\"]] = sviParams\n\n    return sviInfo\n\ndef buildOverlayNetDhcpStructString(dhcpServersList, netVrfName):\n    funcName = sys._getframe(0).f_code.co_name\n\n    # normalize the dhcp relay vrf\n    for entry in dhcpServersList:\n        if entry[\"srvrVrf\"] == \"\":\n            entry[\"srvrVrf\"] = netVrfName\n    string = \"\" if (len(dhcpServersList)== 0) else json.dumps({NET_PROFILE_DHCP_SERVERS_VAR : dhcpServersList})\n\n    # Wrapper.print(\"%s: dhcpServersList %s, JSON string %s\" % (funcName, dhcpServersList, string))\n    return string\n\ndef gatherCfgProfileOverlays(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo,\n                            switchOverlayInfo, cfgProfiles):\n    funcName = sys._getframe(0).f_code.co_name\n    switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n    switchRole = switchInfo['switchRole']\n    formattedName = switchInfo[\"fmtName\"]\n\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n    isServiceLeaf = switchOverlayInfo[\"isServiceLeaf\"]\n\n    Wrapper.print(\"%s %s: Start - Fabric [%s] Switch [%s] Role [%s] doOverlayExtn [%s] isServiceLeaf [%r]\" % (OVERLAY_PREFIX, \n        funcName, FABRIC_NAME, formattedName, switchRole, switchOverlayInfo[\"doOverlayExtn\"], isServiceLeaf))\n\n    if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n        multisiteExtnDict = None\n        # check if switch has multisite configs\n        nvPairList = getTemplateMatchResults(matchResults, \"evpn_multisite\")\n        if ((nvPairList != None) and (len(nvPairList) > 0)):\n            # multisite extension values\n            multisiteExtn = {\"MULTISITE_CONN\" : [{\"IF_NAME\" : globalOverlayInfo[\"routingLoName\"]}]}\n            multisiteExtnDict = {\"MULTISITE_CONN\" : json.dumps(multisiteExtn)}\n\n    networksInfo = switchOverlayInfo[\"NETWORKS_BY_ID\"]\n    overlayVrfsNameToVni = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n    freeformCfg = []\n\n    # external links for this switch. Will get fetched on demand\n    linkNbrList = None\n\n    # dictionary of valid profiles to process. .key is the actual profile name; ex: MyNetwork_30000\n    profilesToProcess = {}\n\n    # gather all the applied profiles on the switch\n    appliedProfiles = getTemplateMatchResults(matchResults, \"apply_profile\")\n    if appliedProfiles:\n        for profileNvPair in appliedProfiles:\n            # add a dummy dictionary entry\n            profilesToProcess[profileNvPair[\"PROFILE_NAME\"]] = None\n\n    for profileCmd in cfgProfiles:\n        \"\"\"\n        \"configure profile MyNetwork_30000\": {\n            \"show_run\": [\n                \"configure profile MyNetwork_30000\",\n                \"  vlan 2300\",\n                \"    vn-segment 30000\",\n            [snip]\n        },\n        \"configure profile MyNetwork_30001\": {\n            \"show_run\": [\n                \"configure profile MyNetwork_30001\",\n                \"  vlan 2301\",\n                \"    vn-segment 30001\",\n            [snip]\n        }\n        \"\"\"\n        profileName = profileCmd.split()[2]\n\n        if profileName in profilesToProcess:\n            # update the dictionary entry with the match entry\n            profilesToProcess[profileName] = cfgProfiles[profileCmd]\n        else:\n            # a config profile that exists on the switch, but, not applied??.. add it to the freeform\n            freeformCfg += cfgProfiles[profileCmd][\"show_run\"]\n\n    # track the missing parent vrf-lite interfaces to avoid repeated errors\n    vrfLiteMissingParentIntfs = []\n    # process each config profile\n    for profileName in profilesToProcess:\n        profileEntry = profilesToProcess[profileName]\n        if profileEntry == None:\n            # not possible, but, better be safe\n            continue\n\n        vlanParams = {}\n        sviParams = {}\n        nve1Params = {}\n        vrfParams = {}\n        bgpParams = {}\n        evpnParams = {}\n        loParams = None\n        loIntfs = []\n        trmParams = {}\n        advertiseHostRouteFlagVal = \"true\"\n        advertiseDefaultRouteFlagVal = \"false\"\n        configureStaticDefaultRouteFlagVal = \"false\"\n        tag = \"\"\n\n        # VRF LITE config Tracking data\n        #   {\n        #       # key is the actual subif name\n        #       \"INTFS\" : {\"subif parent intf name\" : {\"DOT1Q_ID\" : \"dot1q\", \n        #                   \"IP_MASK\" : \"intf ip address with prefix\", \"IP_ADDR\" : \"ip address\",\n        #                           IP_PREFIX\" : \"subnet prefix\", \"IP_SUBNET\" : \"ipv4 subnet\",\n        #                   \"IPV6_MASK\" : \"intf v6 ip address with prefix\",\"IPV6_ADDR\" : \"ip v6 address\", \n        #                           IPV6_PREFIX\" : \"v6 subnet prefix\", \"IPV6_SUBNET\" : \"ipv6 subnet\"}\n        #                 }\n        #\n        #       # key is the v4 or v6 neighbor IP\n        #       \"NEIGHBORS\" : {\"v4/v6 neighbor ip\" : {\"isV6\" : True/False, NEIGHBOR_ASN\" : \"asn\", \"IS_PROCESSED\" : True/False}\n        #       \"CURR_INTF\" : intfEntry\n        #       \"CURR_NEIGHBOR\" : v4/v6 neighbor entry\n        #   }\n        vrfLiteParams = {\"INTFS\" : {}, \"NEIGHBORS\" : {},\n                         \"CURR_INTF\" : None, \"CURR_NEIGHBOR\" : None\n                        }\n\n        context = None\n        #Wrapper.print(\"%s: ******************\" % funcName)\n        #Wrapper.print(\"%s: Profile [%s]\" %  (funcName, profileEntry['show_run']))\n        #Wrapper.print(\"%s: ******************\" % funcName)\n        isBgpVrfContext = False\n        isBgpVrfAFContext = False\n        isBgpVrfNeighborContext = False\n        isBgpVrfNeighborAFContext = False\n\n        for line in profileEntry['show_run']:\n            line = line.rstrip()\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                # skip the 'configure profile xxxx' line\n                continue\n\n            cmd = line.strip()\n            tokens = cmd.split()\n\n            #Wrapper.print(\"%s: Line [%s], depth [%d], cmd [%s] tokens [%s]\" %  (funcName, line, depth, cmd, tokens))\n\n            if depth == 1:\n                vrfLiteParams[\"CURR_INTF\"] = None\n                vrfLiteParams[\"CURR_NEIGHBOR\"] = None\n                # look for the expected top level commands\n                if cmd.startswith('vlan '):\n                    context = \"vlan\"\n                    # extract the vlan id (str)\n                    vlanParams['id'] = tokens[1]\n                elif cmd.startswith('interface '):\n                    lowerIntfName = tokens[1].lower().strip()\n                    if lowerIntfName == \"nve1\":\n                        context = \"nve1\"\n                    elif lowerIntfName.startswith(\"vlan\"):\n                        context = \"svi\"\n                    elif lowerIntfName.startswith(\"loopback\"):\n                        context = \"lo\"\n                        loParams = {}\n                        loParams[\"id\"] = tokens[1][8:]\n                        loIntfs.append(loParams)\n                    elif lowerIntfName.startswith(\"ethernet\") or lowerIntfName.startswith(\"port-channel\"):\n                        #Wrapper.print(\"%s: Processing sub interface Line [%s], depth [%d], cmd [%s] tokens [%s]\" % \n                        #            (funcName, line, depth, cmd, tokens))\n                        if '.' in tokens[1]:\n                            # assume it is VRF Lite sub-interface\n                            context = \"subif\"\n\n                            # get the .1q id\n                            parentIntf, dot1qId = tokens[1].split(\".\")\n                            normalizedParentIntfName = parentIntf\n                            if parentIntf.lower().startswith(\"port-channel\"):\n                                normalizedParentIntfName = parentIntf.capitalize()\n                            \n                            if normalizedParentIntfName not in vrfLiteParams[\"INTFS\"]:\n                                # add a new VRF Lite entry\n                                vrfLiteIntfEntry = {\"DOT1Q_ID\" : dot1qId}\n                                #Wrapper.print(\"%s: Adding vrfLiteIntfEntry [%s]\" % (funcName, vrfLiteIntfEntry))\n                                vrfLiteParams[\"INTFS\"][normalizedParentIntfName] = vrfLiteIntfEntry\n                            else:\n                                vrfLiteIntfEntry = vrfLiteParams[\"INTFS\"][normalizedParentIntfName]\n                            vrfLiteParams[\"CURR_INTF\"] = vrfLiteIntfEntry\n                elif cmd.startswith('vrf context '):\n                    context = \"vrf\"\n                    # extract the vrf name\n                    vrfParams['name'] = tokens[2]\n                elif cmd.startswith('router bgp '):\n                    context = \"bgp\"\n                    # extract the bgp asn\n                    bgpParams['asn'] = tokens[2]\n                elif cmd.startswith('evpn'):\n                    context = \"evpn\"\n            elif depth == 2:\n                if context == \"vlan\":\n                    if cmd.startswith('name '):\n                        vlanParams['name'] = tokens[1]\n                    elif cmd.startswith('vn-segment '):\n                        vlanParams['vni'] = tokens[1]\n                    elif cmd.startswith('private-vlan'):\n                        Wrapper.print(\"%s: vlan [%s] has unsupported pvlan cmd: %s\" % (funcName, vlanParams['id'], cmd))\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OVERLAY\"),\n                                \"Cannot have private-vlan config on VNI VLANs.\", devSerial)\n                        respObj.setFailureRetCode()\n                elif context == \"nve1\":\n                    if cmd.startswith('member vni '):\n                        if \"associate-vrf\" in cmd:\n                            nve1Params['isVrfVni'] = \"true\"\n                        else:\n                            nve1Params['isVrfVni'] = \"false\"\n                elif context == \"svi\":\n                    if cmd.startswith('description '):\n                        sviParams['desc'] = cmd[len('description '):]\n                    elif cmd.startswith('vrf member '):\n                        sviParams['vrfName'] = tokens[2]\n                    elif cmd.startswith('ip address '):\n                        if \"secondary\" in cmd:\n                            # secondary GW IP address\n                            if not \"gw1Ipv4\" in sviParams:\n                                sviParams['gw1Ipv4'] = tokens[2]\n                            elif not \"gw2Ipv4\" in sviParams:\n                                sviParams['gw2Ipv4'] = tokens[2]\n                            elif not \"gw3Ipv4\" in sviParams:\n                                sviParams['gw3Ipv4'] = tokens[2]\n                            else:\n                                sviParams['gw4Ipv4'] = tokens[2]\n                            if \"tag\" in cmd:\n                                tag = tokens[5]\n                        else:\n                            # primary IP address\n                            sviParams['ipv4'] = tokens[2]\n                            if \"tag\" in cmd:\n                                tag = tokens[4]\n                    elif cmd.startswith('ipv6 address '):\n                        if cmd == 'ipv6 address use-link-local-only':\n                            sviParams['ipv6LinkLocal'] = \"true\"\n                        else: \n                            # primary IPv6 address\n                            if 'ipv6' in sviParams and sviParams['ipv6'] != \"\":\n                                sviParams['ipv6'] = sviParams['ipv6'] + \",\" + tokens[2]\n                            else:\n                                sviParams['ipv6'] = tokens[2]\n                            if \"tag\" in cmd:\n                                tag = tokens[4]\n                    elif cmd.startswith('mtu '):\n                        sviParams['mtu'] = tokens[1]\n                    elif cmd == 'ip pim sparse-mode':\n                        trmParams['trmEnabled'] = \"true\"\n                    elif cmd.startswith('ip dhcp relay source-interface '):\n                        if tokens[4].lower().startswith(\"loopback\"):\n                            sviParams['dhcpRelayLoId'] = tokens[4]\n                    elif cmd.startswith(\"ip dhcp relay address \"):\n                        if \"dhcpServersList\" not in sviParams:\n                            # add the key for the DHCP Servers\n                            dhcpServerList = []\n                            sviParams[\"dhcpServersList\"] = dhcpServerList\n                        else:\n                            dhcpServerList = sviParams[\"dhcpServersList\"]\n\n                        # ignore any dhcp relay entries more than the max supported.\n                        # this will cause a diff that customer must fix by updating the profile template to accomodate all\n                        if len(dhcpServerList) <= NET_PROFILE_DHCP_SERVERS_MAX:\n                            dhcpServerList.append({\"srvrAddr\" : tokens[4], \n                                \"srvrVrf\" : (tokens[6] if (\"use-vrf\" in cmd) else \"\")})\n                elif context == \"vrf\":\n                    if cmd.startswith('description '):\n                        vrfParams['desc'] = cmd[len('description '):]\n                    elif cmd.startswith('ip pim rp-address '):\n                        trmParams['trmEnabled'] = \"true\"\n                        trmParams['rpAddress'] = tokens[3]\n                        if \"group-list\" in cmd:\n                            trmParams['multicastGroup'] = tokens[5]\n                    elif cmd.lower().startswith('ip route 0.0.0.0/0 ') or cmd.lower().startswith(\"ipv6 route ::/0\"):\n                        configureStaticDefaultRouteFlagVal = \"true\"\n                elif context == \"lo\":\n                    if cmd.startswith('ip address '):\n                        loParams['ipv4'] = tokens[2][:-3]\n                        if \"tag\" in cmd:\n                            tag = tokens[4]\n                    elif cmd.startswith('ipv6 address '):\n                        loParams['ipv6'] = tokens[2][:-4]\n                        if \"tag\" in cmd:\n                            tag = tokens[4]\n                    elif cmd == 'ip pim sparse-mode':\n                        loParams['isTrm'] = \"true\"\n                        trmParams['trmEnabled'] = \"true\"\n                elif context == \"subif\":\n                    vrfLiteIntfEntry = vrfLiteParams[\"CURR_INTF\"]\n                    if (cmd.startswith('ip address ') or cmd.startswith('ipv6 address ')):\n                        # get the prefix string\n                        ipAddr, prefix = tokens[2].split(\"/\")\n                        if Util.isIpv6Addr(ipAddr):\n                            vrfLiteIntfEntry[\"IPV6_MASK\"] = tokens[2]\n                            vrfLiteIntfEntry[\"IPV6_ADDR\"] = ipAddr\n                            vrfLiteIntfEntry[\"IPV6_PREFIX\"] = prefix\n                            vrfLiteIntfEntry[\"IPV6_SUBNET\"] = Util.getV6SubnetStringWithPrefix(ipAddr, prefix)\n                        else:\n                            vrfLiteIntfEntry[\"IP_MASK\"] = tokens[2]\n                            vrfLiteIntfEntry[\"IP_ADDR\"] = ipAddr\n                            vrfLiteIntfEntry[\"IP_PREFIX\"] = prefix\n                            vrfLiteIntfEntry[\"IP_SUBNET\"] = Util.getSubnetStringWithPrefix(ipAddr, prefix)\n                elif context == \"bgp\":\n                    isBgpVrfContext = False\n                    isBgpVrfNeighborContext = False\n                    isBgpVrfNeighborAFContext = False\n                    if cmd.startswith('vrf '):\n                        vrfLiteParams[\"CURR_NEIGHBOR\"] = None\n                        isBgpVrfContext = True\n            elif depth == 3:\n                if context == \"nve1\":\n                    if cmd.startswith('mcast-group '):\n                        if nve1Params['isVrfVni'] == \"true\":\n                            trmParams['trmEnabled'] = \"true\"\n                            trmParams['L3VniMcastGroup'] = tokens[1]\n                        else:\n                            nve1Params['mcastGroup'] = tokens[1]\n                    elif cmd == \"multisite ingress-replication optimized\":\n                        nve1Params['trmBGWMSiteEnabled'] = \"true\"\n                    elif cmd.startswith('ingress-replication '):\n                        nve1Params['isIR'] = \"true\"\n                    elif cmd.startswith('suppress-arp'):\n                        nve1Params['isSuppessArp'] = \"true\"\n                elif context == \"evpn\":\n                    if cmd == \"route-target both auto\":\n                        evpnParams['rtBoth'] = \"true\"\n                elif context == \"bgp\":\n                    if isBgpVrfContext:\n                        if cmd.startswith('neighbor '):\n                            #Wrapper.print(\"%s: bgp neighbor [%s]\" % (funcName, cmd))\n                            # take care of these cases:\n                            # 1. neighbor 20.1.1.2 remote-as 3000\n                            # 2. neighbor 20.1.1.2\n                            #       remote-as 3000\n                            isBgpVrfNeighborContext = True\n                            isBgpVrfNeighborAFContext = False\n                            isBgpVrfAFContext = False\n\n                            asnStr = None\n                            if 'remote-as' in cmd:\n                                asnStr = tokens[3]\n\n                            #Wrapper.print(\"%s: bgp neighbor cmd [%s] asnStr [%s] tokens [%s]\" % (funcName, cmd, asnStr, tokens))\n                            # add a new neighbor\n                            vrfLiteNeighborEntry = {\"isV6\" : \n                                            Util.isIpv6Addr(tokens[1]), \"NEIGHBOR_ASN\" : asnStr, \"IS_PROCESSED\" : False}\n                            vrfLiteParams[\"NEIGHBORS\"][tokens[1]] = vrfLiteNeighborEntry\n                            vrfLiteParams[\"CURR_NEIGHBOR\"] = vrfLiteNeighborEntry\n                        elif cmd.lower() in [\"address-family ipv4 unicast\", \"address-family ipv6 unicast\"]:\n                            isBgpVrfNeighborContext = False\n                            isBgpVrfAFContext = True\n            elif depth == 4:\n                if context == \"bgp\":\n                    if isBgpVrfNeighborContext:\n                        #Wrapper.print(\"%s: bgp neighbor cmd [%s] tokens [%s]\" % (funcName, cmd, tokens))\n                        if cmd.startswith('remote-as '):\n                            vrfLiteParams[\"CURR_NEIGHBOR\"][\"NEIGHBOR_ASN\"] = tokens[1]\n                            #Wrapper.print(\"%s: bgp neighbor cmd [%s] asnStr [%s]\" %\n                            #    (funcName, cmd, vrfLiteParams[\"CURR_NEIGHBOR\"][\"NEIGHBOR_ASN\"]))\n                        elif cmd.lower() in [\"address-family ipv4 unicast\", \"address-family ipv6 unicast\"]:\n                            isBgpVrfNeighborAFContext = True\n                        elif cmd.startswith('password '):\n                            bgpParams['bgpPasswordKeyType'] = tokens[1]\n                            bgpParams['bgpPassword'] = tokens[2]\n                    elif isBgpVrfAFContext:\n                        #Wrapper.print(\"%s: isBgpVrfAFContext cmd [%s]\" % (funcName, cmd))\n                        if cmd.startswith('redistribute direct route-map '):\n                            bgpParams['rmap'] = tokens[3]\n                        elif cmd.startswith('maximum-paths '):\n                            if \"ibgp\" in cmd:\n                                bgpParams['ibgpMaxPaths'] = tokens[2]\n                            else:\n                                bgpParams['bgpMaxPaths'] = tokens[1]\n                        elif cmd.lower() in [\"network 0.0.0.0/0\", \"network ::/0\"]:\n                            advertiseDefaultRouteFlagVal = \"true\"\n            elif depth == 5:\n                if context == \"bgp\":\n                    if isBgpVrfNeighborAFContext:\n                        if cmd.lower() in [\"route-map extcon-rmap-filter out\", \"route-map extcon-rmap-filter-v6 out\"]:\n                            advertiseHostRouteFlagVal = \"false\"\n        \"\"\"\n        Wrapper.print(\"%s: profile [%s]. vlanParams [%s]\" % (funcName, profileName, vlanParams))\n        Wrapper.print(\"%s: profile [%s]. sviParams [%s]\" % (funcName, profileName, sviParams))\n        Wrapper.print(\"%s: profile [%s]. nve1Params [%s]\" % (funcName, profileName, nve1Params))\n        Wrapper.print(\"%s: profile [%s]. vrfParams [%s]\" % (funcName, profileName, vrfParams))\n        Wrapper.print(\"%s: profile [%s]. bgpParams [%s]\" % (funcName, profileName, bgpParams))\n        Wrapper.print(\"%s: profile [%s]. evpnParams [%s]\" % (funcName, profileName, evpnParams))\n        Wrapper.print(\"%s: profile [%s]. trmParams [%s]\" % (funcName, profileName, trmParams))\n        Wrapper.print(\"%s: profile [%s]. loIntfs [%s]\" % (funcName, profileName, loIntfs))\n        Wrapper.print(\"%s: profile [%s]. vrfLiteParams [%s]\" % (funcName, profileName, vrfLiteParams))\n        Wrapper.print(\"%s: profile [%s]. tag [%s]\" % (funcName, profileName, tag))\n        \"\"\"\n\n        # we found a applied config profile.. check some mandatory parameters before assuming these are VXLAN related\n        if (\"vni\" not in vlanParams) or (\"id\" not in vlanParams):\n            # basic vlan/vn-segment info is missing, not an overlay.. add to the freeform\n            freeformCfg += profileEntry['show_run']\n            # add the 'apply profile xxx'\n            freeformCfg += [(\"apply profile %s\" % profileName)]\n            continue\n\n        vniStr = vlanParams['vni']\n        vlanId = vlanParams['id']\n        vlanIdInt = int(vlanParams['id'])\n        switchOverlayInfo[\"OVERLAY_VLANS\"].append(vlanIdInt)\n\n        setCfgProfileName = None\n        if len(vrfParams.keys()) > 0:\n            # this is a VRF profile\n            # Note on config profile naming scheme in DCNM 10.4(2)\n            #   VRF - fabricname-VRFName-vrfprofile-L3VNI\n            #               > the config profile name can be different on different switches because of the following:\n            #                   - the 'vrfprofile' will be different on the borders\n\n            vrfName  = vrfParams[\"name\"]\n            # check if this is a DCNM 10.4(2) style config profile:\n            if (len(profileName) != len(vrfName)):\n                # this is a DCNM 10.4(2) style VRF config profile. Note: DCNM 10.4(2) preserves the vrf name case\n                setCfgProfileName = profileName\n                newProfileName = vrfName\n            else:\n                # we need to manipulate the VRF profile name if the actual vrf name contains ':' because of a\n                # topdown behavior to replace ':' with a '-' in the config profile name\n                #\n                # Note: we must do the below to take care of char case conversions that occur with the profile name\n                # vs the actual vrf name\n                newProfileName = \"\"\n                for i in range(len(vrfName)):\n                    if vrfName[i] == ':':\n                        # there must be a '-' in the profile name.. replace it with ':'\n                        newProfileName += ':'\n                    else:\n                        newProfileName += profileName[i]\n                # make sure the vrfName case is same as the updated profile name\n                vrfName = newProfileName\n\n            Wrapper.print(\"%s: VRF Orig/New Profile Name [%s]/[%s], VRF name [%s], setCfgProfileName [%s]\" %\n                    (funcName, profileName, newProfileName, vrfName, setCfgProfileName))\n            vrfAttachVlanStr = vlanParams['id']\n            vrfTemplateParams = {\n                \"vrfVlanId\" : vrfAttachVlanStr,\n                \"vrfName\": vrfName,\n                \"vrfSegmentId\": vniStr,\n                \"nveId\" : \"1\",\n                \"mtu\" : sviParams.get('mtu', \"\"),\n                \"vrfVlanName\" : vlanParams.get('name', \"\"),\n                \"vrfIntfDescription\" : sviParams.get('desc', \"\"),\n                \"vrfDescription\" : vrfParams.get('desc', \"\"),\n                \"vrfRouteMap\" : bgpParams.get('rmap', \"\"),\n                \"maxBgpPaths\" : bgpParams.get('bgpMaxPaths', \"1\"),\n                \"maxIbgpPaths\" : bgpParams.get('ibgpMaxPaths', \"1\"),\n                \"asn\" : BGP_AS,\n                \"tag\" : tag,\n                \"isRPExternal\" : \"false\",\n                \"trmBGWMSiteEnabled\" : nve1Params.get('trmBGWMSiteEnabled', \"false\"),\n                \"trmEnabled\" : \"false\",\n                \"advertiseHostRouteFlag\" : advertiseHostRouteFlagVal,\n                \"advertiseDefaultRouteFlag\" : advertiseDefaultRouteFlagVal,\n                \"configureStaticDefaultRouteFlag\" : configureStaticDefaultRouteFlagVal,\n                \"ipv6LinkLocalFlag\" : sviParams.get('ipv6LinkLocal', \"false\"),\n            }\n\n            if \"bgpPassword\" in bgpParams:\n                vrfTemplateParams[\"bgpPassword\"] = bgpParams[\"bgpPassword\"]\n                vrfTemplateParams[\"bgpPasswordKeyType\"] = bgpParams[\"bgpPasswordKeyType\"]\n\n            vrfEntry = {\n                        'name' : newProfileName,\n                        'vni' : vrfTemplateParams['vrfSegmentId'],\n                        # this is the local vlan that the VRF is attached to\n                        'vlanId' : vlanIdInt,\n                        'vrfTemplateParams' : vrfTemplateParams,\n                        # list of network VNIs (integer) associated with this VRF\n                        'networks' : [],\n                        # VRF attach instance values\n                        'instanceVals' : \"\",\n                        # VRF attach extension values\n                        'extensionVals' : \"\",\n                        # the additional configuration that could not be accounted for in the config profile\n                        'freeformCfg' : None,\n                       }\n\n            if setCfgProfileName:\n                # save the original profile name so that we can set it during the VRF attach\n                vrfEntry[\"cfgProfileName\"] = profileName\n\n            if len(trmParams.keys()) > 0:\n                vrfTemplateParams.update(trmParams)\n                # assume TRM Lo is not set\n                vrfTemplateParams['isRPExternal'] = \"true\"\n\n            # process loopback interfaces\n            for loParam in loIntfs:\n                if 'isTrm' in loParam:\n                    # TRM loopback\n                    vrfTemplateParams['isRPExternal'] = \"false\"\n                    vrfTemplateParams['loopbackNumber'] = loParam['id']\n                else:\n                    # build the lo instance params\n                    instanceValues = {'loopbackId': loParam['id']}\n                    if 'ipv4' in loParam:\n                        instanceValues['loopbackIpAddress'] = loParam['ipv4']\n                    if 'ipv6' in loParam:\n                        instanceValues['loopbackIpV6Address'] = loParam['ipv6']\n                    vrfEntry['instanceVals'] = json.dumps(instanceValues)\n\n            vrfEntry[\"freeformCfg\"] = getVrfFreeformCfg(devSerial, vrfName, vniStr, vrfAttachVlanStr, \n                                    matchResults, interfacesRes, True, switchOverlayInfo, globalOverlayInfo[\"SERVICES\"])\n\n            # correlate the sub intf and bgp neighbor VRF Lite entries\n            vrfLiteEntries = []\n            if vrfLiteParams[\"NEIGHBORS\"] and vrfLiteParams[\"INTFS\"]:\n                # process the interfaces first\n                for vrfLiteIntfIfName in vrfLiteParams[\"INTFS\"].keys():\n                    vrfLiteIntfEntry = vrfLiteParams[\"INTFS\"][vrfLiteIntfIfName]\n\n                    # this entry is always with us as the source (this is what topdown also expects)\n                    entry = {\"IF_NAME\" : vrfLiteIntfIfName,\n                             \"DOT1Q_ID\" : vrfLiteIntfEntry[\"DOT1Q_ID\"],\n                             \"IP_MASK\" : vrfLiteIntfEntry[\"IP_MASK\"] if \"IP_MASK\" in vrfLiteIntfEntry else \"\",\n                             \"IPV6_MASK\" : vrfLiteIntfEntry[\"IPV6_MASK\"] if \"IPV6_MASK\" in vrfLiteIntfEntry else \"\",\n                             \"NEIGHBOR_IP\" : \"\",\n                             \"IPV6_NEIGHBOR\" : \"\",\n                             \"NEIGHBOR_ASN\" : \"\",\n                             \"AUTO_VRF_LITE_FLAG\" : \"false\", \"PEER_VRF_NAME\" : \"\",\n                             \"VRF_LITE_JYTHON_TEMPLATE\" : VRF_LITE_IFC_PYTHON_POLICY}\n\n                    isValidEntry = False\n\n                    # find the neighbor entries for this interface\n                    for vrfLiteNeighborIP in vrfLiteParams[\"NEIGHBORS\"].keys():\n                        vrfLiteNeighborEntry = vrfLiteParams[\"NEIGHBORS\"][vrfLiteNeighborIP]\n\n                        if vrfLiteNeighborEntry[\"IS_PROCESSED\"]:\n                            continue\n\n                        if vrfLiteNeighborEntry[\"isV6\"]:\n                            if (\"IPV6_MASK\" in vrfLiteIntfEntry):\n                                bgpNeighborSubnetStr = Util.getV6SubnetStringWithPrefix(vrfLiteNeighborIP, \n                                    vrfLiteIntfEntry[\"IPV6_PREFIX\"])\n                                Wrapper.print(\"%s: VRFLITE: V6: Checking neighbor subnet [%s] Intf Subnet [%s]\" %\n                                         (funcName, bgpNeighborSubnetStr, vrfLiteIntfEntry[\"IPV6_SUBNET\"]))\n                                if (bgpNeighborSubnetStr == vrfLiteIntfEntry[\"IPV6_SUBNET\"]):\n                                    # we found what we are looking for\n                                    vrfLiteNeighborEntry[\"IS_PROCESSED\"] = True\n                                    isValidEntry = True\n                                    entry[\"IPV6_NEIGHBOR\"] = vrfLiteNeighborIP\n                                    entry[\"NEIGHBOR_ASN\"] = vrfLiteNeighborEntry[\"NEIGHBOR_ASN\"]\n                        else:\n                            if (\"IP_MASK\" in vrfLiteIntfEntry):\n                                bgpNeighborSubnetStr = Util.getSubnetStringWithPrefix(vrfLiteNeighborIP, \n                                    vrfLiteIntfEntry[\"IP_PREFIX\"])\n                                # Wrapper.print(\"%s: VRFLITE: V4: Checking neighbor subnet [%s] Intf Subnet [%s]\" %\n                                #         (funcName, bgpNeighborSubnetStr, vrfLiteIntfEntry[\"IP_SUBNET\"]))\n                                if (bgpNeighborSubnetStr == vrfLiteIntfEntry[\"IP_SUBNET\"]):\n                                    # we found what we are looking for\n                                    vrfLiteNeighborEntry[\"IS_PROCESSED\"] = True\n                                    isValidEntry = True\n                                    entry[\"NEIGHBOR_IP\"] = vrfLiteNeighborIP\n                                    entry[\"NEIGHBOR_ASN\"] = vrfLiteNeighborEntry[\"NEIGHBOR_ASN\"]\n\n                    if isValidEntry:\n                        if not switchRole.lower().startswith(\"border\"):\n                            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRFLITE_IFC\"),\n                                \"Unexpected VRF-LITE IFC on Interface [%s] with Dot1Q Encap [%s] for a \"\n                                \"Non Border role [%s]. Please set the correct role and retry \"\n                                \"Recalculate & Deploy\" % (entry[\"IF_NAME\"], entry[\"DOT1Q_ID\"], switchRole), devSerial)\n                            respObj.setFailureRetCode()\n                        else:\n                            vrfLiteEntries.append(entry)\n\n                            # create a IFC entry also\n                            if not linkNbrList:\n                                linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, devSerial,  Helper.getNbrTypeExternal()))\n                            createVrfLiteIFCEntry(switchInfo, switchOverlayInfo, entry, linkNbrList, vrfLiteMissingParentIntfs, respObj)\n\n            if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n                overlayExtnDict = {}\n                if multisiteExtnDict:\n                    overlayExtnDict.update(multisiteExtnDict)\n                Wrapper.print(\"%s: vrfTemplateParams [%s]\" % (funcName, vrfTemplateParams))\n                Wrapper.print(\"%s: vrfLiteEntries %d [%s]\" % (funcName, len(vrfLiteEntries), vrfLiteEntries))\n                Wrapper.print(\"%s: VRF-LITE Link Entries [%s]\" % (funcName, switchOverlayInfo[\"IFCS\"][\"VRF_LITE\"]))\n                vrfLiteExtns = {\"VRF_LITE_CONN\" : vrfLiteEntries}\n                vrfLiteExtnsDict = {\"VRF_LITE_CONN\" : json.dumps(vrfLiteExtns)}\n                overlayExtnDict.update(vrfLiteExtnsDict)\n\n                if len(overlayExtnDict) > 0:\n                    vrfEntry['extensionVals'] = json.dumps(overlayExtnDict)\n                    Wrapper.print(\"%s: extensionVals [%s]\" % (funcName, vrfEntry['extensionVals']))\n\n            overlayVrfsNameToVni[vrfEntry[\"name\"].lower()] = {\"origName\" : vrfEntry[\"name\"], \"vni\" : vniStr}\n            Wrapper.print(\"%s: vrfEntry [%s]\" % (funcName, vrfEntry))\n            overlayVrfsInfoById[vrfEntry[\"vni\"]] = vrfEntry\n        else:\n            # this is a network profile\n            if (\"vrfName\" in sviParams):\n                netVrfName = sviParams['vrfName']\n            else:\n                netVrfName = \"NA\"\n            netTemplateParams = {\n                # mandatory parameters\n                'vlanId' : vlanIdInt,\n                'vlanName' : vlanParams['name'] if (\"name\" in vlanParams) else \"\",\n                'segmentId' : vlanParams['vni'],\n                'tag' : tag,\n                'vrfName' : netVrfName,\n                \"gatewayIpAddress\" : sviParams['ipv4'] if (\"ipv4\" in sviParams) else \"\",\n                \"gatewayIpV6Address\" : sviParams['ipv6'] if (\"ipv6\" in sviParams) else \"\",\n\n                # non-mandatory parameters\n                'isLayer2Only' : \"true\",\n                'suppressArp' : nve1Params['isSuppessArp'] if (\"isSuppessArp\" in nve1Params) else \"false\",\n                'mcastGroup' : nve1Params['mcastGroup'] if (\"mcastGroup\" in nve1Params) else \"\",\n                'enableIR' : nve1Params['isIR'] if (\"isIR\" in nve1Params) else \"false\",\n                'nveId' : \"1\",\n                'rtBothAuto' : evpnParams['rtBoth'] if (\"rtBoth\" in evpnParams) else \"false\",\n                # set to 'true' if the border role switches have the svi (for a L3 network)\n                'enableL3OnBorder' : \"false\"\n                }\n\n            netEntry = {\n                # the 'overlayNetName' will be set later \n                'cfgProfileName': profileName,\n                'vni': int(netTemplateParams[\"segmentId\"]),\n                'vlanId' : vlanIdInt,\n                'vlanName' : netTemplateParams[\"vlanName\"],\n                \"netTemplateParams\" : netTemplateParams,\n                'vrfName' : netTemplateParams[\"vrfName\"],\n                # Network attach extension values\n                'extensionVals' : \"\",\n                # the additional configuration that could not be accounted for in the config profile\n                'freeformCfg' : \"\",\n                # list of interface names. Collected from trunk and access host interfaces where the vlan is enabled explictly\n                'attachInfo' : []\n            }\n\n            if \"trmEnabled\" in trmParams:\n                netTemplateParams[\"trmEnabled\"] = trmParams[\"trmEnabled\"]\n\n            for keyName in sviParams:\n                val = sviParams[keyName]\n                if keyName == \"gw1Ipv4\":\n                    netTemplateParams[\"secondaryGW1\"] = val\n                elif keyName == \"gw2Ipv4\":\n                    netTemplateParams[\"secondaryGW2\"] = val\n                elif keyName == \"gw3Ipv4\":\n                    netTemplateParams[\"secondaryGW3\"] = val\n                elif keyName == \"gw4Ipv4\":\n                    netTemplateParams[\"secondaryGW4\"] = val\n                elif keyName == \"desc\":\n                    netTemplateParams[\"intfDescription\"] = val\n                elif keyName == \"mtu\":\n                    netTemplateParams[\"mtu\"] = val\n                elif keyName == \"dhcpRelayLoId\":\n                    netTemplateParams[\"loopbackId\"] = val[len(\"loopback\"):]\n                elif keyName == \"dhcpServersList\":\n                    # store the actual list in a temp key since we need to normalize things later\n                    netTemplateParams[\"dhcpServersTemp\"] = val\n\n            if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n                overlayExtnDict = {}\n                if multisiteExtnDict:\n                    # multisite extension values\n                    overlayExtnDict.update(multisiteExtnDict)\n                if len(overlayExtnDict) > 0:\n                    netEntry['extensionVals'] = json.dumps(overlayExtnDict)\n\n            netEntry[\"freeformCfg\"] = getNetworkFreeformCfg(vniStr, vlanId, matchResults, interfacesRes, True)\n            networksInfo[vlanParams['vni']] = netEntry\n            switchOverlayInfo[\"NETWORKS_VLAN2VNI\"][netEntry[\"vlanId\"]] = vniStr\n\n    # do some post processing...after all the profiles have been parsed\n    for vniStr in networksInfo:\n        netEntry = networksInfo[vniStr]\n        netTemplateParams = netEntry['netTemplateParams']\n        if netTemplateParams['vrfName'] != \"NA\":\n            vrfLookupEntry = overlayVrfsNameToVni[netTemplateParams['vrfName'].lower()]\n            normalizedVrfName = vrfLookupEntry[\"origName\"]\n            netTemplateParams['vrfName'] = normalizedVrfName\n            netEntry['vrfName'] = normalizedVrfName\n            if ('dhcpServersTemp' in netTemplateParams):\n                netTemplateParams[NET_PROFILE_DHCP_SERVERS_VAR] = buildOverlayNetDhcpStructString(netTemplateParams[\"dhcpServersTemp\"], normalizedVrfName)\n                del netTemplateParams[\"dhcpServersTemp\"]\n            netTemplateParams['isLayer2Only'] = \"false\"\n            if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n                Wrapper.print(\"%s: Fabric [%s] Switch [%s] Border Switch Role [%s] Found SVI [%d] - Setting enableL3OnBorder\" % \n                    (funcName, FABRIC_NAME, devSerial, switchRole, netEntry['vlanId']))\n                netTemplateParams[\"enableL3OnBorder\"] = \"true\"\n\n            if isServiceLeaf:\n                if vniStr in servicesInfo[\"serviceNets\"]:\n                    # do not add the service networks to the VRF networks list.. that intent will be from L4-7 services\n                    continue\n            \n            # add the network to the vrf 'networks'\n            overlayVrfsInfoById[vrfLookupEntry[\"vni\"]][\"networks\"].append(str(netEntry[\"vni\"]))\n\n    if isServiceLeaf:\n        for vniStr in servicesInfo[\"serviceNets\"]:\n            if vniStr in networksInfo:\n                srvcNetEntry = servicesInfo[\"serviceNets\"][vniStr]\n                if \"netEntry\" not in srvcNetEntry:\n                    # update the entry\n                    srvcNetEntry[\"netEntry\"] = networksInfo[vniStr]\n                # remove the service networks from the networks list\n                del networksInfo[vniStr]\n\n    # Wrapper.print(\"%s: Switch [%s] **** VRF and Network Entry Summary ****\" % (funcName, devSerial))\n    # for vniStr in overlayVrfsInfoById:\n    #     Wrapper.print(\"%s: VRF VNI [%s]. Entry [%s]\" % (funcName, vniStr, overlayVrfsInfoById[vniStr]))\n\n    # for vniStr in networksInfo:\n    #     Wrapper.print(\"%s: NET VNI [%s]. Entry [%s]\" % (funcName, vniStr, networksInfo[vniStr]))\n\n    switchOverlayInfo[\"POST_INTF_FF\"] += freeformCfg\n    Wrapper.print(\"%s: vrfLiteMissingParentIntfs [%s]\" % (funcName, vrfLiteMissingParentIntfs))\n    Wrapper.print(\"%s %s: End - Fabric [%s] Switch [%s] Role [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME,\n            formattedName, switchRole))\n\ndef getSwitchVxlanInfo(infoDict, switchOverlayInfo, matchResults, sshObj, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    devSerial = switchOverlayInfo[\"SERIAL\"]\n    fmtName = infoDict[\"fmtName\"]\n    migrateMode = infoDict[\"migrationMode\"]\n\n    # init dictionary containing vlan related info\n    # VLANS - dictionary of vlan info. key is vlan id string. value is {\"name\" : vlan_name, \"vni\" : vnseg value string}\n    # VNIS - dictionary of vn-segment info. key is vn-segment id string. value is {\"vni\" : associated vlan id string}\n    vlanIdInfo = {\"VLANS\" : {}, \"VNIS\" : {}}\n\n    # list of VRF VNI entries from the switch (output of 'show nve vni')\n    vrfVnis = []\n\n    # list of Network VNI entries from the switch (output of 'show nve vni')\n    networkVnis = []\n\n    switchOverlayInfo[\"SWITCH_VXLAN_INFO\"] = {\"vlanIdInfo\" : vlanIdInfo, \"vrfVnis\" : vrfVnis,\n                                              \"networkVnis\" : networkVnis}\n\n    # get a list of all vlans on the switch\n    vlanMatchRes = matchResults[\"FEATURES_INFO\"][\"VLAN_BLOCK\"]\n    for vlanStr in vlanMatchRes.keys():\n        vlanListStr = vlanStr[5:]\n        vlanList = Util.getIntegerRange(vlanListStr)\n        isMultiVlans = False\n        if len(vlanMatchRes) == 1:\n            # we have a single entry....this has to be set of all vlans on switch\n            isMultiVlans = True\n        else:\n            if len(vlanList) > 1:\n                # this has to be set of multiple vlans on switch\n                isMultiVlans = True\n        if isMultiVlans:\n            switchOverlayInfo[\"ALL_VLANS\"].extend(vlanList)\n\n    utilObj = Util()\n    allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n\n    hasCfgProfiles = True if matchResults[\"FEATURES_INFO\"][\"CFG_PROFILES\"] else False\n\n    numVlans = len(switchOverlayInfo[\"ALL_VLANS\"])\n    Wrapper.print(\"%s: Switch [%s] Role [%s] migrateMode [%s] hasCfgProfiles [%r] Vlans (%d)[%s]\" % (funcName,\n        fmtName, infoDict[\"switchRole\"], migrateMode, hasCfgProfiles, numVlans, allVlansOnSwitchStr))\n\n    if ((numVlans == 0) or (migrateMode != \"brownAdd\") or (\"spine\" == infoDict[\"switchRole\"].lower())):\n        # we do not need any VXLAN info from the switches\n        Wrapper.print(\"%s: Skip collecting VXLAN info\" % (funcName))\n        return\n\n    # check if there is a discrepancy between the role set by user and actual switch config\n    # 'feature vn-segment-vlan-based' will not be present on 'spine' role switch\n    nvPairList = getTemplateMatchResults(matchResults, \"feature_vlan_based_vnsegment_11_1\")\n    Wrapper.print(\"%s: nvPairList\" % (nvPairList))\n    if (nvPairList is None):\n        # non spine role, but, missing a required feature\n        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":INCORRECT ROLE\"),\n            \"Required 'feature vn-segment-vlan-based' configuration(s) for role [%s] not found. Please check and \"\n            \"retry 'Recalculate & Deploy'\" % (infoDict[\"switchRole\"]), devSerial)\n        respObj.setFailureRetCode()\n        return\n\n    shNveVniCmdJson = getSwitchCmdJsonOutput(sshObj, devSerial, \"show nve vni | json\", respObj)\n\n    shVlanVnsegCmdJson = getSwitchCmdJsonOutput(sshObj, devSerial, \"show vlan id \" + \n                                    allVlansOnSwitchStr + \" vn-segment | json\", respObj)\n\n    if (((shNveVniCmdJson is None) or (shNveVniCmdJson == \"\")) or \n        (\"TABLE_nve_vni\" not in shNveVniCmdJson)):\n        # something is wrong.. respObj must have the required error\n        Wrapper.print(\"%s: Switch [%s] did not find any VXLAN Overlays on switch\" % (funcName, fmtName))\n        return\n\n    if ((shVlanVnsegCmdJson is None) or (\"TABLE_seginfoid\" not in shVlanVnsegCmdJson)):\n        # we did not find vlans with vn-segments\n        Wrapper.print(\"%s: Switch [%s]. Did not find any vlans with vn-segments\" %  (funcName, fmtName))\n    else:\n        if not isinstance(shVlanVnsegCmdJson[\"TABLE_seginfoid\"][\"ROW_seginfoid\"], list):\n            # this is a single entry.. make a list\n            vlanVnsegRows = [shVlanVnsegCmdJson[\"TABLE_seginfoid\"][\"ROW_seginfoid\"]]\n        else:\n            # this is a list already!\n            vlanVnsegRows = shVlanVnsegCmdJson[\"TABLE_seginfoid\"][\"ROW_seginfoid\"]\n        for vlanVnsegEntry in vlanVnsegRows:\n            vlanStr = vlanVnsegEntry[\"vlanshowinfo-seg-vlanid\"]\n            vnsegStr = vlanVnsegEntry[\"vlanshowinfo-segment-id\"]\n            vlanIdInfo[\"VNIS\"].update({vnsegStr : vlanStr})\n            vlanIdInfo[\"VLANS\"][vlanStr] = {\"vni\" : vnsegStr}\n\n    if not isinstance(shNveVniCmdJson[\"TABLE_nve_vni\"][\"ROW_nve_vni\"], list):\n        # this is a single entry.. make a list\n        nveVniRows = [shNveVniCmdJson[\"TABLE_nve_vni\"][\"ROW_nve_vni\"]]\n    else:\n        # this is a list already!\n        nveVniRows = shNveVniCmdJson[\"TABLE_nve_vni\"][\"ROW_nve_vni\"]\n\n    #Wrapper.print(\"%s: Switch [%s] nveVniRows %s VNIS %s\" % (funcName, fmtName, nveVniRows, vlanIdInfo[\"VNIS\"]))\n    for vniEntry in nveVniRows:\n        # ensure that the VNI state is 'UP'\n        vniStr = vniEntry[\"vni\"]\n        if vniEntry[\"vni-state\"].lower() != \"up\":\n            # flag an error\n            Wrapper.print(\"%s: Switch [%s]. Overlay VNI [%s] non-functional state [%s]\" % \n                (funcName, fmtName, vniStr, vniEntry[\"vni-state\"]))\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":VRF VLAN\"),\n                \"Overlay VNI [%s] in state [%s]. Please resolve and retry 'Recalculate & Deploy'\" % (vniStr, vniEntry[\"vni-state\"]), devSerial)\n            respObj.setFailureRetCode()\n            continue\n\n        netType, vlanOrvrfName = getVniTypeAndVlanId(vniEntry[\"type\"])\n\n        if netType == \"L2\":\n            networkVnis.append(vniEntry)\n        else:\n            vrfVnis.append(vniEntry)\n\ndef gatherOverlayInfo(topologyDataObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, \n                        switchOverlayInfo, migrateMode, device_overlay_vlans, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n    role = switchInfo['switchRole']\n    formattedName = switchInfo[\"fmtName\"]\n    vPCInfo = switchInfo[\"vpcInfo\"]\n\n    Wrapper.print(\"%s %s: Start - FABRIC [%s] Switch [%s] Role [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, formattedName, role))\n\n    cfgProfiles = matchResults[\"FEATURES_INFO\"][\"CFG_PROFILES\"]\n    hasCfgProfiles = True if cfgProfiles else False\n    Wrapper.print(\"%s: Switch [%s] hasCfgProfiles [%r] All Vlans = [%d] [%s]\" % (funcName, formattedName, \n        hasCfgProfiles, len(switchOverlayInfo[\"ALL_VLANS\"]), switchOverlayInfo[\"ALL_VLANS\"]))\n\n    switchHasOverlays = True\n\n    if (role != \"spine\"):\n        if migrateMode == \"upgrade\":\n            switchOverlayInfo[\"OVERLAY_VLANS\"] = getAllTopDownVlans(devSerial, device_overlay_vlans)\n        elif migrateMode == \"brownAdd\":\n            vlanIdInfo = switchOverlayInfo[\"SWITCH_VXLAN_INFO\"][\"vlanIdInfo\"]\n            if not hasCfgProfiles:\n                if len(vlanIdInfo[\"VNIS\"]) == 0:\n                    Wrapper.print(\"%s: Switch [%s] did not find any VXLAN Overlays on switch\" % (funcName, devSerial))\n                    switchHasOverlays = False\n\n            if switchHasOverlays:\n                profInfo = globalOverlayInfo['cfgProfileInfo']\n                if profInfo[\"hasCfgProfile\"] == None:\n                    # set the cfg profile status since this is the first time\n                    profInfo[\"hasCfgProfile\"] = hasCfgProfiles\n                    profInfo[\"refSwitch\"] = devSerial\n\n                Wrapper.print(\"%s: Switch [%s] cfgProfileInfo [%s]\" % (funcName, formattedName, profInfo))\n\n                # check for inconsistency\n                if (hasCfgProfiles != profInfo[\"hasCfgProfile\"]):\n                    # an inconsistency where we are finding a mix of cfg profile and cli based migrations\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OVERLAY\"),\n                       \"Has %s based VXLAN Overlays while Switch [%s] is detected with \"\n                       \"%s based VXLAN Overlays. Inconsistent Overlay Migration with a mix of \"\n                       \"config-profiles and regular CLI based overlays is not supported!\" % (\n                            (\"config-profile\" if hasCfgProfiles else \"CLI\"),\n                            getFormattedSwitchName(profInfo[\"refSwitch\"]),\n                            (\"config-profile\" if profInfo[\"hasCfgProfile\"] else \"CLI\")), devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                if (hasCfgProfiles and OVERLAY_MODE != \"config-profile\"):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OVERLAY\"),\n                        \"Has config-profile based VXLAN Overlays but Overlay Mode is set to [%s] in fabric settings\" %\n                        (OVERLAY_MODE), devSerial)\n                    respObj.setFailureRetCode()\n                    return respObj\n\n                if hasCfgProfiles:\n                    gatherCfgProfileOverlays(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo,\n                        switchOverlayInfo, cfgProfiles)\n                else:\n                    gatherCliOverlays(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, switchOverlayInfo)\n\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    if not switchHasOverlays:\n        freeformCfg = []\n        # collect all the config profiles and add to freeform\n        for profileCmd in cfgProfiles:\n            # a config profile that exists on the switch, but, not applied??.. add it to the freeform\n            freeformCfg += cfgProfiles[profileCmd][\"show_run\"]\n\n        # gather all the applied profiles on the switch\n        appliedProfiles = getTemplateMatchResults(matchResults, \"apply_profile\")\n        if appliedProfiles:\n            for profileNvPair in appliedProfiles:\n                applyCmd = (\"apply profile %s\" % profileNvPair[\"PROFILE_NAME\"])\n                freeformCfg += [(\"apply profile %s\" % profileNvPair[\"PROFILE_NAME\"])]\n        switchOverlayInfo[\"POST_INTF_FF\"] += freeformCfg\n\n    overlayVrfsNameToVni = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n    utilObj = Util()\n    allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n    overlayVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"OVERLAY_VLANS\"])\n\n    Wrapper.print(\"%s: Switch [%s] ALL_VLANS = [%d][%s] OVERLAY_VLANS = [%d][%s]\" %  (funcName, formattedName,\n            len(switchOverlayInfo[\"ALL_VLANS\"]), allVlansOnSwitchStr, \n            len(switchOverlayInfo[\"OVERLAY_VLANS\"]), overlayVlansOnSwitchStr))\n\n    localVlans = list(set(switchOverlayInfo[\"ALL_VLANS\"]) - set(switchOverlayInfo[\"OVERLAY_VLANS\"]))\n\n    vpcVlanInt = 0\n    if switchOverlayInfo[\"isVpc\"] == \"true\":\n        vpcVlanInt = int(vPCInfo[\"peerLinkVlan\"])\n\n    localVlans.remove(1)\n    if vpcVlanInt in localVlans:\n        # remove the vPC peer link vlan\n        localVlans.remove(vpcVlanInt)\n\n    Wrapper.print(\"%s: Switch [%s] local vlans = [%d][%s]\" % (funcName, formattedName, len(localVlans), localVlans))\n\n    # build the toplevel vlan xxx config\n    freeformCfg = []\n    if len(localVlans):\n        util = Util()\n        freeformCfg.append(\"vlan \" + util.vlanStrFromList(localVlans))\n\n    for vlanId in localVlans:\n        vlanIdStr = str(vlanId)\n        vlanRec = getMatchingResultVlan(vlanIdStr, matchResults)\n        if vlanRec:\n            #Wrapper.print(\"%s: vlan [%s] is not an overlay vlan\" % (funcName, vlanIdStr))\n            isPvlan = False\n            isVNI = False\n            for vlanCmd in vlanRec[\"show_run\"]:\n                if \"private-vlan\" in vlanCmd:\n                    isPvlan = True\n                elif \"vn-segment\" in vlanCmd:\n                    isVNI = True\n            if isPvlan and isVNI:\n                Wrapper.print(\"%s: vlan [%s] has unsupported pvlan cmd: %s\" % (funcName, vlanIdStr, vlanCmd))\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":PVLAN OVERLAY\"),\n                    \"Cannot have private-vlan config on VNI VLANs.\", devSerial)\n                respObj.setFailureRetCode()\n                return\n            freeformCfg += vlanRec[\"show_run\"]\n\n    # put all the non overlay SVI configs into the FF\n    for intfName in sorted(interfacesRes.keys()):\n        intfMatchResult = interfacesRes[intfName]\n        if isIntfProcessed(intfMatchResult):\n            continue\n\n        if not intfName.lower().startswith(\"vlan\"):\n            # not an SVI\n            continue\n\n        # mark the interface as processed\n        intfMatchResult.update({\"isProcessed\" : True})\n        #Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\" % (intfName, sys._getframe().f_lineno))\n\n        vlanIdStr = intfName[4:]\n        vlanId = int(vlanIdStr)\n        if ((vlanId in switchOverlayInfo[\"OVERLAY_VLANS\"]) or (vlanId == vpcVlanInt)):\n            # skip the overlay SVI and the VPC peer link vlan\n            continue\n\n        Wrapper.print(\"%s: Non Overlay SVI [%s]\" % (funcName, intfName))\n        freeformCfg.append(\"interface %s\" % intfName)\n        freeformCfg += intfMatchResult[\"show_run_cmds\"]\n\n    # collect all the non overlay related configs that need to be captured in the switch_config_freeform block\n    vrfMatchRes = matchResults[\"FEATURES_INFO\"][\"VRF_BLOCK\"]\n    for vrfStr in vrfMatchRes.keys():\n        vrfRec = vrfMatchRes[vrfStr]\n        vrfName = vrfStr.split(\" \")[2].strip()\n        #Wrapper.print(\"%s: Processing VRF [%s]\" % (funcName, vrfName))\n        \n        if vrfName.lower() == MGMT_VRF_NAME:\n            # the \"management\" vrf is already taken of earlier\n            continue\n\n        # capture the entire config for a non-overlay vrf\n        # Note: in upgrade case, only the non config profile aware CLIs will be present in 'show run'\n        if vrfName.lower() not in overlayVrfsNameToVni:\n            #Wrapper.print(\"%s: [%s]: show run CLI processing\" % (funcName, vrfName))\n            vrfFF = []\n            vrfKey = 'vrf context ' + vrfName\n            vrfRec = matchResults[\"FEATURES_INFO\"][\"VRF_BLOCK\"].get(vrfKey)\n            if vrfRec != None:\n                for line in vrfRec[\"show_run\"]:\n                    if line.strip().startswith(\"ip name-server\"):\n                        # the DNS config will be processed in another part of the code.. do not add to the VRF cfg\n                        continue\n                    vrfFF.append(line)\n\n            freeformCfg += vrfFF\n\n    switchOverlayInfo[\"PRE_INTF_FF\"] += freeformCfg\n\n    # form the 'router bgp <as>' key to lookup\n    routerBgpKey = \"router bgp \" + BGP_AS\n    if routerBgpKey in matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"]:\n        bgpVrfMatchRes = matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"][routerBgpKey]\n        freeformCfg = switchOverlayInfo[\"BGP_FF\"]\n        for bgpVrfName in bgpVrfMatchRes.keys():\n            if bgpVrfName == \"unaccounted\":\n                continue\n            bgpvrfRec = bgpVrfMatchRes[bgpVrfName]\n            vrfName = bgpVrfName.split(\" \")[1].strip()\n            #Wrapper.print(\"%s: Processing BGP VRF [%s]\" % (funcName, vrfName))\n\n            if vrfName.lower() not in overlayVrfsNameToVni:\n                #Wrapper.print(\"%s: BGP VRF [%s]: show run CLI processing\" % (funcName, vrfName))\n                freeformCfg += bgpvrfRec[\"show_run\"]\n\n    freeformCfg = []\n    if \"evpn\" in matchResults[\"FEATURES_INFO\"][\"EVPN_BLOCK\"]:\n        evpnMatchRes = matchResults[\"FEATURES_INFO\"][\"EVPN_BLOCK\"][\"evpn\"]\n        for evpnStr in evpnMatchRes.keys():\n            vniStr = evpnStr.split(\" \")[1].strip()\n            evpnRec = evpnMatchRes[evpnStr]\n            #Wrapper.print(\"%s: Processing EVPN VNI [%s]\" % (funcName, vniStr))\n\n            isValidOverlay = False\n\n            if (migrateMode == \"brownAdd\"):\n                vlanIdInfo = switchOverlayInfo[\"SWITCH_VXLAN_INFO\"][\"vlanIdInfo\"]\n                # map vni -> vlan id\n                if vniStr in vlanIdInfo[\"VNIS\"]:\n                    #Wrapper.print(\"%s: EVPN Vni [%s] has vlan\" % (funcName, vniStr))\n                    # check if the vlan is an overlay vlan\n                    vlanIdInt = int(vlanIdInfo[\"VNIS\"][vniStr])\n                    if vlanIdInt in switchOverlayInfo[\"OVERLAY_VLANS\"]:\n                        #Wrapper.print(\"%s: EVPN Vni [%s] Vlan [%d] is an overlay vni\" % (funcName, vniStr, vlanIdInt))\n                        isValidOverlay = True\n        \n            if not isValidOverlay:\n                freeformCfg += evpnRec[\"show_run\"]\n    switchOverlayInfo[\"POST_INTF_FF\"] += freeformCfg\n    Wrapper.print(\"%s %s: End - FABRIC [%s] Switch [%s] Role [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, formattedName, role))\n\ndef getVlanCfg(vlanIdStr, matchResults, includeAllCfg):\n    freeformCfg = \"\"\n    vlanKey = 'vlan ' + vlanIdStr\n    vlanRec = matchResults[\"FEATURES_INFO\"][\"VLAN_BLOCK\"].get(vlanKey)\n    if vlanRec != None:\n        if includeAllCfg:\n            freeformCfg += Util.newLine()\n            freeformCfg += Util.newLine().join(vlanRec[\"show_run\"])\n        else:\n            if len(vlanRec[\"unaccounted\"]) > 0:\n                freeformCfg += Util.newLine()\n                freeformCfg += Util.newLine().join(vlanRec[\"unaccounted\"])\n\n    return freeformCfg\n\ndef getSviCfg(vlanIdStr, interfacesRes, includeAllCfg, isVrf, servicesInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    freeformCfg = \"\"\n    sviName = 'Vlan'+ vlanIdStr\n    intfMatchResult = interfacesRes.get(sviName)\n    if intfMatchResult != None:\n        if includeAllCfg:\n            ffList = [\"interface \" + sviName]\n            if isVrf and servicesInfo and len(servicesInfo):\n                for cmd in intfMatchResult[\"show_run_cmds\"]:\n                    addCmd = True\n                    strippedCmd = cmd.strip()\n\n                    # need to filter out some services related config\n                    if strippedCmd.startswith(\"ip policy route-map \"):\n                        rmName = strippedCmd.split(\"ip policy route-map \")[1]\n                        for rmPrefix in servicesInfo[\"serviceRmPrefixStr\"]:\n                            if rmName.startswith(rmPrefix):\n                                addCmd = False\n                                break\n                    if addCmd:\n                        ffList.append(cmd)\n            else:\n                ffList += intfMatchResult[\"show_run_cmds\"]\n            freeformCfg += (Util.newLine() + Util.newLine().join(ffList))\n        else:\n            if len(intfMatchResult[\"unaccounted_cmds\"]) > 0:\n                Wrapper.print(\"%s: sviName [%s]. Unaccounted [%s]\" % (funcName, sviName, intfMatchResult[\"unaccounted_cmds\"]))\n\n                sviUnacctCmds = []\n\n                # - these commands have issues with negation. Ex: to remove 'no ip redirects' CC will issue 'ip redirects'\n                #   which causes the command to actually get removed on switch\n                overlaySpecialSviCmds = [\"no ip redirects\", \"no ipv6 redirects\"]\n                sviHasOtherUnaccCmds = False\n\n                # special case some overlay SVI commands.. the redirect and forward related configs do not\n                # have policies to match\n                overlaySviCmds = [\"ip forward\", \"ipv6 forward\", \"no shutdown\"]\n                for cmd in intfMatchResult[\"unaccounted_cmds\"]:\n                    strippedCmd = cmd.strip()\n                    if strippedCmd in overlaySviCmds:\n                        continue\n                    elif strippedCmd not in overlaySpecialSviCmds:\n                        sviHasOtherUnaccCmds = True\n\n                    sviUnacctCmds.append(cmd)\n\n                if \"vlan_interface\" in intfMatchResult[\"matched_templates\"]:\n                    # this policy being present indicates both the CLI are present.. add them \n                    for cmd in overlaySpecialSviCmds:\n                        sviUnacctCmds.append(INTF_FIRST_LVL_SPACING + cmd)\n                if \"pim_interface\" in intfMatchResult[\"matched_templates\"]:\n                    # this is a match, but, for Brownfield this needs to go to the freeform\n                    sviHasOtherUnaccCmds = True\n                    sviUnacctCmds.append(INTF_FIRST_LVL_SPACING + \"ip pim sparse-mode\")\n\n                Wrapper.print(\"%s: sviName [%s]. sviUnacctCmds [%s]\" % (funcName, sviName, sviUnacctCmds))\n                if len(sviUnacctCmds) > 0:\n                    finalCfgToAddToFreeform = None\n                    if sviHasOtherUnaccCmds:\n                        finalCfgToAddToFreeform = sviUnacctCmds\n\n                    if finalCfgToAddToFreeform:\n                        cfg = Util.newLine().join(finalCfgToAddToFreeform)\n                        freeformCfg += (Util.newLine() + \"interface \" + sviName + Util.newLine() + cfg)\n\n                        # we need to add the 'no shutdown' config to avoid an issue seen with CC trying to\n                        # remove individual config lines.. otherwise CC will generate 'shutdown' to negate 'no shutdown'\n                        if \"no_shut_interface\" in intfMatchResult[\"matched_templates\"]:\n                            freeformCfg += (Util.newLine() + (\"%sno shutdown\" % INTF_FIRST_LVL_SPACING))\n                        Wrapper.print(\"%s: sviName [%s]. freeformCfg [%s]\" % (funcName, sviName, freeformCfg))\n    return freeformCfg\n\ndef getNveCfg(vniStr, matchResults, isVrf, includeAllCfg):\n    freeformCfg = \"\"\n    intNveRec = matchResults[\"FEATURES_INFO\"][\"NVE_BLOCK\"].get(\"interface nve1\")\n    if intNveRec != None:\n        if isVrf:\n            nveVniKey = 'member vni ' + vniStr + ' associate-vrf'\n        else:\n            nveVniKey = 'member vni ' + vniStr\n\n        nveVniRec = intNveRec.get(nveVniKey)\n        if nveVniRec != None:\n            if includeAllCfg:\n                freeformCfg += Util.newLine()\n                freeformCfg += Util.newLine().join(nveVniRec[\"show_run\"])\n            else:\n                if len(nveVniRec[\"unaccounted\"]) > 0:\n                    freeformCfg += Util.newLine()\n                    freeformCfg += Util.newLine().join(nveVniRec[\"unaccounted\"])\n    return freeformCfg\n\ndef getVrfCfg(vrfName, matchResults, includeAllCfg):\n    freeformCfg = \"\"\n    vrfKey = 'vrf context ' + vrfName\n    vrfRec = matchResults[\"FEATURES_INFO\"][\"VRF_BLOCK\"].get(vrfKey)\n    if vrfRec != None:\n        if includeAllCfg:\n            nameServerCfgRemoved = False\n            newCfg = []\n            for line in vrfRec[\"show_run\"]:\n                if line.strip().startswith(\"ip name-server\"):\n                    # the DNS config will be processed in another part of the code.. do not add to the VRF cfg\n                    nameServerCfgRemoved = True\n                    continue\n                newCfg.append(line)\n\n            collectCfg = False\n            lenCfg = len(newCfg)\n            if lenCfg > 1:\n                collectCfg = True\n            else:\n                if not nameServerCfgRemoved:\n                    # there is a case of a dangling 'vrf context xxx' line in the 'show run'.. capture that too\n                    # if the unaccounted has any config\n                    if len(vrfRec[\"unaccounted\"]) == 0:\n                        collectCfg = True\n            if collectCfg:\n                freeformCfg += Util.newLine()\n                freeformCfg += Util.newLine().join(newCfg)\n        else:\n            unaccLen = len(vrfRec[\"unaccounted\"])\n            if unaccLen > 0:\n                # handle a special case for \"simplified\" overlay CLIs where the 'vrf context xxx' is as follows:\n                #   vrf context vrf50000\n                #       vni 50000\n                # \n                # This shows up as 'unaccounted' and gets captured in the vrf freeform\n                # look for this special condition and skip if found\n                collectCfg = True\n                if unaccLen == 2:\n                    if vrfRec[\"unaccounted\"][1].strip().startswith(\"vni \"):\n                        collectCfg = False\n                if collectCfg:\n                    freeformCfg += Util.newLine()\n                    freeformCfg += Util.newLine().join(vrfRec[\"unaccounted\"])\n    return freeformCfg\n\ndef getEvpnCfg(vniStr, matchResults, includeAllCfg):\n    freeformCfg = \"\"\n    evpnKey = \"evpn\"\n    \n    evpnRec = matchResults[\"FEATURES_INFO\"][\"EVPN_BLOCK\"].get(evpnKey)\n    if evpnRec != None:\n        vniKey = 'vni ' + vniStr + \" l2\"\n        vniRec = evpnRec.get(vniKey)\n        if vniRec != None:\n            if includeAllCfg:\n                freeformCfg += Util.newLine()\n                freeformCfg += Util.newLine().join(vniRec[\"show_run\"])\n            else:\n                if len(vniRec[\"unaccounted\"]) > 0:\n                    freeformCfg += Util.newLine()\n                    freeformCfg += Util.newLine().join(vniRec[\"unaccounted\"])\n    return freeformCfg\n\ndef isServiceInterTenanteBGPNeighbor(devSerial, servicesInfo, vrfName, neighborIp):\n    funcName = sys._getframe(0).f_code.co_name\n    # check if neighbor is v4\n\n    Wrapper.print(\"%s: switch [%s] vrfName [%s] neighborIp [%s]\" % (funcName, devSerial, vrfName, neighborIp))\n    # check if this VRF is part of a inter-tenant FW\n    for serviceNodeName in servicesInfo[\"serviceSwMaps\"][devSerial][\"nodes\"]:\n        serviceNodeEntry = servicesInfo[\"serviceNodes\"][serviceNodeName]\n\n        for routePeerName in serviceNodeEntry[\"routePeers\"]:\n            rpEntry = serviceNodeEntry[\"routePeers\"][routePeerName]\n            if rpEntry[\"peerOption\"] == \"none\":\n                continue\n\n            # look through the networks and see if the eBGP neighbor is the same subnet\n            for netTypeEntry in rpEntry[\"nets\"].values():\n                netEntry = servicesInfo[\"serviceNets\"][netTypeEntry[\"vni\"]]\n                if vrfName != netEntry[\"vrfName\"]:\n                    continue\n                neighborSubnet = Util.getSubnetStringWithPrefix(neighborIp, netEntry[\"mask\"])\n                if neighborSubnet == netEntry[\"subnet\"]:\n                    nvPairs = netTypeEntry[\"ptNvPairs\"]\n                    if \"NEIGHBOR_IP\" not in nvPairs:\n                        nvPairs[\"NEIGHBOR_IP\"] = neighborIp\n                    return {\"nvPairs\" : nvPairs, \"snEntry\" : serviceNodeEntry}\n\n    return None\n\ndef handleServiceLoopback(fabricName, devSerial, intfName, loopbackId, matchingNvPairs, globalOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    retVal = False\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n\n    Wrapper.print(\"%s: FAB [%s]: switch [%s] intf [%s] id [%s]\" % (funcName, fabricName, devSerial, intfName, loopbackId))\n    if not (servicesInfo and switchOverlayInfo[\"isServiceLeaf\"] and (intfName in servicesInfo[\"serviceSwMaps\"][devSerial][\"lo\"])):\n        # not a service leaf and/or not a loopback we are interested in\n        return retVal\n\n    # check if the specified loopback is part of a eBGP peering\n    for serviceNodeName in servicesInfo[\"serviceSwMaps\"][devSerial][\"nodes\"]:\n        serviceNodeEntry = servicesInfo[\"serviceNodes\"][serviceNodeName]\n\n        #Wrapper.print(\"%s: SN [%s] serviceNodeEntry %s\" % (funcName, serviceNodeName, serviceNodeEntry))\n        isvPCPeer = False\n        for routePeerName in serviceNodeEntry[\"routePeers\"]:\n            rpEntry = serviceNodeEntry[\"routePeers\"][routePeerName]\n            if rpEntry[\"peerOption\"] == \"none\":\n                continue\n\n            for netTypeEntry in rpEntry[\"nets\"].values():\n                #Wrapper.print(\"%s: SN [%s] netTypeEntry %s\" % (funcName, serviceNodeName, netTypeEntry))\n                nvPairs = netTypeEntry[\"ptNvPairs\"]\n                if devSerial == serviceNodeEntry[\"swSerial\"]:\n                    if nvPairs.get(\".nbrLoIntf\", None) != intfName:\n                        continue\n                else:\n                    if devSerial == serviceNodeEntry.get(\"peerSwSerial\", None):\n                        # vPC peer case\n                        isvPCPeer = True\n                        if nvPairs.get(\".peerNbrLoIntf\", None) != intfName:\n                            continue\n\n                nvPairs[\"ADMIN_STATE\"] = \"true\"\n                loopbackIp = None\n                rmTag = \"12345\"\n                for templateName in matchingNvPairs:\n                    matchEntry = matchingNvPairs[templateName]\n                    if (templateName == \"loopback_interface\"):\n                        loopbackIp = matchEntry[\"IP\"]\n                    elif (templateName == \"loopback_interface_with_tag\"):\n                        loopbackIp = matchEntry[\"IP\"]\n                        rmTag = matchEntry[\"ROUTE_MAP_TAG\"]\n                    elif (templateName == \"shut_interface\"):\n                        nvPairs[\"ADMIN_STATE\"] = \"false\"\n\n                if loopbackIp:\n                    if \"LOOPBACK_IP\" not in nvPairs:\n                        nvPairs[\"LOOPBACK_IP\"] = loopbackIp\n                        nvPairs[\"ROUTE_MAP_TAG\"] = rmTag\n                    else:\n                        # vpc peer case\n                        nvPairs[\"PEER_LOOPBACK_IP\"] = loopbackIp\n\n                # set RM for the loopback id\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                entityName = (\"bgp_%s_%s\" % (servicesInfo[\"serviceNets\"][netTypeEntry[\"vni\"]][\"vrfName\"], nvPairs[\"NEIGHBOR_IP\"]))\n                Wrapper.print(\"%s: FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] entityName [%s]\" %\n                              (funcName, fabricName, key, loopbackId, entityName))\n                Util.exe(RM.set(fabricName, \"LOOPBACK_ID\", key, entityName, loopbackId))\n\n                return True\n\n    return retVal\n\ndef getVrfFreeformCfg(devSerial, vrfName, vrfVniStr, vrfVlanStr, matchResults, interfacesRes,\n                                                        includeAllCfg, switchOverlayInfo, servicesInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: vrfName [%s] vrfVni [%s] vrfVlanStr [%s] includeAllCfg [%r]\" % (funcName, vrfName,\n            vrfVniStr, vrfVlanStr, includeAllCfg))\n    freeformCfg = getVlanCfg(vrfVlanStr, matchResults, includeAllCfg)\n    freeformCfg += getSviCfg(vrfVlanStr, interfacesRes, includeAllCfg, True, servicesInfo)\n    freeformCfg += getVrfCfg(vrfName, matchResults, includeAllCfg)\n    freeformCfg += getNveCfg(vrfVniStr, matchResults, True, includeAllCfg)\n    freeformCfg += getEvpnCfg(vrfVniStr, matchResults, includeAllCfg)\n\n    filteredFF = [\"\"]\n    routerBgpKey = \"router bgp \" + BGP_AS\n    bgpRec = matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"].get(routerBgpKey)\n    if bgpRec != None:\n        vrfKey = 'vrf ' + vrfName\n        vrfRec = bgpRec.get(vrfKey)\n        if vrfRec != None:\n            if includeAllCfg:\n                if (switchOverlayInfo[\"isServiceLeaf\"] and (vrfName in servicesInfo[\"serviceSwMaps\"][devSerial][\"vrfs\"])):\n                    matchDict = None\n                    bgpVrfFF = []\n                    for line in vrfRec[\"show_run\"]:\n                        depth = (len(line) - len(line.lstrip(' '))) / 2\n                        #Wrapper.print(\"%s: line [%s] depth [%d] matchDict [%s]\" % (funcName, line, depth, matchDict))\n                        if depth == 0:\n                            matchDict = None\n                        elif depth == 1:\n                            matchDict = None\n                        elif depth == 2:\n                            matchDict = None\n                            strippedLine = line.strip()\n                            parts = strippedLine.split(\" \")\n                            if len(parts) == 2:\n                                if parts[0] == \"neighbor\":\n                                    matchDict = isServiceInterTenanteBGPNeighbor(devSerial, servicesInfo, vrfName, parts[1])\n                        elif depth == 3:\n                            if matchDict:\n                                ptNvPairs = matchDict[\"nvPairs\"]\n                                strippedLine = line.strip()\n                                parts = strippedLine.split(\" \")\n                                if len(parts) == 2:\n                                    if parts[0] == \"remote-as\":\n                                        if \"NEIGHBOR_ASN\" not in ptNvPairs:\n                                            ptNvPairs[\"NEIGHBOR_ASN\"] = parts[1]\n                                    elif parts[0] == \"update-source\":\n                                        snEntry = matchDict[\"snEntry\"]\n                                        # will be processed further later\n                                        if (snEntry[\"swSerial\"] == devSerial):\n                                            if (\".nbrLoIntf\" not in ptNvPairs):\n                                                ptNvPairs[\".nbrLoIntf\"] = parts[1]\n                                        elif \".peerNbrLoIntf\" not in ptNvPairs:\n                                            # vpc peer case\n                                            ptNvPairs[\".peerNbrLoIntf\"] = parts[1]\n\n                                        loList = servicesInfo[\"serviceSwMaps\"][devSerial][\"lo\"]\n                                        if parts[1] not in loList:\n                                            loList.append(parts[1])\n\n                        if matchDict == None:\n                            #Wrapper.print(\"%s: adding line [%s] to bgpVrfFF\" % (funcName, line))\n                            bgpVrfFF.append(line)\n                    # make sure the freeform has some valid configs\n                    #Wrapper.print(\"%s:  bgpVrfFF %s\" % (funcName, bgpVrfFF))\n                    if len(bgpVrfFF) > 2:\n                        filteredFF.extend(bgpVrfFF)\n                else:\n                    filteredFF.extend(vrfRec[\"show_run\"])\n            else:\n                if len(vrfRec[\"unaccounted\"]) > 0:\n                    filteredFF.extend(vrfRec[\"unaccounted\"])\n\n    if len(filteredFF):\n        freeformCfg += Util.newLine().join(filteredFF)\n\n    return freeformCfg.strip()\n\ndef getNetworkFreeformCfg(netVniStr, netVlanStr, matchResults, interfacesRes, includeAllCfg):\n    Wrapper.print(\"getNetworkFreeformCfg: netVni [%s] netVlanStr [%s]\" % (netVniStr, netVlanStr))\n\n    freeformCfg = getVlanCfg(netVlanStr, matchResults, includeAllCfg)\n    freeformCfg += getSviCfg(netVlanStr, interfacesRes, includeAllCfg, False, None)\n    freeformCfg += getNveCfg(netVniStr, matchResults, False, includeAllCfg)\n    freeformCfg += getEvpnCfg(netVniStr, matchResults, includeAllCfg)\n\n    return freeformCfg.strip()\n\ndef processOverlayAttachments(devSerial, switchOverlayInfo, globalOverlayInfo, allOverlayNets):\n    funcName = sys._getframe(0).f_code.co_name\n    switchDict = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n    Wrapper.print(\"%s: Switch [%s] - Is Extn [%s]\" % (funcName, switchDict[\"fmtName\"], switchOverlayInfo[\"doOverlayExtn\"]))\n\n    # process each of the VRF entries\n    for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n        vrfName = vrfEntry[\"name\"]\n        vrfVniId = vrfEntry[\"vni\"]\n        vrfAttachVlan = vrfEntry[\"vlanId\"]\n        configProfName = vrfEntry[\"cfgProfileName\"] if (\"cfgProfileName\" in vrfEntry) else None\n\n        \"\"\"\n        Wrapper.print(\"%s: Switch [%s] - Attaching for VRF [%s] VNI [%s] Profile Name [%s] Vlan [%d] instanceVals [%s] \"\n            \"Freeform [%s] Extension Vals [%s]\" % (funcName, switchDict[\"fmtName\"], vrfName, vrfVniId, configProfName,\n            vrfAttachVlan, vrfEntry[\"instanceVals\"], vrfEntry[\"freeformCfg\"], vrfEntry[\"extensionVals\"]))\n        \"\"\"\n\n        # check if the vrf entry exists in the global info db\n        if vrfVniId not in globalOverlayInfo[\"VRF_ATTACH\"]:\n            vrfAttachEntry = LanAttachByVRF()\n            vrfAttachEntry.setVrfName(vrfName)\n            vrfAttachEntry.setLanAttachList([])\n\n            globalOverlayInfo[\"VRF_ATTACH\"][vrfVniId] = vrfAttachEntry\n\n        # add an entry for this switch to the list\n        vrfSwitchAttach = LanVRFAttach()\n        vrfSwitchAttach.setFabric(FABRIC_NAME)\n        vrfSwitchAttach.setSerialNumber(devSerial)\n        vrfSwitchAttach.setVlan(vrfAttachVlan)\n        vrfSwitchAttach.setVrfName(vrfName)\n        if configProfName:\n            vrfSwitchAttach.setProfileName(configProfName)\n        vrfSwitchAttach.setExtensionValues(vrfEntry[\"extensionVals\"])\n        vrfSwitchAttach.setDeployment(True)\n        vrfSwitchAttach.setInstanceValues(vrfEntry[\"instanceVals\"])\n        vrfSwitchAttach.setFreeformConfig(vrfEntry[\"freeformCfg\"])\n\n        vrfAttachEntry = globalOverlayInfo[\"VRF_ATTACH\"][vrfVniId]\n        attachList = vrfAttachEntry.getLanAttachList()\n        attachList.append(vrfSwitchAttach)\n        vrfAttachEntry.setLanAttachList(attachList)\n\n    # process each of the network attachment entries\n    for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n\n        refNetEntry = allOverlayNets[netEntry[\"vni\"]][\"netEntry\"]\n        refNetName = refNetEntry[\"overlayNetName\"] if refNetEntry[\"overlayNetName\"] else refNetEntry[\"cfgProfileName\"]\n        configProfName = netEntry[\"cfgProfileName\"] if ((\"cfgProfileName\" in netEntry) and refNetEntry[\"overlayNetName\"]) else None\n\n        \"\"\"\n        Wrapper.print(\"%s: Switch [%s] - Attaching for network [%s/%s] Profile Name [%s] interfaces = [%s] Freeform [%s]\" % \n            (funcName, switchDict[\"fmtName\"], netEntry[\"vni\"], refNetName, configProfName, \n                netEntry[\"attachInfo\"], netEntry[\"freeformCfg\"]))\n        \"\"\"\n\n        # check if the network entry exists in the global info db\n        vniStr = str(netEntry[\"vni\"])\n        if vniStr in globalOverlayInfo[\"NETWORK_ATTACH\"]:\n            netAttach = globalOverlayInfo[\"NETWORK_ATTACH\"][vniStr]\n        else:\n            netAttach = LanAttachByNetwork()\n            netAttach.setNetworkName(refNetName)\n            netAttach.setLanAttachList([])\n\n            globalOverlayInfo[\"NETWORK_ATTACH\"][vniStr] = netAttach\n\n        # add a new attach entry for this switch\n        lanAttach = LanAttach()\n        lanAttach.setFabric(FABRIC_NAME)\n        lanAttach.setNetworkName(refNetName)\n        if configProfName:\n            # we have a network name that is different from the config profile name.. set the config profile name\n            lanAttach.setProfileName(configProfName)\n        lanAttach.setSerialNumber(devSerial)\n        lanAttach.setSwitchPorts(\",\".join(netEntry[\"attachInfo\"]))\n        lanAttach.setDetachSwitchPorts(\"\")\n        lanAttach.setVlan(netEntry[\"vlanId\"])\n        lanAttach.setDot1QVlan(1)\n        lanAttach.setUntagged(False)\n        lanAttach.setDeployment(True)\n        lanAttach.setExtensionValues(netEntry[\"extensionVals\"])\n        lanAttach.setInstanceValues(\"\")\n        lanAttach.setFreeformConfig(netEntry[\"freeformCfg\"])\n\n        attachList = netAttach.getLanAttachList()\n        attachList.append(lanAttach)\n        netAttach.setLanAttachList(attachList)\n\ndef ECLVrfSviLocalInfo(vrfName, vrfSviInfo, localFlag):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s(): vrfName [%s] localFlag [%s] vrfSviInfo[%s]\"%\n                  (funcName, vrfName, localFlag, vrfSviInfo))\n    info = {}\n    if localFlag:\n        try:\n            info = vrfSviInfo[vrfName][\"local\"]\n        except:\n            Wrapper.print(\"failed for info vrf %s\"%(vrfName))\n            pass\n    else:\n         try:\n            info = vrfSviInfo[vrfName][\"peer\"]\n         except:\n            Wrapper.print(\"failed for peerInfo vrf %s\"%(vrfName))\n            pass\n    return info\n     \ndef isSameSubnet(ipAddr1, ipAddr2):\n    sameSnet = False\n    try:\n        sameSnet = Util.exe(FabricWrapper.isSameIp4Or6NwAddr(ipAddr1, ipAddr2))\n    except:\n        pass\n    return sameSnet\n\ndef ECLPrepareVrfInstanceValues(fabricName, devices, globalOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Entering====\"%(funcName))\n\n    #VLP VRF <-> LITE PROTOCOL \n    ospfVLP = True if VRF_LITE_PROTOCOL == \"ospf\" else False\n    bgpVLP = True if VRF_LITE_PROTOCOL == \"ebgp\" else False\n    if not (ospfVLP or bgpVLP):\n        return\n\n    switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"]\n    aggSwitches = []\n    for devSerial in devices:\n        dict = switchInfoDict[devSerial]\n        if \"aggregation\" in dict[\"switchRole\"].lower():\n            aggSwitches.append(devSerial)\n    vrfNghborIpDeviceInfoDict = {}\n    vrfNghborIp4InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp4InfoDict\"] = {} \n    vrfNghborIp6InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp6InfoDict\"] = {}\n    vrfSviInstanceValues = {}\n    ECLGetVrfNeighborIpInfo(fabricName, devices, globalOverlayInfo, vrfNghborIpDeviceInfoDict)\n    vrfSviInfo = ECLGetVrfSviInfo(fabricName, devices, globalOverlayInfo, vrfNghborIpDeviceInfoDict)\n    if not vrfSviInfo:\n        return vrfSviInstanceValues\n\n    ignorePairSwitch = []\n    for devSerial in aggSwitches:\n        if devSerial not in ignorePairSwitch:\n            sn = devSerial\n            peerSn = Util.getVpcPeerSwitch(devSerial, fabricName)\n            ignorePairSwitch.append(peerSn)\n            switchOverlayInfo  = globalOverlayInfo[\"SWITCH_OVERLAYS\"][sn]\n            vrfInfo = switchOverlayInfo[\"VRFS_BY_ID\"]\n            vrfNameList = vrfInfo.keys()\n            for vrfName in vrfSviInfo:\n                if vrfName not in vrfNameList: \n                    Wrapper.print(\"%s(): combined-device [%s~%s] skip non-relavent vrf [%s]\"%(funcName, sn, peerSn, vrfName))\n                    continue\n                \"\"\"\n                if bgpVLP:\n                    vrfNghborIp4Info = vrfNghborIp4InfoDict.get(vrfName)\n                    Wrapper.print(\"%s(): combined-device [%s~%s] vrf [%s] vrfNghborIp4Info [%s]\"%(funcName, sn, peerSn, vrfName, vrfNghborIp4Info))\n                    localSnIp4NbrListInfo = vrfNghborIp4Info.get(sn) if vrfNghborIp4Info else None\n                    peerSnIp4NbrListInfo = vrfNghborIp4Info.get(peerSn) if vrfNghborIp4Info else None\n\n                    vrfNghborIp6Info = vrfNghborIp6InfoDict.get(vrfName)\n                    Wrapper.print(\"%s(): combined-device [%s~%s] vrf [%s] vrfNghborIp6Info [%s]\"%(funcName, sn, peerSn, vrfName, vrfNghborIp6Info))\n                    localSnIp6NbrListInfo = vrfNghborIp6Info.get(sn) if vrfNghborIp6Info else None\n                    peerSnIp6NbrListInfo = vrfNghborIp6Info.get(peerSn) if vrfNghborIp6Info else None\n\n                    if not((localSnIp4NbrListInfo and peerSnIp4NbrListInfo) or\n                           (localSnIp6NbrListInfo and peerSnIp6NbrListInfo)):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] localv4[%s] and peer4[%s] \"\n                                      \"or localv6[%s] and peerv6[%s] should be there\"%\n                                      (funcName, sn, peerSn, localSnIp4NbrListInfo, peerSnIp4NbrListInfo,\n                                      localSnIp6NbrListInfo, peerSnIp6NbrListInfo))\n                        continue\n                \"\"\"\n                sn1VrfInfo = ECLVrfSviLocalInfo(vrfName, vrfSviInfo, True)\n                sn2VrfInfo = ECLVrfSviLocalInfo(vrfName, vrfSviInfo, False)\n                localSnVrfInfo = {}\n                peerSnVrfInfo = {}\n                localSnVrfInfo = sn1VrfInfo.get(sn) if sn1VrfInfo.get(sn) else sn2VrfInfo.get(sn)\n                peerSnVrfInfo =  sn1VrfInfo.get(peerSn) if sn1VrfInfo.get(peerSn) else sn2VrfInfo.get(peerSn)\n\n                Wrapper.print(\"%s(): combined-device [%s~%s] vrf [%s] localSnVrfInfo [%s] peerSnVrfInfo[%s]\"%\n                              (funcName, sn, peerSn, vrfName, localSnVrfInfo, peerSnVrfInfo))\n                if not(localSnVrfInfo and peerSnVrfInfo):\n                    Wrapper.print(\"%s(): combined-device [%s~%s] vrfName [%s] skip if local[%s] and peer [%s] vrfInfo \"\n                                  \"both are not there\"%(funcName, sn, peerSn, vrfName, str(localSnVrfInfo), \n                                  str(peerSnVrfInfo)))\n                    continue\n                ipv4Snet = ipv4SnetPeer = \"\"\n                ip4 = localSnVrfInfo['ip4'] \n                pfx4 = localSnVrfInfo['prefix4']\n                ip4Peer = peerSnVrfInfo['ip4'] \n                pfx4Peer = peerSnVrfInfo['prefix4']\n                if ip4 and pfx4 and ip4Peer and pfx4Peer:\n                    ipv4Snet = ip4 + \"/\" + pfx4\n                    ipv4SnetPeer = ip4Peer + \"/\" + pfx4Peer\n                    if not isSameSubnet(ipv4Snet, ipv4SnetPeer):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip not same subnet Ips \"\n                                      \"ipv4Snet[%s]<-->ipv4SnetPeer[%s]\"%\n                                      (funcName, sn, peerSn, vrfName, ipv4Snet, ipv4SnetPeer))\n                        continue\n\n                ipv6Snet = ipv6SnetPeer = \"\"\n                ip6 = localSnVrfInfo['ip6']\n                pfx6 = localSnVrfInfo['prefix6']\n                ip6Peer = peerSnVrfInfo['ip6']\n                pfx6Peer = peerSnVrfInfo['prefix6']\n                if ip6 and pfx6 and ip6Peer and pfx6Peer:\n                    ipv6Snet = ip6 + \"/\" + pfx6\n                    ipv6SnetPeer = ip6Peer + \"/\" + pfx6Peer\n                    if not isSameSubnet(ipv6Snet, ipv6SnetPeer):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip not same subnet Ips \"\n                                      \"ipv6Snet[%s]<-->ipv6SnetPeer[%s]\"%\n                                     (funcName, sn, peerSn, vrfName, ipv6Snet, ipv6SnetPeer))\n                        continue\n\n                ip4Present = False if not (ipv4Snet and ipv4SnetPeer) else True\n                ip6Present = False if not (ipv6Snet and ipv6SnetPeer) else True\n\n                if not (ip4Present or ip6Present):\n                    continue\n                Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] pfx4 [%s] pfx4Peer [%s] pfx6 [%s] pfx6Peer [%s]\"%\n                                     (funcName, sn, peerSn, vrfName, pfx4, pfx4Peer, pfx6, pfx6Peer))\n                \"\"\"\n                matchingIp4VrfSviLocal = False\n                matchingIp4VrfSviPeer = False\n                matchingIp6VrfSviLocal = False\n                matchingIp6VrfSviPeer = False\n\n                Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] localSnIp4NbrListInfo [%s] peerSnIp4NbrListInfo [%s]\"%\n                                     (funcName, sn, peerSn, vrfName, str(localSnIp4NbrListInfo), str(peerSnIp4NbrListInfo)))\n                Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] localSnIp6NbrListInfo [%s] peerSnIp6NbrListInfo [%s]\"%\n                                     (funcName, sn, peerSn, vrfName, str(localSnIp6NbrListInfo), str(peerSnIp6NbrListInfo)))\n                for peerNghbrIp in peerSnIp4NbrListInfo:\n                    if not (peerNghbrIp and pfx4):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip possible misconfig\"\n                                      \"on svi peerNghbrIp [%s] or pfx4[%s]\"%\n                                      (funcName, sn, peerSn, vrfName, peerNghbrIp, pfx4))\n                        continue\n                    peerNghbrIpSnet = peerNghbrIp + \"/\" + pfx4\n                    if isSameSubnet(ipv4Snet, peerNghbrIpSnet):\n                        matchingVrfSviLocal = True\n\n                for localNghbrIp in localSnIp4NbrListInfo:\n                    if not (localNghbrIp and pfx4Peer):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip possible misconfig \"\n                                      \"on svi localNghbrIp [%s] or pfx4Peer[%s]\"%\n                                      (funcName, sn, peerSn, vrfName, localNghbrIp, pfx4Peer))\n                        continue\n                    localNghbrIpSnet = localNghbrIp + \"/\" + pfx4Peer\n                    if isSameSubnet(ipv4SnetPeer, localNghbrIpSnet):\n                        matchingVrfSviPeer = True\n                for peerNghbrIp6 in peerSnIp6NbrListInfo:\n                    if not (peerNghbrIp6 and pfx6):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip possible misconfig \"\n                                      \"on svi peerNghbrIp6 [%s] or pfx6[%s]\"%\n                                      (funcName, sn, peerSn, vrfName, peerNghbrIp6, pfx6))\n                        continue\n \n                    peerNghbrIp6Snet = peerNghbrIp6 + \"/\" + pfx6\n                    if isSameSubnet(ipv6Snet, peerNghbrIp6Snet):\n                        matchingIp6VrfSviLocal = True\n                for localNghbrIp6 in localSnIp6NbrListInfo:\n                    if not (localNghbrIp6 and pfx6Peer):\n                        Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip possible misconfig \"\n                                      \"on svi localNghbrIp6 [%s] or pfx6Peer[%s]\"%\n                                      (funcName, sn, peerSn, vrfName, localNghbrIp6, pfx6Peer))\n                        continue\n                    localNghbrIp6Snet = localNghbrIp6 + \"/\" + pfx6Peer\n                    if isSameSubnet(ipv6SnetPeer, localNghbrIp6Snet):\n                        matchingIp6VrfSviPeer = True\n                if not ((matchingVrfSviLocal and matchingVrfSviPeer) or \n                        (matchingIp6VrfSviLocal and matchingIp6VrfSviPeer)):\n                    Wrapper.print(\"%s(): combined-device [%s~%s] vrfName[%s] skip not matching nbr Ips \"\n                                  \"matchingVrfSviLocal[%s]<-->matchingVrfSviPeer[%s] or \"\n                                  \"matchingIp6VrfSviLocal[%s]<-->matchingIp6VrfSviPeer[%s]\"%\n                                  (funcName, sn, peerSn, vrfName, matchingVrfSviLocal, matchingVrfSviPeer,\n                                   matchingIp6VrfSviLocal, matchingIp6VrfSviPeer))\n                    continue\n                \"\"\"\n                vrfInstanceDict = {}\n                Wrapper.print(\"%s(): sn [%s] <---> peerSn[%s] vrfname=[%s] localSnVrfInfo[%s] peerSnVrfInfo[%s]\"%\n                              (funcName, sn, peerSn, vrfName, localSnVrfInfo, peerSnVrfInfo))\n                snEntry = {}\n                snEntry[\"local\"] = {sn: localSnVrfInfo}\n                peerSnEntry = {}\n                snEntry[\"peer\"] = {peerSn: peerSnVrfInfo}\n                if not vrfSviInstanceValues.get(vrfName):\n                    vrfSviInstanceValues[vrfName] = {}\n                vrfSviInstanceValues[vrfName].update(snEntry)\n                vrfSviInstanceValues[vrfName].update(peerSnEntry)\n    Wrapper.print(\"%s() vrfSviInstanceValues %s\"%(funcName, vrfSviInstanceValues)) \n    Wrapper.print(\"%s():====Exiting====\"%(funcName))\n    return vrfSviInstanceValues\n\ndef ECLGetNbrList(vrfFreeformList, bgpAs, nghbrIp4List, nghbrIp6List):\n    length = len(vrfFreeformList)\n    for i in range (length):\n        remoteAs = \"    remote-as \" + bgpAs\n        if i < length-1:\n            x = vrfFreeformList[i]\n            x1 = vrfFreeformList[i+1]\n            if \"  neighbor\" in x and remoteAs in x1 and \":\" in x:\n                nghbrIp6List.append(x.lstrip(\"  neighbor \"))\n            elif \"  neighbor\" in x and remoteAs in x1 and \":\" not in x:\n                nghbrIp4List.append(x.lstrip(\"  neighbor \"))\n    return\n\ndef ECLGetVrfNeighborIp4OrIp6(devSerial, vrfName, overlayVrfsInfoById, matchResults):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Entering====\"%(funcName))\n    ip4, ip6 = (False, False)\n    if not matchResults:\n        Wrapper.print(\"%s() devSerial[%s] empty matchResults[%s]\"%(funcName, devSerial, matchResults))\n        return (False, False)\n    \n    if overlayVrfsInfoById:\n        swEntryIp4 = {}\n        swEntryIp6 = {}\n        vrfNameList = overlayVrfsInfoById.keys()\n        Wrapper.print(\"%s() devSerial[%s] vrfNameList[%s]\"%(funcName, devSerial, vrfNameList))\n        if vrfName in vrfNameList or vrfName == \"default\":\n            vrfFreeformList = []\n            if vrfName == \"default\":\n                featuresInfo = matchResults[\"FEATURES_INFO\"]\n                bgpBlock = featuresInfo[\"BGP_BLOCK\"]\n                bgpAsKey = \"router bgp \" + BGP_AS\n                defaultVrfUnacc = bgpBlock.get(bgpAsKey)\n                if defaultVrfUnacc:\n                    vrfFreeformList = defaultVrfUnacc.get(\"unaccounted\")\n            else:\n                vrfFreeformInfo = vrfInfo[vrfName][\"freeformCfg\"]\n                vrfFreeformList = vrfFreeformInfo.splitlines()\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] vrfFreeformList[%s]\"%(funcName, devSerial, vrfName, vrfFreeformList))\n            if not vrfFreeformList:\n                return (False, False)\n            nghbrIp4List = []\n            nghbrIp6List = []\n            ECLGetNbrList(vrfFreeformList, BGP_AS, nghbrIp4List, nghbrIp6List)\n            if not (nghbrIp4List or nghbrIp6List):\n                Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] skip without nbrIp4[%s] or nbrIp6[%s] list \"%\n                              (funcName, devSerial, vrfName, nghbrIp4List, nghbrIp6List))\n                return (False, False)\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] nghbrIp4List[%s]\"%(funcName, devSerial, vrfName, nghbrIp4List))\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] nghbrIp6List[%s]\"%(funcName, devSerial, vrfName, nghbrIp6List))\n            if len(nghbrIp4List) > 0:\n                ip4 = True\n            if len(nghbrIp6List) > 0:\n                ip6 = True\n    Wrapper.print(\"%s():====Exiting====\"%(funcName))\n    return (ip4, ip6)\n\ndef ECLGetVrfNeighborIpInfo(fabricName, devices, globalOverlayInfo, vrfNghborIpDeviceInfoDict):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Entering====\"%(funcName))\n    if VRF_LITE_PROTOCOL != \"ebgp\":\n        return\n    switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"]\n    aggSwitches = []\n    for devSerial in devices:\n         dict = switchInfoDict[devSerial]\n         if \"aggregation\" in dict[\"switchRole\"].lower():\n             aggSwitches.append(devSerial)\n    \n    vrfNghborIp4InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp4InfoDict\"]\n    vrfNghborIp6InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp6InfoDict\"]\n    for devSerial in aggSwitches:\n        switchOverlayInfo  = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n        vrfInfo = switchOverlayInfo[\"VRFS_BY_ID\"]\n        vrfNameList = vrfInfo.keys()\n        for vrfName in vrfNameList:\n            swEntryIp4 = {}\n            swEntryIp6 = {}\n            vrfFreeformList = []\n            if vrfName == \"default\":\n                switchDict = switchInfoDict[devSerial]\n                matchResult = Util.exe(getJSONFileContents(switchDict[\"matchResultsFileName\"]))\n                if not matchResult:\n                    continue\n                #Wrapper.print(\"matchResult [%s]\"%(matchResult))\n                featuresInfo = matchResult[\"FEATURES_INFO\"]\n                bgpBlock = featuresInfo[\"BGP_BLOCK\"]\n                bgpAsKey = \"router bgp \" + BGP_AS\n                defaultVrfUnacc = bgpBlock.get(bgpAsKey)\n                if defaultVrfUnacc: \n                    vrfFreeformList = defaultVrfUnacc.get(\"unaccounted\")\n            else:\n                vrfFreeformInfo = vrfInfo[vrfName][\"freeformCfg\"]\n                vrfFreeformList = vrfFreeformInfo.splitlines()\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] vrfFreeformList[%s]\"%(funcName, devSerial, vrfName, vrfFreeformList))\n            if not vrfFreeformList:\n                continue\n            nghbrIp4List = []\n            nghbrIp6List = []\n            ECLGetNbrList(vrfFreeformList, BGP_AS, nghbrIp4List, nghbrIp6List)\n            if not (nghbrIp4List or nghbrIp6List):\n                Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] skip without nbrIp4[%s] or nbrIp6[%s] list \"%\n                              (funcName, devSerial, vrfName, nghbrIp4List, nghbrIp6List))\n                continue\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] nghbrIp4List[%s]\"%(funcName, devSerial, vrfName, nghbrIp4List))\n            Wrapper.print(\"%s(): devSerial [%s] vrfname [%s] nghbrIp6List[%s]\"%(funcName, devSerial, vrfName, nghbrIp6List))\n            swEntryIp4.update({devSerial:nghbrIp4List})\n            swEntryIp6.update({devSerial:nghbrIp6List})\n            if not vrfNghborIp4InfoDict.get(vrfName):\n                vrfNghborIp4InfoDict[vrfName] = {}\n            vrfNghborIp4InfoDict[vrfName].update(swEntryIp4)\n            if not vrfNghborIp6InfoDict.get(vrfName):\n                vrfNghborIp6InfoDict[vrfName] = {}\n            vrfNghborIp6InfoDict[vrfName].update(swEntryIp6)\n    Wrapper.print(\"%s(): devSerial [%s] vrfNghborIp4InfoDict[%s]\"%(funcName, devSerial, vrfNghborIp4InfoDict))\n    Wrapper.print(\"%s(): devSerial [%s] vrfNghborIp6InfoDict[%s]\"%(funcName, devSerial, vrfNghborIp6InfoDict))\n    Wrapper.print(\"%s():====Exiting====\"%(funcName))\n\n\n'''\n#####\n# aggregation vpc pair switches.\n# get s1 int_vlan ptis\n# get s2 int_vlan ptis\n# make combined dictonary which is based on vrf\n# if s1: ipv4 and s2 ipv4 are in same subnet\n# vrf1 = {local: {s1:{vlan:vlanId, ip4:ipv4Val,}}, peer:{s2:{vlan:vlanId, ip4:ip4Val}}}\n# vrf2 = {local: {s1:{vlan:vlanId, ip4:ipv4Val,}}, peer:{s2:{vlan:vlanId, ip4:ip4Val}}}\n#\n####\n'''\n#check if local ip is in peer nbr ip\ndef validInstValBgpNbr(validateInputDict):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Enter====\"%(funcName))\n    vrfName     = validateInputDict.get(\"vrfName\")\n    vlanId      = validateInputDict.get(\"vlanId\")\n    sn          = validateInputDict.get(\"sn\")\n    peerSn      = validateInputDict.get(\"peerSn\")\n    ip4         = validateInputDict.get(\"ip4\")\n    ip6         = validateInputDict.get(\"ip6\")\n    vrfNghborIp4InfoDict = validateInputDict.get(\"vrfNghborIp4InfoDict\")\n    vrfNghborIp6InfoDict = validateInputDict.get(\"vrfNghborIp6InfoDict\")\n\n    peerSwNbrIp4List = []\n    peerSwNbrIp6List = []\n    vrfNghborIp4VrfInfo = vrfNghborIp4InfoDict.get(vrfName)\n    vrfNghborIp6VrfInfo = vrfNghborIp6InfoDict.get(vrfName)\n    if vrfNghborIp4VrfInfo:\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] is my peer here on interest, vrfNghborIp4VrfInfo[%s]\"%\n                      (vlanId, vrfName, peerSn, vrfNghborIp4VrfInfo))\n        peerSwNbrIp4List = vrfNghborIp4VrfInfo.get(peerSn, [])\n    if vrfNghborIp6VrfInfo:\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] is my peer here on interest, vrfNghborIp6VrfInfo[%s]\"%\n                      (vlanId, vrfName, peerSn, vrfNghborIp6VrfInfo))\n        peerSwNbrIp6List = vrfNghborIp6VrfInfo.get(peerSn, [])\n    if not (peerSwNbrIp4List or peerSwNbrIp6List):\n        Wrapper.print(\"%s(): continue without nhbrList local sn [%s] peerSn [%s] vlanId [%s] vrfName [%s]\"%(funcName, sn, peerSn, vlanId, vrfName))\n        return False\n    if (not((ip4 and vrfName and ip4 in peerSwNbrIp4List) or\n            (ip6 and vrfName and ip6 in peerSwNbrIp6List))):\n        Wrapper.print(\"%s(): Skip unwanted vlans sn [%s] vlanId [%s] vrfName [%s] ip4[%s] ip6[%s] peerSwNbrIp4List[%s] peerSwNbrIp6List[%s]\"%\n                  (funcName, sn, vlanId, vrfName, ip4, ip6, peerSwNbrIp4List, peerSwNbrIp6List))\n        return False\n    Wrapper.print(\"%s():====Exit====\"%(funcName))\n    return True\n\n#check if tag and area are matching\ndef validInstValOspfNbr(validateInputDict):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Enter====\"%(funcName))\n    vrfName     = validateInputDict.get(\"vrfName\")\n    vrfName     = validateInputDict.get(\"vrfName\")\n    vlanId      = validateInputDict.get(\"vlanId\")\n    sn          = validateInputDict.get(\"sn\")\n    peerSn      = validateInputDict.get(\"peerSn\")\n    ip4         = validateInputDict.get(\"ip4\")\n    ip6         = validateInputDict.get(\"ip6\")\n    vlanPtiInfoDict     = validateInputDict.get(\"vlanPtiInfoDict\")\n    vlanPtiInfoPeerDict = validateInputDict.get(\"vlanPtiInfoPeerDict\")\n\n\n    sviVlanIdToOspfTagDict          = vlanPtiInfoDict[\"sviVlanIdToOspfTagDict\"]  \n    sviVlanIdToOspfTagPeerDict      = vlanPtiInfoPeerDict[\"sviVlanIdToOspfTagPeerDict\"]\n    sviVlanIdToOspfAreaIdDict       = vlanPtiInfoDict[\"sviVlanIdToOspfAreaIdDict\"]\n    sviVlanIdToOspfAreadIdPeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToOspfAreadIdPeerDict\"]\n\n    sviVlanIdToOspf3TagDict         = vlanPtiInfoDict[\"sviVlanIdToOspf3TagDict\"]\n    sviVlanIdToOspf3TagPeerDict     = vlanPtiInfoPeerDict[\"sviVlanIdToOspf3TagPeerDict\"]\n    sviVlanIdToOspf3AreaIdDict      = vlanPtiInfoDict[\"sviVlanIdToOspf3AreaIdDict\"]\n    sviVlanIdToOspf3AreaIdPeerDict = vlanPtiInfoPeerDict[\"sviVlanIdToOspf3AreaIdPeerDict\"]\n    \n    ospfTag         = sviVlanIdToOspfTagDict.get(vlanId)\n    ospfTagPeer     = sviVlanIdToOspfTagPeerDict.get(vlanId)\n    ospfAreaId      = sviVlanIdToOspfAreaIdDict.get(vlanId) \n    ospfAreaIdPeer  = sviVlanIdToOspfAreadIdPeerDict.get(vlanId)\n\n    ospf3Tag        = sviVlanIdToOspf3TagDict.get(vlanId)\n    ospf3TagPeer    = sviVlanIdToOspf3TagPeerDict.get(vlanId)\n    ospf3AreaId     = sviVlanIdToOspf3AreaIdDict.get(vlanId)\n    ospf3AreaIdPeer = sviVlanIdToOspf3AreaIdPeerDict.get(vlanId)\n\n    if (not ((ospfTag and ospfTagPeer and ospfAreaId and ospfAreaIdPeer) or \n             (ospf3Tag and ospf3AreaId and ospf3TagPeer and ospf3AreaIdPeer))):\n        Wrapper.print(\"vlanId[%s] vrfName [%s] peerSn[%s] ospfTag[%s] ospfTagPeer[%s] \"\n                      \"ospfAreaId[%s] ospfAreaIdPeer[%s] ospf3Tag[%s] ospf3TagPeer[%s] \"\n                      \"ospf3AreaId[%s] ospf3AreaIdPeer[%s]  no ospf or ospf3 config \"\n                      \"looks like misconfig treat it as not interested for instenace values\"%\n                      (vlanId, vrfName, peerSn, ospfTag, ospfTagPeer, ospfAreaId, ospfAreaIdPeer,\n                       ospf3Tag, ospf3AreaId, ospf3TagPeer, ospf3AreaIdPeer))\n        return False\n\n    if not (ospfTag and ospfAreaId):\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] ospfTag[%s] \"\n                      \"ospfAreaId [%s] [%s] not interested\"%\n                      (vlanId, vrfName, peerSn, ospfTag, ospfAreaId))\n        return False\n                 \n    if not (ospfTagPeer and ospfAreaIdPeer):\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] ospfTagPeer[%s] \"\n                      \"ospfAreaIdPeer [%s] not interested\"%\n                      (vlanId, vrfName, peerSn, ospfTagPeer, ospfAreaIdPeer))\n        return False\n\n    if ospfTag != ospfTagPeer or ospfAreaId != ospfAreaIdPeer:\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] ospfTag[%s], ospfTagPeer[%s] \"\n                      \"ospfAreaId [%s] ospfAreaIdPeer [%s] not interested\"%\n                      (vlanId, vrfName, peerSn, ospfTag, ospfTagPeer, ospfAreaId, ospfAreaIdPeer))\n        return False\n\n    if ospf3Tag != ospfTagPeer or ospf3AreaId != ospf3AreaIdPeer:\n        Wrapper.print(\"vlanId [%s] vrfName [%s] peerSn[%s] ospf3Tag[%s], ospf3TagPeer[%s] \"\n                      \"ospf3AreaId [%s] ospf3AreaIdPeer [%s] not interested\"%\n                      (vlanId, vrfName, peerSn, ospf3Tag, ospf3TagPeer, ospf3AreaId, ospf3AreaIdPeer))\n        return False\n    Wrapper.print(\"%s():====Exit====\"%(funcName))\n    return True\n\ndef ECLGetVrfSviInfo(fabricName, devices, globalOverlayInfo, vrfNghborIpDeviceInfoDict):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s():====Entering====\"%(funcName))\n    vrfToSviInfoDict = {}\n    #VLP VRF <-> LITE PROTOCOL \n    ospfVLP = True if VRF_LITE_PROTOCOL == \"ospf\" else False\n    bgpVLP = True if VRF_LITE_PROTOCOL == \"ebgp\" else False\n    if not (ospfVLP or bgpVLP):\n        return vrfToSviInfoDict\n\n    switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"]\n    aggSwitches = []\n    for devSerial in devices:\n         dict = switchInfoDict[devSerial]\n         if \"aggregation\" in dict[\"switchRole\"].lower():\n             aggSwitches.append(devSerial)\n\n    vrfNghborIp4InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp4InfoDict\"]\n    vrfNghborIp6InfoDict = vrfNghborIpDeviceInfoDict[\"vrfNghborIp6InfoDict\"]\n    vrfSwitchInfoDict = {}\n    ignorePairSwitch = []\n    for devSerial in aggSwitches:\n        if devSerial not in ignorePairSwitch:\n            snMR = {}\n            peerSnMR = {}\n            vlanPtiInfoDict = {}\n            vlanPtiInfoPeerDict = {}\n            sn = devSerial\n            peerSn = Util.getVpcPeerSwitch(devSerial, fabricName)\n            ignorePairSwitch.append(peerSn)\n\n            switchOverlayInfo           = globalOverlayInfo[\"SWITCH_OVERLAYS\"][sn]\n            switchOverlayPeerInfo       = globalOverlayInfo[\"SWITCH_OVERLAYS\"][peerSn]\n\n            if ospfVLP:\n                snMR = getMatchResultObjFromGOI(fabricName, sn, globalOverlayInfo) \n                peerSnMR = getMatchResultObjFromGOI(fabricName, peerSn, globalOverlayInfo)\n\n            vrfNameListSn               = switchOverlayInfo[\"VRFS_BY_ID\"].keys()\n            vrfNameListPeerSn           = switchOverlayPeerInfo[\"VRFS_BY_ID\"].keys()\n\n            sviVrfNameToVlanIdDict      = vlanPtiInfoDict[\"sviVrfNameToVlanIdDict\"]             = {}\n            sviVrfNameToVlanIdPeerDict  = vlanPtiInfoPeerDict[\"sviVrfNameToVlanIdPeerDict\"]     = {}\n\n            sviVlanIdToVrfNameDict      = vlanPtiInfoDict[\"sviVlanIdToVrfNameDict\"]             = {}\n            sviVlanIdToVrfNamePeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToVrfNamePeerDict\"]     = {}\n\n            sviVlanIdToVlanNameDict      = vlanPtiInfoDict[\"sviVlanIdToVlanNameDict\"]           = {}\n            sviVlanIdToVlanNamePeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToVlanNamePeerDict\"]   = {}\n\n            sviVlanIdToIp4Dict          = vlanPtiInfoDict[\"sviVlanIdToIp4Dict\"]                 = {}\n            sviVlanIdToIp4PeerDict      = vlanPtiInfoPeerDict[\"sviVlanIdToIp4PeerDict\"]         = {}\n            sviVlanIdToPrefix4Dict      = vlanPtiInfoDict[\"sviVlanIdToPrefix4Dict\"]             = {}\n            sviVlanIdToPrefix4PeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToPrefix4PeerDict\"]     = {}\n\n            sviVlanIdToIp6Dict          = vlanPtiInfoDict[\"sviVlanIdToIp6Dict\"]                 = {}\n            sviVlanIdToIp6PeerDict      = vlanPtiInfoPeerDict[\"sviVlanIdToIp6PeerDict\"]         = {}\n            sviVlanIdToPrefix6Dict      = vlanPtiInfoDict[\"sviVlanIdToPrefix6Dict\"]             = {}\n            sviVlanIdToPrefix6PeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToPrefix6PeerDict\"]     = {}\n\n            sviVlanIdToPtiDict          = vlanPtiInfoDict[\"sviVlanIdToPtiDict\"]                 = {}\n            sviVlanIdToPtiPeerDict      = vlanPtiInfoPeerDict[\"sviVlanIdToPtiPeerDict\"]         = {}\n            sviVlanIdToDescDict         = vlanPtiInfoDict[\"sviVlanIdToDescDict\"]                = {}  \n            sviVlanIdToDescPeerDict     = vlanPtiInfoPeerDict[\"sviVlanIdToDescPeerDict\"]        = {}  \n\n            sviVlanIdToOspfTagDict          = vlanPtiInfoDict[\"sviVlanIdToOspfTagDict\"]         = {}  \n            sviVlanIdToOspfTagPeerDict      = vlanPtiInfoPeerDict[\"sviVlanIdToOspfTagPeerDict\"]     = {}  \n\n            sviVlanIdToOspfAreaIdDict       = vlanPtiInfoDict[\"sviVlanIdToOspfAreaIdDict\"]      = {}  \n            sviVlanIdToOspfAreadIdPeerDict  = vlanPtiInfoPeerDict[\"sviVlanIdToOspfAreadIdPeerDict\"] = {}  \n\n            sviVlanIdToOspf3TagDict         = vlanPtiInfoDict[\"sviVlanIdToOspf3TagDict\"]    = {}  \n            sviVlanIdToOspf3TagPeerDict     = vlanPtiInfoPeerDict[\"sviVlanIdToOspf3TagPeerDict\"]    = {}  \n\n            sviVlanIdToOspf3AreaIdDict      = vlanPtiInfoDict[\"sviVlanIdToOspf3AreaIdDict\"]     = {}  \n            sviVlanIdToOspf3AreaIdPeerDict = vlanPtiInfoPeerDict[\"sviVlanIdToOspf3AreaIdPeerDict\"] = {}  \n            \n            ECLGetVlanInfoFromPti(vlanPtiInfoDict, sn, vrfNameListSn, False, snMR)\n            ECLGetVlanInfoFromPti(vlanPtiInfoPeerDict, peerSn, vrfNameListPeerSn, True, peerSnMR)\n\n            Wrapper.print(\"vlanPtiInfoDict[%s]\"%(vlanPtiInfoDict))\n            Wrapper.print(\"vlanPtiInfoPeerDict[%s]\"%(vlanPtiInfoPeerDict))\n            #for vrfName in sviVrfNameToVlanIdDict:\n            for vlanId in sviVlanIdToVrfNameDict:\n                vrfName = sviVlanIdToVrfNameDict[vlanId]\n                ip4 = sviVlanIdToIp4Dict.get(vlanId)\n                ip6 = sviVlanIdToIp6Dict.get(vlanId)\n                validateInputDict = {}\n                if bgpVLP:\n                    validateInputDict.update({\"vrfName\":vrfName, \"vlanId\":vlanId, \n                                              \"sn\":sn, \"peerSn\":peerSn, \"ip4\":ip4, \"ip6\":ip6,\n                                              \"vrfNghborIp4InfoDict\":vrfNghborIp4InfoDict, \n                                              \"vrfNghborIp6InfoDict\":vrfNghborIp6InfoDict})\n                    if not validInstValBgpNbr(validateInputDict):\n                        continue\n                elif ospfVLP:\n                    validateInputDict.update({\"vrfName\":vrfName, \"vlanId\":vlanId, \"sn\":sn, \"peerSn\":peerSn, \n                                              \"vlanPtiInfoDict\":vlanPtiInfoDict, \"ip4\":ip4, \"ip6\":ip6,\n                                              \"vlanPtiInfoPeerDict\":vlanPtiInfoPeerDict})\n                    if not validInstValOspfNbr(validateInputDict):\n                        continue\n \n                entry    = {}\n                vlanName = sviVlanIdToVlanNameDict.get(vlanId)\n                prefix4  = sviVlanIdToPrefix4Dict.get(vlanId)\n                prefix6  = sviVlanIdToPrefix6Dict.get(vlanId)\n                pti      = sviVlanIdToPtiDict.get(vlanId)\n                desc     = sviVlanIdToDescDict.get(vlanId)\n                sviDict  = {}\n                sviDict.update({\"vlanId\":vlanId,\"vlanName\":vlanName, \"ip4\":ip4, \"ip6\":ip6,\n                                \"prefix4\":prefix4, \"prefix6\":prefix6,\"desc\":desc, \"ptiId\":pti})\n                entry.update({sn:sviDict})\n                local = {\"local\":entry}\n                Wrapper.print(\"%s(): sn [%s] vrfName [%s] entry[%s]\"%(funcName, sn, vrfName, str(entry)))\n                if not vrfToSviInfoDict.get(vrfName):\n                    vrfToSviInfoDict[vrfName] = {}\n                vrfToSviInfoDict[vrfName].update(local)\n                Wrapper.print(\"%s(): sn [%s] vrfToSviInfoDict local [%s]\"%(funcName, sn, str(vrfToSviInfoDict)))\n            for vlanIdPeer in sviVlanIdToVrfNamePeerDict:\n                vrfNamePeer = sviVlanIdToVrfNamePeerDict[vlanIdPeer]\n                ip4Peer = sviVlanIdToIp4PeerDict.get(vlanIdPeer)\n                ip6Peer = sviVlanIdToIp6PeerDict.get(vlanIdPeer)\n                if bgpVLP:\n                    validateInputDict.update({\"vrfName\":vrfNamePeer, \"vlanId\":vlanIdPeer, \n                                              \"sn\":peerSn, \"peerSn\":sn, \"ip4\":ip4Peer, \"ip6\":ip6Peer,\n                                              \"vrfNghborIp4InfoDict\":vrfNghborIp4InfoDict, \n                                              \"vrfNghborIp6InfoDict\":vrfNghborIp6InfoDict})\n                    if not validInstValBgpNbr(validateInputDict):\n                        continue\n                elif ospfVLP:\n                    validateInputDict.update({\"vrfName\":vrfNamePeer, \"vlanId\":vlanIdPeer, \n                                              \"sn\":peerSn, \"peerSn\":sn, \"ip4\":ip4Peer, \"ip6\":ip6Peer,\n                                              \"vlanPtiInfoDict\":vlanPtiInfoDict, \n                                              \"vlanPtiInfoPeerDict\":vlanPtiInfoPeerDict})\n                    if not validInstValOspfNbr(validateInputDict):\n                        continue\n                \n                peerEntry    = {}\n                vlanNamePeer = sviVlanIdToVlanNamePeerDict.get(vlanIdPeer)\n                prefix4Peer  = sviVlanIdToPrefix4PeerDict.get(vlanIdPeer)\n                prefix6Peer  = sviVlanIdToPrefix6PeerDict.get(vlanIdPeer)\n                ptiPeer      = sviVlanIdToPtiPeerDict.get(vlanIdPeer)\n                descPeer     = sviVlanIdToDescPeerDict.get(vlanIdPeer)\n                sviPeerDict  = {}\n                sviPeerDict.update({\"vlanId\":vlanIdPeer,\"vlanName\":vlanNamePeer, \"ip4\":ip4Peer, \"ip6\":ip6Peer,\n                                    \"prefix4\":prefix4Peer, \"prefix6\":prefix6Peer, \"desc\":descPeer, \"ptiId\":ptiPeer})\n                peerEntry.update({peerSn:sviPeerDict})\n                peer = {\"peer\":peerEntry}\n                Wrapper.print(\"%s(): peerSn [%s] vrfNamePeer [%s] peerEntry[%s]\"%(funcName, peerSn, vrfNamePeer, str(peerEntry)))\n                if not vrfToSviInfoDict.get(vrfNamePeer):\n                    vrfToSviInfoDict[vrfNamePeer] = {}\n                vrfToSviInfoDict[vrfNamePeer].update(peer)\n                Wrapper.print(\"%s(): peerSn [%s] vrfToSviInfoDict peer [%s]\"%(funcName, peerSn, str(vrfToSviInfoDict)))\n            Wrapper.print(\"%s(): combinedSn [%s~%s] vrfToSviInfoDict [%s]\"%(funcName, sn, peerSn, str(vrfToSviInfoDict)))\n    Wrapper.print(\"%s():====Exiting====\"%(funcName))\n    return vrfToSviInfoDict\n\n#considers only one agg pair, parent call should ensure other aggpairs\ndef ECLGetVlanInfoFromPti(vlanPtiInfoDict, devSerial, overlayVrfNameList, peer, matchResults):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s(): devSerial [%s] ====Entering====\"%(funcName, devSerial))\n    Wrapper.print(\"%s(): devSerial [%s] overlayVrfNameList [%s]\"%(funcName, devSerial, overlayVrfNameList))\n    sviVlanIdToVrfNameDict = vlanPtiInfoDict[\"sviVlanIdToVrfNameDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToVrfNamePeerDict\"]\n    sviVrfNameToVlanIdDict = vlanPtiInfoDict[\"sviVrfNameToVlanIdDict\"] if not peer else vlanPtiInfoDict[\"sviVrfNameToVlanIdPeerDict\"]\n    sviVlanIdToIp4Dict     = vlanPtiInfoDict[\"sviVlanIdToIp4Dict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToIp4PeerDict\"]\n    sviVlanIdToPrefix4Dict = vlanPtiInfoDict[\"sviVlanIdToPrefix4Dict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToPrefix4PeerDict\"]\n    sviVlanIdToIp6Dict     = vlanPtiInfoDict[\"sviVlanIdToIp6Dict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToIp6PeerDict\"]\n    sviVlanIdToPrefix6Dict = vlanPtiInfoDict[\"sviVlanIdToPrefix6Dict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToPrefix6PeerDict\"]\n    sviVlanIdToPtiDict     = vlanPtiInfoDict[\"sviVlanIdToPtiDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToPtiPeerDict\"]\n    sviVlanIdToDescDict    = vlanPtiInfoDict[\"sviVlanIdToDescDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToDescPeerDict\"]\n    sviVlanIdToOspfTagDict    = vlanPtiInfoDict[\"sviVlanIdToOspfTagDict\"]  if not peer else vlanPtiInfoDict[\"sviVlanIdToOspfTagPeerDict\"]\n    sviVlanIdToOspfAreaIdDict = vlanPtiInfoDict[\"sviVlanIdToOspfAreaIdDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToOspfAreadIdPeerDict\"]  \n    sviVlanIdToOspf3TagDict    = vlanPtiInfoDict[\"sviVlanIdToOspf3TagDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToOspf3TagPeerDict\"] \n    sviVlanIdToOspf3AreaIdDict = vlanPtiInfoDict[\"sviVlanIdToOspf3AreaIdDict\"] if not peer else vlanPtiInfoDict[\"sviVlanIdToOspf3AreaIdPeerDict\"]  \n \n    vlanIdList = []\n\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"int_vlan\")\n    srchOpt.setEntityType(\"INTERFACE\")\n    srchOpt.setTemplateContentType(\"PYTHON\")\n    srchOpt.setSource(\"\")\n    sviPtis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    ospfVlanIntfList = []\n    ospf3VlanIntfList = []\n    if matchResults:\n        #oil <-> ospfIntfList\n        #o3il <-> ospf3IntfList\n        oil = matchResults[\"ospf_interface_11_1\"]\n        ospfVlanIntfList = list(filter(lambda oil: \"Vlan\" in oil['INTF_NAME'], oil))\n        o3il = matchResults[\"ospf_interface_11_1\"]\n        ospf3VlanIntfList = list(filter(lambda oil: \"Vlan\" in oil['INTF_NAME'], o3il))\n\n    for pti in sviPtis:\n        if not pti.isDeleted():\n            policyId = pti.getPolicyId()\n            ptiNvPairs = pti.getNvPairs()\n            vrfName = ptiNvPairs.get(\"INTF_VRF\")\n            if vrfName == \"\":\n                vrfName = \"default\"\n            #Wrapper.print(\"%s(): devSerial [%s] vrfName [%s]\"%(funcName, devSerial, vrfName))\n            if vrfName not in overlayVrfNameList:\n                Wrapper.print(\"%s(): devSerial [%s] unexpected vrfName [%s]\"%(funcName, devSerial, vrfName))\n                continue\n            \n            #Wrapper.print(\"%s(): devSerial [%s] ptiNvPairs [%s]\"%(funcName, devSerial, ptiNvPairs))\n            intfName = ptiNvPairs.get(\"INTF_NAME\").lower()\n            adminState = ptiNvPairs.get(\"ADMIN_STATE\").lower()\n            if adminState != \"true\":\n                Wrapper.print(\"%s(): devSerial [%s] vrfName [%s] svi [%s] \"\n                              \"skip possible misconfig with shut svi\"%\n                              (funcName, devSerial, vrfName, intfName))\n                continue\n\n            ffConf = ptiNvPairs.get(\"CONF\")\n            ffConfList = ffConf.splitlines()\n            secondaryIpAddPresent = False\n            multipleIp6Count = 0\n            for line in ffConfList:\n                if \"ip address\" in line and \"secondary\" in line:\n                    secondaryIpAddPresent = True\n                if \"ipv6 address\" in line:\n                    multipleIp6Count += 1\n            if secondaryIpAddPresent or multipleIp6Count > 1:\n                Wrapper.print(\"%s(): do not consider svi with secondary ip or multiple v6\"\n                              \" devSerial [%s] vrfName [%s] freeform [%s]\"%(funcName, devSerial, vrfName, ffConf))\n                continue\n\n            vlanId = intfName.lstrip(\"Vlan\")\n            sviDesc = ptiNvPairs.get(\"DESC\").lower()\n            sviVlanIdToDescDict[vlanId] = sviDesc\n            #Wrapper.print(\"%s(): devSerial [%s] vlanId [%s]\"%(funcName, devSerial, vlanId))\n            vlanIdList.append(vlanId)\n            sviVlanIdToVrfNameDict[vlanId] = vrfName\n            sviVrfNameToVlanIdDict[vrfName] = vlanId\n            sviVlanIdToPtiDict[vlanId] =  policyId\n            if ospfVlanIntfList:\n                for ospfIntfRecord in ospfVlanIntfList:\n                    ospfIntf = ospfIntfRecord[\"INTF_NAME\"].lower()\n                    if ospfIntf == intfName:\n                        ospfAreaId = ospfIntfRecord[\"OSPF_AREA_ID\"]\n                        ospfTag = ospfIntfRecord[\"OSPF_TAG\"]\n                        if ospfTag and ospfAreaId:\n                            sviVlanIdToOspfTagDict[vlanId] = ospfTag\n                            sviVlanIdToOspfAreaIdDict[vlanId] = ospfAreaId\n                \n            if ospf3VlanIntfList:\n                for ospf3IntfRecord in ospf3VlanIntfList:\n                    ospf3Intf = ospf3IntfRecord[\"INTF_NAME\"].lower()\n                    if ospf3Intf == intfName:\n                        ospf3AreaId = ospf3IntfRecord[\"OSPF_AREA_ID\"]\n                        ospf3Tag = ospf3IntfRecord[\"OSPF_TAG\"]\n                        if ospf3Tag and ospf3AreaId:\n                            sviVlanIdToOspf3TagDict[vlanId] = ospf3Tag\n                            sviVlanIdToOspf3AreaIdDict[vlanId] = ospf3AreaId\n \n            ip4 = ptiNvPairs.get(\"IP\")\n            prefix4 = ptiNvPairs.get(\"PREFIX\")\n            #Wrapper.print(\"%s(): devSerial [%s] ip4 [%s] prefix4[%s]\"%(funcName, devSerial, ip4,prefix4))\n            if ip4 and prefix4:\n                sviVlanIdToIp4Dict[vlanId] = ip4 \n                sviVlanIdToPrefix4Dict[vlanId] = prefix4 \n            for line in ffConfList:\n                ffConf = line.lstrip()\n                if \"ipv6 address\" in ffConf:\n                    ipPrefix6 = ffConf.lstrip(\"ipv6 address\")\n                    ip6, prefix6 = ipPrefix6.split(\"/\") \n                    if ip6 and prefix6:\n                        sviVlanIdToIp6Dict[vlanId] = ip6\n                        sviVlanIdToPrefix6Dict[vlanId] = prefix6\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToVrfNameDict [%s]\"%(funcName, devSerial, sviVlanIdToVrfNameDict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToPtiDict [%s]\"%(funcName, devSerial, sviVlanIdToPtiDict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToIp4Dict [%s]\"%(funcName, devSerial, sviVlanIdToIp4Dict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToPrefix6Dict [%s]\"%(funcName, devSerial, sviVlanIdToPrefix6Dict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToOspfTagDict [%s]\"%(funcName, devSerial, sviVlanIdToOspfTagDict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToOspfAreaIdDict [%s]\"%(funcName, devSerial, sviVlanIdToOspfAreaIdDict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToOspf3TagDict [%s]\"%(funcName, devSerial, sviVlanIdToOspf3TagDict))\n            Wrapper.print(\"%s(): devSerial [%s], sviVlanIdToOspf3AreaIdDict [%s]\"%(funcName, devSerial, sviVlanIdToOspf3AreaIdDict))\n\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"switch_freeform\")\n    srchOpt.setEntityType(\"INTERFACE\")\n    srchOpt.setTemplateContentType(\"PYTHON\")\n    srchOpt.setSource(\"\")\n    ffPtis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    for vlanId in vlanIdList:\n        for pti in ffPtis:\n            if not pti.isDeleted():\n                ptiNvPairs = pti.getNvPairs()\n                conf = ptiNvPairs.get(\"CONF\")\n                if (\"vlan \"+vlanId) in conf:\n                     isVlanConfigBlock = False\n                     confList = conf.splitlines()\n                     for line in confList:\n                         Wrapper.print(\"looking for vlanId [%s], found line [%s]\"%(vlanId, line))\n                         depth = (len(line) - len(line.lstrip(' '))) / 2\n                         if depth == 0:\n                            if isVlanConfigBlock:\n                                # we are out of the Vlan configuration block\n                                isVlanConfigBlock = False\n                            if line.startswith(\"vlan \"+vlanId):\n                                isVlanConfigBlock = True\n                                continue\n                         if isVlanConfigBlock:\n                             if \"name\" in line:\n                                vlanName = re.sub(r'. name ', '', line, count=1)\n                                sviVlanIdToVlanNameDict[vlanId] = vlanName\n\n    Wrapper.print(\"%s(): devSerial [%s] ====Exiting====\"%(funcName, devSerial))\n\ndef ECLGetDeviceVrfInstanceValue(vrfName, devSerial, vrfSviInstanceValues):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s(): vrfName [%s] devSerial [%s] ====Enter====\"%(funcName, vrfName, devSerial))\n    localVrfInstanceValues = {}\n    peerVrfInstanceValues = {}\n    localVrfDeviceInstanceValues = {}\n    localVrfDeviceInstanceValues = {}\n    vrfInstValsAndPti = {}\n    imlocal = \"\"\n    try:\n        localVrfInstanceValues = vrfSviInstanceValues[vrfName][\"local\"]\n        peerVrfInstanceValues = vrfSviInstanceValues[vrfName][\"peer\"]\n    except:\n        pass\n    Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] localVrfInstanceValues [%s] \"\n                  \"peerVrfInstanceValues [%s]\"%(funcName, devSerial, vrfName, \n                  localVrfInstanceValues, peerVrfInstanceValues))\n    if localVrfInstanceValues and peerVrfInstanceValues:\n        if devSerial in localVrfInstanceValues.keys():\n            localVrfDeviceInstanceValues =  localVrfInstanceValues[devSerial]\n            peerVrfDeviceInstanceValues = peerVrfInstanceValues.values()[0]\n            Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] got in local order\"%\n                          (funcName, devSerial, vrfName))\n        elif devSerial in peerVrfInstanceValues.keys():\n            localVrfDeviceInstanceValues =  peerVrfInstanceValues[devSerial]\n            peerVrfDeviceInstanceValues = localVrfInstanceValues.values()[0]\n            Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] got in peer order\"%\n                          (funcName, devSerial, vrfName))\n        \n        if localVrfDeviceInstanceValues and peerVrfDeviceInstanceValues:\n            Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] collect instances\"%\n                          (funcName, devSerial, vrfName))\n            ip4L = localVrfDeviceInstanceValues[\"ip4\"]\n            prefix4L = localVrfDeviceInstanceValues[\"prefix4\"]\n            \n            ip4MaskL = (ip4L + \"/\" + prefix4L) if (ip4L and prefix4L) else \"\"\n            nghbrIp4L = peerVrfDeviceInstanceValues[\"ip4\"]\n            nghbrIp4L = nghbrIp4L if nghbrIp4L else \"\" \n\n            ip6L = localVrfDeviceInstanceValues[\"ip6\"]\n            prefix6L = localVrfDeviceInstanceValues[\"prefix6\"]\n\n            ip6MaskL = (ip6L + \"/\" + prefix6L) if (ip6L and prefix6L) else \"\"\n            nghbrIp6L = peerVrfDeviceInstanceValues[\"ip6\"]\n            nghbrIp6L = nghbrIp6L if nghbrIp6L else \"\" \n\n            vlanIdL = localVrfDeviceInstanceValues[\"vlanId\"].lstrip(\"vlan\")\n            vlanIdL = vlanIdL if vlanIdL else \"\" \n            sviDescL = localVrfDeviceInstanceValues[\"desc\"]\n            sviDescL = sviDescL if sviDescL else \"\"\n\n            vlanNameL = localVrfDeviceInstanceValues[\"vlanName\"]\n            vlanNameL = vlanNameL if vlanNameL else \"\"\n                \n            ptiIdL = localVrfDeviceInstanceValues[\"ptiId\"]\n\n            instanceValsDict = {\"vrfVlanName\": vlanNameL,\n                                \"SVI_IP_MASK\": ip4MaskL,\n                                \"SVI_NEIGHBOR_IP\": nghbrIp4L,\n                                \"SVI_IPv6_MASK\": ip6MaskL,\n                                \"SVI_NEIGHBOR_IPv6\": nghbrIp6L,\n                                \"vrfIntfDescription\": sviDescL\n                               }\n            instanceVals = json.dumps(instanceValsDict)\n            vrfInstValsAndPti.update({\"instanceVals\":instanceVals, \"ptiId\":ptiIdL, \"vlanId\":vlanIdL})\n    Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] vrfInstValsAndPti [%s]\"%\n                  (funcName, devSerial, vrfName, vrfInstValsAndPti))\n    Wrapper.print(\"%s(): vrfName [%s] devSerial [%s] ====Exit====\"%(funcName, vrfName, devSerial))\n    return vrfInstValsAndPti\n\n\ndef ECLprocessOverlayAttachments(devSerial, switchOverlayInfo, globalOverlayInfo, allOverlayNets, topologyDataObj, vrfSviInstanceValues):\n    funcName = sys._getframe(0).f_code.co_name\n    switchDict = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n    Wrapper.print(\"%s: Switch [%s] - Is Extn [%s] %s\" % (funcName, switchDict[\"fmtName\"], switchOverlayInfo[\"doOverlayExtn\"], switchDict))\n\n    # process each of the VRF entries\n    for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n        vrfName = vrfEntry[\"name\"]\n        instanceVals = \"\"\n        vrfAttachVlan = 0\n        instanceValsDict = ECLGetDeviceVrfInstanceValue(vrfName, devSerial, vrfSviInstanceValues)\n        if instanceValsDict:\n            instanceVals = instanceValsDict.get(\"instanceVals\")\n            ptiId = instanceValsDict.get(\"ptiId\")\n            vlanId = instanceValsDict.get(\"vlanId\")\n            vrfAttachVlan = int(vlanId) if vlanId else 0\n            Wrapper.print(\"%s(): devSerial [%s], vrfName[%s] vlanId[%s] instanceVals [%s] ptiId [%s]\"%\n                          (funcName, devSerial, vrfName, vlanId, instanceVals,ptiId))\n            if instanceVals and vrfAttachVlan > 0:\n                vrfEntry[\"instanceVals\"] = instanceVals\n \n        configProfName = vrfEntry[\"cfgProfileName\"] if (\"cfgProfileName\" in vrfEntry) else None\n        Wrapper.print(\"%s: Switch [%s] - Attaching for VRF [%s] VNI [%s] Profile Name [%s] Vlan [%s] instanceVals [%s] \"\n            \"Freeform [%s] Extension Vals [%s]\" % (funcName, switchDict[\"fmtName\"], vrfName, vrfName, configProfName,\n            vrfAttachVlan, instanceVals, vrfEntry[\"freeformCfg\"], vrfEntry[\"extensionVals\"]))\n\n        # check if the vrf entry exists in the global info db\n        if vrfName not in globalOverlayInfo[\"VRF_ATTACH\"]:\n            vrfAttachEntry = LanAttachByVRF()\n            vrfAttachEntry.setVrfName(vrfName)\n            vrfAttachEntry.setLanAttachList([])\n            globalOverlayInfo[\"VRF_ATTACH\"][vrfName] = vrfAttachEntry\n\n        # add an entry for this switch to the list\n        vrfSwitchAttach = LanVRFAttach()\n        vrfSwitchAttach.setFabric(FABRIC_NAME)\n        vrfSwitchAttach.setSerialNumber(devSerial)\n        vrfSwitchAttach.setVlan(vrfAttachVlan)\n        vrfSwitchAttach.setVrfName(vrfName)\n        vrfSwitchAttach.setExtensionValues(vrfEntry[\"extensionVals\"])\n        vrfSwitchAttach.setDeployment(True)\n        vrfSwitchAttach.setInstanceValues(vrfEntry[\"instanceVals\"])\n        vrfSwitchAttach.setFreeformConfig(vrfEntry[\"freeformCfg\"])\n\n        vrfAttachEntry = globalOverlayInfo[\"VRF_ATTACH\"][vrfName]\n        attachList = vrfAttachEntry.getLanAttachList()\n        attachList.append(vrfSwitchAttach)\n        vrfAttachEntry.setLanAttachList(attachList)\n        if vrfAttachVlan:\n            #delete vlan pti after this\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            lowerIntfName = \"vlan\"+str(vrfAttachVlan)\n            ignore, rmId = Util.exeRM(RM.get(FABRIC_NAME, \"TOP_DOWN_NETWORK_VLAN\", key, lowerIntfName))\n            Wrapper.print(\"%s() devSerial [%s] vrfName[%s] intfName [%s] ptiId=[%s] delete rmId=[%s]\"%(funcName, devSerial, vrfName, lowerIntfName, ptiId, rmId))\n            PTI.deleteInstance(ptiId)\n            if rmId > 0:\n                RM.deleteResource(rmId)\n        #Wrapper.print(\"%s: Switch [%s] - vrfSwitchAttach for VRF [%s] vrfSwitchAttach[%s] \" % (funcName, switchDict[\"fmtName\"], vrfName, vrfSwitchAttach))\n        #Wrapper.print(\"%s: Switch [%s] - vrfAttachEntry for VRF [%s] attach entryvrfAttachEntry[%s]\" % (funcName, switchDict[\"fmtName\"], vrfName, vrfAttachEntry))\n\n        \n    # process each of the network attachment entries\n    for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n        refEntry = allOverlayNets[netEntry[\"vlanId\"]]\n        refNetEntry = allOverlayNets[netEntry[\"vlanId\"]][\"netEntry\"]\n        refNetName = refNetEntry[\"overlayNetName\"] if refNetEntry[\"overlayNetName\"] else refNetEntry[\"cfgProfileName\"]\n        configProfName = netEntry[\"cfgProfileName\"] if ((\"cfgProfileName\" in netEntry) and refNetEntry[\"overlayNetName\"]) else None\n\n        Wrapper.print(\"%s: Switch [%s] - Attaching for network [%s/%s] Profile Name [%s] interfaces = [%s] Freeform [%s] refEntry [%s]\" % \n            (funcName, switchDict[\"fmtName\"], netEntry[\"vlanId\"], refNetName, configProfName, \n                netEntry[\"attachInfo\"], netEntry[\"freeformCfg\"], refEntry))\n\n        # check if the network entry exists in the global info db\n        vlanIdStr = netEntry[\"vlanId\"]\n        if vlanIdStr in globalOverlayInfo[\"NETWORK_ATTACH\"]:\n            netAttach = globalOverlayInfo[\"NETWORK_ATTACH\"][vlanIdStr]\n        else:\n            netAttach = LanAttachByNetwork()\n            netAttach.setNetworkName(refNetName)\n            netAttach.setLanAttachList([])\n\n            globalOverlayInfo[\"NETWORK_ATTACH\"][vlanIdStr] = netAttach\n\n        #\n        # Aggs will always be a vPC pair.\n        # For each agg vPC pair, determine vPC pair key. That determines Agg1~Agg2\n        # From each Agg switch, various network/vrf specific parameters will be individually learnt\n        # To determine, how to populate this in the network wrt parameters associated with Agg1 vs Agg2, compare the \n        # switch serial number with vPCPairKey. Accordingly, populate pip1 and other variables vs pip2 and other variables\n        # Do this only for non-layer2 only networks\n        #\n        isActive = False\n        isLayer3Net = False\n        if refNetEntry[\"netTemplateParams\"][\"isLayer2Only\"] != \"true\":\n            isLayer3Net = True\n            vpcPairkey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, devSerial))\n            serials = vpcPairkey.split(Helper.DELIMITER)\n            Agg1Sn = serials[0]\n            Agg2Sn = serials[1]\n            Wrapper.print(\"%s: vpcPair[%s], device %s[%s]\" % (funcName, vpcPairkey, switchDict[\"fmtName\"], devSerial))\n            if Agg1Sn == devSerial and devSerial == refEntry[\"refSwitchSerial\"]:\n                Wrapper.print(\"%s: vpcPair[%s], device %s[%s] refSwitchSerial %s setting Agg1Sn isActive true\" % (funcName, vpcPairkey, switchDict[\"fmtName\"], refEntry[\"refSwitchSerial\"], devSerial))\n                isActive = True\n            elif Agg2Sn == devSerial and devSerial == refEntry[\"refSwitchSerial\"]:\n                Wrapper.print(\"%s: vpcPair[%s], device %s[%s] refSwitchSerial %s setting Agg2Sn isActive true\" % (funcName, vpcPairkey, switchDict[\"fmtName\"], refEntry[\"refSwitchSerial\"], devSerial))\n                isActive = True\n        # add a new attach entry for this switch\n        lanAttach = LanAttach()\n        lanAttach.setFabric(FABRIC_NAME)\n        lanAttach.setNetworkName(refNetName)\n        lanAttach.setSerialNumber(devSerial)\n        #Need to filter out agg downlink ports that are part of the uplink_access policies \n        #These are the interfaces connected between access-agg based on the b2b vpc, dual-attached or single attached case\n        #This means that there must be some torPorts also present that in turn will auto-attach the access uplinks & agg downlinks\n        Wrapper.print(\"%s: device %s[%s] attachInfo %s UplinkInts %s\" % \n                    (funcName, switchDict[\"fmtName\"], devSerial, netEntry[\"attachInfo\"], switchDict[\"accessUplinkIntfs\"]))\n        \n        netAttachInfo = set(netEntry[\"attachInfo\"]) - set(switchDict[\"accessUplinkIntfs\"])\n        Wrapper.print(\"%s: device %s[%s] NetattachInfo %s\" % \n                    (funcName, switchDict[\"fmtName\"], devSerial, netAttachInfo))\n        \n        lanAttach.setSwitchPorts(\",\".join(netAttachInfo))\n\n        #To get the torPorts, for this agg device, find out all the access devices that are attached/paired to it. \n        #For each paired access device, get the netEntry[\"attachInfo\"] for that access device and append it to the torPorts\n        newRespObj = WrappersResp.getRespObj()\n        newRespObj.setSuccessRetCode()\n        torPorts = getAggTorPorts(topologyDataObj, devSerial, vlanIdStr, newRespObj, globalOverlayInfo)\n        Wrapper.print(\"%s: device %s[%s] netAttachInfo %s %s torPorts %s %s\" % \n                    (funcName, switchDict[\"fmtName\"], devSerial, netAttachInfo, \",\".join(netAttachInfo), torPorts, \",\".join(torPorts)))        \n        if not newRespObj.isRetCodeSuccess():\n            #TODO:Should we return an error from here or continue?\n            Wrapper.print(\"Switch [%s]: getAggTorPorts call failed\" % switchDict[\"fmtName\"])        \n        lanAttach.setTorPorts(\" \".join(torPorts))\n        lanAttach.setDetachSwitchPorts(\"\")\n        lanAttach.setVlan(netEntry[\"vlanId\"])\n        lanAttach.setDot1QVlan(1)\n        lanAttach.setUntagged(False)\n        lanAttach.setDeployment(True)\n        lanAttach.setExtensionValues(netEntry[\"extensionVals\"])\n        if not isLayer3Net:\n            lanAttach.setInstanceValues(\"\")\n        else:            \n            if isActive:\n                lanAttach.setInstanceValues('{\"isActive\":\"true\"}')\n            else:    \n                lanAttach.setInstanceValues('{\"isActive\":\"false\"}')\n        lanAttach.setFreeformConfig(netEntry[\"freeformCfg\"])\n\n        attachList = netAttach.getLanAttachList()\n        attachList.append(lanAttach)\n        netAttach.setLanAttachList(attachList)\n        \ndef checkOverlayParam(vrfOrNetName, paramName, refSwitchSn, switchSn, refParamVal, paramVal, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    retVal = True\n    if refParamVal != paramVal:\n        respObj.addErrorReport(\"OVERLAY_PARAM\",\n            \"[%s] Overlay parameter [%s] mismatch detected! Value [%s] on switch [%s] does not match \"\n            \"value [%s] on switch [%s]\" % (vrfOrNetName, paramName, refParamVal, getFormattedSwitchName(refSwitchSn), \n                paramVal, getFormattedSwitchName(switchSn)))\n        respObj.setFailureRetCode()\n        retVal = False\n    return retVal\n\ndef resetSwitchMigration(fabricName, devices, globalOverlayInfo, gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: Fabric [%s] - Reset Migration state on failure\" % (funcName, fabricName))\n\n    vpcPairs = {}\n\n    gVarDictObj[\"notDeleteSwitch\"] = True\n    gVarDictObj[\"FABRIC_NAME\"] = fabricName\n    fabTech = gVarDictObj[\"globalOverlayInfo\"][\"fabricTechnology\"]\n    \n    if fabTech == \"VLANFabric\":\n        aggSwitches = []\n        accessSwitches = []\n        switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"]\n        for deviceSn in devices:\n            dict = switchInfoDict[deviceSn]\n            if \"aggregation\" in dict[\"switchRole\"].lower():\n                aggSwitches.append(deviceSn)\n            elif \"access\" in dict[\"switchRole\"].lower():\n                accessSwitches.append(deviceSn)\n        switchList = accessSwitches + list(set(devices) - set(accessSwitches))\n        devices = switchList\n\n    Wrapper.print(\"%s: Fabric [%s] - Reset Migration state for switches %s \" % (funcName, fabricName, devices))\n    for deviceSn in devices:\n        gVarDictObj[\"deviceSerial\"] = deviceSn\n        if fabTech == \"VLANFabric\":\n            PTIWrapper.executePyTemplateMethod(\"Easy_Fabric_Classic\", gVarDictObj, \"preSwitchDelete\")\n        else:\n            PTIWrapper.executePyTemplateMethod(\"Easy_Fabric\", gVarDictObj, \"preSwitchDelete\")\n        # all the PTIs will be deleted as part of the preSwitchDelete() call above\n        # we are here because of overlay migration for the Brownfield case only, so put back the switch in the brownfield migration mode\n        putSwitchIntoBfMigrMode(fabricName, deviceSn)\n\n        switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n\n        # check if the switch was a vpc pair at the start of the import and set the pairing since the previous\n        # cleanup would have removed the paring\n        peerSn = switchInfo[\"vpcPeer\"]\n        if peerSn and (peerSn not in vpcPairs):\n            # check to make sure the peer switch is still in the fabric\n            if peerSn in globalOverlayInfo[\"SWITCH_INFO\"]:\n                # add a new vpc pair info\n                vpcPairs[deviceSn] = peerSn\n\n        # recreate the vpc peer link vlan PTI that user had created earlier since the earlier step would\n        # have cleared all PTIs\n        vPCInfo = switchInfo.get(\"vpcInfo\", None)\n        if vPCInfo and vPCInfo[\"userPeerLinkVlanPtiId\"]:\n            PTI.create(deviceSn, \"SWTICH\", \"SWTICH\", \"\", 500, \"vpc_peer_link_vlan\",\n                {\"VLAN\" : vPCInfo[\"peerLinkVlan\"]})\n\n        # recreate the inband POAP seed switch PTI\n        seedSwNvPairs = switchInfo.get(\"inbandPoapSeedSwitch\", None)\n        if seedSwNvPairs is not None:\n            Util.exe(PTI.create(deviceSn, \"SWITCH\", \"SWITCH\", \"\", 500, \"seed_switch\", seedSwNvPairs))\n\n    # redo the vPC pairings that the user would have done before the import\n    for deviceSn in vpcPairs:\n        switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n        peerSwitchInfo = globalOverlayInfo[\"SWITCH_INFO\"][vpcPairs[deviceSn]]\n\n        # do the vpc paring\n        respObj = VpcWrapper.create(deviceSn, vpcPairs[deviceSn])\n        Wrapper.print(\"%s: Fabric [%s] - Set vPC pair %s <-> %s. Success: [%r]\" % (funcName, \n            fabricName, switchInfo[\"fmtName\"], peerSwitchInfo[\"fmtName\"], not respObj.isRetCodeFailure()))\n\n# process the int_access_host\ndef getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans):\n    devSerial = switchInfo[\"deviceSerial\"]\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"INTF_NAME\" : intfName,\n               \"BPDUGUARD_ENABLED\" : \"no\",\n               \"PORTTYPE_FAST_ENABLED\": \"false\",\n               \"ACCESS_VLAN\" : \"1\",\n               \"SPEED\" : \"Auto\",\n               \"MTU\" : MTU_STR_JUMBO,\n               \"DESC\" : \"\",\n               \"ADMIN_STATE\" : \"true\",\n               \"CONF\": \"\"\n              }\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n            # there is always a match on \"interface_mtu\", even with default mtu\n            nvPairs[\"MTU\"] = Util.getHostIntfMTUStrFromParsedInfo(matchingNvPairs[templateName][\"MTU\"])\n        elif (\"bpduguard_enable\" == templateName):\n            nvPairs[\"BPDUGUARD_ENABLED\"] = \"true\"\n        elif (\"bpduguard_disable\" == templateName):\n            nvPairs[\"BPDUGUARD_ENABLED\"] = \"false\"\n        elif (\"shut_interface\" == templateName):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (\"interface_speed\" == templateName):\n            nvPairs[\"SPEED\"] = Util.mapSwitchSpeedToEnum(matchingNvPairs[templateName][\"SPEED\"])\n        elif (\"porttype_fast_enable\" == templateName):\n            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = \"true\"\n        elif (\"interface_desc\" == templateName):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"interface_orphan_port\" == templateName):\n            nvPairs[\"ENABLE_ORPHAN_PORT\"] = \"true\"\n        elif (\"access_vlan\" == templateName):\n            access_vlan = matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"]\n            nvPairs[\"ACCESS_VLAN\"] = processAccessIntfOverlayInfo(devSerial, switchInfo[\"migrationMode\"], \n                intfName, access_vlan, globalOverlayInfo, device_overlay_vlans)\n\n    templateList = [\n                    \"porttype_fast_trunk\",\n                    \"cdp_disable_interface_11_1\"\n                    ]\n\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = adjustAccessIntfAllowedVlans(intfMatchResult) + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n    #Wrapper.print(\"getAccessIntfNvpairs: device [%s] Interface [%s] nvPairs [%s]\"%(devSerial, intfName, nvPairs))\n\n    return nvPairs\n\ndef adjustAccessIntfAllowedVlans(intfMatchResult):\n    allowedVlans = []\n    unAcctCfg = []\n    utilObj = Util()\n    isDone = False\n\n    # merge all the allowed vlan related config in the unaccounted config into a single line\n    for line in intfMatchResult[\"unaccounted_cmds\"]:\n        addToUnacct = True\n        stripLine = line.strip()\n        if stripLine.startswith(\"switchport trunk allowed vlan \"):\n            addToUnacct = False\n            values = line.strip().split(\"switchport trunk allowed vlan add \")\n            if len(values) == 2:\n                allowedVlans.extend(utilObj.getIntegerRange(values[1]))\n            else:\n                values = line.strip().split(\"switchport trunk allowed vlan \")\n                if len(values) == 2:\n                    vlanListStr = values[1].lower()\n                    if ((vlanListStr == \"none\") or (vlanListStr == \"all\")):\n                        addToUnacct = True\n                        isDone = True\n                    else:\n                        allowedVlans.extend(utilObj.getIntegerRange(vlanListStr))\n\n        if addToUnacct:\n            unAcctCfg.append(line)\n\n    if ((not isDone) and (len(allowedVlans) > 0)):\n        unAcctCfg.append(\"  switchport trunk allowed vlan %s\" % (utilObj.vlanStrFromList(allowedVlans)))\n\n    return unAcctCfg\n\ndef getTrunkIntfAllowedVlanList(intfMatchResult, matchingNvPairs):\n    unAcctCfg = None\n    allowedVlans = None\n    utilObj = Util()\n    isDone = False\n    vlanStr = \"none\"\n\n    for templateName in [\"trunk_interface_fex\", \"port_channel_trunk_interface_11_1\"]:\n        if templateName in matchingNvPairs:\n            vlanListStr = matchingNvPairs[templateName][\"ALLOWED_VLANS\"].lower()\n            if ((vlanListStr == \"none\") or (vlanListStr == \"all\")):\n                vlanStr = vlanListStr\n                isDone = True\n            else:\n                allowedVlans = utilObj.getIntegerRange(vlanListStr)\n            # ignore the other match\n            break\n\n    if not isDone:\n        unAcctCfg = []\n        # need to scan and remove 'switchport trunk allowed vlan add' configs in the unaccounted configs (if any)\n        for line in intfMatchResult[\"unaccounted_cmds\"]:\n            values = line.strip().split(\"switchport trunk allowed vlan add \")\n            if len(values) == 2:\n                allowedVlans.extend(utilObj.getIntegerRange(values[1]))\n            else:\n                unAcctCfg.append(line)\n\n        vlanStr = \"none\" if len(allowedVlans) == 0 else utilObj.vlanStrFromList(allowedVlans)\n    else:\n        unAcctCfg = intfMatchResult[\"unaccounted_cmds\"]\n\n    return vlanStr, unAcctCfg\n\n# process the int_trunk_host\ndef getTrunkIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans):\n    devSerial = switchInfo[\"deviceSerial\"]\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"INTF_NAME\" : intfName,\n               \"BPDUGUARD_ENABLED\" : \"no\",\n               \"PORTTYPE_FAST_ENABLED\": \"false\",\n               \"MTU\" : MTU_STR_JUMBO,\n               \"SPEED\" : \"Auto\",\n               \"ALLOWED_VLANS\" : \"none\",\n               \"DESC\" : \"\",\n               \"CONF\" : \"\",\n               \"ADMIN_STATE\" : \"true\"\n              }\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n            # there is always a match on \"interface_mtu\", even with default mtu\n            nvPairs[\"MTU\"] = Util.getHostIntfMTUStrFromParsedInfo(matchingNvPairs[templateName][\"MTU\"])\n        elif (\"bpduguard_enable\" == templateName):\n            nvPairs[\"BPDUGUARD_ENABLED\"] = \"true\"\n        elif (\"bpduguard_disable\" == templateName):\n            nvPairs[\"BPDUGUARD_ENABLED\"] = \"false\"\n        elif (\"shut_interface\" == templateName):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (\"porttype_fast_trunk\" == templateName):\n            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = \"true\"\n        elif (\"native_vlan\" == templateName):\n            nativeVlan =  matchingNvPairs[templateName][\"NATIVE_VLAN\"]\n            nvPairs[\"NATIVE_VLAN\"] = \"\" if nativeVlan == \"1\" else nativeVlan \n        elif (\"interface_desc\" == templateName):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"interface_orphan_port\" == templateName):\n            nvPairs[\"ENABLE_ORPHAN_PORT\"] = \"true\"\n        elif (\"interface_speed\" == templateName):\n            nvPairs[\"SPEED\"] = Util.mapSwitchSpeedToEnum(matchingNvPairs[templateName][\"SPEED\"])\n\n    currAllowedVlans, unAcctCfg = getTrunkIntfAllowedVlanList(intfMatchResult, matchingNvPairs)\n    if currAllowedVlans != \"none\":\n        if getIsOkToResync(switchInfo, intfName, globalOverlayInfo):\n            nvPairs[\"ALLOWED_VLANS\"] = processTrunkIntfOverlayInfo(devSerial, switchInfo[\"migrationMode\"], intfName,\n                        currAllowedVlans, globalOverlayInfo, device_overlay_vlans)\n\n    templateList = [\n                    \"access_vlan\", \n                    \"cdp_disable_interface_11_1\"\n                    ]\n    if not Util.isFexHIF(intfName):\n        templateList.append(\"porttype_fast_enable\")\n\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = unAcctCfg + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    #Wrapper.print(\"getTrunkIntfNvpairs: device [%s] Interface [%s] nvPairs [%s]\"%(devSerial, intfName, nvPairs))\n\n    return nvPairs\n\ndef getRoutedIntfNvpairs(switchInfo, intfName, matchingNvPairs, includeMemberInheritedCfg=False):\n    funcName = sys._getframe(0).f_code.co_name\n\n    # devSerial = switchInfo[\"deviceSerial\"]\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    isL3PoMember = False\n    templateNameMatches = intfMatchResult[\"matched_templates\"]\n    if (('port_channel_mode' in templateNameMatches) or \n        ('port_channel_mode_on' in templateNameMatches)):\n        isL3PoMember = True\n\n    #Wrapper.print(\"%s. Device [%s] Intf [%s] isL3PoMember [%r]\" % (funcName, devSerial, intfName, isL3PoMember))\n    nvPairs = {\"INTF_NAME\" : intfName, \"INTF_VRF\" : \"\", \"IP\" : \"\", \"PREFIX\" : \"\", \"ROUTING_TAG\" : \"\",\n               \"INTF_VRF\" : \"\", \"ADMIN_STATE\" : \"true\", \"DESC\" : \"\", \"CONF\": \"\", \"MTU\": DEFAULT_MTU, \"SPEED\":\"Auto\"\n              }\n\n    genCfg = [\"  no switchport\"]\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n            if not isL3PoMember:\n                nvPairs.update({\"MTU\" : matchingNvPairs[templateName][\"MTU\"]})\n                genCfg.append(\"  mtu %s\" % nvPairs[\"MTU\"])\n        elif (\"interface_speed\" == templateName):\n            if not isL3PoMember:\n                swSpeed = matchingNvPairs[templateName][\"SPEED\"]\n                nvPairs[\"SPEED\"]  = Util.mapSwitchSpeedToEnum(swSpeed)\n                genCfg.append(\"  speed %s\" % swSpeed)\n        elif (\"interface_no_nego_auto\" == templateName):\n            if not isL3PoMember:\n                genCfg.append(\"  no negotiate auto\")\n        elif (\"interface_desc\" == templateName):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n            genCfg.append(\"  description %s\" % nvPairs[\"DESC\"])\n        elif (\"interface_vrf\" == templateName):\n            nvPairs[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n            genCfg.append(\"  vrf member %s\" % nvPairs[\"INTF_VRF\"])\n        elif (\"shut_interface\" == templateName):\n            nvPairs.update({\"ADMIN_STATE\" : \"false\"})\n        elif (\"p2p_routed_interface\" == templateName):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n            genCfg.append(\"  ip address %s/%s\" % (nvPairs[\"IP\"], nvPairs[\"PREFIX\"]))\n        elif (\"p2p_routed_interface_tag\" == templateName):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n            nvPairs[\"ROUTING_TAG\"] = matchingNvPairs[templateName][\"ROUTING_TAG\"]\n            genCfg.append(\"  ip address %s/%s tag %s\" % (nvPairs[\"IP\"], nvPairs[\"PREFIX\"], nvPairs[\"ROUTING_TAG\"]))\n\n    if nvPairs[\"ADMIN_STATE\"] == \"true\":\n        genCfg.append(\"  no shutdown\")\n    else:\n        genCfg.append(\"  shutdown\")\n\n    # get the configs that do not match our expected generated config\n    unaccCfg = list(OrderedSet(intfMatchResult[\"show_run_cmds\"]) - OrderedSet(genCfg))\n    # Wrapper.print(\"%s: Device [%s] Interface [%s] isL3PoMember [%r] sh_run [%s] genCfg [%s] unaccCfg [%s]\" % (funcName, devSerial, \n    #    intfName, isL3PoMember, intfMatchResult[\"show_run_cmds\"], genCfg, unaccCfg))\n\n    if unaccCfg:\n        if isL3PoMember:\n            isUpdated, newFF = getPoMemberFF(unaccCfg, intfName, includeMemberInheritedCfg)\n            #Wrapper.print(\"%s: Intf [%s]. isUpdated [%r] Original FF [%s] Filtered FF [%s]\" % (funcName, intfName, isUpdated, unaccCfg, newFF))\n        else:\n            newFF = unaccCfg\n\n        if newFF:\n            nvPairs[\"CONF\"] = Util.newLine().join(newFF)\n\n    return nvPairs\n\n# process the int_loopback\ndef getLoopbackIntfNvpairs(fabricName, switchInfo, intfName, matchingNvPairs):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"FABRIC_NAME\" : fabricName, \"INTF_NAME\" : intfName, \"DESC\" : \"\", \"INTF_VRF\" : \"\", \"IP\" : \"\", \"V6IP\" : \"\", \n                \"ROUTE_MAP_TAG\" : \"\", \"LINK_STATE_ROUTING_TAG\" : \"\", \"ADMIN_STATE\" : \"true\", \"CONF\" : \"\"}\n\n    for templateName in matchingNvPairs:\n        if (templateName == \"shut_interface\"):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (templateName == \"interface_desc\"):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (templateName == \"interface_vrf\"):\n            nvPairs[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n        elif (templateName == \"loopback_interface_with_tag\"):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"ROUTE_MAP_TAG\"] = matchingNvPairs[templateName][\"ROUTE_MAP_TAG\"]\n        elif (templateName == \"loopback_interface\"):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n\n    templateList = [\n                    \"bfd_interface_auth\",\n                    \"bfd_no_echo_interface\", \n                    \"bpduguard_disable\", \n                    \"bpduguard_enable\", \n                    \"porttype_fast_enable\",\n                    \"porttype_fast_trunk\",\n                    \"ospf_interface_11_1\",\n                    \"v6_ospf_interface\",\n                    \"isis_interface\",\n                    \"ospf_p2p_interface\",\n                    \"ospf_interface_auth\",\n                    \"pim_interface\",\n                    \"pim_interface_hello_auth\",\n                    \"isis_interface_auth\",\n                    \"isis_interface_auth_no_lvl\",\n                    \"vlan_interface_fwd_mode_11_1\",\n                    \"interface_ipv6_11_1\",\n                    \"interface_ipv6_tag_11_1\",\n                    \"cdp_disable_interface_11_1\",\n                    \"routed_interface_no_ip_redirects\"\n                    ]\n    \n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = intfMatchResult[\"unaccounted_cmds\"] + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    return nvPairs\n\n# process the int_freeform\ndef getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"INTF_NAME\": intfName, \"CONF\" : \"\", \"ADMIN_STATE\" : \"true\"}\n\n    if \"shut_interface\" in matchingNvPairs:\n        nvPairs[\"ADMIN_STATE\"] = \"false\"\n\n    # make a string of all the configs seen (in show run) for the interface except 'shutdown'\n    dot1qID = None\n    cfgList = []\n    for cfg in intfMatchResult[\"show_run_cmds\"]:\n        lowerStr = cfg.lower()\n        if (\"shutdown\" in lowerStr):\n            # skip the shut/no shut config since that is a separate PTI\n            continue\n\n        if (\"encapsulation dot1q\" in lowerStr):\n            dot1qID = lowerStr.strip()[20:]\n\n        cfgList.append(cfg)\n\n    nvPairs[\"CONF\"] = Util.newLine().join(cfgList)\n    return dot1qID, nvPairs\n\n# process the int_mgmt\ndef getMgmtIntfNvpairs(switchInfo, intfName, matchingNvPairs):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n    #Wrapper.print(\"getMgmtIntfNvpairs: Fabric [%s] Serial [%s] intfName [%s] isGreenfield [%r]\" %\n    #        (fabricName, devSerial, intfName, isGreenfield))\n\n    nvPairs = {\"INTF_NAME\" : intfName, \"DESC\" : \"\", \"CDP_ENABLE\" : \"true\", \"ADMIN_STATE\" : \"true\", \"CONF\":\"\" }\n\n    for templateName in matchingNvPairs:\n        if (templateName == \"cdp_disable_interface_11_1\"):\n            nvPairs[\"CDP_ENABLE\"] = \"false\"\n        elif (templateName == \"shut_interface_force\"):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (templateName == \"interface_desc\"):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n    \n    templateList = [\"interface_speed\", \"interface_ipv4_11_1\", \"interface_ipv6_11_1\"]\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = intfMatchResult[\"unaccounted_cmds\"] + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    return nvPairs\n\n# process the int_vlan\ndef getVlanIntfNvpairs(switchInfo, intfName, matchingNvPairs):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"INTF_NAME\": intfName, \"INTF_VRF\": \"\", \"IP\": \"\", \"PREFIX\": \"\", \"MTU\": \"\",\n               \"ROUTING_TAG\": \"\", \"DESC\" : \"\", \"CONF\": \"\", \"ADMIN_STATE\": \"true\",\n               \"DISABLE_IP_REDIRECTS\": \"false\", \"ENABLE_HSRP\": \"false\", \"advSubnetInUnderlay\": \"false\"\n              }\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n           nvPairs[\"MTU\"] = matchingNvPairs[templateName][\"MTU\"]\n        elif (\"interface_desc\" == templateName):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"interface_vrf\" == templateName):\n            nvPairs[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n        elif ((\"interface_ipv4_11_1\" == templateName) or (\"interface_ipv4_tag_11_1\" == templateName)):\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n            if (\"interface_ipv4_tag_11_1\" == templateName):\n                nvPairs[\"ROUTING_TAG\"] = matchingNvPairs[templateName][\"TAG\"]\n        elif (\"routed_interface_no_ip_redirects\" == templateName):\n           nvPairs[\"DISABLE_IP_REDIRECTS\"] = \"true\"\n        elif (\"shut_interface\" == templateName):\n           nvPairs[\"ADMIN_STATE\"] = \"false\"\n\n    templateList = [\n                    \"ospf_interface_11_1\",\n                    \"ospf_interface_auth\",\n                    \"v6_ospf_interface\",\n                    \"isis_interface\",\n                    \"pim_interface\",\n                    \"vlan_interface_fwd_mode_11_1\",\n                    \"interface_ipv6_11_1\",\n                    \"interface_ipv6_tag_11_1\",\n                    \"cdp_disable_interface_11_1\",\n                    \"interface_hsrp_vip\",\n                    \"interface_hsrp_version\",\n                    \"interface_hsrp_priority\",\n                    \"interface_hsrp_mac\",\n                    \"interface_hsrp_preempt\",\n                    \"vlan_interface_dhcp_relay_vrf_11_1\",\n                    \"vlan_interface_dhcp_relay_11_1\",\n                    \"interface_ipv4_netflow\"\n                    ]\n    \n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = intfMatchResult[\"unaccounted_cmds\"] + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    return nvPairs\n\n# process the int_subif\ndef getSubIntfNvPairs(switchInfo, intfName, matchingNvPairs):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n    dot1qID = None\n\n    nvPairs = {\"INTF_NAME\" : intfName, \"VLAN\" : \"\", \"INTF_VRF\" : \"\", \"IP\" : \"\", \"PREFIX\" : \"\",\n               \"ROUTING_TAG\": \"\", \"MTU\": \"9216\", \"DESC\" : \"\", \"CONF\": \"\", \"ADMIN_STATE\" : \"true\"\n              }\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n           nvPairs[\"MTU\"] = matchingNvPairs[templateName][\"MTU\"]\n        elif (\"interface_desc\" == templateName):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"interface_vrf\" == templateName):\n            nvPairs[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n        elif (\"eth_sub_interface\" == templateName or \"eth_sub_interface_tag\" == templateName):\n            nvPairs[\"VLAN\"] = matchingNvPairs[templateName][\"VLAN\"]\n            nvPairs[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            nvPairs[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n            dot1qID = nvPairs[\"VLAN\"]\n            if (\"eth_sub_interface_tag\" == templateName):\n                nvPairs[\"ROUTING_TAG\"] = matchingNvPairs[templateName][\"TAG\"]\n        elif (\"shut_interface\" == templateName):\n           nvPairs[\"ADMIN_STATE\"] = \"false\"\n\n    templateList = [\n                    \"bfd_interface_auth\",\n                    \"bfd_no_echo_interface\", \n                    \"bpduguard_disable\", \n                    \"bpduguard_enable\", \n                    \"porttype_fast_enable\",\n                    \"porttype_fast_trunk\",\n                    \"ospf_interface_11_1\",\n                    \"v6_ospf_interface\",\n                    \"isis_interface\",\n                    \"ospf_p2p_interface\",\n                    \"ospf_interface_auth\",\n                    \"pim_interface_hello_auth\",\n                    \"isis_interface_auth\",\n                    \"isis_interface_auth_no_lvl\",\n                    \"pim_interface\",\n                    \"vlan_interface_fwd_mode_11_1\",\n                    \"interface_ipv6_11_1\",\n                    \"interface_ipv6_tag_11_1\",\n                    \"cdp_disable_interface_11_1\",\n                    \"routed_interface_no_ip_redirects\"\n                    ]\n    \n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = intfMatchResult[\"unaccounted_cmds\"] + configList\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    return dot1qID, nvPairs\n\n# process the int_nve\ndef getNveIntfNvpairs(switchInfo, intfName, matchingNvPairs, isExternalFab=False):\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    nvPairs = {\"INTF_NAME\" : intfName, \"DESC\" : \"\", \"SOURCE_INTF_NAME\" : \"\", \"ANYCAST_INTF_NAME\" : \"\",\n               \"ADMIN_STATE\" : \"true\", \"HD_TIME\": \"180\", \"CONF\":\"\", \"FABRIC_NAME\":FABRIC_NAME,\n              }\n\n    for templateName in matchingNvPairs:\n        if (templateName == \"shut_interface\"):\n            nvPairs[\"ADMIN_STATE\"] = \"false\"\n        elif (templateName == \"nve_interface\"):\n            nvPairs[\"SOURCE_INTF_NAME\"] = matchingNvPairs[templateName][\"SOURCE_INTF_NAME\"]\n        elif (templateName == \"nve_anycast_interface\"):\n            nvPairs[\"SOURCE_INTF_NAME\"] = matchingNvPairs[templateName][\"SOURCE_INTF_NAME\"]\n            nvPairs[\"ANYCAST_INTF_NAME\"] = matchingNvPairs[templateName][\"ANYCAST_INTF_NAME\"]\n        elif (templateName == \"interface_desc\"):\n            nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (templateName == \"nve_holddown_time\"):\n            hdTime = matchingNvPairs[templateName][\"HD_TIME\"]\n            if (hdTime != \"\" or hdTime != \"180\"):\n                nvPairs[\"HD_TIME\"] = hdTime\n    \n    # use the 'NVE_BLOCK' unaccounted config\n    #intNveRec = matchResult[\"FEATURES_INFO\"][\"NVE_BLOCK\"].get(\"interface \" + intfName)\n    #ffList = intNveRec[\"unaccounted\"].pop(0) if len(intNveRec[\"unaccounted\"] > 1)\n    ffList = intfMatchResult[\"unaccounted_cmds\"]\n    if ffList:\n        nvPairs[\"CONF\"] = Util.newLine().join(ffList)\n\n    if isExternalFab:\n        # collect all the 'member vni' configs from the running configs\n        pass\n        \n    return nvPairs\n\ndef getIsOkToResync(switchInfo, intfName, globalOverlayInfo):\n    devSerial = switchInfo[\"deviceSerial\"]\n\n    hostPortResyncDict = globalOverlayInfo.get(\"HOST_PORT_RESYNC\", None)\n    if not hostPortResyncDict:\n        return True\n\n    switchDict = hostPortResyncDict[\"switches\"]\n    dbIfEntry = switchDict[devSerial][intfName.lower()]\n    okToRsync = (dbIfEntry['okToResyn'] and not dbIfEntry['isIGMember'])\n    Wrapper.print(\"getIsOkToResync: switch [%s] Intf [%s] val [%r]\" % (devSerial, intfName, okToRsync))\n    return okToRsync\n\ndef getL3PoIntfParams(switchInfo, intfName, matchingNvPairs):\n    devSerial = switchInfo[\"deviceSerial\"]\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    lowerIntfName = intfName.lower()\n    ignore, pcid = lowerIntfName.split(\"port-channel\")\n\n    templateNameMatches = intfMatchResult[\"matched_templates\"]\n\n    params = {\"PO_ID\" : intfName, \"INTF_VRF\" : \"\", \"IP\" : \"\", \"PREFIX\" : \"\", \"ROUTING_TAG\" : \"\",\n             \"MTU\" : DEFAULT_MTU, \"SPEED\" : \"Auto\", \"DESC\" : \"\", \"CONF\" : \"\", \"ADMIN_STATE\" : \"true\"}\n\n    for templateName in matchingNvPairs:\n        if (\"interface_mtu\" == templateName):\n            params[\"MTU\"] = matchingNvPairs[templateName][\"MTU\"]\n        elif (\"interface_speed\" == templateName):\n            params[\"SPEED\"]  = Util.mapSwitchSpeedToEnum(matchingNvPairs[templateName][\"SPEED\"])\n        elif (\"interface_desc\" == templateName):\n            params[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n        elif (\"interface_vrf\" == templateName):\n            params[\"INTF_VRF\"] = matchingNvPairs[templateName][\"INTF_VRF\"]\n        elif (\"shut_interface\" == templateName):\n            params[\"ADMIN_STATE\"] = \"false\"\n        elif (\"p2p_routed_interface\" == templateName):\n            params[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            params[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n        elif (\"p2p_routed_interface_tag\" == templateName):\n            params[\"IP\"] = matchingNvPairs[templateName][\"IP\"]\n            params[\"PREFIX\"] = matchingNvPairs[templateName][\"PREFIX\"]\n            params[\"ROUTING_TAG\"] = matchingNvPairs[templateName][\"ROUTING_TAG\"]\n\n    templateList = [\"cdp_disable_interface_11_1\", \"pim_interface\", \"routed_interface_no_ip_redirects\"]\n\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = intfMatchResult[\"unaccounted_cmds\"] + configList\n    if ffList:\n        params[\"CONF\"] = Util.newLine().join(ffList)\n\n    return params\n\ndef getL2PoIntfParams(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans):\n    devSerial = switchInfo[\"deviceSerial\"]\n    matchResult = switchInfo[\"matchResult\"]\n    intfMatchResult = switchInfo[\"interfacesRes\"][intfName]\n\n    lowerIntfName = intfName.lower()\n    ignore, pcid = lowerIntfName.split(\"port-channel\")\n\n    templateNameMatches = intfMatchResult[\"matched_templates\"]\n    isVpcPeerLinkPo = False\n    ifFexPo = False\n    isAccess = False\n    if (\"fex_port_channel_interface\" in templateNameMatches):\n        ifFexPo = True\n    elif ((\"port_channel_access_interface\" in templateNameMatches) or\n        (\"port_channel_dot1q_tunnel_interface\" in templateNameMatches)):\n        # treat the dot1q tunnell interface as access\n        isAccess = True\n\n    unAcctCfg = intfMatchResult[\"unaccounted_cmds\"]\n    params = {\"pcId\" : pcid, \"fexId\" : \"\", \"vpcId\" : \"\", \"poMtu\" : \"default\", \"poSpeed\" : \"Auto\", \"poAdminState\" : \"true\",\n              \"native_vlan\": \"\", \"poDesc\" : \"\", \"orphanPort\": \"false\", \"bpduGuardState\" : \"no\", \"porttype_fast_enable\" : \"false\",\n              \"porttype_fast_trunk\" : \"false\", \"vpcId\" : \"\", \"fexId\" : \"\", \"poConf\" : \"\"}\n\n    if (\"interface_mtu\" in templateNameMatches):\n        params[\"poMtu\"] = Util.getHostIntfMTUStrFromParsedInfo(matchingNvPairs[\"interface_mtu\"][\"MTU\"])\n    if (\"interface_speed\" in templateNameMatches):\n        params[\"poSpeed\"] = Util.mapSwitchSpeedToEnum(matchingNvPairs[\"interface_speed\"][\"SPEED\"])\n    if (\"fex_port_channel_interface\" in templateNameMatches):\n        params[\"fexId\"] = matchingNvPairs[\"fex_port_channel_interface\"][\"FEX_ID\"]\n    if (\"shut_interface\" in templateNameMatches):\n        params[\"poAdminState\"] = \"false\"\n    if (\"interface_desc\" in templateNameMatches):\n        params[\"poDesc\"] = matchingNvPairs[\"interface_desc\"][\"DESC\"]\n    if (\"interface_orphan_port\" in templateNameMatches):\n        params[\"orphanPort\"] = \"true\"\n    if (\"bpduguard_enable\" in templateNameMatches):\n        params[\"bpduGuardState\"] = \"true\"\n    if (\"bpduguard_disable\" in templateNameMatches):\n        params[\"bpduGuardState\"] = \"false\"\n    if (\"porttype_fast_trunk\" in templateNameMatches):\n        params[\"porttype_fast_trunk\"] = \"true\"\n    if (\"porttype_fast_enable\" in templateNameMatches):\n        params[\"porttype_fast_enable\"] = \"true\"\n    if (\"port_channel_vpc_id_11_1\" in templateNameMatches):\n        vpcId = matchingNvPairs[\"port_channel_vpc_id_11_1\"][\"VPC_ID\"]\n        if vpcId != \"peer-link\":\n            params[\"vpcId\"]  = vpcId\n        else:\n            isVpcPeerLinkPo = True\n    if (\"native_vlan\" in templateNameMatches):\n        params[\"native_vlan\"] = matchingNvPairs[\"native_vlan\"][\"NATIVE_VLAN\"]\n\n    if isAccess:\n        accessVlan = matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"] if \"access_vlan\" in matchingNvPairs else \"1\"\n        params[\"access_vlan\"] = processAccessIntfOverlayInfo(devSerial, switchInfo[\"migrationMode\"], \n            intfName, accessVlan, globalOverlayInfo, device_overlay_vlans)\n        unAcctCfg = adjustAccessIntfAllowedVlans(intfMatchResult)\n    else:\n        if not ifFexPo:\n            currAllowedVlans, unAcctCfg = getTrunkIntfAllowedVlanList(intfMatchResult, matchingNvPairs)\n            if getIsOkToResync(switchInfo, intfName, globalOverlayInfo):\n                params[\"allowed_vlans\"] = processTrunkIntfOverlayInfo(devSerial, switchInfo[\"migrationMode\"], intfName,\n                        currAllowedVlans, globalOverlayInfo, device_overlay_vlans)\n            else:\n                # keep the allowed vlans intact\n                params[\"allowed_vlans\"] = currAllowedVlans\n\n    templateList = [\"cdp_disable_interface_11_1\"]\n    if isAccess:\n        templateList.append(\"native_vlan\")\n        templateList.append(\"porttype_fast_trunk\")\n    else:\n        if not ifFexPo:\n            templateList.append(\"access_vlan\")\n            templateList.append(\"porttype_fast_enable\")\n    \n    if isVpcPeerLinkPo:\n        if \"access_vlan\" not in templateList:\n            templateList.append(\"access_vlan\")\n        if \"porttype_fast_enable\" not in templateList:\n            templateList.append(\"porttype_fast_enable\")\n        if \"porttype_fast_trunk\" not in templateList:\n            templateList.append(\"porttype_fast_trunk\")\n        templateList.append(\"bpduguard_disable\")\n        templateList.append(\"bpduguard_enable\")\n        templateList.append(\"interface_speed\")\n        templateList.append(\"interface_no_nego_auto\")\n\n    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n    ffList = unAcctCfg + configList\n    if ffList:\n        params[\"poConf\"] = Util.newLine().join(ffList)\n\n    return params\n\ndef getPoMembersInfo(fabricName, devSerial, poMembersDict, matchResult, interfacesRes):\n    for intfName in poMembersDict:\n        nvPairs = poMembersDict[intfName]\n\n        lowerIntfName = intfName.lower()\n\n        intfMatchResult = interfacesRes[intfName]\n        templateNameMatches = intfMatchResult[\"matched_templates\"]\n        matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n        for templateName in matchingNvPairs:\n            if (\"shut_interface\" == templateName):\n                nvPairs[\"ADMIN_STATE\"] = \"false\"\n            elif (\"interface_desc\" == templateName):\n                nvPairs[\"DESC\"] = matchingNvPairs[templateName][\"DESC\"]\n\ndef getCurrentIntfPyPtiById(policyId):\n    return Util.exe(PTIWrapper.getInstance(policyId))\n\ndef getCurrentIntfPyPti(devSerial, intfName):\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateContentType(\"PYTHON\")\n    srchOpt.setEntityName(intfName)\n    srchOpt.setEntityType(\"INTERFACE\")\n    ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    return ptiList[0] if ptiList else None\n\nstandaloneSwitchShippingIntfPolicies = [\"breakout_interface\",\n                        \"int_port_channel_fex\", \"int_port_channel_trunk_host\",\n                        \"int_port_channel_access_host\", \"int_port_channel_dot1q_tunnel_host\",\n                        \"int_trunk_host\", \"int_access_host\", \"int_dot1q_tunnel_host\",\n                        \"int_freeform\", \"int_loopback\", \"int_subif\", \"int_routed_host\",\n                        \"int_mgmt\", \"int_nve\", \"int_vlan\"]\n\nvpcSwitchShippingIntfPolicies = [\"int_port_channel_aa_fex\", \"int_vpc_trunk_host\", \"int_vpc_access_host\",\n                                 \"int_vpc_dot1q_tunnel\"]\n\n# the host interface DB\n#   switches - dictionary of interfaces and corresponding info. Key is intf name (vpc key pair for vpcs)\n#              value is a dictionary that holds the following:\n#                   - current information found in IM\n#                   - new info obtained from switch\n#hostPortResyncDict = {\"switches\" : {}, \"vpcHostPairs\" : {}, \"networks\" : {}}\n\n# build a dictionary of interface information that IM is aware of\ndef buildCurrentIntfInfoDb(fabricName, gVarDictObj, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    switchInfo = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    formattedName = switchInfo[\"fmtName\"]\n    hostPortResyncDict = globalOverlayInfo[\"HOST_PORT_RESYNC\"]\n    switchDict = hostPortResyncDict[\"switches\"]\n    vpcIntfDict = hostPortResyncDict[\"vpcHostPairs\"]\n\n    allTemplates = vpcSwitchShippingIntfPolicies + standaloneSwitchShippingIntfPolicies\n\n    # get info from IM\n    intfInfo = json.loads(Util.exe(IM.getInterfaceDetail(devSerial)))\n    Wrapper.print(\"%s: FAB [%s]: Switch [%s] Num Interfaces %s\" % (funcName, fabricName, devSerial, len(intfInfo)))\n\n    for intfEntry in intfInfo:\n        # we expect only one underlay policy (the jython)\n        underlayPolicyEntry = intfEntry[\"underlayPolicies\"][0] if intfEntry[\"underlayPolicies\"] else None\n        nvPairs = None\n        ifType = intfEntry[\"ifType\"]\n        ifName = intfEntry[\"ifName\"]\n        serialNum = intfEntry[\"serialNo\"]\n\n        isIGMember = True if intfEntry[\"interfaceGroup\"] else False\n\n        # ignore interface for resync for the following conditions:\n        #   - is IG member\n        #   - if the source of the policy is non empty\n        #   - if the policy template is not one the feature recognizes\n        okToResyn = False if isIGMember else True\n        if underlayPolicyEntry:\n            if ((underlayPolicyEntry[\"source\"] != \"\") or \n                (underlayPolicyEntry[\"templateName\"] not in allTemplates)):\n                okToResyn = False\n\n        hasOverlays = True if (intfEntry[\"overlayNetwork\"] or isIGMember) else False\n\n        if ifType == \"INTERFACE_VPC\":\n            # isPresent = True indicates interface is still present on switch, False otherwise. Set to False by default\n            dbIfEntry = {\"ifName\" : intfEntry[\"ifName\"], \"current\" : {}, \"new\" : None, \"isPresent\" : False,\n                \"okToResyn\" : okToResyn, \"isIGMember\" : isIGMember}\n            vpcIntfDict[serialNum][ifName] = dbIfEntry\n        else:\n            # non vPC interfaces\n            ifName = ifName.lower()\n\n            dbIfEntry = {\"ifName\" : intfEntry[\"ifName\"], \"current\" : {}, \"new\" : None, \"isPresent\" : False,\n                \"okToResyn\" : okToResyn, \"isIGMember\" : isIGMember}\n            switchDict[serialNum][ifName] = dbIfEntry\n\n        dbIfEntry[\"current\"] = {\"ifType\": ifType, \"policy\" : underlayPolicyEntry, \n                                \"discovered\" : intfEntry[\"discovered\"], \"hasOverlays\" : hasOverlays}\n        #Wrapper.print(\"%s: FAB [%s]: Switch [%s] dbIfEntry %s Entry %s\" % (funcName, fabricName,\n        #    devSerial, dbIfEntry, intfEntry))\n\n    #Wrapper.print(\"%s: FAB [%s]: Switch [%s] hostPortResyncDict %s\" % (funcName, fabricName,\n    #    devSerial, json.dumps(hostPortResyncDict, indent=4, sort_keys=True)))\n\ndef buildHostPortResyncDb(fabricName, gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n\n    switchInfo = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    matchResult = switchInfo[\"matchResult\"]\n    interfacesRes = switchInfo[\"interfacesRes\"]\n    formattedName = switchInfo[\"fmtName\"]\n\n    isExternalFab = globalOverlayInfo[\"isExternalFab\"]\n\n    Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s. Switch [%s]\" % (fabricName, funcName, formattedName))\n\n    hostPortResyncDict = globalOverlayInfo[\"HOST_PORT_RESYNC\"]\n    switchDict = hostPortResyncDict[\"switches\"]\n    vpcIntfDict = hostPortResyncDict[\"vpcHostPairs\"]\n\n    switchGbl = switchDict[devSerial]\n    vpcPairGbl = None\n    isPeer1 = None\n\n    Wrapper.print(\"%s: vpcIntfDict [%s] \" % (funcName, json.dumps(vpcIntfDict, indent=4, sort_keys=True)))\n\n    vpcPeerSw = switchGbl.get(\".vpcPeer\", None)\n    if vpcPeerSw == None:\n        vpcPeerSw = switchInfo[\"vpcPeer\"]\n\n    peerLinkPcId = None\n    if vpcPeerSw:\n        # build the VPC pair key\n        vpcPairkey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, vpcPeerSw))\n        vpcPairGbl = vpcIntfDict[vpcPairkey]\n        if vpcPairGbl[\"peer1Sn\"] == devSerial:\n            isPeer1 = True\n        else:\n            isPeer1 = False\n\n        templateName = \"vpc_peer_link_po_interface\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            # we expect only one\n            ignore, peerLinkPcId = nvPairList[0][\"INTF_NAME\"].lower().split(\"port-channel\")\n\n    Wrapper.print(\"%s: vpcPeerSw [%s] isPeer1 [%r] peerLinkPcId [%s]\" % (funcName, vpcPeerSw, isPeer1, peerLinkPcId))\n    \n    # check to make sure we do not find any vpc configs while the switch is not tagged as such\n    templateName = \"port_channel_vpc_id_11_1\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        if not vpcPairGbl:\n            # the switch is not tagged as a vpc pair\n            respObj.addErrorReport(\"HOST_PORT_RESYNC:VPC-PAIRING\", \"Found vPC configuration on switch that is \"\n                \"not marked as a vPC Pair in the topology. Please make the vPC Pairings and retry\", devSerial)\n            respObj.setFailureRetCode()\n            return respObj\n\n    try:\n        # collect the breakout ports\n        templateName = \"breakout_interface\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            entries = {}\n            switchGbl[\".breakout\"] = {\"templateName\" : templateName, \"entries\" : entries}\n            for nvPair in nvPairList:\n                # if the PORT is a range, then we need to unroll it into individual PTIs\n                ports = getIntegerRange(nvPair[\"PORT\"])\n\n                Wrapper.print(\"Breakout: slot [%s], ports [%s] portList %s\" % (nvPair[\"SLOT\"], nvPair[\"PORT\"], ports))\n\n                for port in ports:\n                    strPort = str(port)\n                    # build the parent intf name\n                    intfName = \"Ethernet\" + nvPair[\"SLOT\"] + \"/\" + strPort\n\n                    nvPairs = {\"SLOT\": nvPair[\"SLOT\"], \"PORT\" : strPort, \"MAP\" : nvPair[\"MAP\"]}\n\n                    intfEntry = {\"ifName\" : intfName, \"nvPairs\" : nvPairs}\n                    entries[intfName.lower()] = intfEntry\n\n        # the N9K host trunk/access interfaces policies depend on the system_jumbomtu policy.. need to process that\n        templateName = \"system_jumbomtu\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        #Wrapper.print(\"%s: Switch [%s] system_jumbomtu nvPairList [%s]\" % (funcName, formattedName, nvPairList))\n        if (nvPairList != None):\n            entries = {}\n            switchGbl[\".jumbomtu\"] = {\"templateName\" : templateName, \"entries\" : entries}\n            for nvPair in nvPairList:\n                # there will be one entry only\n\n                # check the existing value and see if there is any change.. a change will require us to reeval all\n                # trunk/access ports\n                isMtuChanged = False\n                srchOpt = CtrlPolicySearch()\n                srchOpt.setSerialNumber(devSerial)\n                srchOpt.setTemplateName(templateName)\n                ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                for pti in ptiList:\n                    # we expect only one\n                    if pti.isDeleted():\n                        continue\n\n                    existingNvPairs = pti.getNvPairs()\n                    if existingNvPairs[\"MTU\"] != nvPair[\"MTU\"]:\n                        isMtuChanged = True\n\n                entries[\"SWITCH\"] = {\"isMtuChanged\" : isMtuChanged, \"nvPairs\" : {\"MTU\" : nvPair[\"MTU\"]}}\n                break\n\n        # vlan capture for external fabric\n        if isExternalFab:\n            vlanMatchRes = matchResult[\"FEATURES_INFO\"][\"VLAN_BLOCK\"]\n            vlanFreeForm = \"\"\n            for vlanStr in vlanMatchRes.keys():\n                vlanRec = vlanMatchRes[vlanStr]\n                if vlanFreeForm == \"\":\n                    vlanFreeForm = Util.newLine().join(vlanRec[\"show_run\"])\n                else:\n                    vlanFreeForm = vlanFreeForm + Util.newLine() + Util.newLine().join(vlanRec[\"show_run\"])\n            if vlanFreeForm != \"\":\n                entries = {}\n                Wrapper.print(\"%s, vlanFreeForm %s\" % (funcName, vlanFreeForm))\n                switchGbl[\".vlanCfg\"] = {\"templateName\" : \"switch_freeform\", \"entries\" : entries}\n                entries[\"SWITCH_VLANS\"] = {\"nvPairs\" : {\"CONF\" : vlanFreeForm}}\n\n        fexNameDict = {}\n        templateName = \"base_fex\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        #Wrapper.print(\"%s: Switch [%s] base_fex nvPairList [%s]\" % (funcName, formattedName, nvPairList))\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                fexNameDict[nvPair[\"FEX_ID\"]] = nvPair[\"DESC\"]\n\n        sortedIntfNames = sorted(interfacesRes.keys())\n\n        # dictionary for PO. Key is po id. value is a dictionary for the name, members, channel mode\n        poMemberIntfDict = {\"id2Name\" : {}, \"fex\" : {}, \"po\" : {}}\n        for intfName in sortedIntfNames:\n            lowerIntfName = intfName.lower()\n            if lowerIntfName not in switchGbl:\n                \"\"\"\n                # this interface has not been discovered yet? error and instruct user to do a resyn and retry\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:REDISCOVER\", \"Interface [%s] exists on switch, but, \"\n                    \"not discovered in NDFC yet. Please Rediscover the switch and retry Recalculate & Deploy.\" % (intfName), devSerial)\n                respObj.setFailureRetCode()\n                return respObj\n                \"\"\"\n                # add a new entry\n                currentEntry = {\"policy\" : None, \"discovered\" : False, \"hasOverlays\" : False}\n                switchGbl[lowerIntfName] = {\"ifName\" : intfName, \"current\" : currentEntry, \"new\" : None,\n                                                                \"okToResyn\" : True, \"isIGMember\" : False}\n\n            dbIfEntry = switchGbl[lowerIntfName]\n            # update with the name as found on switch\n            dbIfEntry[\"ifName\"] = intfName\n            # mark the intf as pesent\n            dbIfEntry[\"isPresent\"] = True\n\n            \"\"\"\n            if not dbIfEntry[\"okToResyn\"]:\n                # do not consider this\n                Wrapper.print(\"%s: Switch [%s] Skipping Intf [%s]\" % (funcName, formattedName, intfName))\n                intfMatchResult.update({\"isProcessed\" : True})\n                continue\n            \"\"\"\n            Wrapper.print(\"%s: Switch [%s] intfName [%s] Switch Intf [%s]\" % (funcName, formattedName, intfName, dbIfEntry))\n\n            # get the interface match results\n            intfMatchResult = interfacesRes[intfName]\n\n            # skip interfaces that have been processed\n            if isIntfProcessed(intfMatchResult):\n                continue\n\n            templateNameMatches = intfMatchResult[\"matched_templates\"]\n            matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n            newIntfEntry = None\n            if (lowerIntfName.startswith(\"vlan\")):\n                if isExternalFab:\n                    Wrapper.print(\"%s: intfMatchResult %s: matchingNvPairs %s\" % (lowerIntfName, intfMatchResult, matchingNvPairs))\n                    srchOpt = CtrlPolicySearch()\n                    srchOpt.setSerialNumber(devSerial)\n                    srchOpt.setTemplateName(\"int_vlan_internal\")\n                    srchOpt.setEntityName(intfName)\n                    ptiList = Util.exe(PTI.getPTIs(srchOpt))\n                    if ptiList:\n                        Wrapper.print(\"%s skip %s with int_vlan_internal policy\" % (funcName, intfName))\n                        dbIfEntry[\"okToResyn\"] = False\n                        continue\n\n                    templateName = \"int_vlan\"\n                    nvPairs = {\"INTF_NAME\": lowerIntfName,\n                               \"interface\": lowerIntfName,\n                               \"VLANS\": lowerIntfName[4:],\n                               \"INTF_VRF\": \"\",\n                               \"IP\": \"\",\n                               \"PREFIX\": \"\",\n                               \"MTU\" : \"\",\n                               \"ROUTING_TAG\": \"\",\n                               \"DISABLE_IP_REDIRECTS\": \"false\",\n                               \"DESC\": \"\",\n                               \"ADMIN_STATE\": \"true\",\n                               \"CONF\": \"\",\n                               \"ENABLE_HSRP\": \"false\",\n                               \"HSRP_VIP\": \"\",\n                               \"HSRP_VERSION\": \"\",\n                               \"HSRP_PRIORITY\": \"\",\n                               \"HSRP_GROUP\": \"\",\n                               \"MAC\": \"\",\n                               \"PREEMPT\": \"\"\n                              }\n\n                    freeformCfg = []\n                    other_hsrp_subcmds = []\n                    if \"shut_interface\" in templateNameMatches:\n                        nvPairs[\"ADMIN_STATE\"] = \"false\"\n\n                    cur_hsrp_top_cli = \"\"\n                    for cmd in intfMatchResult[\"show_run_cmds\"]:\n                        if not cmd.startswith(\"    \"):\n                            # first level interface cmd\n\n                            if cur_hsrp_top_cli != \"\":\n                                if nvPairs[\"ENABLE_HSRP\"] != \"true\":\n                                    # all goes to freeform\n                                    freeformCfg.append(cur_hsrp_top_cli)\n\n                                    if nvPairs[\"HSRP_PRIORITY\"] != \"\":\n                                        other_hsrp_subcmds.append(\"    priority %s\" % nvPairs[\"HSRP_PRIORITY\"])\n                                        nvPairs[\"HSRP_PRIORITY\"] = \"\"\n                                    if nvPairs[\"PREEMPT\"] == \"true\":\n                                        other_hsrp_subcmds.append(\"    preempt\")\n                                        nvPairs[\"PREEMPT\"] = \"false\"\n                                    if nvPairs[\"MAC\"] != \"\":\n                                        other_hsrp_subcmds.append(\"    mac-address %s\" % nvPairs[\"MAC\"])\n                                        nvPairs[\"MAC\"] = \"\"\n                                else:\n                                    nvPairs[\"HSRP_GROUP\"] = cur_hsrp_top_cli.split()[1]\n\n                                if len(other_hsrp_subcmds) > 0:\n                                    if nvPairs[\"ENABLE_HSRP\"] == \"true\":\n                                        freeformCfg.append(cur_hsrp_top_cli)\n                                    freeformCfg = freeformCfg + other_hsrp_subcmds\n\n                                cur_hsrp_top_cli = \"\"\n                                other_hsrp_subcmds = []\n\n                            if cmd.startswith(\"  ip address \") and (not \"route\" in cmd) and (not \"secondary\" in cmd) and (not \"dhcp\" in cmd):\n                                ip = cmd.split()[2].split(\"/\")\n                                nvPairs[\"IP\"] = ip[0]\n                                nvPairs[\"PREFIX\"] = ip[1]\n                                if \"tag\" in cmd:\n                                    nvPairs[\"ROUTING_TAG\"] = cmd.split()[4]\n                            elif cmd.startswith('  vrf member '):\n                                nvPairs[\"INTF_VRF\"] = cmd.split()[2]\n                            elif cmd.startswith('  description '):\n                                nvPairs[\"DESC\"] = cmd[14:]\n                            elif cmd.startswith('  mtu '):\n                                nvPairs[\"MTU\"] = cmd.split()[1]\n                            elif cmd == '  shutdown':\n                                nvPairs[\"ADMIN_STATE\"] = \"false\"\n                            elif cmd == '  no shutdown':\n                                continue\n                            elif cmd == \"  no ip redirects\":\n                                nvPairs[\"DISABLE_IP_REDIRECTS\"] = \"true\"\n                            elif cmd == \"  no ipv6 redirects\":\n                                nvPairs[\"DISABLE_IP_REDIRECTS\"] = \"true\"\n                            elif cmd.startswith('  hsrp '):\n                                if cmd.startswith(\"  hsrp version\"):\n                                    nvPairs[\"HSRP_VERSION\"] = cmd.split()[2]\n                                else:\n                                    if nvPairs[\"HSRP_GROUP\"] == \"\":\n                                        keys = cmd.split()\n                                        key1 = keys[1]\n                                        if len(keys) == 2 and key1[:1].isdigit():\n                                            cur_hsrp_top_cli = cmd\n                                            other_hsrp_subcmds = []\n                                        else:\n                                            freeformCfg.append(cmd)\n                                    else:\n                                        freeformCfg.append(cmd)\n                            else:\n                                freeformCfg.append(cmd)\n                        else:\n                            if cur_hsrp_top_cli == \"\":\n                                freeformCfg.append(cmd)\n                                continue\n\n                            # hsrp sub-cmd following the v4 group\n                            if cmd.startswith(\"    ip \") and len(cmd.split()) == 2:\n                                nvPairs[\"HSRP_VIP\"] = cmd.split()[1]\n                                nvPairs[\"ENABLE_HSRP\"] = \"true\"\n                            elif cmd.startswith(\"    priority \") and len(cmd.split()) == 2:\n                                nvPairs[\"HSRP_PRIORITY\"] = cmd.split()[1]\n                            elif cmd.strip() == \"preempt\":\n                                nvPairs[\"PREEMPT\"] = \"true\"\n                            elif cmd.startswith(\"    mac-address \"):\n                                nvPairs[\"MAC\"] = cmd.split()[1]\n                            else:\n                                other_hsrp_subcmds.append(cmd)\n\n                    # if hsrp group is the last block\n                    if cur_hsrp_top_cli != \"\":\n                        if nvPairs[\"ENABLE_HSRP\"] != \"true\":\n                            # all goes to freeform\n                            freeformCfg.append(cur_hsrp_top_cli)\n\n                            if nvPairs[\"HSRP_PRIORITY\"] != \"\":\n                                other_hsrp_subcmds.append(\"    priority %s\" % nvPairs[\"HSRP_PRIORITY\"])\n                                nvPairs[\"HSRP_PRIORITY\"] = \"\"\n                            if nvPairs[\"PREEMPT\"] == \"true\":\n                                other_hsrp_subcmds.append(\"    preempt\")\n                                nvPairs[\"PREEMPT\"] = \"false\"\n                            if nvPairs[\"MAC\"] != \"\":\n                                other_hsrp_subcmds.append(\"    mac-address %s\" % nvPairs[\"MAC\"])\n                                nvPairs[\"MAC\"] = \"\"\n                        else:\n                            nvPairs[\"HSRP_GROUP\"] = cur_hsrp_top_cli.split()[1]\n\n                        if len(other_hsrp_subcmds) > 0:\n                            if nvPairs[\"ENABLE_HSRP\"] == \"true\":\n                                freeformCfg.append(cur_hsrp_top_cli)\n                            freeformCfg = freeformCfg + other_hsrp_subcmds\n\n                        Wrapper.print(\"++++ %s: cur_hsrp_top_cli %s, freeform %s\" %(funcName,cur_hsrp_top_cli, freeformCfg))\n\n\n                    if nvPairs[\"ENABLE_HSRP\"] != \"true\":\n                        if nvPairs[\"HSRP_VERSION\"] != \"\":\n                            freeformCfg.append(\"  hsrp version %s\" % nvPairs[\"HSRP_VERSION\"])\n                            nvPairs[\"HSRP_VERSION\"] = \"\"\n                    elif nvPairs[\"IP\"] == \"\":\n                        # all hsrp cli go to freeform\n                        if nvPairs[\"HSRP_VERSION\"] != \"\":\n                            freeformCfg.append(\"  hsrp version %s\" % nvPairs[\"HSRP_VERSION\"])\n                            nvPairs[\"HSRP_VERSION\"] = \"\"\n\n                        hsrp_clis = [\"  hsrp %s\" % nvPairs[\"HSRP_GROUP\"]]\n                        nvPairs[\"HSRP_GROUP\"] = \"\"\n                        nvPairs[\"ENABLE_HSRP\"] = \"false\"\n                        if nvPairs[\"HSRP_VIP\"] != \"\":\n                            hsrp_clis.append(\"    ip %s\" % nvPairs[\"HSRP_VIP\"])\n                            nvPairs[\"HSRP_VIP\"] = \"\"\n                        if nvPairs[\"HSRP_PRIORITY\"] != \"\":\n                            hsrp_clis.append(\"    priority %s\" % nvPairs[\"HSRP_PRIORITY\"])\n                            nvPairs[\"HSRP_PRIORITY\"] = \"\"\n                        if nvPairs[\"PREEMPT\"] == \"true\":\n                            hsrp_clis.append(\"    preempt\")\n                            nvPairs[\"PREEMPT\"] = \"false\"\n                        if nvPairs[\"MAC\"] != \"\":\n                            hsrp_clis.append(\"    mac-address %s\" % nvPairs[\"MAC\"])\n                            nvPairs[\"MAC\"] = \"\"\n\n                        freeformCfg = freeformCfg + hsrp_clis\n\n                    if len(freeformCfg) > 0:\n                        nvPairs[\"CONF\"] = Util.newLine().join(freeformCfg)\n\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                    Wrapper.print(\"%s: %s nvPairs %s\" % (funcName, lowerIntfName, nvPairs))\n\n                    dbIfEntry[\"okToResyn\"] = True\n                else:\n                    # do not do anything for easy fabric\n                    dbIfEntry[\"okToResyn\"] = False\n                    continue\n            else:\n                templateNameMatches = intfMatchResult[\"matched_templates\"]\n                if lowerIntfName.startswith(\"port-channel\"):\n                    ignore, pcId = lowerIntfName.split(\"port-channel\")\n                    usePoFF = False\n                    if ((\"port_channel_trunk_interface_11_1\" in templateNameMatches) or \n                        (\"port_channel_access_interface\" in templateNameMatches) or \n                        (\"port_channel_dot1q_tunnel_interface\" in templateNameMatches) or \n                        (\"fex_port_channel_interface\" in templateNameMatches) or\n                        (\"vpc_peer_link_po_interface\" in templateNameMatches)):\n                        # L2 PO\n                        poMemberIntfDict[\"id2Name\"][pcId] = {\"intfName\" : intfName, \"isL3\" : False}\n                    elif (\"port_channel_routed_interface\" in templateNameMatches):\n                        if not isExternalFab:\n                            usePoFF = True\n                        else:\n                            # support resync for L3 Po in external fabric for the following conditions:\n                            #   - there is no policy associated with the interface\n                            #   - policy is present:\n                            #       > source in empty\n                            #       > current template is \"int_l3_port_channel\"\n                            if \"policy\" in dbIfEntry:\n                                currPolicy = dbIfEntry[\"policy\"]\n                                currTemplate = currPolicy.get(\"templateName\", \"\")\n                                if ((currPolicy.get(\"source\") == \"\") and\n                                    (currTemplate in [\"\", \"int_l3_port_channel\"])):\n                                    # support resync for L3 Po in external fabric if current source in non-empty\n                                    dbIfEntry[\"okToResyn\"] = True\n                            else:\n                                dbIfEntry[\"okToResyn\"] = True\n\n                            # L3 PO - process it as int_l3_port_channel only in External Fabric/LAN_Classic\n                            poMemberIntfDict[\"id2Name\"][pcId] = {\"intfName\" : intfName, \"isL3\" : True}\n                    else:\n                        usePoFF = True\n                    \n                    if usePoFF:\n                        # process as int_freeform\n                        templateName = \"int_freeform\"\n                        dot1qID, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                        newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs, \"dot1qID\" : dot1qID}\n                elif lowerIntfName.startswith(\"mgmt\"):\n                    templateName = \"int_mgmt\"\n                    nvPairs = getMgmtIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                elif lowerIntfName.startswith(\"loopback\"):\n                    # process as int_freeform\n                    loopbackId = intfName[8:]\n                    templateName = \"int_freeform\"\n                    ignore, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs, \"loID\" : loopbackId}\n                elif lowerIntfName.startswith(\"nve\"):\n                    if isExternalFab:\n                        templateName = \"int_freeform\"\n                        ignore, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                    else:\n                        templateName = \"int_nve\"\n                        nvPairs = getNveIntfNvpairs(switchInfo, intfName, matchingNvPairs, isExternalFab)\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                elif (\".\" in lowerIntfName):\n                    if ((\"eth_sub_interface\" in templateNameMatches) or\n                        (\"eth_sub_interface_tag\" in templateNameMatches)):\n                        templateName = \"int_subif\"\n                        dot1qID, nvPairs = getSubIntfNvPairs(switchInfo, intfName, matchingNvPairs)\n                    else:\n                        # process as int_freeform\n                        templateName = \"int_freeform\"\n                        dot1qID, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs, \"dot1qID\" : dot1qID}\n                elif ((\"trunk_interface_fex\" in templateNameMatches) or \n                      (\"access_interface_fex\" in templateNameMatches) or\n                      (\"dot1q_tunnel_interface\" in templateNameMatches) or\n                      (\"fex_po_member_interface\" in templateNameMatches)):\n                    # L2 interfaces\n                    if ((\"port_channel_mode_on\" in templateNameMatches) or\n                        (\"port_channel_mode\" in templateNameMatches)):\n                        # member interfaces\n                        pcid = \"\"\n                        mode = \"\"\n                        fexId = \"\"\n\n                        for templateName in matchingNvPairs:\n                            if (\"port_channel_mode_on\" == templateName):\n                                pcid = matchingNvPairs[templateName][\"PCID\"]\n                                mode = \"on\"\n                            elif (\"port_channel_mode\" == templateName):\n                                pcid = matchingNvPairs[templateName][\"PCID\"]\n                                mode = matchingNvPairs[templateName][\"PC_MODE\"]\n                            elif (\"fex_po_member_interface\" == templateName):\n                                pcid = matchingNvPairs[templateName][\"PCID\"]\n                                fexId = matchingNvPairs[templateName][\"FEX_ID\"]\n\n                        Wrapper.print(\"%s: Switch [%s] pcid [%s] mode [%s] fexId [%s]\" % (funcName, formattedName, pcid, mode, fexId))\n                        poMembersDict = None\n                        if fexId != \"\":\n                            lookupKey = \"fex\"\n                        else:\n                            lookupKey = \"po\"\n                        if pcid not in poMemberIntfDict[lookupKey]:\n                            poMembersDict = {}\n                            poMemberIntfDict[lookupKey][pcid] = {\"MODE\" : mode, \"MEMBERS\" : poMembersDict}\n                        else:\n                            poMembersDict = poMemberIntfDict[lookupKey][pcid][\"MEMBERS\"]\n\n                        Wrapper.print(\"Switch [%s] - Found L2 PO member intf [%s] mode [%s] parent PO id [%s] poMembersDict %s\" %\n                            (devSerial, intfName, mode, pcid, poMembersDict))\n\n                        ignore, poMembersDict[intfName] = getPoMemberIntfNvpairs(devSerial, intfName, True, pcid,\n                                matchResult, interfacesRes, False)\n                        dbIfEntry[\"okToResyn\"] = False\n                    else:\n                        # standalone ports\n                        if (\"access_interface_fex\" in templateNameMatches):\n                            templateName = \"int_access_host\"\n                            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, None)\n                        elif (\"dot1q_tunnel_interface\" in templateNameMatches):\n                            templateName = \"int_dot1q_tunnel_host\"\n                            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, None)\n                        else:\n                            templateName = \"int_trunk_host\"\n                            nvPairs = getTrunkIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, None)\n\n                        newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                elif (\"routed_interface\" in templateNameMatches):\n                    # L3 interfaces\n                    isStandaloneL3Intf = True\n                    includeMemberInheritedCfg = False\n                    if ((\"port_channel_mode_on\" in templateNameMatches) or\n                        (\"port_channel_mode\" in templateNameMatches)):\n                        # L3 po member interfaces\n                        if isExternalFab:\n                            isStandaloneL3Intf = False\n                            pcid = \"\"\n                            mode = \"\"\n\n                            for templateName in matchingNvPairs:\n                                if (\"port_channel_mode_on\" == templateName):\n                                    pcid = matchingNvPairs[templateName][\"PCID\"]\n                                    mode = \"on\"\n                                elif (\"port_channel_mode\" == templateName):\n                                    pcid = matchingNvPairs[templateName][\"PCID\"]\n                                    mode = matchingNvPairs[templateName][\"PC_MODE\"]\n\n                            poMembersDict = None\n                            lookupKey = \"po\"\n                            if pcid not in poMemberIntfDict[lookupKey]:\n                                poMembersDict = {}\n                                poMemberIntfDict[lookupKey][pcid] = {\"MODE\" : mode, \"MEMBERS\" : poMembersDict}\n                            else:\n                                poMembersDict = poMemberIntfDict[lookupKey][pcid][\"MEMBERS\"]\n\n                            Wrapper.print(\"Switch [%s] - Found L3 PO member intf [%s] mode [%s] parent PO id [%s] poMembersDict %s\" %\n                                (devSerial, intfName, mode, pcid, poMembersDict))\n\n                            ignore, poMembersDict[intfName] = getPoMemberIntfNvpairs(devSerial, intfName, True, pcid,\n                                    matchResult, interfacesRes, False)\n                            dbIfEntry[\"okToResyn\"] = False\n                        else:\n                            # non external fab and this will be captured in a routed host port\n                            includeMemberInheritedCfg = True\n                    \n                    if isStandaloneL3Intf:\n                        # standalone L3 interfaces\n                        templateName = \"int_routed_host\"\n                        nvPairs = getRoutedIntfNvpairs(switchInfo, intfName, matchingNvPairs, includeMemberInheritedCfg)\n                        newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                else:\n                    # process as int_freeform\n                    templateName = \"int_freeform\"\n                    dot1qID, nvPairs = getFreeformIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs, \"dot1qID\" : dot1qID}\n\n            #Wrapper.print(\"%s: Switch [%s] newIntfEntry [%s]\" % (funcName, formattedName, newIntfEntry))\n            if newIntfEntry:\n                dbIfEntry[\"new\"] = newIntfEntry\n\n        Wrapper.print(\"%s: poMemberIntfDict %s \" % (funcName, json.dumps(poMemberIntfDict, indent=4, sort_keys=True)))\n\n        # process the port channels\n        for pcid in sorted(poMemberIntfDict[\"id2Name\"]):\n            intfName = poMemberIntfDict[\"id2Name\"][pcid][\"intfName\"]\n            isL3 = poMemberIntfDict[\"id2Name\"][pcid][\"isL3\"]\n            lowerIntfName = intfName.lower()\n\n            Wrapper.print(\"%s: Switch [%s] intfName [%s] pcid [%s] isL3 [%r]\" % (funcName, formattedName, intfName, pcid, isL3))\n            intfMatchResult = interfacesRes[intfName]\n            templateNameMatches = intfMatchResult[\"matched_templates\"]\n\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            #Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\" % (intfName, sys._getframe().f_lineno))\n\n            matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n            dbIfEntry = None\n            poMemberEntry = None\n            if pcid in poMemberIntfDict[\"po\"]:\n                poMemberEntry = poMemberIntfDict[\"po\"][pcid]\n            elif pcid in poMemberIntfDict[\"fex\"]:\n                poMemberEntry = poMemberIntfDict[\"fex\"][pcid]\n\n            Wrapper.print(\"Switch [%s] : Processing PO [%s] pcid [%s] poMemberEntry %s\" % (devSerial,\n                                intfName, pcid, poMemberEntry))\n\n            # Note: poMemberEntry can be empty for port channels that do not have any members\n            if not isL3:\n                poParams = getL2PoIntfParams(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, None)\n                accessPort = False\n                dot1qTunnelPort = False\n                if (\"port_channel_access_interface\" in templateNameMatches):\n                    accessPort = True\n                elif (\"port_channel_dot1q_tunnel_interface\" in templateNameMatches):\n                    dot1qTunnelPort = True\n\n                Wrapper.print(\"Switch [%s] : Found PO [%s] poParams [%s] accessPort [%r] dot1qTunnelPort [%r]\" % (devSerial, \n                    intfName, poParams, accessPort, dot1qTunnelPort))\n            else:\n                poParams = getL3PoIntfParams(switchInfo, intfName, matchingNvPairs)\n\n            newIntfEntry = None\n            if isL3:\n                dbIfEntry = switchGbl[lowerIntfName]\n\n                poMemberInfo = poMemberEntry\n\n                poMembersDict = poMemberInfo[\"MEMBERS\"] if poMemberInfo else {}\n                memberPortsList = poMembersDict.keys()\n\n                nvPairs = poParams\n                nvPairs[\"PC_MODE\"] = poMemberInfo[\"MODE\"] if poMemberInfo else \"on\"\n                nvPairs[\"MEMBER_INTERFACES\"] = \",\".join(memberPortsList)\n\n                newIntfEntry = {\"templateName\" : \"int_l3_port_channel\", \"nvPairs\" : nvPairs, \n                                                                        \"memberPorts\" : poMembersDict}\n            elif (poParams[\"vpcId\"] != \"\"):\n                vpcIntfName = (\"vPC%s\" % poParams[\"vpcId\"])\n\n                if vpcIntfName not in vpcPairGbl:\n                    # this interface has not been discovered yet? ok to add\n                    currentEntry = {\"policy\" : None, \"discovered\" : False, \"hasOverlays\" : False}\n                    vpcPairGbl[vpcIntfName] = {\"ifName\" : vpcIntfName, \"current\" : currentEntry, \"new\" : None,\n                                                            \"okToResyn\" : True, \"isIGMember\" : False}\n\n                dbIfEntry = vpcPairGbl[vpcIntfName]\n                # mark the intf as pesent\n                dbIfEntry[\"isPresent\"] = True\n\n                Wrapper.print(\"%s: Switch [%s] Processing vPC [%s] Intf [%s] dbIfEntry %s\" % (funcName, formattedName, \n                    vpcPairkey, vpcIntfName, dbIfEntry))\n\n                if not dbIfEntry[\"okToResyn\"]:\n                    # do not consider this\n                    Wrapper.print(\"%s: Switch [%s] Skipping Intf [%s]\" % (funcName, formattedName, vpcIntfName))\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    continue\n\n                newIntfEntry = dbIfEntry[\"new\"]\n                currentIntfEntry = dbIfEntry[\"current\"]\n\n                memberLookupKey = \"fex\" if (poParams[\"fexId\"] != \"\") else \"po\"\n                poMemberInfo = poMemberIntfDict[memberLookupKey].get(poParams[\"pcId\"], None)\n                poMembersDict = poMemberInfo[\"MEMBERS\"] if poMemberInfo else {}\n\n                if (poParams[\"fexId\"] != \"\"):\n                    # AA FEX\n                    templateName = \"int_port_channel_aa_fex\"\n                    if not newIntfEntry:\n                        nvPairs = {\"INTF_NAME\" : vpcIntfName, \"FEX_ID\" : poParams[\"fexId\"], \n                                   \"DESC\" : fexNameDict.get(poParams[\"fexId\"], \"\"), \"MTU\" : poParams[\"poMtu\"], \n                                   \"ADMIN_STATE\" : poParams[\"poAdminState\"], \"FABRIC_NAME\" : fabricName}\n                        newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                    else:\n                        nvPairs = newIntfEntry[\"nvPairs\"]\n                else:\n                    pcMode = poMemberInfo[\"MODE\"] if poMemberInfo else \"on\"\n\n                    # vPC PO\n                    templateName = \"int_vpc_access_host\" if accessPort else (\"int_vpc_dot1q_tunnel\" if dot1qTunnelPort else \"int_vpc_trunk_host\")\n                    if not newIntfEntry:\n                        nvPairs = {\"INTF_NAME\" : vpcIntfName, \"ENABLE_MIRROR_CONFIG\" : \"false\",\n                                   \"MTU\" : poParams[\"poMtu\"], \"BPDUGUARD_ENABLED\" : poParams[\"bpduGuardState\"],\n                                   \"PC_MODE\" : pcMode, \"SPEED\" : poParams[\"poSpeed\"], \"ADMIN_STATE\" : poParams[\"poAdminState\"]}\n                        if accessPort or dot1qTunnelPort:\n                            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poParams[\"porttype_fast_enable\"]\n                        else:\n                            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poParams[\"porttype_fast_trunk\"]\n\n                        newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs}\n                    else:\n                        nvPairs = newIntfEntry[\"nvPairs\"]\n\n                #Wrapper.print(\"Switch [%s] : PO [%s] poMembersDict %s\" % (devSerial, intfName, poMembersDict))\n                memberPortsList = poMembersDict.keys()\n                if isPeer1:\n                    newIntfEntry[\"peer1MemberPorts\"] = poMembersDict\n                else:\n                    newIntfEntry[\"peer2MemberPorts\"] = poMembersDict\n\n                # set \"peer\" specific keys\n                if isPeer1:\n                    nvPairs[\"PEER1_PCID\"] = poParams[\"pcId\"]\n                    nvPairs[\"PEER1_PO_DESC\"] = poParams[\"poDesc\"]\n                    nvPairs[\"PEER1_PO_CONF\"] = poParams[\"poConf\"]\n                    nvPairs[\"PEER1_MEMBER_INTERFACES\"] = \",\".join(memberPortsList)\n                    if (poParams[\"fexId\"] == \"\"):                    \n                        if accessPort or dot1qTunnelPort:\n                            nvPairs[\"PEER1_ACCESS_VLAN\"] = poParams[\"access_vlan\"]\n                        else:\n                            nvPairs[\"PEER1_ALLOWED_VLANS\"] = poParams[\"allowed_vlans\"]\n                            nvPairs[\"PEER1_NATIVE_VLAN\"] = \"\" if poParams[\"native_vlan\"] == \"1\" else poParams[\"native_vlan\"]\n                else:\n                    nvPairs[\"PEER2_PCID\"] = poParams[\"pcId\"]\n                    nvPairs[\"PEER2_PO_DESC\"] = poParams[\"poDesc\"]\n                    nvPairs[\"PEER2_PO_CONF\"] = poParams[\"poConf\"]\n                    nvPairs[\"PEER2_MEMBER_INTERFACES\"] = \",\".join(memberPortsList)\n                    if (poParams[\"fexId\"] == \"\"):                    \n                        if accessPort or dot1qTunnelPort:\n                            nvPairs[\"PEER2_ACCESS_VLAN\"] = poParams[\"access_vlan\"]\n                        else:\n                            nvPairs[\"PEER2_ALLOWED_VLANS\"] = poParams[\"allowed_vlans\"]\n                            nvPairs[\"PEER2_NATIVE_VLAN\"] = \"\" if poParams[\"native_vlan\"] == \"1\" else poParams[\"native_vlan\"]\n            else:\n                isVpcPeerLinkPo = False\n                # non vpc po\n                dbIfEntry = switchGbl[lowerIntfName]\n                #Wrapper.print(\"%s: Switch [%s] dbIfEntry %s\" % (funcName, formattedName, dbIfEntry))\n                if (poParams[\"fexId\"] != \"\"):\n                    # ST-FEX\n                    templateName = \"int_port_channel_fex\"\n                    poMemberInfo = poMemberIntfDict[\"fex\"].get(poParams[\"pcId\"], None)\n                    nvPairs = {\"PO_ID\" : intfName, \"FEX_ID\" : poParams[\"fexId\"], \n                               \"DESC\" : fexNameDict.get(poParams[\"fexId\"], \"\"), \"PO_DESC\" : poParams[\"poDesc\"],\n                               \"MTU\" : poParams[\"poMtu\"], \"CONF\" : poParams[\"poConf\"], \"ADMIN_STATE\" : poParams[\"poAdminState\"],\n                               \"FABRIC_NAME\" : fabricName}\n                else:\n                    # normal PO\n                    if isExternalFab and (pcid == peerLinkPcId):\n                        isVpcPeerLinkPo = True\n                    \n                    if not isVpcPeerLinkPo:\n                        templateName = \"int_port_channel_access_host\" if accessPort else (\"int_port_channel_dot1q_tunnel_host\" if dot1qTunnelPort else \"int_port_channel_trunk_host\")\n\n                    poMemberInfo = poMemberIntfDict[\"po\"].get(poParams[\"pcId\"], None)\n                    pcMode = poMemberInfo[\"MODE\"] if poMemberInfo else \"on\"\n\n                    if isVpcPeerLinkPo:\n                        nvPairs = {\"PO_ID\" : intfName, \n                                   \"DESC\" : poParams[\"poDesc\"], \"NATIVE_VLAN\" : \"\",\n                                   \"MEMBER_DESC\" : \"\",\n                                   \"CONF\" : poParams[\"poConf\"], \"ADMIN_STATE\" : poParams[\"poAdminState\"]}\n                    else:\n                        nvPairs = {\"PO_ID\" : intfName, \n                                   \"DESC\" : poParams[\"poDesc\"], \"BPDUGUARD_ENABLED\" : poParams[\"bpduGuardState\"],\n                                   \"PC_MODE\" : pcMode, \"SPEED\" : poParams[\"poSpeed\"],\n                                   \"ENABLE_ORPHAN_PORT\": poParams[\"orphanPort\"], \"CONF\" : poParams[\"poConf\"],\n                                   \"MTU\" : poParams[\"poMtu\"], \"ADMIN_STATE\" : poParams[\"poAdminState\"]}\n                        if accessPort or dot1qTunnelPort:\n                            nvPairs[\"ACCESS_VLAN\"] = poParams[\"access_vlan\"]\n                            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poParams[\"porttype_fast_enable\"]\n                        else:\n                            nvPairs[\"ALLOWED_VLANS\"] = poParams[\"allowed_vlans\"]\n                            nvPairs[\"NATIVE_VLAN\"] = \"\" if poParams[\"native_vlan\"] == \"1\" else poParams[\"native_vlan\"]\n                            nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poParams[\"porttype_fast_trunk\"]\n\n                Wrapper.print(\"Switch [%s] : Found Non-VPC PO [%s] peerLinkPcId [%s] isVpcPeerLinkPo [%r] isPeer1 [%r] poMemberInfo %s\" % (devSerial,\n                                                                        intfName, peerLinkPcId, isVpcPeerLinkPo, isPeer1, poMemberInfo))\n                poMembersDict = poMemberInfo[\"MEMBERS\"] if poMemberInfo else {}\n                memberPortsList = poMembersDict.keys()\n                nvPairs[\"MEMBER_INTERFACES\"] = \",\".join(memberPortsList)\n\n                if isVpcPeerLinkPo:\n                    vpcPairEntry = vpcPairGbl[\"vpc_pair\"]\n                    vpcPairNvpairs = vpcPairEntry[\"nvPairs\"]\n                    if isPeer1:\n                        vpcPairEntry[\"peer1MemberPorts\"] = poMembersDict\n                        vpcPairNvpairs[\"ADMIN_STATE\"] = nvPairs[\"ADMIN_STATE\"]\n                        vpcPairNvpairs[\"ALLOWED_VLANS\"] = poParams[\"allowed_vlans\"]\n                        vpcPairNvpairs[\"PC_MODE\"] = \"active\"\n                        vpcPairNvpairs[\"PEER1_PCID\"] = pcid\n                        vpcPairNvpairs[\"PEER1_MEMBER_INTERFACES\"] = nvPairs[\"MEMBER_INTERFACES\"]\n                        vpcPairNvpairs[\"PEER1_PO_DESC\"] = nvPairs[\"DESC\"]\n                        vpcPairNvpairs[\"PEER1_PO_CONF\"] = nvPairs[\"CONF\"]\n                    else:\n                        vpcPairEntry[\"peer2MemberPorts\"] = poMembersDict\n                        vpcPairNvpairs[\"PEER2_PCID\"] = pcid\n                        vpcPairNvpairs[\"PEER2_MEMBER_INTERFACES\"] = nvPairs[\"MEMBER_INTERFACES\"]\n                        vpcPairNvpairs[\"PEER2_PO_DESC\"] = nvPairs[\"DESC\"]\n                        vpcPairNvpairs[\"PEER2_PO_CONF\"] = nvPairs[\"CONF\"]\n                else:\n                    newIntfEntry = {\"templateName\" : templateName, \"nvPairs\" : nvPairs, \"memberPorts\" : poMembersDict}\n\n            #Wrapper.print(\"%s: Switch [%s] newIntfEntry [%s]\" % (funcName, formattedName, newIntfEntry))\n            if newIntfEntry:\n                dbIfEntry[\"new\"] = newIntfEntry\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error during Host Port Resync. Please review the errors and \"\n            \"retry Recalculate & Deploy after fixing them.\" % (formattedName))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"HOST_PORT_RESYNC\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Switch [%s] Success = [%r]\" % (fabricName, \n                                                        funcName, formattedName, respObj.isRetCodeSuccess()))\n        return respObj\n\n# get the current overlay networks and port attachments for the switches\ndef buildSwitchNetworkPortAttachments(fabricName, globalOverlayInfo, hostPortResyncSwitches, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    networkVniToName = {}\n    networkNameToVni = {}\n    # key is network name, value is a dict of switch serials of type 'LanAttach'\n    netAttachEntries = {}\n    overlayNetDict = {\"vniToName\" : networkVniToName, \"attachEntries\" : netAttachEntries}\n\n    globalOverlayInfo[\"HOST_PORT_RESYNC\"][\"networks\"] = overlayNetDict\n\n    # get a list of all network entries for the fabric to build the vni to name mapping\n    # list of type 'LanNetworkStatus'\n    netEntries = Util.exe(TD.getAllNetworks(fabricName))\n    Wrapper.print(\"%s: Fabric [%s] Num Networks %s\" % (funcName, fabricName, len(netEntries)))\n    if not netEntries:\n        # no overlays defined.. nothing more to do\n        Wrapper.print(\"%s: Fabric [%s] No overlay networks found\" % (funcName, fabricName))\n        return\n\n    for netEntry in netEntries:\n        networkVniToName[netEntry.getNetworkId()] = netEntry.getNetworkName()\n        networkNameToVni[netEntry.getNetworkName()] = netEntry.getNetworkId()\n\n    allNetNames = \",\".join(sorted(networkNameToVni.keys()))\n    allSwitchSerials = \",\".join(hostPortResyncSwitches)\n\n    #Wrapper.print(\"%s: Fabric [%s] allNetNames [%s] allSwitchSerials [%s]\" % (funcName, fabricName, allNetNames, allSwitchSerials))\n\n    # now get the port attachments for the switches we are interested in. list has elements of type 'LanSwitchDetailsByNetwork'\n    netDetailEntries = Util.exe(TD.getSwitchDetailsByNetwork(fabricName, allNetNames, allSwitchSerials))\n\n    #Wrapper.print(\"%s: Fabric [%s] netDetailEntries %s\" % (funcName, fabricName, netDetailEntries))\n\n    # build the existing Net Attach entries\n    for netDetEntry in netDetailEntries:\n        # netDetEntry is of type 'LanSwitchDetailsByNetwork'\n        netName = netDetEntry.getNetworkName()\n        vniStr = networkNameToVni[netName]\n        netAttachEntries[vniStr] = {}\n\n        switchList = netDetEntry.getSwitchDetailsList()\n        # process the 'LanNetworkSwitchStatus' list\n        Wrapper.print(\"%s: Fabric [%s] Network [%s/%s] Num attachments = %d\" % (funcName, fabricName, vniStr, netName, len(switchList)))\n        for switchEntry in switchList:\n            deviceSerial = switchEntry.getSerialNumber()\n\n            if not switchEntry.isIslanAttached():\n                # network is not attached to this switch.. skip\n                Wrapper.print(\"%s: Fabric [%s] Network [%s/%s] Switch [%s] - Skip since unattached\" % (funcName,\n                    fabricName, vniStr, netName, deviceSerial))\n                continue\n\n            vlanId = switchEntry.getVlanId()\n            switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSerial]\n    \n            switchOverlayInfo[\"OVERLAY_VLANS\"].append(vlanId)\n            switchOverlayInfo[\"NETWORKS_VLAN2VNI\"][vlanId] = vniStr\n\n            # build the port list\n            portsList = []\n            for portEntry in switchEntry.getPort():\n                if portEntry.getPortStatus() == \"true\":\n                    portsList.append(portEntry.getPortName())\n\n            # add a new attach entry for this switch\n            lanAttach = LanAttach()\n            # portList will be updated when we process the switch config host port vlan lists later\n            netAttachEntries[vniStr][deviceSerial] = {\"lanAttach\" : lanAttach, \"origPortList\" : portsList, \"portList\" : []}\n\n            Wrapper.print(\"%s: Fabric [%s] Switch [%s] Network [%s/%s] Port List %s\" % (funcName, fabricName,\n                deviceSerial, vniStr, netName, portsList))\n\n            lanAttach.setFabric(fabricName)\n            lanAttach.setNetworkName(netName)\n            lanAttach.setSerialNumber(deviceSerial)\n            lanAttach.setSwitchPorts(\"\")\n            lanAttach.setDetachSwitchPorts(\"\")\n            lanAttach.setVlan(vlanId)\n            lanAttach.setDot1QVlan(1)\n            lanAttach.setUntagged(False)\n            lanAttach.setDeployment(True)\n            lanAttach.setExtensionValues(switchEntry.getExtensionValues())\n            lanAttach.setInstanceValues(switchEntry.getInstanceValues())\n            lanAttach.setFreeformConfig(switchEntry.getFreeformConfig())\n\n            printNetAttachList(fabricName, globalOverlayInfo, [netAttachEntries[vniStr][deviceSerial][\"lanAttach\"]])\n    #Wrapper.print(\"%s: Fabric [%s] Network DB %s\" % (funcName, fabricName,\n    #    json.dumps(globalOverlayInfo[\"HOST_PORT_RESYNC\"][\"networks\"], indent=4, sort_keys=True)))\n\ndef printNetAttachList(fabricName, globalOverlayInfo, attachList):\n    funcName = sys._getframe(0).f_code.co_name\n\n    for attachEntry in attachList:\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][attachEntry.getSerialNumber()]\n        Wrapper.print(\"-----[%s], Name [%s/%s] Vlan [%d] A Ports [%s] D Ports [%s] ExtensionVals [%s] FF [%s]\" % (switchDict[\"fmtName\"],\n            attachEntry.getNetworkName(), attachEntry.getProfileName(), attachEntry.getVlan(), attachEntry.getSwitchPorts(),\n            attachEntry.getDetachSwitchPorts(), attachEntry.getExtensionValues(), attachEntry.getFreeformConfig()))\n\ndef doNetworkAttach(fabricName, globalOverlayInfo, numProcessed, numEntries, vniStr, netAttach):\n    funcName = sys._getframe(0).f_code.co_name\n    netName = netAttach.getNetworkName()\n\n    attachList = netAttach.getLanAttachList()\n    Wrapper.print(\"%s %s: Fabric [%s] Attaching Network [%s,%s] [%d of %d] Attach Count = %d\" % (OVERLAY_PREFIX, funcName,\n        fabricName, vniStr, netName, numProcessed, numEntries, len(attachList)))\n    \n    printNetAttachList(fabricName, globalOverlayInfo, attachList)\n\n    newResp = TD.attachNetwork(fabricName, netAttach, False)\n    if not newResp.isRetCodeSuccess():\n        Wrapper.print(\"%s: Fabric [%s] Attaching network [%s/%s] - Failed\" % (funcName, fabricName, vniStr, netName))\n        return newResp\n\n    # there could still be a failure on a success return\n    respStr = newResp.getValue()\n\n    # check if the response contains \"invalid\" references which indicates some issue occured\n    if (\"invalid\" or \"failed\") in respStr.lower():\n        # we have a failure\n        Wrapper.print(\"%s: Fabric [%s] Attaching network [%s/%s] - Failed with response [%s]\" % \n            (funcName, fabricName, vniStr, netName, respStr))\n        newResp.addErrorReport(funcName,\n            \"Error attaching overlay network [%s]. Response = [%s]\" % (netName, respStr))\n        newResp.setFailureRetCode()\n\n    Wrapper.print(\"%s %s: Fabric [%s] Attaching Network [%s,%s] Resp [%r]\" % (OVERLAY_PREFIX, funcName,\n        fabricName, vniStr, netName, newResp.isRetCodeSuccess()))\n    return newResp\n\ndef doNetworkAttachments(fabricName, progressPrefix, progressStart, progressRange, globalOverlayInfo, netAttachDict, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    numProcessed = 0\n    numEntries = len(netAttachDict)\n    Wrapper.print(\"%s: Fabric [%s] Net Attach Count %d\" % (funcName, fabricName, numEntries))\n    for vniStr in sorted(netAttachDict.keys()):\n        netAttachEntry = netAttachDict[vniStr]\n        numProcessed += 1\n        netName = netAttachEntry.getNetworkName()\n\n        progress = progressStart + int(float(numProcessed)/float(numEntries) * progressRange)\n\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n            (\"%s - %d of %d - Attaching Network [%s/%s]\" % (progressPrefix, numProcessed, numEntries, vniStr, netName)))\n\n        newResp = doNetworkAttach(fabricName, globalOverlayInfo, numProcessed, numEntries, vniStr, netAttachEntry)\n        if not newResp.isRetCodeSuccess():\n            Wrapper.print(\"%s: Fabric [%s] Attaching network [%s/%s] - Failed\" % (funcName, fabricName, vniStr, netName))\n            Util.processRespObj(respObj, newResp)\n            continue\n\ndef setLanAttachPorts(origSet, newSet, lanAttach):\n    lanAttach.setSwitchPorts(\",\".join(list(newSet)))\n    detachPortsList = list(origSet - newSet)\n    lanAttach.setDetachSwitchPorts(\",\".join(detachPortsList))\n\ndef updateSwitchNetworkPortAttachments(fabricName, progressPrefix, progressStart, progressRange, globalOverlayInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    overlayNetDict = globalOverlayInfo[\"HOST_PORT_RESYNC\"][\"networks\"]\n    overlayAttachEntries = overlayNetDict[\"attachEntries\"]\n\n    netAttachDict = {}\n\n    numEntries = len(overlayAttachEntries)\n    Wrapper.print(\"%s: Fabric [%s] Original numEntries %d\" % (funcName, fabricName, numEntries))\n    for vniStr in sorted(overlayAttachEntries.keys()):\n        netName = overlayNetDict[\"vniToName\"][vniStr]\n        lanAttachList = []\n\n        serials = sorted(overlayAttachEntries[vniStr].keys())\n\n        vpcPairs = {}\n        standalone = {}\n        for deviceSerial in serials:\n            switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSerial]\n            swLanAttachDict = overlayAttachEntries[vniStr][deviceSerial]\n\n            portList = swLanAttachDict[\"portList\"]\n            portListSet = set(portList)\n            origPortList = swLanAttachDict[\"origPortList\"]\n            origPortListSet = set(origPortList)\n            skipUpdate = True if portListSet == origPortListSet else False\n\n            swLanAttach = swLanAttachDict[\"lanAttach\"]\n            if switchInfo[\"vpcPeer\"]:\n                vpcPairkey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, deviceSerial))\n                if vpcPairkey not in vpcPairs:\n                    # save the info.. process it later when the peer entry is found\n                    vpcPairs[vpcPairkey] = {deviceSerial : {\"swLanAttachDict\" : swLanAttachDict, \"skipUpdate\" : skipUpdate}}\n                    setLanAttachPorts(origPortListSet, portListSet, swLanAttach)\n                    continue\n                else:\n                    # we found the peer of an existing entry\n                    peerEntry = vpcPairs[vpcPairkey][switchInfo[\"vpcPeer\"]]\n                    if skipUpdate and peerEntry[\"skipUpdate\"]:\n                        # no changes on both the vpc pair switches...\n                        continue\n                    \n                    Wrapper.print(\"%s: Fabric [%s] Network [%s/%s] - Switch [%s] skipUpdate [%r] - Original %s New  %s\" % (funcName,\n                        fabricName, vniStr, netName, deviceSerial, skipUpdate, origPortListSet, portListSet))\n\n                    setLanAttachPorts(origPortListSet, portListSet, swLanAttach)\n                    lanAttachList.append(peerEntry[\"swLanAttachDict\"][\"lanAttach\"])\n                    lanAttachList.append(swLanAttach)\n            else:\n                Wrapper.print(\"%s: Fabric [%s] Network [%s/%s] - Switch [%s] skipUpdate [%r] - Original %s New  %s\" % (funcName,\n                    fabricName, vniStr, netName, deviceSerial, skipUpdate, origPortListSet, portListSet))\n                if not skipUpdate:\n                    setLanAttachPorts(origPortListSet, portListSet, swLanAttach)\n                    lanAttachList.append(swLanAttach)\n\n        Wrapper.print(\"%s: Fabric [%s] Network [%s/%s] Num Attachments - %d\" % (funcName, fabricName, vniStr, netName, len(lanAttachList)))\n        if lanAttachList:\n            netAttach = LanAttachByNetwork()\n            netAttach.setNetworkName(netName)\n            netAttach.setLanAttachList(lanAttachList)\n\n            netAttachDict[vniStr] = netAttach\n\n    # do the attachments\n    doNetworkAttachments(fabricName, progressPrefix, progressStart, progressRange, globalOverlayInfo, netAttachDict, respObj)\n\ndef updatePoMemberPolicy(devSerial, memberIntfDict, ptiTemplate, poPCId, source):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: SN [%s], PO [%s] Member interfaces [%s]\"% (funcName, devSerial, poPCId, \",\".join(memberIntfDict)))\n    for intfName in memberIntfDict:\n        Wrapper.print(\"%s: SN [%s] processing [%s] of [%s] for template [%s] and source [%s]\"%\n                      (funcName, devSerial, intfName, poPCId, ptiTemplate, source))\n\n        # get the current nvPairs\n        ptiList = Util.exe(PTI.getPTIs(devSerial, \"INTERFACE\", intfName, \"PYTHON\"))\n        if ptiList:\n            nvPairs = copy.deepcopy(ptiList[0].getNvPairs())\n\n            newNvPairs = memberIntfDict[intfName]\n            update = False\n            for key in newNvPairs:\n                update = True if (key in nvPairs) and (nvPairs[key] != newNvPairs[key]) else update\n                nvPairs[key] = newNvPairs[key]\n\n            if update:\n                createPTI(devSerial, nvPairs, ptiTemplate, intfName, source, -1)\n\ndef getPOMemberLists(currMembers, newMembers):\n    funcName = sys._getframe(0).f_code.co_name\n\n    currMemberStr = Util.expand_interface_range(currMembers)\n    currentMembers = currMemberStr.split(\",\")\n    newMemberStr = Util.expand_interface_range(newMembers)\n    newMembers = newMemberStr.split(\",\")\n    Wrapper.print(\"%s: currentMembers %d/%s newMembers %d/%s\" % (funcName,\n        len(currentMembers), currentMembers, len(newMembers), newMembers))\n\n    return currMemberStr, currentMembers, newMemberStr, newMembers\n\ndef validateOOBChanges(fabricName, globalOverlayInfo, respObj):\n    # error on the following conditions\n    #   - interface has overlays attached and policy template is changed\n    #   - po membership changes\n    funcName = sys._getframe(0).f_code.co_name\n    hostPortResyncDict = globalOverlayInfo[\"HOST_PORT_RESYNC\"]\n    switchDict = hostPortResyncDict[\"switches\"]\n    vpcIntfDict = hostPortResyncDict[\"vpcHostPairs\"]\n    isExternalFab = globalOverlayInfo[\"isExternalFab\"]\n\n    Wrapper.print(\"FAB [%s]: Start: %s - isExternalFab [%r]\" % (fabricName, funcName, isExternalFab))\n\n    switchList = sorted(switchDict)\n    vpcPairsList = sorted(vpcIntfDict)\n\n    # check the standalone policies\n    for devSerial in switchList:\n        switchGbl = switchDict[devSerial]\n\n        for intfName in switchGbl:\n            if intfName.startswith(\".\"):\n                continue\n\n            intfEntry = switchGbl[intfName]\n\n            #Wrapper.print(\"%s: Processing intf [%s] entry %s\" % (funcName, intfName, intfEntry))\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            currEntry = intfEntry[\"current\"]\n            if not currEntry:\n                # not discovered yet.. nothing special to do\n                continue\n\n            newEntry = intfEntry[\"new\"]\n            if not newEntry:\n                \"\"\"\n                # check to make sure interfaces with overlay attachments are still discovered and also present on switch\n                if currEntry[\"hasOverlays\"] and (currEntry[\"ifType\"] != \"INTERFACE_VLAN\"):\n                    respObj.addErrorReport(\"HOST_PORT_RESYNC:INTF_OVERLAY\", \"Interface [%s] has \"\n                        \"overlay network(s) attached and cannot be deleted from the switch. Please undo the \"\n                        \"out-of-band changes and retry.\" % (intfEntry[\"ifName\"]), devSerial)\n                    respObj.setFailureRetCode()\n                \"\"\"\n                continue\n\n            if not currEntry[\"policy\"]:\n                # no policy attached to this earlier\n                continue\n\n            isSameTemplate = True if currEntry[\"policy\"][\"templateName\"] == newEntry[\"templateName\"] else False\n            \n            if currEntry[\"hasOverlays\"]:\n                # there was an existing policy with overlays\n                if not isSameTemplate:\n                    # error - template type has changed\n                    respObj.addErrorReport(\"HOST_PORT_RESYNC:TEMPLATE_NAME\", \"Interface [%s] policy \"\n                        \"cannot be changed from [%s] to [%s] with Overlays attached or if interface belongs to an \"\n                        \"Interface Group. Please undo the out-of-band changes and retry.\" % (intfEntry[\"ifName\"], \n                            currEntry[\"policy\"][\"templateName\"], newEntry[\"templateName\"]), devSerial)\n                    respObj.setFailureRetCode()\n                    continue\n\n            pti = getCurrentIntfPyPtiById(currEntry[\"policy\"][\"policyId\"])\n            nvPairs = pti.getNvPairs()\n            currMembers = nvPairs.get(\"MEMBER_INTERFACES\", None)\n\n            # check for PO membership changes\n            if ((currMembers != None) and (newEntry[\"templateName\"] in [\"int_port_channel_trunk_host\",\n                \"int_port_channel_access_host\", \"int_port_channel_dot1q_tunnel_host\", \"int_port_channel_fex\"])):\n                # check to make sure the membership is intact\n                currMemberStr, currentMembers, newMemberStr, newMembers = getPOMemberLists(currMembers,\n                                                                    newEntry[\"nvPairs\"][\"MEMBER_INTERFACES\"])\n                if set(currentMembers) != set(newMembers):\n                    # error - membership change detected\n                    respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_MEMBERS\", \"Port Channel Interface [%s] membership \"\n                        \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                        \"changes and retry.\" % (intfEntry[\"ifName\"], currMemberStr, newMemberStr), devSerial)\n                    respObj.setFailureRetCode()\n                    continue\n\n            # update our new nvPairs to avoid unnecessary updates during the PTI updates\n            if isSameTemplate:\n                currNvpairs = copy.deepcopy(nvPairs)\n                for key in currNvpairs:\n                    if key not in newEntry[\"nvPairs\"]:\n                        newEntry[\"nvPairs\"][key]  = currNvpairs[key]\n\n    # check the vPC policies\n    for vpcPairKey in vpcPairsList:\n        vpcPairGbl = vpcIntfDict[vpcPairKey]\n        vpcPairFormattedName = vpcPairGbl[\"fmtName\"]\n\n        for intfName in vpcPairGbl:\n            intfEntry = vpcPairGbl[intfName]\n\n            Wrapper.print(\"%s: Processing vPC intf [%s] entry %s\" % (funcName, intfName, intfEntry))\n\n            if intfName == \"vpc_pair\":\n                if not isExternalFab:\n                    continue               \n                \n                # check the vpc pairing in external fabric\n                #   - do not allow po membership changes\n                vpcPairNvpairs = intfEntry[\"nvPairs\"]\n                if intfEntry[\"ptiID\"]:\n                    # get the current PTI\n                    pti = Util.exe(PTIWrapper.getInstance(intfEntry[\"ptiID\"]))\n                    nvPairs = pti.getNvPairs()\n\n                    # check that the vpc po association is not changed\n                    if nvPairs[\"PEER1_PCID\"] != vpcPairNvpairs[\"PEER1_PCID\"]:\n                        # error - PO association change detected\n                        respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_ASSOCIATION\", \"vPC Pair [%s] Interface [port-channel%s] Peer 1 Port Channel \"\n                            \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                            \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                                nvPairs[\"PEER1_PCID\"], vpcPairNvpairs[\"PEER1_PCID\"]))\n                        respObj.setFailureRetCode()\n                        continue\n\n                    if nvPairs[\"PEER2_PCID\"] != vpcPairNvpairs[\"PEER2_PCID\"]:\n                        # error - PO association change detected\n                        respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_ASSOCIATION\", \"vPC Pair [%s] Interface [port-channel%s] Peer 2 Port Channel \"\n                            \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                            \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                                nvPairs[\"PEER2_PCID\"], vpcPairNvpairs[\"PEER2_PCID\"]))\n                        respObj.setFailureRetCode()\n                        continue\n\n                    currMemberStr, currentMembers, newMemberStr, newMembers = getPOMemberLists(nvPairs[\"PEER1_MEMBER_INTERFACES\"],\n                                                                    vpcPairNvpairs[\"PEER1_MEMBER_INTERFACES\"])\n                    if set(currentMembers) != set(newMembers):\n                        # error - membership change detected\n                        respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_MEMBERS\", \"vPC Pair [%s] Interface [port-channel%s] \"\n                            \"Peer 1 PO Member interface changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                            \"changes and retry.\" % (vpcPairFormattedName, nvPairs[\"PEER1_PCID\"], currMemberStr, newMemberStr))\n                        respObj.setFailureRetCode()\n                        continue\n\n                    currMemberStr, currentMembers, newMemberStr, newMembers = getPOMemberLists(nvPairs[\"PEER2_MEMBER_INTERFACES\"],\n                                                                    vpcPairNvpairs[\"PEER2_MEMBER_INTERFACES\"])\n                    if set(currentMembers) != set(newMembers):\n                        # error - membership change detected\n                        respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_MEMBERS\", \"vPC Pair [%s] Interface [port-channel%s] \"\n                            \"Peer 2 PO Member interface changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                            \"changes and retry.\" % (vpcPairFormattedName, nvPairs[\"PEER1_PCID\"], currMemberStr, newMemberStr))\n                        respObj.setFailureRetCode()\n                        continue\n\n                    currNvpairs = copy.deepcopy(nvPairs)\n                    for key in currNvpairs:\n                        if key not in vpcPairNvpairs:\n                            vpcPairNvpairs[key] = currNvpairs[key]\n\n            if not intfName.startswith(\"vPC\"):\n                continue\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            currEntry = intfEntry[\"current\"]\n            newEntry = intfEntry[\"new\"]\n            if not newEntry:\n                # we did not find this in sh run? we do not care.. leave the intent as is\n                continue\n\n            # check to make sure the vPCs are defined correctly on both peers\n            if (\"PEER1_PCID\" not in newEntry[\"nvPairs\"]):\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:INCORRECT_VPC\", \"vPC Pair [%s] Interface [%s] in missing on \"\n                    \"switch [%s]. Please make configuration consistent and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                        vpcPairGbl[\"peer1Sn\"]))\n                respObj.setFailureRetCode()\n                continue\n\n            if (\"PEER2_PCID\" not in newEntry[\"nvPairs\"]):\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:INCORRECT_VPC\", \"vPC Pair [%s] Interface [%s] in missing on \"\n                    \"switch [%s]. Please make configuration consistent and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                        vpcPairGbl[\"peer2Sn\"]))\n                respObj.setFailureRetCode()\n                continue\n\n            if not currEntry or not currEntry[\"policy\"]:\n                # no policy attached to this earlier\n                continue\n            \n            if currEntry[\"hasOverlays\"]:\n                # there was an existing policy with overlays\n                if currEntry[\"policy\"][\"templateName\"] != newEntry[\"templateName\"]:\n                    # error - template type has changed\n                    respObj.addErrorReport(\"HOST_PORT_RESYNC:TEMPLATE_NAME\", \"vPC Pair  [%s] - Interface [%s] policy \"\n                        \"cannot be changed from [%s] to [%s] with Overlays attached or if interface belongs to an \"\n                        \"Interface Group. Please undo the out-of-band changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                            currEntry[\"policy\"][\"templateName\"], newEntry[\"templateName\"]))\n                    respObj.setFailureRetCode()\n                    continue\n\n            pti = getCurrentIntfPyPtiById(currEntry[\"policy\"][\"policyId\"])\n            nvPairs = pti.getNvPairs()\n\n            # check that the vpc po association is not changed\n            if nvPairs[\"PEER1_PCID\"] != newEntry[\"nvPairs\"][\"PEER1_PCID\"]:\n                # error - PO association change detected\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_ASSOCIATION\", \"vPC Pair [%s] Interface [%s] Peer 1 Port Channel \"\n                    \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                    \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                        nvPairs[\"PEER1_PCID\"], newEntry[\"nvPairs\"][\"PEER1_PCID\"]))\n                respObj.setFailureRetCode()\n                continue\n\n            if nvPairs[\"PEER2_PCID\"] != newEntry[\"nvPairs\"][\"PEER2_PCID\"]:\n                # error - PO association change detected\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_ASSOCIATION\", \"vPC Pair [%s] Interface [%s] Peer 2 Port Channel \"\n                    \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                    \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"],\n                        nvPairs[\"PEER2_PCID\"], newEntry[\"nvPairs\"][\"PEER2_PCID\"]))\n                respObj.setFailureRetCode()\n                continue\n\n            # check for PO member interfaces changes\n            currMemberStr, currentMembers, newMemberStr, newMembers = getPOMemberLists(nvPairs[\"PEER1_MEMBER_INTERFACES\"],\n                                                                    newEntry[\"nvPairs\"][\"PEER1_MEMBER_INTERFACES\"])\n            if set(currentMembers) != set(newMembers):\n                # error - membership change detected\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_MEMBERS\", \"vPC Pair [%s] Interface [%s] Peer 1 PO Member interface \"\n                    \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                    \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"], currMemberStr, newMemberStr))\n                respObj.setFailureRetCode()\n                continue\n\n            currMemberStr, currentMembers, newMemberStr, newMembers = getPOMemberLists(nvPairs[\"PEER2_MEMBER_INTERFACES\"],\n                                                                    newEntry[\"nvPairs\"][\"PEER2_MEMBER_INTERFACES\"])\n            if set(currentMembers) != set(newMembers):\n                # error - membership change detected\n                respObj.addErrorReport(\"HOST_PORT_RESYNC:PO_MEMBERS\", \"vPC Pair [%s] Interface [%s] Peer 2 PO Member interface \"\n                    \"changes are not supported. Expected [%s] Detected [%s]. Please undo the out-of-band \"\n                    \"changes and retry.\" % (vpcPairFormattedName, intfEntry[\"ifName\"], currMemberStr, newMemberStr))\n                respObj.setFailureRetCode()\n                continue\n\n            # update our new nvPairs to avoid unnecessary updates during the PTI updates\n            if isSameTemplate:\n                currNvpairs = copy.deepcopy(nvPairs)\n                for key in currNvpairs:\n                    if key not in newEntry[\"nvPairs\"]:\n                        newEntry[\"nvPairs\"][key]  = currNvpairs[key]\n\ndef updateHostPortPolicies(fabricName, progressPrefix, progressStart, progressRange, globalOverlayInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    hostPortResyncDict = globalOverlayInfo[\"HOST_PORT_RESYNC\"]\n    switchDict = hostPortResyncDict[\"switches\"]\n    vpcIntfDict = hostPortResyncDict[\"vpcHostPairs\"]\n    isExternalFab = globalOverlayInfo[\"isExternalFab\"]\n\n    Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s. isExternalFab [%r] \" % (fabricName, funcName, isExternalFab))\n\n    switchList = sorted(switchDict)\n    vpcPairsList = sorted(vpcIntfDict)\n\n    # do the vPC pairing in external fabric first\n    if isExternalFab:\n        for vpcPairKey in vpcPairsList:\n            vpcPairGbl = vpcIntfDict[vpcPairKey]\n\n            vpcPairEntry = vpcPairGbl[\"vpc_pair\"]\n            nvPairs = vpcPairEntry[\"nvPairs\"]\n            if nvPairs == None:\n                continue\n        \n            Wrapper.print(\"%s: Performing vPC pairing for [%s] with nvpairs %s\" % (funcName, vpcPairGbl[\"fmtName\"], nvPairs))\n            Util.exe(VpcWrapper.createOrUpdate(vpcPairGbl[\"peer1Sn\"], vpcPairGbl[\"peer2Sn\"], \"false\", \"vpc_pair\", nvPairs))\n\n            poMemberTemplateName = \"vpc_pair_peer_link_po_member\"\n            src = \"VPC_PAIR\"\n            if \"peer1MemberPorts\" in vpcPairEntry:\n                updatePoMemberPolicy(vpcPairGbl[\"peer1Sn\"], vpcPairEntry[\"peer1MemberPorts\"], poMemberTemplateName, nvPairs[\"PEER1_PCID\"], src)\n            if \"peer2MemberPorts\" in vpcPairEntry:\n                updatePoMemberPolicy(vpcPairGbl[\"peer2Sn\"], vpcPairEntry[\"peer2MemberPorts\"], poMemberTemplateName, nvPairs[\"PEER2_PCID\"], src)\n\n    # delete the host policies for non existant interfaces\n    progress = progressStart\n    FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - Cleaning up Standalone Host Policies\" % (progressPrefix))) \n    Wrapper.print(\"%s: Cleanup Standalone Host Policies\" % (funcName))\n    for devSerial in switchList:\n        switchGbl = switchDict[devSerial]\n\n        for intfName in switchGbl:\n            intfEntry = switchGbl[intfName]\n            if intfName.startswith(\".\"):\n                continue\n\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            Wrapper.print(\"%s: Delete Processing - Switch [%s] intfName [%s]\" % (funcName, devSerial, intfName))\n            currEntry = intfEntry[\"current\"]\n            newEntry = intfEntry[\"new\"]\n            if currEntry and not currEntry[\"policy\"]:\n                continue\n\n            delPti = False\n            if not intfEntry[\"isPresent\"]:\n                # interface had intent already, but, interface has been deleted now\n                delPti = True\n            elif newEntry:\n                # if the templates are different.. delete the current one\n                if newEntry[\"templateName\"] != currEntry[\"policy\"][\"templateName\"]:\n                    delPti = True\n            if delPti:\n                Wrapper.print(\"%s: Deleting intf [%s] entry %s\" % (funcName, intfName, intfEntry))\n                PTI.deleteInstance(currEntry[\"policy\"][\"policyId\"])\n                currEntry[\"policy\"] = None\n\n    # delete the current breakout_interface PTI.. new ones will be created as needed below\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"breakout_interface\")\n    ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    for pti in ptiList:\n        if pti.isDeleted():\n            continue\n        Wrapper.print(\"%s: Deleting breakout PTI for [%s]\" % (funcName, pti.getEntityName()))\n        PTI.deleteInstance(pti.getPolicyId())\n\n    # delete the host policies for non existant vpc interfaces\n    progress += 5\n    FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - Cleaning up vPC Host Policies\" % (progressPrefix))) \n    Wrapper.print(\"%s: Cleanup vPC Host Policies\" % (funcName))\n    for vpcPairKey in vpcPairsList:\n        vpcPairGbl = vpcIntfDict[vpcPairKey]\n\n        for intfName in vpcPairGbl:\n            if not intfName.startswith(\"vPC\"):\n                continue\n\n            Wrapper.print(\"%s: Delete Processing - vPC [%s] intfName [%s]\" % (funcName, vpcPairKey, intfName))\n            intfEntry = vpcPairGbl[intfName]\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            currEntry = intfEntry[\"current\"]\n            newEntry = intfEntry[\"new\"]\n\n            if not currEntry or not currEntry[\"policy\"]:\n                continue\n\n            delPti = False\n            if not intfEntry[\"isPresent\"]:\n                # interface had intent already, but, interface has been deleted now\n                delPti = True\n            elif newEntry:\n                # if the templates are different.. delete the current one\n                if newEntry[\"templateName\"] != currEntry[\"policy\"][\"templateName\"]:\n                    delPti = True\n            if delPti:\n                Wrapper.print(\"%s: Deleting vPC intf [%s] entry %s\" % (funcName, intfName, intfEntry))\n                PTI.deleteInstance(currEntry[\"policy\"][\"policyId\"])\n                currEntry[\"policy\"] = None\n\n    # assume system jumbo mtu chnaged to force all pti updated to be forced.. this will \n    # be updated when system_jumbomtu is processed\n    isMtuChanged = True\n\n    # process the special non intf policies first\n    Wrapper.print(\"%s: Processing Special vPC Policies\" % (funcName))\n    for devSerial in switchList:\n        switchGbl = switchDict[devSerial]\n        for intfName in [\".breakout\", \".jumbomtu\", \".vlanCfg\"]:\n            if intfName not in switchGbl:\n                continue\n\n            intfEntry = switchGbl[intfName]\n            \n            #Wrapper.print(\"%s: Switch [%s] Intf [%s] Entry %s\" % (funcName, devSerial, intfName, intfEntry))\n            if intfName == \".breakout\":\n                templateName = intfEntry[\"templateName\"]\n                for entry in intfEntry[\"entries\"].values():\n                    Util.exe(PTI.createOrUpdate(devSerial, entry[\"ifName\"], \"INTERFACE\", \"\", getPrio(templateName),\n                                                templateName, entry[\"nvPairs\"]))\n            elif intfName == \".jumbomtu\":\n                templateName = intfEntry[\"templateName\"]\n                for entry in intfEntry[\"entries\"].values():\n                    isMtuChanged = entry[\"isMtuChanged\"]\n                    Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", getPrio(templateName),\n                                                templateName, entry[\"nvPairs\"]))\n            elif intfName == \".vlanCfg\":\n                Wrapper.print(\"%s .vlanCfg intfEntry %s\" % (funcName, intfEntry))\n                ptiList = Util.exe(PTI.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n                for pti in ptiList:\n                    if pti.getDescription() == \"vlan configuration\":\n                        PTI.deleteInstance(pti.getPolicyId())\n                        break\n                for entry in intfEntry[\"entries\"].values():\n                    Util.exe(PTI.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_TOP,\n                                        \"switch_freeform\", entry[\"nvPairs\"],\n                                        \"vlan configuration\"))\n\n    # create the standlaone host port policies\n    progress += 5\n    FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - Create/Update Standalone Host Policies\" % (progressPrefix))) \n    Wrapper.print(\"%s: Create/Update Standalone Host Policies. isMtuChanged [%r]\" % (funcName, isMtuChanged))\n    for devSerial in switchList:\n        switchGbl = switchDict[devSerial]\n        #switchInfoDict = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n        #fmtname = switchInfoDict[\"fmtName\"]\n\n        for intfName in switchGbl:\n            intfEntry = switchGbl[intfName]\n            if intfName.startswith(\".\"):\n                continue\n\n            Wrapper.print(\"%s: Switch [%s] Intf [%s] Entry %s\" % (funcName, devSerial, intfName, intfEntry))\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            if not intfEntry[\"new\"]:\n                # interface no longer exists on switch\n                continue\n\n            currEntry = intfEntry[\"current\"]\n            newEntry = intfEntry[\"new\"]\n\n            # key to use for RM allocations\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            templateName = newEntry[\"templateName\"]\n            nvPairs = newEntry[\"nvPairs\"]\n            isNewPTI =  False if (currEntry and currEntry[\"policy\"]) else True\n            rmIds = None\n            poMemberTemplateName = None\n            doForceUpdate = False\n\n            if templateName == \"int_loopback\":\n                if isNewPTI:\n                    # record resources in RM\n                    loopbackId = intfName[8:]\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s]\" %\n                                  (fabricName, key, loopbackId, intfName))\n                    ignore, loRmId = Util.exeRM(RM.set(fabricName, \"LOOPBACK_ID\", key, intfEntry[\"ifName\"], loopbackId))\n                    rmIds = [loRmId]\n            elif templateName in [\"int_port_channel_trunk_host\", \"int_port_channel_access_host\",\n                                  \"int_port_channel_fex\", \"int_port_channel_dot1q_tunnel_host\"]:\n                doForceUpdate = isMtuChanged\n                ignore, pcid = intfName.split(\"port-channel\")\n                if isNewPTI:\n                    normalizedIntfName = intfName.capitalize()\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: Intf [%s] PORT_CHANNEL_ID [%s]\" % (fabricName, key, normalizedIntfName, pcid))\n                    ignore, pcRmId = Util.exeRM(RM.set(fabricName, \"PORT_CHANNEL_ID\", key, normalizedIntfName, pcid))\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: Intf [%s] PORT_CHANNEL_ID [%s]: rmId [%s]\" % (fabricName, key,\n                            normalizedIntfName, pcid, pcRmId))\n                    rmIds = [pcRmId]\n\n                if templateName == \"int_port_channel_fex\":\n                    poMemberTemplateName = \"int_fex_po_member_11_1\"\n                    if isNewPTI:\n                        fexId = nvPairs[\"FEX_ID\"]\n                        # set the FEX related RM\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: FEX_ID [%s]\" % (fabricName, key, fexId))\n                        ignore, fexRmId = Util.exeRM(RM.set(fabricName, \"FEX_ID\", key, \"fex-\"+fexId, fexId))\n                        Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: FEX_ID [%s]: rmId [%s]\" % (fabricName, key, fexId, fexRmId))\n                        rmIds.append(fexRmId)\n                elif templateName == \"int_port_channel_access_host\":\n                    poMemberTemplateName = \"int_port_channel_access_member_11_1\"\n                elif templateName == \"int_port_channel_dot1q_tunnel_host\":\n                    poMemberTemplateName = \"int_port_channel_dot1q_tunnel_member_11_1\"\n                else:\n                    poMemberTemplateName = \"int_port_channel_trunk_member_11_1\"\n            elif templateName == \"int_l3_port_channel\":\n                ignore, pcid = intfName.split(\"port-channel\")\n                if isNewPTI:\n                    normalizedIntfName = intfName.capitalize()\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: Intf [%s] PORT_CHANNEL_ID [%s]\" % (fabricName, key, normalizedIntfName, pcid))\n                    ignore, pcRmId = Util.exeRM(RM.set(fabricName, \"PORT_CHANNEL_ID\", key, normalizedIntfName, pcid))\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: Intf [%s] PORT_CHANNEL_ID [%s]: rmId [%s]\" % (fabricName, key,\n                            normalizedIntfName, pcid, pcRmId))\n                    rmIds = [pcRmId]\n\n                poMemberTemplateName = \"int_l3_port_channel_member\"\n            elif templateName in [\"int_trunk_host\", \"int_access_host\", \"int_dot1q_tunnel_host\"]:\n                doForceUpdate = isMtuChanged\n            elif templateName in [\"int_subif\", \"int_freeform\"]:\n                dot1qID = newEntry.get(\"dot1qID\", None)\n                if dot1qID:\n                    Wrapper.print(\"%s: Switch [%s] isNewPTI [%r] dot1qID [%s] Entry %s\" % (funcName, devSerial, isNewPTI, dot1qID, intfEntry))\n                    rmIds = [setDot1qRMResource(fabricName, devSerial, intfEntry[\"ifName\"], dot1qID)]\n                loID = newEntry.get(\"loID\", None)\n                if loID:\n                    Wrapper.print(\"%s: Switch [%s] isNewPTI [%r] loID [%s] Entry %s\" % (funcName, devSerial, isNewPTI, loID, intfEntry))\n                    key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                    ignore, loRmId = Util.exeRM(RM.set(fabricName, \"LOOPBACK_ID\", key, intfEntry[\"ifName\"], loID))\n                    rmIds = [loRmId]\n            elif templateName == \"int_vlan\":\n                Wrapper.print(\"%s: int_vlan %s intfEntry %s\" % (funcName, intfName, intfEntry))\n                vlanId = intfName[4:]\n                if isNewPTI and vlanId !=\"1\":\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: TOP_DOWN_NETWORK_VLAN [%s] intfName [%s]\" %\n                                  (fabricName, key, vlanId, intfName))\n                    ignore, loRmId = Util.exeRM(RM.set(fabricName, \"TOP_DOWN_NETWORK_VLAN\", key, intfEntry[\"ifName\"], vlanId))\n\n            if globalOverlayInfo[\"isExternalFab\"]:\n                src = \"\"\n            else:\n                src = getSrc(templateName)\n            \n            if isNewPTI:\n                Util.exe(PTI.createOrUpdate(devSerial, \"INTERFACE\", intfEntry[\"ifName\"], src, getPrio(templateName),\n                                            rmIds, templateName, nvPairs))\n            else:\n                Util.exe(PTI.updateInstance(currEntry[\"policy\"][\"policyId\"], nvPairs, doForceUpdate))\n\n            if \"memberPorts\" in newEntry:\n                # update the member port configs\n                updatePoMemberPolicy(devSerial, newEntry[\"memberPorts\"], poMemberTemplateName, pcid, intfEntry[\"ifName\"])\n\n    # create the vPC host port policies\n    progress += 5\n    FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress, (\"%s - Create/Update vPC Host Policies\" % (progressPrefix))) \n    Wrapper.print(\"%s: Create/Update vPC Host Policies. isMtuChanged [%r]\" % (funcName, isMtuChanged))\n    for vpcPairKey in vpcPairsList:\n        vpcPairGbl = vpcIntfDict[vpcPairKey]\n\n        for intfName in vpcPairGbl:\n            if not intfName.startswith(\"vPC\"):\n                continue\n\n            intfEntry = vpcPairGbl[intfName]\n\n            if not intfEntry[\"okToResyn\"]:\n                # we are not interested in this\n                continue\n\n            if not intfEntry[\"new\"]:\n                # interface no longer exists on switch\n                continue\n\n            Wrapper.print(\"%s: Start - Processing vPC Host [%s] Entry [%s]\" % (funcName, intfName,\n                                                    json.dumps(intfEntry, indent=4, sort_keys=True)))\n\n            currEntry = intfEntry[\"current\"]\n            newEntry = intfEntry[\"new\"]\n\n            templateName = newEntry[\"templateName\"]\n            nvPairs = newEntry[\"nvPairs\"]\n            isNewPTI =  False if (currEntry and currEntry[\"policy\"]) else True\n            rmIds = None\n            ignore, vpcId = intfName.split('vPC')\n\n            if isNewPTI:\n                key = Util.exe(Helper.getKey(\"DeviceInterface\", vpcPairGbl[\"peer1Sn\"], vpcPairGbl[\"peer2Sn\"], intfName))\n                ignore, vpcRmId1 = Util.exeRM(RM.set(fabricName, \"VPC_ID\", vpcPairGbl[\"peer1Sn\"], key, vpcId))\n                ignore, vpcRmId2 = Util.exeRM(RM.set(fabricName, \"VPC_ID\", vpcPairGbl[\"peer2Sn\"], key, vpcId))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s]: VPC_ID [%s] Peer 1 rmId [%s], Peer 2 rmId [%s]\" % (fabricName, key, vpcId, vpcRmId1, vpcRmId2))\n\n                peer1key = Util.exe(Helper.getKey(\"Device\", vpcPairGbl[\"peer1Sn\"]))\n                peer2key = Util.exe(Helper.getKey(\"Device\", vpcPairGbl[\"peer2Sn\"]))\n                pcId = nvPairs[\"PEER1_PCID\"]\n                ignore, pcRmId1 = Util.exeRM(RM.set(fabricName, \"PORT_CHANNEL_ID\", peer1key, intfName, pcId))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], intfName [%s] rmId [%s]\"\n                              % (fabricName, peer1key, pcId, intfName, pcRmId1))\n\n                pcId = nvPairs[\"PEER2_PCID\"]\n                ignore, pcRmId2 = Util.exeRM(RM.set(fabricName, \"PORT_CHANNEL_ID\", peer2key, intfName, nvPairs[\"PEER2_PCID\"]))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], intfName [%s] rmId [%s]\"\n                              % (fabricName, peer2key, pcId, intfName, pcRmId2))\n\n                rmIds = [vpcRmId1, vpcRmId2, pcRmId1, pcRmId2]\n\n            if isNewPTI and templateName == \"int_port_channel_aa_fex\":\n                fexId = nvPairs[\"FEX_ID\"]\n                fexKey = Util.exe(Helper.getKey(\"DeviceInterface\", vpcPairGbl[\"peer1Sn\"], vpcPairGbl[\"peer2Sn\"], \"fex-\" + intfName))\n\n                Wrapper.print(\"FAB [%s] RM SET: FEX_ID [%s] peer1key [%s] fexKey [%s] fexId [%s]\"\n                              % (fabricName, fexId, peer1key, fexKey, fexId))\n                ignore, fexRmId1 = Util.exeRM(RM.set(fabricName, \"FEX_ID\", peer1key, fexKey, fexId))\n                Wrapper.print(\"FAB [%s] RM SET: FEX_ID [%s] peer2key [%s] fexKey [%s] fexId [%s]\"\n                              % (fabricName, fexId, peer2key, fexKey, fexId))\n                ignore, fexRmId2 = Util.exeRM(RM.set(fabricName, \"FEX_ID\", peer2key, fexKey, fexId))\n                Wrapper.print(\"FAB [%s] RM SET: FEX_ID [%s] Peer1 Key [%s] fexRmId1 [%s] Peer2 Key [%s] fexRmId2 [%s]\"\n                              % (fabricName, fexId, peer1key, fexRmId1, peer2key, fexRmId2))\n\n                rmIds.extend([fexRmId1, fexRmId2])\n\n            if globalOverlayInfo[\"isExternalFab\"]:\n                src = \"\"\n            else:\n                src = getSrc(templateName)\n\n            if isNewPTI:\n                Util.exe(PTI.createOrUpdate(vpcPairKey, \"INTERFACE\", intfName, src, getPrio(templateName),\n                    rmIds, templateName, nvPairs))\n            else:\n                Util.exe(PTI.updateInstance(currEntry[\"policy\"][\"policyId\"], nvPairs, isMtuChanged))\n\n            if templateName == \"int_port_channel_aa_fex\":\n                poMemberTemplateName = \"int_fex_po_member_11_1\"\n            elif templateName == \"int_vpc_trunk_host\":\n                poMemberTemplateName = \"int_vpc_trunk_po_member_11_1\"\n            elif templateName == \"int_vpc_dot1q_tunnel\":\n                poMemberTemplateName = \"int_vpc_dot1q_tunnel_po_member_11_1\"\n            else:\n                poMemberTemplateName = \"int_vpc_access_po_member_11_1\"\n            \n            if \"peer1MemberPorts\" in newEntry:\n                updatePoMemberPolicy(vpcPairGbl[\"peer1Sn\"], newEntry[\"peer1MemberPorts\"], poMemberTemplateName, nvPairs[\"PEER1_PCID\"], intfName)\n            if \"peer2MemberPorts\" in newEntry:\n                updatePoMemberPolicy(vpcPairGbl[\"peer2Sn\"], newEntry[\"peer2MemberPorts\"], poMemberTemplateName, nvPairs[\"PEER2_PCID\"], intfName)\n            Wrapper.print(\"%s: End - Processing vPC Host [%s]\" % (funcName, intfName))\n\ndef handleOverlayMigration(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s\" % (fabricName, funcName))\n    doErrorHandling = False\n    try:\n        handleOverlayMigrationInt(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj)\n        if respObj.isRetCodeFailure():\n            doErrorHandling = True\n        else:\n            for deviceSn in devices:\n                # delete the user created vpc peer link vlan PTI since we would have already created the required PTI\n                # with \"UNDERLAY\" source\n                vPCInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn][\"vpcInfo\"]\n                if vPCInfo[\"userPeerLinkVlanPtiId\"]:\n                    PTI.deleteInstance(vPCInfo[\"userPeerLinkVlanPtiId\"])\n                # take switch out of migration mode\n                delMigrationState(fabricName, deviceSn)\n    except Exception as e:\n        doErrorHandling = True\n        msg = \"Unexpected error during Overlay Migration\"\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"OVERLAY_MIGRATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        if doErrorHandling:\n            resetSwitchMigration(fabricName, devices, globalOverlayInfo, gVarDictObj)\n\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Success = [%r]\" % (fabricName, funcName, respObj.isRetCodeSuccess()))\n        return respObj\n\ndef ECLhandleOverlayMigration(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj, topologyDataObj):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s\" % (fabricName, funcName))\n    doErrorHandling = False\n    try:\n        vrfSviInstanceValues = ECLPrepareVrfInstanceValues(fabricName, devices, globalOverlayInfo)\n        ECLhandleOverlayMigrationInt(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj, topologyDataObj, vrfSviInstanceValues)\n\n        #respObj.addErrorReport(funcName,\"DUMMY ERROR\")\n        #respObj.setFailureRetCode()\n        #return respObj\n        if respObj.isRetCodeFailure():\n            doErrorHandling = True\n        else:\n            for deviceSn in devices:\n                # delete the user created vpc peer link vlan PTI since we would have already created the required PTI\n                # with \"UNDERLAY\" source\n                vPCInfo = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn][\"vpcInfo\"]\n                if vPCInfo[\"userPeerLinkVlanPtiId\"]:\n                    PTI.deleteInstance(vPCInfo[\"userPeerLinkVlanPtiId\"])\n                # take switch out of migration mode\n                delMigrationState(fabricName, deviceSn)\n    except Exception as e:\n        doErrorHandling = True\n        msg = \"Unexpected error during ECL Network/VRF Migration\"\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"OVERLAY_MIGRATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        if doErrorHandling:\n            resetSwitchMigration(fabricName, devices, globalOverlayInfo, gVarDictObj)\n\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Success = [%r]\" % (fabricName, funcName, respObj.isRetCodeSuccess()))\n        return respObj\n\ndef setOverlayVrfReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayVrfs):\n    funcName = sys._getframe(0).f_code.co_name\n    # process all the VRFs found on this switch\n    for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n        vrfEntryTemplateParams = vrfEntry[\"vrfTemplateParams\"]\n        if vrfEntry[\"vni\"] not in allOverlayVrfs:\n            formattedName = getFormattedSwitchName(deviceSn)\n            Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] is reference for VRF \"\n                \"vni [%s]. Params = [%s]\" % (OVERLAY_PREFIX, funcName, fabricName, switchOverlayInfo[\"switchRole\"], formattedName,\n                vrfEntry[\"vni\"], vrfEntryTemplateParams))\n            refVrfEntry = copy.deepcopy(vrfEntry)\n            refEntry = {\"refSwitchSerial\" : deviceSn, \"vrfEntry\" : refVrfEntry}\n            allOverlayVrfs[vrfEntry[\"vni\"]] = refEntry\n            continue\n\n        refEntry = allOverlayVrfs[vrfEntry[\"vni\"]]\n        refEntryTemplateParams = refEntry[\"vrfEntry\"][\"vrfTemplateParams\"]\n\n        # collect the 'tag' from other entries just in case there is a valid value elsewhere\n        if refEntryTemplateParams[\"tag\"] == \"\":\n            refEntryTemplateParams[\"tag\"] = vrfEntryTemplateParams[\"tag\"]\n\n        # collect other extension specific params from borders\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            if \"bgpPassword\" not in refEntryTemplateParams:\n                if \"bgpPassword\" in vrfEntryTemplateParams:\n                    refEntryTemplateParams[\"bgpPassword\"] = vrfEntryTemplateParams[\"bgpPassword\"]\n                    refEntryTemplateParams[\"bgpPasswordKeyType\"] = vrfEntryTemplateParams[\"bgpPasswordKeyType\"]\n\n            paramNameList = [\"advertiseDefaultRouteFlag\", \"advertiseHostRouteFlag\", \"configureStaticDefaultRouteFlag\",\n                                \"trmBGWMSiteEnabled\"]\n            for paramName in paramNameList:\n                if paramName in vrfEntry[\"vrfTemplateParams\"]:\n                    refEntryTemplateParams[paramName] = vrfEntryTemplateParams[paramName]\n\ndef ECLsetOverlayVrfReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayVrfs):\n    funcName = sys._getframe(0).f_code.co_name\n    # process all the VRFs found on this switch\n    for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n        vrfEntryTemplateParams = vrfEntry[\"vrfTemplateParams\"]\n        if vrfEntry[\"name\"] not in allOverlayVrfs:\n            formattedName = getFormattedSwitchName(deviceSn)\n            Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] is reference for VRF \"\n                \"vrfName [%s]. Params = [%s]\" % (OVERLAY_PREFIX, funcName, fabricName, switchOverlayInfo[\"switchRole\"], formattedName,\n                vrfEntry[\"name\"], vrfEntryTemplateParams))\n            refVrfEntry = copy.deepcopy(vrfEntry)\n            refEntry = {\"refSwitchSerial\" : deviceSn, \"vrfEntry\" : refVrfEntry}\n            allOverlayVrfs[vrfEntry[\"name\"]] = refEntry\n            continue\n\n        refEntry = allOverlayVrfs[vrfEntry[\"name\"]]\n        refEntryTemplateParams = refEntry[\"vrfEntry\"][\"vrfTemplateParams\"]\n\n        # collect the 'tag' from other entries just in case there is a valid value elsewhere\n        if refEntryTemplateParams[\"tag\"] == \"\":\n            refEntryTemplateParams[\"tag\"] = vrfEntryTemplateParams[\"tag\"]\n\n        # collect other extension specific params from borders\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            if \"bgpPassword\" not in refEntryTemplateParams:\n                if \"bgpPassword\" in vrfEntryTemplateParams:\n                    refEntryTemplateParams[\"bgpPassword\"] = vrfEntryTemplateParams[\"bgpPassword\"]\n                    refEntryTemplateParams[\"bgpPasswordKeyType\"] = vrfEntryTemplateParams[\"bgpPasswordKeyType\"]\n\n            paramNameList = [\"configureStaticDefaultRouteFlag\"]\n            for paramName in paramNameList:\n                if paramName in vrfEntry[\"vrfTemplateParams\"]:\n                    refEntryTemplateParams[paramName] = vrfEntryTemplateParams[paramName]\n                    \ndef generateNetworkName(deviceSn, refNetEntry, respObj):\n    refNetEntry[\"overlayNetName\"] = BROWNFIELD_NETWORK_NAME_FORMAT.replace(\"$$VNI$$\", \n        (\"%d\" % refNetEntry[\"vni\"])).replace(\"$$VLAN_ID$$\", (\"%d\" % refNetEntry[\"vlanId\"]))\n    lenName = len(refNetEntry[\"overlayNetName\"])\n    if lenName > MAX_TOPDOWN_NETWORK_NAME_LENGTH:\n        respObj.addErrorReport(\"Overlay Network Name\", \"Auto generated network name [%s] for VNI [%d] \"\n            \"is %d characters and exceeds the maximum %d characters limit. Please update the \"\n            \"\\'Overlay Network Name Format\\' fabric setting and retry \"\n            \"Recalculate & Deploy.\" % (refNetEntry[\"overlayNetName\"], lenName, MAX_TOPDOWN_NETWORK_NAME_LENGTH, \n                refNetEntry[\"vni\"]), deviceSn)\n        respObj.setFailureRetCode()\n    else:\n        Wrapper.print(\"generateNetworkName: Switch [%s] Network VNI [%s] Name [%s]\" % (deviceSn, refNetEntry[\"vni\"], refNetEntry[\"overlayNetName\"]))\n\ndef setOverlayNetReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayNets, globalOverlayInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    formattedName = getFormattedSwitchName(deviceSn)\n    \n    fabNamePrefix = (\"%s-\" % (fabricName))\n\n    # process all the networks found on this switch\n    for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n        netEntryTemplateParams = netEntry[\"netTemplateParams\"]\n        if netEntry[\"vni\"] not in allOverlayNets:\n            Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] is reference for Network \"\n                \"vni [%s]. Params = [%s]\" % (OVERLAY_PREFIX, funcName, fabricName, formattedName, switchOverlayInfo[\"switchRole\"],\n                netEntry[\"vni\"], netEntryTemplateParams))\n            refNetEntry = copy.deepcopy(netEntry)\n            refEntry = {\"refSwitchSerial\" : deviceSn, \"netEntry\" : refNetEntry}\n            allOverlayNets[netEntry[\"vni\"]] = refEntry\n\n            if \"cfgProfileName\" in refNetEntry:\n                # this is a config profile based BF import.. set the network name to be None (meaning it is same as the\n                # config profile name)\n                # the overlay name can change if the config profile names are different on different switches.. in which\n                # case we will auto generate the network name. This will be done later\n                refNetEntry[\"overlayNetName\"] = None\n\n                # check for a few patterns typical of DCNM 10.4(2) naming conventions and extract the correct network name\n                profileName = refNetEntry[\"cfgProfileName\"]\n                netNameSuffix = (\"-%s-%d\" % (\n                    (globalOverlayInfo[\"networkExtProfileName\"] if switchOverlayInfo[\"doOverlayExtn\"] == \"true\" else \n                        globalOverlayInfo[\"networkProfileName\"]), refNetEntry[\"vlanId\"]))\n                if profileName.startswith(fabNamePrefix) and profileName.endswith(netNameSuffix):\n                    refNetEntry[\"overlayNetName\"] = profileName[len(fabNamePrefix) : -len(netNameSuffix)]\n                else:\n                    if len(profileName) > MAX_TOPDOWN_NETWORK_NAME_LENGTH:\n                        generateNetworkName(deviceSn, refNetEntry, respObj)\n                    else:\n                        refNetEntry[\"overlayNetName\"] = profileName\n\n                Wrapper.print(\"%s %s: Fabric [%s] profileName [%s][%d] fabNamePrefix [%s] \"\n                    \"netNameSuffix [%s] overlayNetName [%s]\" % (OVERLAY_PREFIX, funcName, fabricName,\n                        profileName, len(profileName), fabNamePrefix, netNameSuffix, refNetEntry[\"overlayNetName\"]))\n            else:\n                # regular CLI based import.. need to auto generate the network name\n                generateNetworkName(deviceSn, refNetEntry, respObj)\n        \n        refEntry = allOverlayNets[netEntry[\"vni\"]]\n        refNetEntry = refEntry[\"netEntry\"]\n        refEntryTemplateParams = refNetEntry[\"netTemplateParams\"]\n\n        # process the 'enableL3OnBorder' setting. Set it to 'true' if atleast one switch has it \"true\"\n        if netEntryTemplateParams[\"enableL3OnBorder\"] == \"true\":\n            if refEntryTemplateParams[\"enableL3OnBorder\"] != \"true\":\n                Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] vni [%s] \"\n                    \"Setting enableL3OnBorder to true\" % (OVERLAY_PREFIX, funcName, fabricName, formattedName,\n                        switchOverlayInfo[\"switchRole\"], netEntry[\"vni\"]))\n                refEntryTemplateParams[\"enableL3OnBorder\"] = \"true\"\n\ndef ECLgenerateNetworkName(deviceSn, refNetEntry, respObj):\n    refNetEntry[\"overlayNetName\"] = BROWNFIELD_NETWORK_NAME_FORMAT.replace(\"$$VLAN_ID$$\", (\"%d\" % refNetEntry[\"vlanId\"]))\n    lenName = len(refNetEntry[\"overlayNetName\"])\n    if lenName > MAX_TOPDOWN_NETWORK_NAME_LENGTH:\n        respObj.addErrorReport(\"Network Name\", \"Auto generated network name [%s] for vlanId [%d] \"\n            \"is %d characters and exceeds the maximum %d characters limit. Please update the \"\n            \"\\' Network Name Format\\' fabric setting and retry \"\n            \"Recalculate & Deploy.\" % (refNetEntry[\"overlayNetName\"], lenName, MAX_TOPDOWN_NETWORK_NAME_LENGTH, \n                refNetEntry[\"vlanId\"]), deviceSn)\n        respObj.setFailureRetCode()\n    else:\n        Wrapper.print(\"generateNetworkName: Switch [%s] Network vlanId [%s] Name [%s]\" % (deviceSn, refNetEntry[\"vlanId\"], refNetEntry[\"overlayNetName\"]))\n\ndef get_fhrp_cmd_str(fhrp_proto, fhrp_group, protocol):\n    return_str = \"\"\n    if fhrp_proto == \"hsrp\" or fhrp_proto == \"vrrp\":\n        return_str = fhrp_proto + ' ' + fhrp_group\n        if protocol == \"IPv6\":\n            return_str += ' ipv6'\n    else:\n        #vrrpv3\n        return_str = fhrp_proto + ' ' + fhrp_group\n        if protocol == \"IPv4\":\n            return_str += ' address-family ipv4'\n        else:    \n            return_str += ' address-family ipv6'\n    return return_str\n    \ndef ECLsetOverlayNetReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayNets, globalOverlayInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    formattedName = getFormattedSwitchName(deviceSn)\n    \n    fabNamePrefix = (\"%s-\" % (fabricName))\n\n    # process all the networks found on this switch\n    for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n        netEntryTemplateParams = netEntry[\"netTemplateParams\"]\n        replaceRefEntry = False\n\n        if netEntry[\"vlanId\"] not in allOverlayNets:\n            Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] is reference for Network \"\n                \"vlanId [%s]. Params = [%s]\" % (OVERLAY_PREFIX, funcName, fabricName, formattedName, switchOverlayInfo[\"switchRole\"],\n                netEntry[\"vlanId\"], netEntryTemplateParams))\n            refNetEntry = copy.deepcopy(netEntry)\n            refEntry = {\"refSwitchSerial\" : deviceSn, \"netEntry\" : refNetEntry}\n            allOverlayNets[netEntry[\"vlanId\"]] = refEntry\n\n            # regular CLI based import.. need to auto generate the network name\n            ECLgenerateNetworkName(deviceSn, refNetEntry, respObj)\n        else:\n            refEntry = allOverlayNets[netEntry[\"vlanId\"]]\n            refNetEntry = refEntry[\"netEntry\"]\n            refEntryTemplateParams = refNetEntry[\"netTemplateParams\"]\n        \n            forceIgnorePriority = False\n            if (refNetEntry and refEntryTemplateParams[\"activePriority\"] and  \n                refEntryTemplateParams[\"activePriority\"] == netEntry[\"netTemplateParams\"][\"activePriority\"]):\n                Wrapper.print(\"%s %s: netEntry[%s] refNetEntry[%s]\" % (funcName, deviceSn, netEntry, refNetEntry))\n                forceIgnorePriority = True\n            #for an agg vPC pair check if ignorePriority mismatch is present \n            if (forceIgnorePriority or \n                (refEntryTemplateParams[\"ignorePriority\"] == \"true\" and \n                (netEntryTemplateParams[\"ignorePriority\"] == \"false\" and \n                 netEntryTemplateParams[\"activePriority\"]))):\n                netEntryTemplateParams[\"ignorePriority\"] = \"true\"\n                #this means that for netEntryParams, v4/v6 fhrp priority cmds need to go to freeform\n                curr_netEntry_freeform = netEntry[\"freeformCfg\"]\n                #Construct svi, fhrp parent cmds before inserting priority cmd\n                svi_cmd = Util.newLine() + 'interface ' + 'Vlan' + str(netEntry[\"vlanId\"])\n                v4_cfg = None\n                v6_cfg = None\n                if netEntryTemplateParams['GROUP']:\n                    fhrp_cmd = Util.newLine() + '  ' + get_fhrp_cmd_str(FHRP_PROTOCOL, netEntryTemplateParams['GROUP'], \"IPv4\")\n                    fhrp_priority_cmd = Util.newLine() + '    priority ' + netEntryTemplateParams[\"activePriority\"]\n                    v4_cfg = svi_cmd + fhrp_cmd + fhrp_priority_cmd\n                if netEntryTemplateParams['GROUP_V6']:\n                    fhrp_cmd = Util.newLine() + '  ' + get_fhrp_cmd_str(FHRP_PROTOCOL, netEntryTemplateParams['GROUP_V6'], \"IPv6\")\n                    fhrp_priority_cmd = Util.newLine() + '    priority ' + netEntryTemplateParams[\"activePriority\"]\n                    if v4_cfg:\n                        v6_cfg = fhrp_cmd + fhrp_priority_cmd\n                    else:\n                        v6_cfg = svi_cmd + fhrp_cmd + fhrp_priority_cmd\n                if v4_cfg:   \n                    netEntry[\"freeformCfg\"] = netEntry[\"freeformCfg\"] + v4_cfg\n                if v6_cfg:   \n                    netEntry[\"freeformCfg\"] = netEntry[\"freeformCfg\"] + v6_cfg\n\n            if (forceIgnorePriority or \n                (netEntryTemplateParams[\"ignorePriority\"] == \"true\" and \n                (refEntryTemplateParams[\"ignorePriority\"] == \"false\" and \n                 refEntryTemplateParams[\"activePriority\"]))):\n                refEntryTemplateParams[\"ignorePriority\"] = \"true\"\n                #this means that for netEntryParams, v4/v6 fhrp priority cmds need to go to freeform\n                curr_refNetEntry_freeform = refNetEntry[\"freeformCfg\"]\n                #Construct svi, fhrp parent cmds before inserting priority cmd\n                svi_cmd = Util.newLine() + 'interface ' + 'Vlan' + str(refNetEntry[\"vlanId\"])\n                v4_cfg = None\n                v6_cfg = None\n                if refEntryTemplateParams['GROUP']:\n                    fhrp_cmd = Util.newLine() + '  ' + get_fhrp_cmd_str(FHRP_PROTOCOL, refEntryTemplateParams['GROUP'], \"IPv4\")\n                    fhrp_priority_cmd = Util.newLine() + '    priority ' + refEntryTemplateParams[\"activePriority\"]\n                    v4_cfg = svi_cmd + fhrp_cmd + fhrp_priority_cmd\n                if refEntryTemplateParams['GROUP_V6']:\n                    fhrp_cmd = Util.newLine() + '  ' + get_fhrp_cmd_str(FHRP_PROTOCOL, refEntryTemplateParams['GROUP_V6'], \"IPv6\")\n                    fhrp_priority_cmd = Util.newLine() + '    priority ' + refEntryTemplateParams[\"activePriority\"]\n                    if v4_cfg:\n                        v6_cfg = fhrp_cmd + fhrp_priority_cmd\n                    else:\n                        v6_cfg = svi_cmd + fhrp_cmd + fhrp_priority_cmd\n                if v4_cfg:   \n                    refNetEntry[\"freeformCfg\"] = refNetEntry[\"freeformCfg\"] + v4_cfg\n                if v6_cfg:   \n                    refNetEntry[\"freeformCfg\"] = refNetEntry[\"freeformCfg\"] + v6_cfg\n\n                refDeviceSN = refEntry[\"refSwitchSerial\"]\n                refSwitchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][refDeviceSN]\n                refSwitchOverlayInfoNetworks = refSwitchOverlayInfo[\"NETWORKS_BY_ID\"]\n                refSwitchOverlayInfoNetworks[netEntry[\"vlanId\"]] = refEntry[\"netEntry\"]\n\n            #Wrapper.print(\"TEST: netEntryParams %s refEntryParams %s\" %(netEntryTemplateParams, refEntryTemplateParams) )\n            #Even if there is a refEntry present for the network, check the FHRP priority. \n            #Ensure refEntry always corresponds to the switch that has the highest priority\n            #Default hsrp priority is 100\n            #Check that ignorePriority has not been set to true\n            if refEntryTemplateParams['ignorePriority'] != \"true\":\n                if netEntryTemplateParams[\"activePriority\"] and refEntryTemplateParams[\"activePriority\"]:\n                    if int(refEntryTemplateParams[\"activePriority\"]) < int(netEntryTemplateParams[\"activePriority\"]):\n                        replaceRefEntry = True\n                elif netEntryTemplateParams[\"activePriority\"] and int(netEntryTemplateParams[\"activePriority\"]) > 100:\n                    replaceRefEntry = True\n                elif refEntryTemplateParams[\"activePriority\"] and int(refEntryTemplateParams[\"activePriority\"]) < 100:\n                    replaceRefEntry = True\n\n        if replaceRefEntry:\n            Wrapper.print(\"%s %s: Fabric [%s] Switch [%s] Role [%s] is *NEW* reference for Network \"\n                \"vlanId [%s]. Params = [%s]\" % (OVERLAY_PREFIX, funcName, fabricName, formattedName, switchOverlayInfo[\"switchRole\"],\n                netEntry[\"vlanId\"], netEntryTemplateParams))\n            #netEntry should be the new reference network Entry\n            refNetEntry = copy.deepcopy(netEntry)\n            refEntry = {\"refSwitchSerial\" : deviceSn, \"netEntry\" : refNetEntry}\n            allOverlayNets[netEntry[\"vlanId\"]] = refEntry            \n\n            # regular CLI based import.. need to auto generate the network name\n            ECLgenerateNetworkName(deviceSn, refNetEntry, respObj)    \n            \n        refEntry = allOverlayNets[netEntry[\"vlanId\"]]\n        refNetEntry = refEntry[\"netEntry\"]\n        refEntryTemplateParams = refNetEntry[\"netTemplateParams\"]\n\n                \ndef handleOverlayMigrationInt(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    switchesNeedingOverlayMigration = []\n    borderSwitches = []\n    nonBorderSwitches = []\n    Wrapper.print(\"%s %s: Start - FABRIC [%s] OVERLAY_MODE [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, OVERLAY_MODE))\n\n    # at this point the underlay migration is complete for all switches and we are ready for the overlay migration\n    for deviceSn in devices:\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n\n        # skip spine role switches since they do not have any overlays\n        if switchDict[\"switchRole\"] == \"spine\":\n            continue\n\n        if not isSwitchInOverlayMigration(deviceSn):\n            continue\n        \n        # retrieve the switch overlay info from the file stored during the underlay migration\n        Wrapper.print(\"%s: Switch [%s] - Loading overlay info from file [%s]\" % (funcName, \n            switchDict[\"fmtName\"], switchDict[\"overlayInfoFileName\"]))\n        switchOverlayInfo = Util.exe(getJSONFileContents(switchDict[\"overlayInfoFileName\"]))\n\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            borderSwitches.append(deviceSn)\n        else:\n            nonBorderSwitches.append(deviceSn)\n\n    # make the list such that all the border switches are at the end\n    switchesNeedingOverlayMigration = nonBorderSwitches + borderSwitches\n\n    # dictionary of all VRFs in the fabric. Key is the VRF vni (string)\n    allOverlayVrfs = {}\n\n    # dictionary of all networks in the fabric. Key is the network vni (integer)\n    allOverlayNets = {}\n\n    # process all the networks/vrf on the switches\n    for deviceSn in switchesNeedingOverlayMigration:\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n        switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n\n        Wrapper.print(\"%s: Switch [%s] Role [%s] collecting (%d) Networks/ (%d) Vrfs\" % (funcName,\n            switchDict[\"fmtName\"], switchDict[\"switchRole\"], len(switchOverlayInfo[\"NETWORKS_BY_ID\"]), \n            len(switchOverlayInfo[\"VRFS_BY_ID\"])))\n\n        setOverlayVrfReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayVrfs)\n        setOverlayNetReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayNets, globalOverlayInfo, respObj)\n\n    profInfo = globalOverlayInfo['cfgProfileInfo']\n    if not profInfo[\"hasCfgProfile\"]:\n        # do some validations\n        #   - the vrfVlanName, maxBgpPaths, maxIbgpPaths must be the same on all switches\n        #   - the network must be L2 or L3 on every leaf switch (no missing SVI)\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 70, \"Brownfield - Checking Overlay information consistency\") \n        for deviceSn in switchesNeedingOverlayMigration:\n            switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n            switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n\n            # check all the vrf entries for this switch with the vrf entry we plan to use to create\n            Wrapper.print(\"%s %s: Validating VRF params for switch [%s]\" % (OVERLAY_PREFIX, funcName, switchDict[\"fmtName\"]))\n            for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n                refVrfEntry = allOverlayVrfs[vrfEntry[\"vni\"]]\n                if refVrfEntry[\"refSwitchSerial\"] == deviceSn:\n                    continue\n                refVrfTemplParams = refVrfEntry[\"vrfEntry\"][\"vrfTemplateParams\"]\n                allMatch = True\n                for param in refVrfTemplParams:\n                    if param == \"vrfVlanId\":\n                        # the vlan ids could be different on different switches\n                        continue\n                    if param in vrfEntry[\"vrfTemplateParams\"]:\n                        if not checkOverlayParam(refVrfEntry[\"vrfEntry\"][\"name\"], param, refVrfEntry[\"refSwitchSerial\"], \n                            deviceSn, refVrfTemplParams[param], vrfEntry[\"vrfTemplateParams\"][param], respObj):\n                            allMatch = False\n                if not allMatch:\n                    Wrapper.print(\"%s: Fabric [%s] VRF param mismatch: Switch [%s] Ref [%s] - Params [%s] refVrfTemplParams [%s]\" %\n                        (funcName, FABRIC_NAME, switchDict[\"fmtName\"], refVrfEntry[\"refSwitchSerial\"], vrfEntry[\"vrfTemplateParams\"], refVrfTemplParams))\n\n            # check all the network entries for this switch with the network entry we plan to use to create\n            Wrapper.print(\"%s %s: Validating Network params for switch [%s]\" % (OVERLAY_PREFIX, funcName, switchDict[\"fmtName\"]))\n            for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n                refNetEntry = allOverlayNets[netEntry[\"vni\"]]\n                if refNetEntry[\"refSwitchSerial\"] == deviceSn:\n                    continue\n                refNetTemplParams = refNetEntry[\"netEntry\"][\"netTemplateParams\"]\n                allMatch = True\n                for param in refNetTemplParams:\n                    if (param == \"vlanId\") or (param == \"enableL3OnBorder\"):\n                        continue\n                    if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n                        if (param in [\"isLayer2Only\"]):\n                            # do not check this on the border\n                            continue\n\n                        # skip some additional params for the case where the SVI does not exist on the\n                        # borders, i.e, 'enableL3OnBorder' is false\n                        if netEntry[\"netTemplateParams\"]['enableL3OnBorder'] != \"true\":\n                            if (param in [\"gatewayIpAddress\", \"gatewayIpV6Address\", \"vrfName\", \"tag\", NET_PROFILE_DHCP_SERVERS_VAR]):\n                                continue\n                    if param in netEntry[\"netTemplateParams\"]:\n                        if not checkOverlayParam(refNetEntry[\"netEntry\"][\"overlayNetName\"], param, refNetEntry[\"refSwitchSerial\"], \n                            deviceSn, refNetTemplParams[param], netEntry[\"netTemplateParams\"][param], respObj):\n                            allMatch = False\n\n                if not allMatch:\n                    Wrapper.print(\"%s: Fabric [%s] Net param mismatch: Switch [%s] Ref [%s] - Params [%s] refNetTemplParams [%s]\" %\n                        (funcName, FABRIC_NAME, switchDict[\"fmtName\"], refNetEntry[\"refSwitchSerial\"], netEntry[\"netTemplateParams\"], refNetTemplParams))\n\n    # do not proceed if there are errors\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    # process the attachments\n    for deviceSn in switchesNeedingOverlayMigration:\n        switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n        processOverlayAttachments(deviceSn, switchOverlayInfo, globalOverlayInfo, allOverlayNets)\n\n    cleanupOverlayOrigClis = False\n    if ((OVERLAY_MODE == \"config-profile\") and (not profInfo[\"hasCfgProfile\"])):\n        cleanupOverlayOrigClis = (globalOverlayInfo[\"cleanupOverlayOrigCliCfg\"] == \"true\")\n    Wrapper.print(\"%s: Fabric [%s] cleanupOverlayOrigClis [%r] hasCfgProfile [%r]\" %\n                    (funcName, FABRIC_NAME, cleanupOverlayOrigClis, profInfo[\"hasCfgProfile\"]))\n    isFailure = False\n    \n    sortedVrfVnis = sorted(allOverlayVrfs.keys())\n    sortedNetVnis = sorted(allOverlayNets.keys())\n\n    # create the vrfs if they do not exist\n    progressBase = 60\n    numEntries = len(sortedVrfVnis)\n    numProcessed = 0\n    Wrapper.print(\"%s %s: FABRIC [%s] VRF Creations [Total = %d]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries))\n    for vrfVni in sortedVrfVnis:\n        numProcessed += 1\n        progress = progressBase + int(float(numProcessed)/float(numEntries) * 5)\n\n        vrfEntry = allOverlayVrfs[vrfVni][\"vrfEntry\"]\n\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Creating VRF [%s/%s]\" % (numProcessed, numEntries, vrfVni, vrfEntry[\"name\"])))\n\n        Wrapper.print(\"%s: FABRIC [%s]: [%d of %d] Creating TD VRF [%s/%s]. Params [%s]\" % (funcName, \n            FABRIC_NAME, numProcessed, numEntries, vrfVni, vrfEntry[\"name\"], vrfEntry[\"vrfTemplateParams\"]))\n\n        # Check the TD DB to see if the VRF has been created already\n        tdVrf = Util.exe(TD.getVrfById(FABRIC_NAME, int(vrfVni)))\n        if tdVrf:\n            # entry exists...\n            Wrapper.print(\"%s: Fabric [%s] Skip Creating Existing TD VRF [%s/%s]\" %\n                            (funcName, FABRIC_NAME, vrfVni, vrfEntry[\"name\"]))\n            continue\n\n        tdVrf = LanVRF()\n        tdVrf.setFabric(FABRIC_NAME)\n        tdVrf.setVrfId(int(vrfVni))\n        tdVrf.setVrfName(vrfEntry[\"name\"])\n        tdVrf.setVrfTemplate(globalOverlayInfo[\"vrfProfileName\"])\n        tdVrf.setVrfExtensionTemplate(globalOverlayInfo[\"vrfExtProfileName\"])\n        tdVrf.setVrfTemplateConfig(json.dumps(vrfEntry[\"vrfTemplateParams\"]))\n\n        # create the VRF\n        newResp = TD.createOrUpdateVrf(FABRIC_NAME, tdVrf, False)\n        if not newResp.isRetCodeSuccess():\n            isFailure = True\n            Util.processRespObj(respObj, newResp)\n    \n    if not isFailure:\n        # create the networks if they do not exist\n        progressBase = 65\n        numEntries = len(sortedNetVnis)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: FABRIC [%s] Network Creations [Total = %d]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries))\n        for netVni in sortedNetVnis:\n            numProcessed += 1\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 5)\n\n            netEntry = allOverlayNets[netVni][\"netEntry\"]\n            netName = netEntry[\"overlayNetName\"] if netEntry[\"overlayNetName\"] else netEntry[\"cfgProfileName\"]\n\n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Creating Network [%s/%s]\" % (numProcessed, numEntries, netVni, netName)))\n\n            Wrapper.print(\"%s: FABRIC [%s] [%d of %d] Creating TD Network [%s/%s] Params [%s]\" % (funcName,\n                FABRIC_NAME, numProcessed, numEntries, netVni, netName, netEntry[\"netTemplateParams\"]))\n            \n            # Check the TD DB to see if the network has been created already\n            updateNetwork = False\n            tdNet = Util.exe(TD.getNetworkById(FABRIC_NAME, int(netVni)))\n            if tdNet:\n                Wrapper.print(\"%s: Fabric [%s] Skip Creating Existing TD Network [%s/%s]\" % (funcName, FABRIC_NAME, netVni, netName))\n                continue\n\n            tdNet = LanNetwork()\n            tdNet.setFabric(FABRIC_NAME)\n            tdNet.setNetworkName(netName)\n            tdNet.setNetworkId(int(netVni))\n            tdNet.setVrf(netEntry[\"vrfName\"])\n            tdNet.setNetworkTemplate(globalOverlayInfo[\"networkProfileName\"])\n            tdNet.setNetworkExtensionTemplate(globalOverlayInfo[\"networkExtProfileName\"])\n            tdNet.setNetworkTemplateConfig(json.dumps(netEntry[\"netTemplateParams\"]))\n\n            # create the network\n            newResp = TD.createOrUpdateNetwork(FABRIC_NAME, tdNet, False)\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Util.processRespObj(respObj, newResp)\n    \n    if not isFailure:\n        # do the overlay VRF attach as needed\n        progressBase = 70\n        numEntries = len(sortedVrfVnis)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: Start - FABRIC [%s] Attaching VRFs [Total = %d]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries))\n        for vrfVniId in sortedVrfVnis:\n            numProcessed += 1\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 10)\n\n            vrfAttach = globalOverlayInfo[\"VRF_ATTACH\"][vrfVniId]\n            vrfName = vrfAttach.getVrfName()\n\n            Wrapper.print(\"%s %s: Fabric [%s] [%d of %d] Attaching VRF [%s/%s] [Attach Count = %d] - Start\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME,\n                numProcessed, numEntries, vrfVniId, vrfName, len(vrfAttach.getLanAttachList())))\n\n            for attachEntry in vrfAttach.getLanAttachList():\n                switchDict = globalOverlayInfo[\"SWITCH_INFO\"][attachEntry.getSerialNumber()]\n                Wrapper.print(\"-----[%s], Name [%s/%s], Vlan [%d], ExtensionVals [%s] InstanceVals [%s] FF [%s]\" % (switchDict[\"fmtName\"],\n                    attachEntry.getVrfName(), attachEntry.getProfileName(), attachEntry.getVlan(), attachEntry.getExtensionValues(),\n                    attachEntry.getInstanceValues(), attachEntry.getFreeformConfig()))\n\n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Attaching VRF [%s/%s]\" % (numProcessed, numEntries, vrfVniId, vrfName)))\n\n            newResp = TD.attachVrf(FABRIC_NAME, vrfAttach)\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Wrapper.print(\"%s: Fabric [%s] Attaching VRF [%s/%s] - Failed\" % (funcName, FABRIC_NAME, vrfVniId, vrfName))\n                Util.processRespObj(respObj, newResp)\n                continue\n\n            # there could still be a failure on a success return\n            respStr = newResp.getValue()\n            # check if the response contains \"invalid\" references which indicates some issue occured\n            if \"failed\" in respStr.lower():\n                isFailure = True\n                # we have a failure\n                Wrapper.print(\"%s: Fabric [%s] Attaching VRF [%s/%s] - Failed with response [%s]\" %\n                    (funcName, FABRIC_NAME, vrfVniId, vrfName, respStr))\n                respObj.addErrorReport(funcName,\n                    \"Error attaching overlay VRF [%s]. Response = [%s]\" % (vrfName, respStr))\n                respObj.setFailureRetCode()\n                continue\n\n            if ((not isFailure) and cleanupOverlayOrigClis):\n                # create the PTI to unapply the original CLIs configs present on the switch\n                Wrapper.print(\"%s: FABRIC [%s] Cleaning up original VRF [%s/%s] CLIs\" % (funcName,\n                    FABRIC_NAME, vrfVniId, vrfName))\n                for attachEntry in vrfAttach.getLanAttachList():\n                    deviceSn = attachEntry.getSerialNumber()\n                    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n                    #Wrapper.print(\"%s: Fabric [%s] Cleanup VRF [%s,%s] - Start\" % \n                    #    (funcName, FABRIC_NAME, vrfVniId, vrfName))\n                    cfg = getSwitchOverlayVrfGeneratedCfg(vrfName, globalOverlayInfo, switchOverlayInfo)\n                    if cfg != \"\":\n                        # this should delete the old policy if any\n                        utilObj = Util()\n                        pti = utilObj.exeVal(PTIWrapper.createOrUpdate(deviceSn, \"SWITCH\", \"SWITCH\", \"CONFIG_PROFILE\",\n                            vrfName, \"VRF_OVERLAY_MIGRATION\", TOPDOWN_VRF_PROFILE_FREEFORM_PRIO,\n                            \"switch_freeform_config\", {\"DONT_EXPUNGE\" : \"\", \"CONF\" : cfg}))\n\n                        # markDelete it for CC to unapply the commands\n                        PTIWrapper.markDeleteInstance(pti.getPolicyId())\n                    #Wrapper.print(\"%s: Fabric [%s] Cleanup VRF [%s,%s] - Done\" % \n                    #    (funcName, FABRIC_NAME, vrfVniId, vrfName))\n\n        Wrapper.print(\"%s %s: End - FABRIC [%s] Attaching VRFs\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n    if not isFailure:\n        # do the overlay network attach in batches\n        batchInfo = {}\n        count = 0\n        batchIndex = 0\n        netAttachList = []\n        vniList = []\n        for vniId in sortedNetVnis:\n            vniStr = str(vniId)\n            netAttachList.append(globalOverlayInfo[\"NETWORK_ATTACH\"][vniStr])\n            vniList.append(vniStr)\n            count += 1\n            if count >= BF_NETWORK_ATTACH_BATCH_SIZE:\n                batchIndex += 1\n                batchInfo[batchIndex] = {\"vniList\": vniList, \"netAttachList\" : netAttachList}\n                # Wrapper.print(\"%s %s: Added Batches %d. Num %d\" % (OVERLAY_PREFIX, funcName, batchIndex, len(netAttachList)))\n\n                # start a new batch\n                count = 0\n                netAttachList = []\n                vniList = []\n\n        if len(netAttachList):\n            batchIndex += 1\n            batchInfo[batchIndex] = {\"vniList\": vniList, \"netAttachList\" : netAttachList}\n            # Wrapper.print(\"%s %s: Added Batches %d. Num %d\" % (OVERLAY_PREFIX, funcName, batchIndex, len(netAttachList)))\n        netAttachList = None\n        vniList = None\n\n        sortedBatchIndices = sorted(batchInfo)\n        # range is 80 - 95\n        progressBase = 80\n        numEntries = len(sortedNetVnis)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: Start - Fabric [%s] Attaching Networks [Total Entries %d, Batches = %d]\" % (OVERLAY_PREFIX, funcName,\n                                                FABRIC_NAME, numEntries, len(sortedBatchIndices)))\n\n        for index in sortedBatchIndices:\n            netAttachList = batchInfo[index][\"netAttachList\"]\n\n            numProcessed += len(netAttachList)\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 15)\n\n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Attaching Networks\" % (numProcessed, numEntries)))\n            \n            Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - Start - VNIs (%d) %s\" % (OVERLAY_PREFIX, funcName,\n                                FABRIC_NAME, len(batchInfo[index][\"vniList\"]), batchInfo[index][\"vniList\"]))\n\n            # print the attachment details for this batch\n            Wrapper.print(\"%s %s: Fabric [%s] ===  Network Attachment Entries - Start ===\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n            for netAttach in netAttachList:\n                Wrapper.print(\"%s %s: Fabric [%s] Network [%s] Num Attachments [%d]\" % (OVERLAY_PREFIX, funcName,\n                                    FABRIC_NAME, netAttach.getNetworkName(), len(netAttach.getLanAttachList())))\n\n                printNetAttachList(FABRIC_NAME, globalOverlayInfo, netAttach.getLanAttachList())\n                \n            Wrapper.print(\"%s %s: Fabric [%s] ===  Network Attachment Entries - End ===\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n            newResp = TD.attachNetworks(FABRIC_NAME, netAttachList, False)\n            Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - End - isSuccess [%r]\" % (OVERLAY_PREFIX, funcName,\n                                FABRIC_NAME, newResp.isRetCodeSuccess()))\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Wrapper.print(\"%s: Fabric [%s] Attaching network failed for VNIs %s\" % (funcName, fabricName, batchInfo[index][\"vniList\"]))\n                Util.processRespObj(respObj, newResp)\n                continue\n\n            # check the return value\n            respDict = json.loads(newResp.getValue())\n            # Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - VNIs %s\" % (OVERLAY_PREFIX, funcName,\n            #                     FABRIC_NAME, batchInfo[index][\"vniList\"]))\n            for netIdKey in respDict:\n                Wrapper.print(\"Entry: [%-30s] -> [%s]\" % (netIdKey, respDict[netIdKey]))\n                statusStr = str(respDict[netIdKey])\n                if not statusStr.lower().startswith(\"success\"):\n                    isFailure = True\n                    msg = (\"%s: Fabric [%s] Network attachment [%s] failed with reason [%s]\" % (funcName,\n                                                fabricName, netIdKey, respDict[netIdKey]))\n                    Wrapper.print(msg)\n                    respObj.addErrorReport(getFabErrEntity(funcName, netIdKey+\":netAttach\"), msg)\n                    respObj.setFailureRetCode()\n                    continue\n\n            if ((not isFailure) and cleanupOverlayOrigClis):\n                # create the PTI to unapply the original CLI configs present on the switch\n                for vniStr in batchInfo[index][\"vniList\"]:\n                    netAttach = globalOverlayInfo[\"NETWORK_ATTACH\"][vniStr]\n                    netName = netAttach.getNetworkName()\n\n                    Wrapper.print(\"%s: FABRIC [%s] Cleaning up original Network [%s/%s] CLIs - Start\" % (funcName, FABRIC_NAME, vniStr, netName))\n                    for attachRec in netAttach.getLanAttachList():\n                        swiSerial = attachRec.getSerialNumber()                    \n                        switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][swiSerial]\n                        #Wrapper.print(\"%s: Fabric [%s] Cleanup network [%s/%s] - Start\" % \n                        #    (funcName, FABRIC_NAME, vniStr, netName))\n                        cfg = getSwitchOverlayNetGeneratedCfg(vniStr, globalOverlayInfo, switchOverlayInfo)\n                        if cfg != \"\":\n                            # this should delete the old policy if any\n                            utilObj = Util()\n                            pti = utilObj.exeVal(PTIWrapper.createOrUpdate(swiSerial, \"SWITCH\", \"SWITCH\", \"CONFIG_PROFILE\",\n                                netAttach.getNetworkName(), \"NETWORK_OVERLAY_MIGRATION\", TOPDOWN_NETWORK_PROFILE_FREEFORM_PRIO,\n                                \"switch_freeform_config\", {\"DONT_EXPUNGE\" : \"\", \"CONF\" : cfg}))\n\n                            # markDelete it for CC to unapply the commands\n                            PTIWrapper.markDeleteInstance(pti.getPolicyId())\n                        #Wrapper.print(\"%s: Fabric [%s] Cleanup network [%s,%s] - End\" % \n                        #    (funcName, FABRIC_NAME, vniStr, netName))\n                    Wrapper.print(\"%s: FABRIC [%s] Cleaning up original Network [%s/%s] CLIs - End\" % (funcName, FABRIC_NAME, vniStr, netName))\n\n        Wrapper.print(\"%s %s: End - Fabric [%s] Attaching Networks\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n    if not isFailure:\n        handleServicesMigration(fabricName, globalOverlayInfo, respObj, gVarDictObj)\n\n    Wrapper.print(\"%s %s: End - FABRIC [%s]. retcode [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, respObj.isRetCodeSuccess()))\n    return respObj\n\ndef getLastIPv4InSubnet(rpVniEntry):\n    ip, mask = getIPAndPrefix(rpVniEntry[\"ipv4\"])\n    #subnet, ignore = getIPAndPrefix(rpVniEntry[\"subnet\"])\n\n    ipInt = Util.IP2Int(ip)\n    #subnetInt = Util.IP2Int(subnet)\n    bcastInt =  (~(0xFFFFFFFF << (32 - int(mask)))) & 0xFFFFFFFF\n\n    lastIP = (ipInt | bcastInt) - 1\n    #Wrapper.print(\"getLastIPv4InSubnet: bcastInt [%0X] ipInt [%0X] subnetInt [%0X] lastIP [%0X]\" % (bcastInt, \n    #    ipInt, subnetInt, lastIP))\n    while True:\n        if lastIP != ipInt:\n            break\n        lastIP -= 1\n\n    ipStr = Util.Int2IP(lastIP) \n    #Wrapper.print(\"getLastIPv4InSubnet: ipStr [%s]\" % (ipStr))\n    return ipStr\n\ndef handleServicesMigration(fabricName, globalOverlayInfo, respObj, gVarDictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    servicesInfo = globalOverlayInfo[\"SERVICES\"]\n\n    Wrapper.print(\"%s %s: Start - FABRIC [%s]\" % (OVERLAY_PREFIX, funcName, fabricName))\n\n    if not servicesInfo:\n        Wrapper.print(\"%s %s: End - FABRIC [%s] - No Services found\" % (OVERLAY_PREFIX, funcName, fabricName))\n        return\n\n    # create the services related entries\n    progressBase = 95\n    numEntries = len(servicesInfo[\"serviceNodes\"])\n    numProcessed = 0\n    for srvcNodeName in sorted(servicesInfo[\"serviceNodes\"]):\n        srvcEntry = servicesInfo[\"serviceNodes\"][srvcNodeName]\n\n        numProcessed += 1\n        progress = progressBase + int(float(numProcessed)/float(numEntries) * 5)\n\n        extName = srvcEntry[\"extFabricName\"]\n        swSerial = srvcEntry[\"swSerial\"]\n        swIntf = srvcEntry[\"swIntf\"]\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][swSerial]\n\n        Wrapper.print(\"%s: Processing Service Node [%s] on switch [%s]\" % (funcName, srvcNodeName, switchDict[\"fmtName\"]))\n\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n            (\"Brownfield - %d of %d - Processing Service Node [%s]\" % (numProcessed, numEntries, srvcNodeName)))\n\n        linkTemplateName = None\n        linkTemplateNvPairs = None\n        pti = getCurrentIntfPyPti(swSerial, swIntf)\n        if pti:\n            tmplName = pti.getTemplateName()\n            nvPairs = pti.getNvPairs()\n            Wrapper.print(\"%s: SN [%s] Intf [%s] Template [%s]\" % (funcName, srvcNodeName, swIntf, tmplName))\n\n            linkTemplateNvPairs = {\"SOURCE_FABRIC_NAME\" : fabricName,\n                                   \"DEST_FABRIC_NAME\" : extName,\n                                   \"SOURCE_SERIAL_NUMBER\" : swSerial,\n                                   \"DEST_SERIAL_NUMBER\" : (\"%s-%s\" % (srvcNodeName, extName)),\n                                   \"SOURCE_SWITCH_NAME\" : switchDict[\"hostName\"],\n                                   \"DEST_SWITCH_NAME\" : srvcNodeName,\n                                   \"SOURCE_IF_NAME\" : swIntf,\n                                   \"DEST_IF_NAME\" : srvcEntry[\"snIntf\"],\n                                   \"BPDUGUARD_ENABLED\" : nvPairs[\"BPDUGUARD_ENABLED\"],\n                                   \"MTU\" : nvPairs[\"MTU\"],\n                                   \"SPEED\" : nvPairs[\"SPEED\"],\n                                   \"PEER1_DESC\" : nvPairs[\"DESC\"],\n                                   \"PEER1_CONF\" : nvPairs[\"CONF\"],\n                                   \"ADMIN_STATE\" : nvPairs[\"ADMIN_STATE\"]\n                                   }\n\n            if \"int_vpc_trunk_po_11_1\" == tmplName:\n                #linkTemplateName = \"service_link_vpc\"\n                linkTemplateNvPairs = None\n                swIntf = nvPairs[\"PRIMARY_INTF\"]    # the vPCx interface\n                # comma separated string of vpc serials\n                swSerial = (\"%s,%s\" % (swSerial, srvcEntry[\"peerSwSerial\"]))\n                #linkTemplateNvPairs[\"SOURCE_IF_NAME\"] = swIntf\n                #linkTemplateNvPairs[\"SOURCE_SERIAL_NUMBER\"] = swSerial\n                #linkTemplateNvPairs[\"PC_MODE\"] = nvPairs[\"PC_MODE\"]\n            elif \"int_port_channel_trunk_host\" == tmplName:\n                linkTemplateName = \"service_link_port_channel_trunk\"\n                linkTemplateNvPairs[\"PC_MODE\"] = nvPairs[\"PC_MODE\"]\n            elif \"int_trunk_host\" == tmplName:\n                linkTemplateName = \"service_link_trunk\"\n                linkTemplateNvPairs[\"PORTTYPE_FAST_ENABLED\"] = nvPairs[\"PORTTYPE_FAST_ENABLED\"]\n            else:\n                linkTemplateNvPairs = None\n                Wrapper.print(\"**** %s: SN [%s] Intf [%s] Unexpected PTI\" % (funcName, srvcNodeName, swIntf))\n                continue\n        else:\n            linkTemplateNvPairs = None\n            Wrapper.print(\"%s: SN [%s] Intf [%s] PTI does not exist\" % (funcName, srvcNodeName, swIntf))\n\n        if srvcEntry[\"serviceNodeType\"] == \"fw\":\n            nodeType = ES.NodeType.Firewall\n        elif srvcEntry[\"serviceNodeType\"] == \"lb\":\n            nodeType = ES.NodeType.ADC\n        else:\n            nodeType = ES.NodeType.VNF\n\n        Wrapper.print(\"%s: Creating Service Node [%s] Serial [%s] Intf [%s]\" % (funcName, srvcNodeName, swSerial, swIntf))\n\n        Util.exe(ES.addServiceNode(extName, srvcNodeName, nodeType,\n            srvcEntry[\"snIntf\"], swSerial, swIntf, linkTemplateName, linkTemplateNvPairs))\n\n        # create the route peers\n        for routePeerName in srvcEntry[\"routePeers\"]:\n            rtPeerEntry = srvcEntry[\"routePeers\"][routePeerName]\n\n            if rtPeerEntry[\"isInter\"]:\n                useDefNextHop = False\n            else:\n                useDefNextHop = True if (len(rtPeerEntry[\"servicePolicies\"]) == 0) else False\n\n            Wrapper.print(\"%s: SN [%s] Processing Route Peer [%s] useDefNextHop [%r] rtPeerEntry %s\" % (funcName, srvcNodeName,\n                routePeerName, useDefNextHop, rtPeerEntry))\n\n            rpNets = rtPeerEntry[\"nets\"]\n            nextHopIp = \"\"\n            revNextHopIp = \"\"\n            if nodeType == ES.NodeType.Firewall:\n                inEntry = rpNets[\"inside\"]\n                outEntry = rpNets[\"outside\"]\n\n                if \"nextHop\" in inEntry:\n                    nextHopIp = inEntry[\"nextHop\"]\n                elif useDefNextHop and \"vni\" in inEntry:\n                    # try to get the default next hop ip\n                    nextHopIp = getLastIPv4InSubnet(servicesInfo[\"serviceNets\"][inEntry[\"vni\"]])\n                if \"nextHop\" in outEntry:\n                    revNextHopIp = outEntry[\"nextHop\"]\n                elif useDefNextHop and \"vni\" in outEntry:\n                    # try to get the default next hop ip\n                    revNextHopIp = getLastIPv4InSubnet(servicesInfo[\"serviceNets\"][outEntry[\"vni\"]])\n            else:\n                if len(rpNets) == 1:\n                    # one armed\n                    oneEntry = rpNets[\"one\"]\n                    if \"nextHop\" in oneEntry:\n                        revNextHopIp = oneEntry[\"nextHop\"]\n                    elif useDefNextHop and \"vni\" in oneEntry:\n                        # try to get the default next hop ip\n                        revNextHopIp = getLastIPv4InSubnet(servicesInfo[\"serviceNets\"][oneEntry[\"vni\"]])\n                else:\n                    twoEntry = rpNets[\"two\"]\n                    if \"nextHop\" in twoEntry:\n                        revNextHopIp = twoEntry[\"nextHop\"]\n                    elif useDefNextHop and \"vni\" in twoEntry:\n                        # try to get the default next hop ip\n                        revNextHopIp = getLastIPv4InSubnet(servicesInfo[\"serviceNets\"][twoEntry[\"vni\"]])\n\n            # update some values in the ptNvPairs\n            for rpNetEntry in rtPeerEntry[\"nets\"].values():\n                if \"ptNvPairs\" not in rpNetEntry:\n                    continue\n\n                nvPairs = rpNetEntry[\"ptNvPairs\"]\n                # add the correct VRF_NAME key\n                nvPairs[\"VRF_NAME\"] = servicesInfo[\"serviceNets\"][rpNetEntry[\"vni\"]][\"netEntry\"][\"vrfName\"]\n\n                # delete some unwanted data\n                if \".nbrLoIntf\" in nvPairs:\n                    del nvPairs[\".nbrLoIntf\"]\n                if \".peerNbrLoIntf\" in nvPairs:\n                    del nvPairs[\".peerNbrLoIntf\"]\n\n            ptNvPairs1 = None\n            ptNvPairs2 = None\n            if (nodeType == ES.NodeType.Firewall):\n                if rtPeerEntry[\"isInter\"]:\n                    ptNvPairs1 = rpNets[\"inside\"][\"ptNvPairs\"]\n                    ptNvPairs2 = rpNets[\"outside\"][\"ptNvPairs\"]\n\n                    if \"LOOPBACK_IP\" in ptNvPairs1:\n                        # eBGP peering\n                        rtPeerEntry[\"peerOption\"] = \"dynamic\"\n            else:\n                ptNvPairs1 = rpNets[\"one\"][\"ptNvPairs\"]\n                if \"two\" in rpNets:\n                    ptNvPairs2 = rpNets[\"two\"][\"ptNvPairs\"]\n\n                if ptNvPairs2 != None:\n                    if ptNvPairs2[\"VRF_NAME\"] == ptNvPairs1[\"VRF_NAME\"]:\n                        # must not provide the second nvpairs\n                        ptNvPairs2 = None\n                \n                if \"LOOPBACK_IP\" in ptNvPairs1:\n                    # eBGP peering\n                    rtPeerEntry[\"peerOption\"] = \"dynamic\"\n\n            peerTemplate = None\n            if rtPeerEntry[\"peerOption\"] == \"none\":\n                rtPeerEntry[\"peerOption\"] = ES.PeeringOption.None\n            elif rtPeerEntry[\"peerOption\"] == \"static\":\n                rtPeerEntry[\"peerOption\"] = ES.PeeringOption.StaticPeering\n                peerTemplate = \"service_static_route\"\n            elif rtPeerEntry[\"peerOption\"] == \"dynamic\":\n                rtPeerEntry[\"peerOption\"] = ES.PeeringOption.EBGPDynamicPeering\n                peerTemplate = \"service_ebgp_route\"\n\n            netList = []\n            srvcPolicyVrfName = None  # this will hold the VRF Name as it is topdown (not lower cased)\n            for netType in rpNets:\n                rpNetEntry = rpNets[netType]\n                vni = rpNetEntry[\"vni\"]\n                netEntry = servicesInfo[\"serviceNets\"][vni]\n\n                if not srvcPolicyVrfName:\n                    srvcPolicyVrfName = netEntry[\"netEntry\"][\"vrfName\"]\n                tdNet = LanNetwork()\n                tdNet.setFabric(fabricName)\n                tdNet.setNetworkName(netEntry[\"networkName\"])\n                tdNet.setNetworkId(int(vni))\n                tdNet.setVrf(netEntry[\"netEntry\"][\"vrfName\"])\n                tdNet.setNetworkTemplate(\"Service_Network_Universal\")\n                tdNet.setNetworkExtensionTemplate(globalOverlayInfo[\"networkExtProfileName\"])\n                tdNet.setNetworkTemplateConfig(json.dumps(netEntry[\"netEntry\"][\"netTemplateParams\"]))\n\n                netList.append(tdNet)\n\n            Wrapper.print(\"%s: SN [%s] Creating Route Peer [%s] nextHopIp [%s] revNextHopIp [%s] peerTemplate [%s]\"\n                \" ptNvPairs1 %s ptNvPairs2 %s\" % (funcName,\n                srvcNodeName, routePeerName, nextHopIp, revNextHopIp, peerTemplate, ptNvPairs1, ptNvPairs2))\n\n            Util.exe(ES.addRoutePeering(extName, srvcNodeName, swSerial, routePeerName, netList,\n                rtPeerEntry[\"peerOption\"], nextHopIp, revNextHopIp, peerTemplate, ptNvPairs1, ptNvPairs2, True))\n\n            # create the service policies\n            for srvcName in rtPeerEntry[\"servicePolicies\"]:\n                srvEntry = rtPeerEntry[\"servicePolicies\"][srvcName]\n\n                policyNvPairs = srvEntry[\"policyTemplateNvPairs\"]\n                srvcRevNextHopIp = revNextHopIp if srvEntry[\"isReverse\"] else \"\"\n                policyNvPairs[\"NEXT_HOP_IP\"] = nextHopIp\n                policyNvPairs[\"REVERSE_NEXT_HOP_IP\"] = srvcRevNextHopIp\n\n                Wrapper.print(\"%s: SN [%s] Route Peer [%s] Creating Service Policy [%s] nextHopIp [%s] \"\n                    \"srvcRevNextHopIp [%s] vrf [%s] policyNvPairs %s\" % (funcName, \n                    srvcNodeName, routePeerName, srvcName, nextHopIp, srvcRevNextHopIp, srvcPolicyVrfName, policyNvPairs))\n                Util.exe(ES.addServicePolicy(extName, srvcNodeName, nodeType, swSerial, routePeerName,\n                    srvcPolicyVrfName, policyNvPairs[\"SRC_NETWORK\"], policyNvPairs[\"DEST_NETWORK\"],\n                    nextHopIp, srvcRevNextHopIp, \"service_pbr\", policyNvPairs, True))\n\n    Wrapper.print(\"%s %s: End - FABRIC [%s]\" % (OVERLAY_PREFIX, funcName, fabricName))\n\ndef getSwitchOverlayVrfGeneratedCfg(vrfName, globalOverlayInfo, switchOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchDict = globalOverlayInfo[\"SWITCH_INFO\"][switchOverlayInfo[\"SERIAL\"]]\n    genCfg = \"\"\n    vrfNameLower = vrfName.lower()\n    if vrfNameLower in switchOverlayInfo[\"VRFS_NAME2VNI\"]:\n        vrfEntry = switchOverlayInfo[\"VRFS_BY_ID\"][switchOverlayInfo[\"VRFS_NAME2VNI\"][vrfNameLower][\"vni\"]]\n\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            templateName = globalOverlayInfo[\"vrfExtProfileName\"]\n        else:\n            templateName = globalOverlayInfo[\"vrfProfileName\"]\n\n        # get the template generated config\n        templateParams = copy.deepcopy(vrfEntry[\"vrfTemplateParams\"])\n        templateParams[\"vrfVlanId\"] = str(vrfEntry[\"vlanId\"])\n        # add the 'isVPC' flag also\n        templateParams[\"isVPC\"] = switchOverlayInfo[\"isVpc\"]\n        templateParams[\"platformType\"] = \"Nexus\"\n\n        Wrapper.print(\"%s: VRF [%s] Device [%s] Template [%s] Config Params [%s]\" % (funcName, \n            vrfName, switchDict[\"fmtName\"], templateName, templateParams))\n        genCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, templateParams, False, None).strip()\n    return genCfg\n\ndef getSwitchOverlayNetGeneratedCfg(netVni, globalOverlayInfo, switchOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchDict = globalOverlayInfo[\"SWITCH_INFO\"][switchOverlayInfo[\"SERIAL\"]]\n    genCfg = \"\"\n    if netVni in switchOverlayInfo[\"NETWORKS_BY_ID\"]:\n        netEntry = switchOverlayInfo[\"NETWORKS_BY_ID\"][netVni]\n\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            templateName = globalOverlayInfo[\"networkExtProfileName\"]\n        else:\n            templateName = globalOverlayInfo[\"networkProfileName\"]\n\n        # get the template generated config\n        templateParams = copy.deepcopy(netEntry[\"netTemplateParams\"])\n        templateParams[\"vlanId\"] = str(netEntry[\"vlanId\"])\n        # add the 'isVPC' flag also\n        templateParams[\"isVPC\"] = switchOverlayInfo[\"isVpc\"]\n        templateParams[\"platformType\"] = \"Nexus\"\n        Wrapper.print(\"%s: Network VNI [%s] Device [%s] Template [%s] Config Params [%s]\" % (funcName,\n            netVni, switchDict[\"fmtName\"], templateName, templateParams))\n        genCfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, templateParams, False, None).strip()\n    return genCfg\n\ndef updateHifIntfPolicies(deviceSn):\n    for templateName in [\"trunk_interface_fex\", \"access_interface_fex\"]:\n        newTemplateName = \"trunk_interface\" if templateName == \"trunk_interface_fex\" else \"access_interface\"\n        srchOpt = CtrlPolicySearch()\n        srchOpt.setSerialNumber(deviceSn)\n        srchOpt.setTemplateName(templateName)\n        ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n        for pti in ptiList:\n            if pti.isDeleted():\n                continue\n\n            # create the new HIF policy with the new template name\n            PTIWrapper.create(deviceSn, pti.getEntityType(), pti.getEntityName(), pti.getSource(),\n                pti.getPriority(), newTemplateName, pti.getNvPairs())\n\n            # delete the original policy\n            PTIWrapper.deleteInstance(pti.getPolicyId())\n\ndef handleUpgradeInRecalc(dictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    topologyDataObj = dictObj[\"topologyObj\"]\n    upgradeFromVersion = dictObj[\"upgradeFromVersion\"]\n    fabricName = dictObj[\"fabricName\"]\n    Wrapper.print(\"%s(): UPGRADE_FROM_VERSION [%s]\" %(funcName, upgradeFromVersion))\n    devices = topologyDataObj.get(TopologyInfoType.SWITCHES)\n    devices = filter(None, devices)\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        # dictionary to hold the progress status of each spine processing\n        devicesStatusDict = OrderedDict()\n        devicesInfoDict = OrderedDict()\n        # dictionary of parameters\n        paramDict = {\"topologyDataObj\": topologyDataObj, \"respObj\": respObj, \"upgradeFromVersion\": upgradeFromVersion,\n                     \"fabricName\": fabricName, \"devicesStatusDict\": devicesStatusDict}\n        threadCount = Util.getThreadCount(devices)\n        devicesThread = []\n        Wrapper.print(\"%s(): threadCount [%s]\"%(funcName, threadCount))\n        for i in range(0, len(devices), threadCount):\n            tDevices = devices[i:i+threadCount]\n            for deviceSn in tDevices:\n                Wrapper.print(\"%s(): deviceSn [%s]\"%(funcName, deviceSn))\n                devicesStatusDict[deviceSn] = {\"Progress\" : \"Pending\"}\n                role = topologyDataObj.getSwitchRole(deviceSn)\n                fmtName = getFormattedSwitchName(deviceSn)\n                devicesInfoDict[deviceSn] = {\"fmtName\": fmtName, \"switchRole\": role}\n            devicesThread.append(threading.Thread(target=handleUpgrade, args=(tDevices, paramDict)))\n            devicesThread[-1].start()\n        for thread in devicesThread:\n            thread.join()\n        processThreadStatus(devicesStatusDict, devicesInfoDict, respObj)\n        devicesStatusDict.clear()\n\n        Util.exe(handleUpgradePerFabric(fabricName, dictObj))\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef handleUpgrade(tDevices, paramDict):\n    funcName = sys._getframe(0).f_code.co_name\n    topologyDataObj = paramDict[\"topologyDataObj\"]\n    upgradeFromVersion = paramDict[\"upgradeFromVersion\"]\n    fabricName = paramDict[\"fabricName\"]\n    respObj = paramDict[\"respObj\"]\n\n    Wrapper.print(\"%s: Start\" %(funcName))\n    try:\n        fabricSettings = Util.exe(FabricWrapper.get(fabricName)).getNvPairs()\n        for deviceSn in tDevices:\n            currentDeviceSn = deviceSn\n            model = topologyDataObj.getSwitchModel(deviceSn)\n            statusDict = paramDict[\"devicesStatusDict\"][deviceSn]\n            hostName = topologyDataObj.getHostName(deviceSn)\n            Wrapper.print(\"%s: Start - Switch [%s/%s] Model [%s]\" % (funcName, deviceSn, hostName, model))\n            statusDict[\"Progress\"] = \"regen started\"\n\n            if upgradeFromVersion in [\"11.5.4\"]:\n                updateHifIntfPolicies(deviceSn)\n\n            if ((fabricSettings.get(\"OVERLAY_MODE\", \"config-profile\") == \"cli\") and \n                (fabricSettings.get(\"ENABLE_EVPN\", \"true\") == \"true\")):\n                Util.exe(PTI.createOrUpdate(deviceSn, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                            ConfigPriority.temp_anycast_gateway, \"base_evpn\", {}))\n\n            if \"UNDERLAY_IS_V6\" in fabricSettings and fabricSettings[\"UNDERLAY_IS_V6\"] == \"true\":\n                if Util.isSwVersionOk(deviceSn, \"9.3(5)\"):\n                    srchOpt = CtrlPolicySearch()\n                    srchOpt.setSerialNumber(deviceSn)\n                    srchOpt.setEntityType(\"INTERFACE\")\n                    srchOpt.setTemplateName(\"interface_ipv6_link_local\")\n                    ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                    statusDict[\"Progress\"] = \"interface_ipv6_link_local regen started for \" + hostName\n                    for pti in ptiList:\n                        if pti.isDeleted():\n                            continue\n                        nvPairs = pti.getNvPairs()\n                        if \"Vlan\" not in nvPairs[\"INTF_NAME\"]:\n                            Util.exe(PTIWrapper.createOrUpdate(deviceSn, \"INTERFACE\",\n                                                   nvPairs[\"INTF_NAME\"], pti.getSource(),\n                                                   ConfigPriority.CONFIG_PRIO_INTF,\n                                                   \"interface_ipv6_link_local_bia\",\n                                                   {\"INTF_NAME\": nvPairs[\"INTF_NAME\"]}))\n                            Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n                    statusDict[\"Progress\"] = \"interface_ipv6_link_local regen completed for \" + hostName\n    \n            if fabricSettings[\"LINK_STATE_ROUTING\"] == \"ebgp\":\n                srchOpt = CtrlPolicySearch()\n                srchOpt.setSerialNumber(deviceSn)\n                srchOpt.setSource(\"UNDERLAY\")\n                srchOpt.setTemplateName(\"route_map\")\n                ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                statusDict[\"Progress\"] = \"route_map conversion to route_map_with_tag started for \" + hostName\n                for pti in ptiList:\n                    if pti.isDeleted():\n                        continue\n                    Util.exe(PTIWrapper.createOrUpdate(deviceSn, \"SWITCH\", \"SWITCH\", \"UNDERLAY\",\n                                           ConfigPriority.abstract_route_map, \"route_map_with_tag\",\n                                           {\"ROUTE_MAP\": \"FABRIC-RMAP-REDIST-SUBNET\", \"ROUTING_TAG\": \"12345\"}))\n    \n                    Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n                statusDict[\"Progress\"] = \"route_map conversion to route_map_with_tag completed for \" + hostName\n            else:\n                switchRole = topologyDataObj.get(TopologyInfoType.GET_SWITCH_ROLE, deviceSn)\n                if \"border\" in switchRole:\n                    srchOpt = CtrlPolicySearch()\n                    srchOpt.setSerialNumber(deviceSn)\n                    srchOpt.setTemplateName(\"ext_multisite_overlay_setup_11_1\")\n                    msOverlayPtiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                    statusDict[\"Progress\"] = \"ext_multisite_overlay_setup_11_1 regen started for \" + hostName\n                    for pti in msOverlayPtiList:\n                        if pti.isDeleted():\n                            continue\n                        if \"IS_HUB_SITE\" not in pti.getNvPairs():\n                            nvPairs = copy.deepcopy(pti.getNvPairs())\n                            nvPairs[\"IS_HUB_SITE\"] = \"false\"\n                            Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), nvPairs))\n                    statusDict[\"Progress\"] = \"ext_multisite_overlay_setup_11_1 regen completed for \" + hostName\n    \n            srchOpt = CtrlPolicySearch()\n            srchOpt.setSerialNumber(deviceSn)\n            srchOpt.setTemplateName(\"ext_bgp_neighbor_rf\")\n            ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            statusDict[\"Progress\"] = \"ext_bgp_neighbor_rf regen started for \" + hostName\n            for pti in ptiList:\n                if pti.isDeleted():\n                    continue\n                nvPairs = copy.deepcopy(pti.getNvPairs())\n                nvPairs[\"IP_TYPE\"] = \"ipv4\"\n                nvPairs[\"ROUTE_MAP_NAME\"] = \"EXTCON-RMAP-FILTER-ALLOW-HOST\"\n                Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), nvPairs))\n            statusDict[\"Progress\"] = \"ext_bgp_neighbor_rf regen completed for \" + hostName\n\n            if fabricSettings[\"LINK_STATE_ROUTING\"] != \"ebgp\" and upgradeFromVersion in [\"12.1.1e\", \"12.1.2e\", \"12.1.2p\"]:\n                srchOpt = CtrlPolicySearch()\n                srchOpt.setSerialNumber(deviceSn)\n                srchOpt.setTemplateName(\"int_port_channel_leaf_tor_assoc\")\n                ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                statusDict[\"Progress\"] = \"int_port_channel_leaf_tor_assoc conversion to int_port_channel_uplink_access started for \" + hostName\n                for pti in ptiList:\n                    if pti.isDeleted():\n                        continue\n                    nvPairs = copy.deepcopy(pti.getNvPairs())\n                    # Delete the old python policy first, otherwise python policies created for members may be deleted\n                    # if the old python policy is deleted after the new python policy is created\n                    Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n                    Util.exe(PTIWrapper.create(deviceSn, pti.getEntityType(), pti.getEntityName(), pti.getSource(),\n                                               pti.getPriority(), \"int_port_channel_uplink_access\", nvPairs))\n                statusDict[\"Progress\"] = \"int_port_channel_leaf_tor_assoc conversion to int_port_channel_uplink_access completed for \" + hostName\n\n                isSwitchVPC = Util.exe(VpcWrapper.isVpc(fabricName, deviceSn))\n                if isSwitchVPC:\n                    vpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, fabricName, deviceSn))\n                    srchOpt.setSerialNumber(vpcPairSerialKey)\n                    srchOpt.setTemplateName(\"int_vpc_leaf_tor_assoc\")\n                    ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                    statusDict[\"Progress\"] = \"int_vpc_leaf_tor_assoc conversion to int_vpc_uplink_access started for \" + hostName\n                    for pti in ptiList:\n                        if pti.isDeleted():\n                            continue\n                        nvPairs = copy.deepcopy(pti.getNvPairs())\n                        # Delete the old python policy first, otherwise python policies created for members may be deleted\n                        # if the old python policy is deleted after the new python policy is created\n                        Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n                        Util.exe(PTIWrapper.create(vpcPairSerialKey, pti.getEntityType(), pti.getEntityName(), pti.getSource(),\n                                                   pti.getPriority(), \"int_vpc_uplink_access\", nvPairs))\n                    statusDict[\"Progress\"] = \"int_vpc_leaf_tor_assoc conversion to int_vpc_uplink_access completed for \" + hostName\n\n                    if upgradeFromVersion in [\"12.1.1e\"]:\n                        srchOpt.setSerialNumber(vpcPairSerialKey)\n                        srchOpt.setTemplateName(\"vpc_pair\")\n                        ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n                        statusDict[\"Progress\"] = \"vpc_pair regen started for \" + hostName\n                        for pti in ptiList:\n                            if pti.isDeleted():\n                                continue\n                            nvPairs = copy.deepcopy(pti.getNvPairs())\n                            nvPairs[\"KEEP_ALIVE_HOLD_TIMEOUT\"] = \"3\"\n                            Util.exe(PTIWrapper.updateInstance(pti.getPolicyId(), nvPairs, True))\n                        statusDict[\"Progress\"] = \"vpc_pair regen completed for \" + hostName\n\n            statusDict[\"Progress\"] = \"Complete\"\n            Wrapper.print(\"%s: End - Switch [%s/%s]\" % (funcName, deviceSn, hostName))\n\n        Wrapper.print(\"%s: End\" %(funcName))\n        return respObj\n    except Exception as e:\n        msg = (\"[%s] - Unexpected error during one time regeneration of policies after upgrade. \"\n            \"Last Status [%s]\" % (getFormattedSwitchName(currentDeviceSn), (statusDict[\"Progress\"] if statusDict else \"Unknown\")))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"POLICY_REGENERATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n\n# fabric wide post upgrade handling\ndef handleUpgradePerFabric(fabricName, dictObj):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s\" %funcName)\n    respObj = WrappersResp.getRespObj()\n    respObj.setSuccessRetCode()\n    try:\n        # check for vrf lite IFC for upgrade from pre 12.1.3\n        fabLinks = json.loads(Util.exe(Helper.getFabricLinks(fabricName)))\n        Wrapper.print(\"%s, fabric %s found %s links\" % (funcName, fabricName, len(fabLinks)))\n        for link in fabLinks:\n            templateName = link.get(\"templateName\", None)\n            if templateName != \"ext_fabric_setup\":\n                continue\n\n            origNvPairs = link.get(\"nvPairs\", None)\n            if not origNvPairs:\n                continue\n\n            if origNvPairs[\"AUTO_VRF_LITE_FLAG\"] != \"true\":\n                continue\n\n            sw1Info = link[\"sw1-info\"]\n            sw1_sn = sw1Info[\"sw-serial-number\"]\n            sw1_fabric_name = sw1Info[\"fabric-name\"]\n            sw1_fabric = Util.exe(FabricWrapper.get(sw1Info[\"fabric-name\"]))\n            sw1_FabricType = sw1_fabric.getFabricType()\n\n            sw2Info = link[\"sw2-info\"]\n            sw2_sn = sw2Info[\"sw-serial-number\"]\n            sw2_fabric_name = sw2Info[\"fabric-name\"]\n            sw2_fabric = Util.exe(FabricWrapper.get(sw2Info[\"fabric-name\"]))\n            sw2_FabricType = sw2_fabric.getFabricType()\n\n            if sw1_FabricType == \"External\" or sw2_FabricType == \"External\":\n                turnOffAutoDeployPeer = False\n                templateChange = \"\"\n                if sw1_FabricType == \"External\":\n                    checkSn = sw1_sn\n                else:\n                    checkSn = sw2_sn\n\n                model = Util.exe(InventoryWrapper.getSwitchModel(checkSn))\n\n                if not (Util.isNXOSDevice(checkSn, model) or Util.isIOSXEDevice(checkSn, model) or Util.isIOSXRDevice(checkSn, model)):\n                    turnOffAutoDeployPeer = True\n                elif Util.isIOSXEDevice(checkSn, model) and (origNvPairs[\"VRF_LITE_JYTHON_TEMPLATE\"] == \"Ext_VRF_Lite_Jython\" or origNvPairs[\"VRF_LITE_JYTHON_TEMPLATE\"] == \"ios_xr_Ext_VRF_Lite_Jython\"):\n                    templateChange = \"ios_xe_Ext_VRF_Lite_Jython\"\n                elif Util.isIOSXRDevice(checkSn, model) and (origNvPairs[\"VRF_LITE_JYTHON_TEMPLATE\"] == \"Ext_VRF_Lite_Jython\" or origNvPairs[\"VRF_LITE_JYTHON_TEMPLATE\"] == \"ios_xe_Ext_VRF_Lite_Jython\"):\n                    templateChange = \"ios_xr_Ext_VRF_Lite_Jython\"\n\n                if turnOffAutoDeployPeer or templateChange:\n                    # update only if IFC is not extended\n                    swId1 =  Util.exe(InterfabricConnectionWrapper.getLanSwitchId(sw1_sn));\n                    swId2 =  Util.exe(InterfabricConnectionWrapper.getLanSwitchId(sw2_sn))\n                    source_inter_fabric_connection_id = Util.exe(InterfabricConnectionWrapper.getInterfabricId(swId1, sw1Info.get(\"if-name\"),\n                                                          swId2, sw2Info.get(\"if-name\")))\n\n                    dest_inter_fabric_connection_id = Util.exe(InterfabricConnectionWrapper.getInterfabricId(swId2, sw2Info.get(\"if-name\"),\n                                                          swId1, sw1Info.get(\"if-name\")))\n\n                    source_extended = destination_extended = False\n                    if source_inter_fabric_connection_id != 0:\n                        source_extended = Util.exe(InterfabricConnectionWrapper.isInterfabricExtended(source_inter_fabric_connection_id))\n\n                    if dest_inter_fabric_connection_id != 0:\n                        destination_extended = Util.exe(InterfabricConnectionWrapper.isInterfabricExtended(dest_inter_fabric_connection_id))\n\n                    if source_extended or destination_extended:\n                        Wrapper.print(\"%s link %s has extension, skip update\" % (funcName, link[\"policyId\"]))\n                        continue\n\n                    nvPairs = copy.deepcopy(origNvPairs)\n                    if turnOffAutoDeployPeer:\n                        nvPairs[\"AUTO_VRF_LITE_FLAG\"] = \"false\"\n                        nvPairs[\"DEFAULT_VRF_FLAG\"] = \"false\"\n                        nvPairs[\"SYMMETRIC_DEFAULT_VRF_FLAG\"] = \"false\"\n                    if templateChange:\n                        nvPairs[\"VRF_LITE_JYTHON_TEMPLATE\"] = templateChange\n\n                    Wrapper.print(\"%s update link %s: turnOffAutoDeployPeer %s, templateChange %s nvPairs %s\" % (funcName, link[\"policyId\"], turnOffAutoDeployPeer, templateChange, nvPairs))\n                    Util.exe(PTIWrapper.updateInstance(link[\"policyId\"], nvPairs, True))\n\n        return respObj\n    except respObjError as e:\n        msg = (\"[%s] - Unexpected error during one time regeneration of policies after upgrade. \" % funcName)\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(\"POLICY_REGENERATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n\ndef getAndAddToList(fabricSettings, key, list):\n    val = fabricSettings.get(key, None)\n    if val:\n        list.append(val)\n\ndef mgmtFabricSettingsUpgrade(fabricSettings):\n    isSettingChange = False\n    # Handling DNS fabric settings\n    Wrapper.print(\"mgmtFabricSettingsUpgrade: Fabric [%s] DNS_SERVER_IP_LIST [%s]\" %\n            (FABRIC_NAME, fabricSettings.get(\"DNS_SERVER_IP_LIST\", None)))\n    if (\"DNS_SERVER_IP_LIST\" not in fabricSettings):\n        serverIPs = []\n        vrfs = []\n        \n        if fabricSettings.get(\"DNS_SERVER_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'DNS_SERVER_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'DNS_SERVER_VRF', vrfs)\n\n        if fabricSettings.get(\"DNS2_SERVER_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'DNS2_SERVER_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'DNS2_SERVER_VRF', vrfs)\n\n        isSettingChange = setFabricSettingValue(fabricSettings, \"DNS_SERVER_IP_LIST\", (\",\".join(serverIPs)))\n        isSettingChange = setFabricSettingValue(fabricSettings, \"DNS_SERVER_VRF\", (\",\".join(vrfs)))\n        \n    # Handling NTP Upgrades\n    Wrapper.print(\"mgmtFabricSettingsUpgrade: Fabric [%s] NTP_SERVER_IP_LIST [%s]\" %\n            (FABRIC_NAME, fabricSettings.get(\"NTP_SERVER_IP_LIST\", None)))\n    if (\"NTP_SERVER_IP_LIST\" not in fabricSettings):\n        serverIPs = []\n        vrfs = []\n\n        if fabricSettings.get(\"NTP_SERVER_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'NTP_SERVER_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'NTP_SERVER_VRF', vrfs)\n\n        if fabricSettings.get(\"NTP2_SERVER_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'NTP2_SERVER_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'NTP2_SERVER_VRF', vrfs)\n\n        isSettingChange = setFabricSettingValue(fabricSettings, \"NTP_SERVER_IP_LIST\", (\",\".join(serverIPs)))\n        isSettingChange = setFabricSettingValue(fabricSettings, \"NTP_SERVER_VRF\", (\",\".join(vrfs)))\n\n    # Handling SYSLOG Upgrades\n    Wrapper.print(\"mgmtFabricSettingsUpgrade: Fabric [%s] SYSLOG_SERVER_IP_LIST [%s]\" %\n            (FABRIC_NAME, fabricSettings.get(\"SYSLOG_SERVER_IP_LIST\", None)))\n    if (\"SYSLOG_SERVER_IP_LIST\" not in fabricSettings):\n        serverIPs = []\n        vrfs = []\n        sevs = []\n\n        if fabricSettings.get(\"SYSLOG_SERVER1_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'SYSLOG_SERVER1_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'SYSLOG_VRF1', vrfs)\n            getAndAddToList(fabricSettings, 'SYSLOG_SEV1', sevs)\n\n        if fabricSettings.get(\"SYSLOG_SERVER2_IP\", \"\") != \"\":\n            getAndAddToList(fabricSettings, 'SYSLOG_SERVER2_IP', serverIPs)\n            getAndAddToList(fabricSettings, 'SYSLOG_VRF2', vrfs)\n            getAndAddToList(fabricSettings, 'SYSLOG_SEV2', sevs)\n\n        isSettingChange = setFabricSettingValue(fabricSettings, \"SYSLOG_SERVER_IP_LIST\", (\",\".join(serverIPs)))\n        isSettingChange = setFabricSettingValue(fabricSettings, \"SYSLOG_SERVER_VRF\", (\",\".join(vrfs)))\n        isSettingChange = setFabricSettingValue(fabricSettings, \"SYSLOG_SEV\", (\",\".join(sevs)))\n\n    # Handling AAA Upgrades\n    Wrapper.print(\"mgmtFabricSettingsUpgrade: Fabric [%s] AAA_SERVER_CONF [%s]\" %\n            (FABRIC_NAME, fabricSettings.get(\"AAA_SERVER_CONF\", None)))\n    if (\"AAA_SERVER_CONF\" not in fabricSettings):\n        aaa_IP = fabricSettings.get('AAA_SERVER', \"\")\n        aaa_IP2 = fabricSettings.get('AAA2_SERVER', \"\")\n        aaa_Secret = fabricSettings.get('AAA_SECRET', \"\")\n        aaa_Secret2 = fabricSettings.get('AAA2_SECRET', \"\")\n        aaa_vrf = fabricSettings.get('AAA_VRF', \"default\")\n        aaa_vrf = fabricSettings.get('AAA_VRF', \"default\")\n        if aaa_vrf == \"\":\n            aaa_vrf = \"default\"\n        aaa_Type = fabricSettings.get('AAA_TYPE', \"none\")\n\n        configureKeys       = \"\"\n        configure_Vrfs      = \"\"\n        configureBASEAAA    = \"\" \n        update_AAA_Freeform = \"\"\n\n        Wrapper.print(\"mgmtFabricSettingsUpgrade: Fabric [%s] aaa_Type [%s]\" % (FABRIC_NAME, aaa_Type))\n        if aaa_Type != \"none\":\n            if aaa_Type == \"radius\":\n                configureKeys, configure_Vrfs, configureBASEAAA = configureRADIUS(aaa_IP, aaa_Secret, \n                                                                    aaa_IP2, aaa_Secret2, aaa_vrf, aaa_Type)\n            elif aaa_Type == \"tacacs\":\n                configureKeys, configure_Vrfs, configureBASEAAA = configureTACACS(aaa_IP, aaa_Secret,\n                                                                    aaa_IP2, aaa_Secret2, aaa_vrf, aaa_Type)\n        \n            update_AAA_Freeform = (configureKeys + configure_Vrfs + configureBASEAAA)\n        isSettingChange = setFabricSettingValue(fabricSettings, \"AAA_SERVER_CONF\", update_AAA_Freeform)\n    return isSettingChange\n\ndef configureRADIUS(aaa_IP, aaa_Secret, aaa_IP2, aaa_Secret2, aaa_vrf, aaa_Type):\n    if aaa_IP and aaa_IP2:\n        configureKeys   = \"radius-server host \" + aaa_IP + \" key 7 \" + \"\\\"\" +aaa_Secret + \"\\\"\" +\" authentication accounting\" + Util.newLine()\n        configureKeys   += \"radius-server host \" + aaa_IP2 + \" key 7 \" + \"\\\"\" + aaa_Secret2 + \"\\\"\" + \" authentication accounting\" + Util.newLine()\n        configure_Vrfs  = \"aaa group server radius AAA_RADIUS\" + Util.newLine() + \"  server \" + aaa_IP + Util.newLine() + \"  server \" + aaa_IP2 + Util.newLine() + \"  use-vrf \" + aaa_vrf + Util.newLine()\n    elif not aaa_IP2:\n        configureKeys = \"radius-server host \" + aaa_IP + \" key 7 \" + \"\\\"\" + aaa_Secret + \"\\\"\" + \" authentication accounting \" + Util.newLine()\n        configure_Vrfs  = \"aaa group server radius AAA_RADIUS\" + Util.newLine() + \"  server \" + aaa_IP + Util.newLine() + \"  use-vrf \" + aaa_vrf +Util.newLine()\n    else:\n        configureKeys = \"radius-server host \" + aaa_IP2 + \" key 7 \" + \"\\\"\" + aaa_Secret2 + \"\\\"\" + \" authentication accounting \" + Util.newLine()\n        configure_Vrfs  = \"aaa group server radius AAA_RADIUS\" + Util.newLine() + \"  server \" + aaa_IP2 + Util.newLine() + \"  use-vrf \" + aaa_vrf + Util.newLine()\n        \n    configureBASEAAA =  \"aaa authentication login default group AAA_RADIUS local\" + Util.newLine() + \"aaa authentication login console local\" + Util.newLine() + \"aaa accounting default group AAA_RADIUS\" + Util.newLine() +\"aaa authentication login error-enable\"\n    return configureKeys, configure_Vrfs, configureBASEAAA\n    \ndef configureTACACS(aaa_IP, aaa_Secret, aaa_IP2, aaa_Secret2, aaa_vrf, aaa_Type):\n    \n    configureKeys = \"\"\n    configure_Vrfs = \"\"\n    configureBASEAAA = \"\" \n    base_tacacs = \"feature tacacs+\"+Util.newLine()\n    \n    if aaa_IP and aaa_IP2:\n        configureKeys = base_tacacs + \"tacacs-server host \" + aaa_IP + \" key 7 \" + \"\\\"\" + aaa_Secret + \"\\\"\" +Util.newLine()\n        configureKeys += \"tacacs-server host \" + aaa_IP2 + \" key 7 \" + \"\\\"\" + aaa_Secret2 + \"\\\"\" +Util.newLine()\n        configure_Vrfs = \"aaa group server tacacs+ AAA_TACACS\" +Util.newLine() + \"  server \" + aaa_IP + Util.newLine() + \"  server \" + aaa_IP2 +Util.newLine() + \"  use-vrf \" + aaa_vrf +Util.newLine()\n    elif not aaa_IP2:\n        configureKeys = base_tacacs + \"tacacs-server host \" + aaa_IP + \" key 7 \" + \"\\\"\" + aaa_Secret + \"\\\"\" +Util.newLine()\n        configure_Vrfs = \"aaa group server tacacs+ AAA_TACACS\" +Util.newLine() + \"  server \" + aaa_IP +Util.newLine() + \"  use-vrf \" + aaa_vrf + Util.newLine()\n    else:\n        configureKeys = base_tacacs + \"tacacs-server host \" + aaa_IP2 + \" key 7 \" + \"\\\"\" + aaa_Secret2 + \"\\\"\" +Util.newLine()\n        configure_Vrfs = \"aaa group server tacacs+ AAA_TACACS\" +Util.newLine() + \"  server \" + aaa_IP2 +Util.newLine()+ \"  use-vrf \" + aaa_vrf + Util.newLine()\n        \n    configureBASEAAA = \"aaa authentication login default group AAA_TACACS local\" + Util.newLine() + \"aaa authentication login console local\" + Util.newLine() + \"aaa accounting default group AAA_TACACS\" + Util.newLine() + \"aaa authentication login error-enable\"\n    return configureKeys, configure_Vrfs, configureBASEAAA\n\n#\n# Handles N9K and N3K switches\n# returns the following:\n#   \"FRETTA\" - for -R series HW (Fixed chassis is N3K-xxx-R, modular is N9k with -R LCs)\n#   \"CLOUDSCALE\" - for Tahoe based HW\n#   \"NXOSV\" - for NXOSv\n#   \"OTHER\" - for all other HW types (T2)\n#   \"UNKNOWN\" - if HW type is unknown\n#\ndef getHwAsicType(topologyDataObj, sn):\n    funcName = sys._getframe(0).f_code.co_name\n    devModel = topologyDataObj.getSwitchModel(sn)\n\n    asicType = \"UNKNOWN\"\n    if Util.isN9kTahoe(topologyDataObj, sn):\n        asicType = \"CLOUDSCALE\"\n\n        # need to check further for fretta LCs\n        devModules = topologyDataObj.getSwitchModules(sn)\n\n        #Wrapper.print(\"%s: sn [%s] devModel [%s] devModules [%s]\" % (funcName, sn, devModel, devModules))\n        # need to check further for -R series\n        if not devModules:\n            if \"-R\" in devModel:\n                asicType = \"FRETTA\"\n        else:\n            for module in devModules:\n                model = module.get(\"ModelName\")\n                if model is None:\n                    # the model name is not present.. skip\n                    continue\n                if \"-R\" in model:\n                    asicType = \"FRETTA\"\n                    #Wrapper.print(\"%s: sn [%s] devModel [%s] module model [%s]\" % (funcName, sn, devModel, model))\n                    break\n    elif Util.isN9kv(topologyDataObj, sn):\n        asicType = \"NXOSV\"\n    elif \"-R\" in devModel:\n        asicType = \"FRETTA\"\n    else:\n        # has to be T2\n        asicType = \"OTHER\"\n\n    Wrapper.print(\"%s: sn [%s] devModel [%s] asicType [%s]\" % (funcName, sn, devModel, asicType))\n    return asicType\n\ndef ECLdeviceUpgradeExt(gVarDictObj, respObj, doFullProcessing):\n\n    funcName = sys._getframe(0).f_code.co_name\n\n    dictionaryObj = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = dictionaryObj[\"deviceSerial\"]\n    migrateMode = dictionaryObj[\"migrationMode\"]\n    topologyDataObj = gVarDictObj[\"topologyObj\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    vpcSrcToDstMacMap = gVarDictObj[\"vpcSrcToDstMacMap\"]\n    matchResult = dictionaryObj[\"matchResult\"]\n    interfacesRes = dictionaryObj[\"interfacesRes\"]\n    switchRole = dictionaryObj[\"switchRole\"]\n    hostName = dictionaryObj[\"hostName\"]\n    fmtName = dictionaryObj[\"fmtName\"]\n    model = dictionaryObj[\"deviceModel\"]\n    dcnmUser = gVarDictObj[\"dcnmUser\"]\n    \n    isAgg = False\n    if \"aggregation\" in switchRole.lower():\n        isAgg = True\n    Wrapper.print(\"==========%s: Fabric = %s, Serial [%s] Model [%s] Role [%s] isAgg [%r]\" % \n        (funcName, FABRIC_NAME, devSerial, model, switchRole, isAgg))\n\n    vPCInfo = dictionaryObj[\"vpcInfo\"]\n    isValidVPC = (vPCInfo[\"domainId\"] != None)\n\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][devSerial]\n    switchOverlayInfo[\"isVpc\"] = \"true\" if isValidVPC else \"false\"\n\n    device_overlay_vlans = {}\n    doOverlayMigr = False\n    if migrateMode == \"brownAdd\":\n        #Do overlay migration for both access & aggregation roles. \n        #Access will yield its network attachments that will be added as torPorts to the corresponding paired agg(s)\n        doOverlayMigr = True\n        # record state that the switch overlay migration is not completed yet\n        if isAgg:\n            switchOverlayInfo[\"doOverlayExtn\"] = \"true\"\n        putSwitchIntoOverlayMigrMode(FABRIC_NAME, devSerial)\n    elif migrateMode == \"upgrade\":\n        #TODO: IS THIS REQUIRED?\n        if switchRole.lower() != \"spine\":\n            doOverlayMigr = True\n            # the switch will be in migration mode from the backend code\n            # get the interface specific network vlan info\n            device_overlay_vlans = TopDownMigrationUtils.getOverlayInterfaceInfo(devSerial)\n            Wrapper.print(\"Fabric upgrade %s device_overlay_vlans %s\" % (devSerial, device_overlay_vlans))\n            for x in device_overlay_vlans.entrySet():\n                Wrapper.print(\" intf %s, %s\" % (x.key, x.value.getVlanList()))\n\n    if doOverlayMigr:\n        # collect all the network/vrf information for the switches\n        ECLgatherNwkVrfInfo(topologyDataObj, devSerial, matchResult, interfacesRes, globalOverlayInfo,\n                    switchOverlayInfo, migrateMode, device_overlay_vlans, respObj, dcnmUser)\n\n    if respObj.isRetCodeFailure() or (not doFullProcessing):\n        return respObj\n\n    if Util.exe(FabricWrapper.isFeatureEnabled(\"nxcloud\")):\n        manageNxCloudPolicies(devSerial, matchResult, respObj)\n\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    # add the special route-map policy template for the Aggs\n    if isAgg:\n        # do a check first\n        templateName = \"route_map\"\n        if (getTemplateMatchResults(matchResult, templateName) == None):\n            # add the match entry\n            matchResult.update({templateName : [{}]})\n\n    # process common configs\n    if isValidVPC:\n        createPTI(devSerial, {}, \"base_feature_vpc\", \"SWITCH\", \"UNDERLAY\", -1)\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"nfm_switch_user\")\n    createMatchedPtis(devSerial, matchResult, \"password_no_strength\")\n    createMatchedPtis(devSerial, matchResult, \"host_11_1\")\n    createMatchedPtis(devSerial, matchResult, \"switchnm_11_1\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"v4_mgmt_default_gateway\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"v6_mgmt_default_gateway_11_1\")\n    createMatchedPtis(devSerial, matchResult, \"feature_bfd\")\n    createMatchedPtis(devSerial, matchResult, \"feature_nxapi\")\n    createMatchedPtis(devSerial, matchResult, \"nxapi_http_port\")\n    createMatchedPtis(devSerial, matchResult, \"nxapi_https_port\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"banner\")\n    nvPairList = getTemplateMatchResults(matchResult, \"ssh_key_rsa\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            bits = nvPair.get(\"BITS\")\n            if bits != \"1024\" and bits != \"\":\n                rsaNvPair = {\"BITS\":bits}\n                Wrapper.print(\"match ssh_key_rsa %s\" % nvPair)\n                Util.exe(PTIWrapper.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n                                           \"ssh_key_rsa_force\", rsaNvPair))\n\n    createMatchedPtis(devSerial, matchResult, \"pre_config\")\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"base_bgp\")\n\n    #manageBgpRelatedBrownfieldPolicies(devSerial, matchResult, gVarDictObj, switchOverlayInfo[\"BGP_FF\"], respObj)\n\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"ntp_server\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"ntp_prefer_server\")\n    createMatchedPtis(devSerial, matchResult, \"clock_protocol\")\n    createMatchedPtis(devSerial, matchResult, \"clock_timezone\")\n    createMatchedPtis(devSerial, matchResult, \"clock_summertime\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"dnsList\")  #cleanup first since we use create,not update to support multiple dns_vrf\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"dns-vrfList\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_sev\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_vrf\")\n    deleteAndCreateMatchedPtis(devSerial, matchResult, \"syslog_server_vrf_no_sev\")\n\n    # check system jumbomtu\n    jumboMtuVal = \"9216\"\n    templateName = \"system_jumbomtu\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            jumboMtuVal = nvPair[\"MTU\"]\n\n    Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n        templateName, {\"MTU\" : jumboMtuVal}))\n\n    # create the internal PTI to track the switch jumbomtu setting\n    Util.exe(PTI.createOrUpdate(devSerial, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP,\n        \"switch_mtu_state\", {\"JUMBO_MTU_VAL\" : jumboMtuVal}))\n\n    nvPairList = getTemplateMatchResults(matchResult, \"aaa_tacacs\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            if nvPair[\"AAA_TACACS\"] == \"tacacs+\":\n                Wrapper.print(\"match aaa_tacacs, %s\" % nvPair)\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2,\n                                           \"aaa_tacacs\", nvPair))\n\n    nvPairList = getTemplateMatchResults(matchResult, \"aaa_tacacs_use_vrf\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            if nvPair[\"AAA_TACACS\"] == \"tacacs+\":\n                Wrapper.print(\"match aaa_tacacs_use_vrf, %s\" % nvPair)\n                Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\",\n                                           ConfigPriority.CONFIG_PRIO_UNDERLAY_TOP_LVL2,\n                                           \"aaa_tacacs_use_vrf\", nvPair))\n    \n    isN7k = isModelN7k(topologyDataObj, devSerial) \n    if not isN7k:\n        if (POWER_REDUNDANCY_MODE == \"combined\"):\n            createPTI(devSerial, {}, \"power_redundancy_combined\", \"SWITCH\", \"\", -1)\n        else:\n            createPTI(devSerial, {\"REDUNDANCY_MODE\": POWER_REDUNDANCY_MODE},\n                                     \"power_redundancy\", \"SWITCH\", \"\", -1)\n\n    # handle pre-interface global unaccounted cmds\n    features_info = matchResult[\"FEATURES_INFO\"]\n    global_unaccounted = features_info[\"GLOBAL_UNACCTED\"][\"unaccounted\"]\n\n    keyChainLine = \"\"\n    '''\n    if LINK_STATE_ROUTING == \"ospf\":\n        underlayProtocolCfgLine = \"router \" + (\"ospf \" if UNDERLAY_IS_V6 == \"false\" else \"ospfv3 \") + LINK_STATE_ROUTING_TAG\n    else:\n        underlayProtocolCfgLine = \"router isis \" + LINK_STATE_ROUTING_TAG\n    Wrapper.print(\"%s: underlayProtocolCfgLine: [%s]\" % (funcName, underlayProtocolCfgLine))\n    '''\n    underlayProtocolCfgLine = \"\"\n    \n    filteredUnaccounted = []\n    feature_unaccounted = []\n\n    tcamUnaccounted = []\n    AAA_Configs = []\n    global_unaccounted_AAA = []\n    logging_Configs = []\n    snmpServer_Configs = []\n    ntp_Configs = []\n    routeMap_Configs = []\n    qos_Configs = []\n    copp_Configs = []\n    ipSla_Configs = []\n    track_Configs = []\n    netflow_Configs = []\n    vpcDomain_Configs = []\n    vlanConfig_Configs = []\n    skipAcl = False\n    skipPfxList = False\n    skipMmodeProfile = False\n    isAAABlock = False\n    isRouteMapBlock = False\n    isQosBlock = False\n    isCoppBlock = False\n    isIpSlaBlock = False\n    isTrackBlock = False\n    isNetflowBlock = False\n    isVpcDomainBlock = False\n    isVlanConfigBlock = False\n    keyChainLines = []\n    keepKeyChain = False\n    isKeyChain = False\n    startCurrAclContext = False\n    isN7KExpandTabCli = False\n    aclDict = {}\n    prefixListDict = {}\n    for line in global_unaccounted:\n        depth = (len(line) - len(line.lstrip(' '))) / 2\n        if depth == 0:\n            # top level CLIs\n            isKeyChain = False\n            keepKeyChain = False\n            isN7KExpandTabCli = False\n\n            #IP acl list parsing is done for a single acl\n            if startCurrAclContext:\n                aclDict[aclNameDesc] = currAclCmds\n                startCurrAclContext = False\n                currAclCmds = []\n\n            if skipAcl:\n                # we are out of the ACL block\n                skipAcl = False\n            elif isAAABlock:\n                # we are out of the AAA block\n                isAAABlock = False\n            elif isRouteMapBlock:\n                # we are out of the Route-map block\n                isRouteMapBlock = False\n            elif isVpcDomainBlock:\n                # we are out of the vPC domain block\n                isVpcDomainBlock = False\n            elif isVlanConfigBlock:\n                # we are out of the Vlan configuration block\n                isVlanConfigBlock = False                \n            elif isQosBlock:\n                # we are out of the current class-map/policy-map block\n                isQosBlock = False\n            elif isCoppBlock:\n                # we are out of the current control-plane class-map/policy-map block\n                isCoppBlock = False                \n            elif isTrackBlock:\n                # we are out of the current track config block\n                isTrackBlock = False\n            elif isNetflowBlock:\n                # we are out of the current netflow config block\n                isNetflowBlock = False\n            elif skipMmodeProfile:\n                # we are out of the current maintenance mode profile block\n                skipMmodeProfile = False\n                \n            if isN7k:\n                if (line.startswith(\"vlan access-map\")):\n                    isN7KExpandTabCli = True\n                    filteredUnaccounted.append(line)\n                    continue\n\n            if (line.startswith(\"power redundancy-mode\") or line.startswith(\"version\")):\n                # these should not be captured in the accounted configs\n                continue\n\n            if line.startswith(\"feature \"):\n                if \"tacacs\" not in line:\n                    feature_unaccounted.append(line)\n                else:\n                    AAA_Configs.append(line)\n                continue\n\n            if line.startswith(\"aaa\"):\n                global_unaccounted_AAA.append(line)\n                isAAABlock = True\n                continue\n\n            if line.startswith(\"hardware access-list tcam region\"):\n                tcamUnaccounted.append(line)\n                continue\n\n            if line.startswith(\"snmp-server \") or line.startswith(\"no snmp-server \"):\n                snmpServer_Configs.append(line)\n                continue\n\n            if line.startswith(\"ntp \"):\n                ntp_Configs.append(line)\n                continue\n\n            if line.startswith(\"route-map \"):\n                routeMap_Configs.append(line)\n                isRouteMapBlock = True\n                continue\n\n            if line.startswith(\"vpc domain \"):\n                vpcDomain_Configs.append(line)\n                isVpcDomainBlock = True\n                continue\n\n            if line.startswith(\"vlan configuration \"):\n                if \"aggregation\" in switchRole.lower():\n                    vlanConfig_Configs.append(line)\n                isVlanConfigBlock = True\n                continue\n              \n            if line.startswith(\"track \"):\n                track_Configs.append(line)\n                isTrackBlock = True\n                continue\n\n            if line.startswith(\"flow exporter \") or line.startswith(\"flow monitor \") or line.startswith(\"flow record \") or line.startswith(\"sampler \"):\n                netflow_Configs.append(line)\n                isNetflowBlock = True\n                continue\n              \n            if line.startswith(\"class-map type qos \") or line.startswith(\"policy-map type qos \"):\n                qos_Configs.append(line)\n                isQosBlock = True\n                continue\n\n            if line.startswith(\"class-map type control-plane \") or line.startswith(\"policy-map type control-plane \"):\n                copp_Configs.append(line)\n                isCoppBlock = True\n                continue\n              \n            aclCmdPrefixDict = {\"IP ACL: \":\"ip access-list \", \"IPv6 ACL: \":\"ipv6 access-list \", \"MAC ACL: \":\"mac access-list \"}\n            for aclCmdPrefix in aclCmdPrefixDict:\n                if line.startswith(aclCmdPrefixDict[aclCmdPrefix]):\n                    aclName = line[len(aclCmdPrefixDict[aclCmdPrefix]):].strip()\n                    aclNameDesc = aclCmdPrefix + aclName\n                    # look for NDI telemetry specific ACL that we need to skip\n                    if aclName == \"telemetryipv4acl\" or aclName == \"telemetryipv6acl\":\n                        skipAcl = True\n                    else:\n                        #Start of a new ip acl\n                        startCurrAclContext = True\n                        currAclCmds = []\n                        currAclCmds.append(line)\n                        skipAcl = True\n                    break    \n            if skipAcl:\n                continue\n\n            # look for either maintenance mode or normal mode profile and skip it\n            if line.startswith(\"configure maintenance profile \"):\n                skipMmodeProfile = True\n                continue\n\n            prefixListCmdDict = {\"IP Prefix-list: \":\"ip prefix-list \", \"IPv6 Prefix-list: \":\"ipv6 prefix-list \"}\n            for prefixListCmdPrefix in prefixListCmdDict:\n                if line.startswith(prefixListCmdDict[prefixListCmdPrefix]):\n                    prefixListName = line.split()[2]\n                    prefixListDesc = prefixListCmdPrefix + prefixListName\n                    if prefixListDesc not in prefixListDict:\n                        #Start a new prefix list\n                        prefixListDict[prefixListDesc] = []\n                        prefixListDict[prefixListDesc].append(line)\n                    else:\n                        #Append commands to the existing prefix list\n                        prefixListDict[prefixListDesc].append(line)\n                    skipPfxList = True\n                    break    \n            if skipPfxList:\n                continue\n                \n            if line.startswith(\"key chain \"):\n                isKeyChain = True\n                if (line == keyChainLine):\n                    keepKeyChain = True\n                    keyChainLines.append(line)\n                    continue\n        else:\n            # subcommands\n            if isN7KExpandTabCli:\n                # replace the tab with 6 spaces\n                line = line.replace(\"\\t\", \"      \")\n                Wrapper.print(\"%s: N7K line [%s]\" % (funcName, line))\n\n        if isKeyChain:\n            if keepKeyChain:\n                keyChainLines.append(line)\n            continue\n        elif isAAABlock:\n            global_unaccounted_AAA.append(line)\n            continue\n        elif isRouteMapBlock:\n            routeMap_Configs.append(line)\n            continue\n        elif isVpcDomainBlock:\n            vpcDomain_Configs.append(line)\n            continue\n        elif isVlanConfigBlock:\n            if \"aggregation\" in switchRole.lower():\n                vlanConfig_Configs.append(line)\n            continue          \n        elif isTrackBlock:\n            track_Configs.append(line)\n            continue\n        elif isNetflowBlock:\n            netflow_Configs.append(line)\n            continue          \n        elif isQosBlock:\n            qos_Configs.append(line)\n            continue\n        elif isCoppBlock:\n            copp_Configs.append(line)\n            continue          \n        elif startCurrAclContext:\n            currAclCmds.append(line)\n            continue\n        elif skipAcl:\n            continue\n        elif skipMmodeProfile:\n            continue\n          \n        filteredUnaccounted.append(line)\n\n    Wrapper.print(\"%s: %s ip access list acldict %s prefixlistdict %s\" % (funcName, fmtName, aclDict, prefixListDict))\n                    \n    # filter out the unaccounted key chain config specific to out ISIS auth key chain and key id\n    keyChainLinesFiltered = []\n    if keyChainLine != \"\":\n        for line in keyChainLines:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                ourBlock = False\n                if line == keyChainLine:\n                    ourBlock = True\n            elif depth == 1:\n                strippedLine = line.strip()\n                ourBlock = False\n                if strippedLine == isisKeyId:\n                    ourBlock = True\n\n            if ourBlock:\n                keyChainLinesFiltered.append(line)\n\n        if len(keyChainLinesFiltered) == 1:\n            keyChainLinesFiltered.clear()\n\n    Wrapper.print(\"%s: %s filteredUnaccounted %s\" % (funcName, fmtName, filteredUnaccounted))\n    #Wrapper.print(\"%s: keyChainLine [%s] isisKeyId [%s] keyChainLines %s keyChainLinesFiltered %s\" % (funcName, keyChainLine, isisKeyId, keyChainLines, keyChainLinesFiltered))\n\n    # update the 'global_unaccounted' to the filtered list for subsequent use\n    global_unaccounted = (filteredUnaccounted + keyChainLinesFiltered)\n\n    # look for the vrf references in matches for 'dns_vrf_one' and 'dns_vrf' policies\n    vrfsWithDns = []\n    dnsTemplates = ['dns-vrfList']\n    for templateName in dnsTemplates:\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            getVrfsWithDns(nvPairList, vrfsWithDns)\n\n    vrf_block = features_info[\"VRF_BLOCK\"]\n    for vrfStr in vrf_block.keys():\n        vrfRec = vrf_block[vrfStr]\n        vrfName = vrfStr.split(\" \")[2].strip()\n        Wrapper.print(\"%s: Processing DNS for VRF context [%s]\" % (funcName, vrfName))\n        \n        if vrfName.lower() == MGMT_VRF_NAME:\n            global_unaccounted += vrfRec[\"unaccounted\"]\n        else:\n            if vrfName in vrfsWithDns:\n                continue\n            newCfg = []\n            for line in vrfRec[\"show_run\"]:\n                strippedLine = line.strip()\n                if strippedLine.startswith(\"vrf context\") or strippedLine.startswith(\"ip name-server\"):\n                    newCfg.append(line)\n            if len(newCfg) > 1:\n                Wrapper.print(\"%s: VRF context [%s]. Name server cfg = [%s]\" % (funcName, vrfName, newCfg))\n                global_unaccounted += newCfg\n                #global_unaccounted += Util.newLine().join(newCfg)\n\n    if isAgg:\n        bgp_unaccounted = []\n        routerBgpKey = \"router bgp \" + BGP_AS\n        if routerBgpKey in features_info[\"BGP_BLOCK\"]:\n            bgp_unaccounted = features_info[\"BGP_BLOCK\"][routerBgpKey][\"unaccounted\"]\n    \n        #TODO:Revisit\n        #bgp_unaccounted.append(\"router bgp %s\" % BGP_AS)\n    \n        Wrapper.print(\"BGP unaccounted with template: %s\" % bgp_unaccounted)\n\n    ptiList = Util.exe(PTIWrapper.get(devSerial, \"SWITCH\", \"SWITCH\", \"\", \"switch_freeform\"))\n    for pti in ptiList:\n        Util.exe(PTIWrapper.deleteInstance(pti.getPolicyId()))\n\n    if feature_unaccounted:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_TOP,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(feature_unaccounted)}, \"Additional Feature Configuration\"))\n\n    # need to process the config blocks collected from the 'show run'\n    linkProtoCfgLines = []\n    keyChainCfgLines = []\n    if isAgg:\n        cfgBlocksFromShRun = matchResult.get(\".SH_RUN_CFG_BLOCKS\", {})\n        for key in cfgBlocksFromShRun:\n            instances = cfgBlocksFromShRun[key]\n            if (key in [\"ROUTER_ISIS\", \"ROUTER_OSPF\"]):\n                for instance in instances:\n                    if underlayProtocolCfgLine == instance:\n                        # we are not interested in this since the policy matches would have captured the intent\n                        continue\n                    else:\n                        linkProtoCfgLines += instances[instance]\n            elif key == \"KEY_CHAIN\":\n                for instance in instances:\n                    if keyChainLine == instance:\n                        # look further into the key id of interest.. (will not get here is ISIS and auth is not enabled)\n                        isisKeyLines = []\n                        ourBlock = False\n                        for line in instances[instance]:\n                            depth = (len(line) - len(line.lstrip(' '))) / 2\n    \n                            if depth == 1:\n                                strippedLine = line.strip()\n                                ourBlock = False\n                                if strippedLine == isisKeyId:\n                                    ourBlock = True\n    \n                            if not ourBlock:\n                                isisKeyLines.append(line)\n                        if len(isisKeyLines) > 1:\n                            # the first line is the 'key chain <name>'\n                            keyChainCfgLines += isisKeyLines\n                    else:\n                        keyChainCfgLines += instances[instance]\n\n    switchOverlayInfo[\"PRE_INTF_FF\"] = (global_unaccounted + keyChainCfgLines + switchOverlayInfo[\"PRE_INTF_FF\"])\n    if switchOverlayInfo[\"PRE_INTF_FF\"]:\n        # this needs to show up before the interfaces\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(switchOverlayInfo[\"PRE_INTF_FF\"])}, BF_PRE_INTF_FF_PTI_DESC))\n    switchOverlayInfo[\"PRE_INTF_FF\"] = None\n\n    #Add switchfreeform for every ACL discovered in BF import\n    for aclEntry in aclDict:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 20,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(aclDict[aclEntry])}, aclEntry))\n                    \n    #Add Track configs discovered in BF import\n    if track_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 15,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(track_Configs)}, \"Track related configuration\"))\n\n    #Add QoS Class-map/Policy-map related configuration\n    if qos_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(qos_Configs)}, \"QoS Class-map/Policy-map configuration\"))\n\n    #Add CoPP Class-map/Policy-map related configuration\n    if copp_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(copp_Configs)}, \"Control-plane policing configuration\"))\n                    \n    #Add NTP related extra configuration\n    if ntp_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(ntp_Configs)}, \"NTP extra configuration\"))\n                    \n    #Add SNMP server related extra configuration\n    if snmpServer_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(snmpServer_Configs)}, \"SNMP extra configuration\")) \n\n    #Add Netflow related configuration\n    if netflow_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(netflow_Configs)}, \"Netflow configuration\")) \n                    \n    #Add switch freeform for every IPv4/v6 Prefix list\n    for prefixListEntry in prefixListDict:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 5,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(prefixListDict[prefixListEntry])}, prefixListEntry))\n                    \n    #Add Route-map related configuration\n    if routeMap_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 5,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(routeMap_Configs)}, \"Route-map configuration\"))\n\n    #Add vPC Domain related configuration\n    if vpcDomain_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 5,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(vpcDomain_Configs)}, \"vPC Domain configuration\"))\n\n    #Add Vlan configuration related configuration\n    if vlanConfig_Configs and \"aggregation\" in switchRole.lower():\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 5,\n                 \"switch_freeform\", {\"CONF\": Util.newLine().join(vlanConfig_Configs)}, \"VLAN config configuration\"))\n\n    # create the post interface unaccounted config block.. this must show up after the interfaces\n    global_unaccounted_AAA_INTF = []\n    filteredUnaccounted = []\n    if 'GLOBAL_POST_INTF_UNACCTED' in features_info:\n        if features_info[\"GLOBAL_POST_INTF_UNACCTED\"]:\n            global_unaccounted = features_info[\"GLOBAL_POST_INTF_UNACCTED\"][\"unaccounted\"]\n            for line in global_unaccounted:\n                depth = (len(line) - len(line.lstrip(' '))) / 2\n\n                if depth == 0:\n\n                    if isIpSlaBlock:\n                        isIpSlaBlock = False\n\n                    # top level config\n                    skipBlock = False\n                    if line.startswith(\"boot\"):\n                        # these should not be captured in the accounted configs\n                        continue\n                    if line.startswith(\"router ospf \") or line.startswith(\"router ospfv3 \") or line.startswith(\"router isis \"):\n                        if line != underlayProtocolCfgLine:\n                            # the entire configs for these will be obtained from the 'show run' already.. remove from here\n                            skipBlock = True\n                    elif line.startswith(\"ip sla \"):\n                        #Account for all IP SLA configs if present  \n                        ipSla_Configs.append(line)\n                        isIpSlaBlock = True\n                        continue                  \n                    elif line.startswith(\"logging \"):\n                        logging_Configs.append(line)\n                        continue\n\n                if skipBlock:\n                    Wrapper.print(\"underlayProtocolCfgLine: skipping line [%s]\" % line)\n                    continue\n\n                if (line.startswith(\"radius\") or line.startswith(\"tacacs\") or\n                    line.startswith(\"aaa\") or line.startswith(\"  server\")):\n                    global_unaccounted_AAA_INTF.append(line)\n                    continue\n\n                #Take care of child commands for IP SLA if present\n                if isIpSlaBlock:\n                    ipSla_Configs.append(line)\n                    continue\n\n                filteredUnaccounted.append(line)\n\n    postIntfFF = filteredUnaccounted + linkProtoCfgLines + switchOverlayInfo[\"POST_INTF_FF\"]\n    if postIntfFF:\n        # this needs to show up after the interfaces\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.POST_INTF_SWITCH_FF,\n            \"switch_freeform\", {\"CONF\": Util.newLine().join(postIntfFF)}, \"Post Interfaces Configuration\"))\n    switchOverlayInfo[\"POST_INTF_FF\"] = None\n\n    AAA_Configs += global_unaccounted_AAA_INTF\n    AAA_Configs += global_unaccounted_AAA\n    if AAA_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.AAA_SWITCH_FF,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(AAA_Configs)}, \"AAA extra configuration\")) \n\n    #Add IP SLA related configuration\n    if ipSla_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.POST_INTF_SWITCH_FF + 5,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(ipSla_Configs)}, \"IP SLA configuration\"))\n                    \n    #Add logging related extra configuration\n    if logging_Configs:\n        Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.POST_INTF_SWITCH_FF + 10,\n                    \"switch_freeform\", {\"CONF\": Util.newLine().join(logging_Configs)}, \"Logging extra configuration\")) \n                    \n    if isAgg:\n        bgpFF = bgp_unaccounted + switchOverlayInfo[\"BGP_FF\"]\n        \n        if bgpFF:\n            Util.exe(PTIWrapper.create(devSerial, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_UNDERLAY_BOTTOM,\n                        \"switch_freeform\", {\"CONF\": Util.newLine().join(bgpFF)}, \"BGP Configuration\"))\n    switchOverlayInfo[\"BGP_FF\"] = None\n\n    # process leaf/spine specific global configs\n    vpcPairInfo = {}\n    if isAgg:\n        # process agg specific configs\n        createPTI(devSerial, {}, \"base_feature_agg\", \"SWITCH\", getSrc(\"base_feature_agg\"), -1)\n        templateName = \"feature_ospf\" if UNDERLAY_IS_V6 == \"false\" else \"feature_ospfv3\"\n        createMatchedPtis(devSerial, matchResult, templateName)\n        createMatchedPtis(devSerial, matchResult, \"feature_lacp\")\n        createMatchedPtis(devSerial, matchResult, \"feature_pim\")\n        createMatchedPtis(devSerial, matchResult, \"feature_dhcp\")\n        createMatchedPtis(devSerial, matchResult, \"eth_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv4_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv6_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"base_dhcp\")\n\n        # create the extra CLIs PTI (we will not match these from the config)\n        if EXTRA_CONF_LEAF != \"\":\n            createPTI(devSerial, {\"CONF\": EXTRA_CONF_LEAF}, \"extra_config_leaf\",\n                                  \"SWITCH\", \"UNDERLAY\", -1)\n    else:\n        #access role scenario\n        createMatchedPtis(devSerial, matchResult, \"feature_lacp\")\n        createMatchedPtis(devSerial, matchResult, \"eth_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv4_cfs\")\n        createMatchedPtis(devSerial, matchResult, \"ipv6_cfs\")\n\n        # create the extra CLIs PTI (we will not match these from the config)\n        if EXTRA_CONF_TOR != \"\":\n            createPTI(devSerial, {\"CONF\": EXTRA_CONF_TOR}, \"extra_config_tor\",\n                                  \"SWITCH\", \"UNDERLAY\", -1)\n                                  \n    #VPC pairing is mandatory at aggregation layer but optional at access layer                              \n    if isValidVPC:\n        vpcPairInfo[\"domainId\"] = vPCInfo[\"domainId\"]\n\n        createMatchedPtis(devSerial, matchResult, \"vpc_domain_mgmt\")\n        createMatchedPtis(devSerial, matchResult, \"vpc_domain_ipv6_nd_11_1\")\n        peerSerial = getVPCPeerDeviceSN(devSerial, vpcSrcToDstMacMap)\n        if peerSerial:\n            Util.exe(VpcWrapper.create(devSerial, peerSerial))\n\n        vpcPeerLinkPoNvPairs = { \"PO_ID\" : \"\",\n                                 \"NATIVE_VLAN\" : \"\",\n                                 \"DESC\" : \"\",\n                                 \"ALLOWED_VLAN\":\"\",\n                                 \"MEMBER_DESC\":\"\",\n                                 \"ADMIN_STATE\" : \"true\",\n                                 \"MEMBER_INTERFACES\":\"\",\n                                 \"CONF\":\"\"\n                               }\n\n        # lookup the vpc peer link PO\n        vpcMCTPoId = \"\"\n        pcRmId = -1\n        templateName = \"vpc_peer_link_po_interface\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        if (nvPairList != None):\n            # we expect only one nv pair\n            entityType = getEType(templateName)\n            entityName = getEntityName(devSerial, entityType, nvPairList[0], templateName)\n            intfMatchResult = interfacesRes[entityName]\n\n            vpcPeerLinkPoNvPairs.update({\"PO_ID\" : entityName})\n\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(entityName, sys._getframe().f_lineno))\n\n            # set the PO id resource\n            portChannelIntf = entityName.lower()\n            pc, vpcMCTPoId = portChannelIntf.split(\"port-channel\")\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC Peer-Link PO: PORT_CHANNEL_ID [%s]\"%\n                          (FABRIC_NAME, key, vpcMCTPoId))\n            ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, entityName, vpcMCTPoId))\n\n            # get the interface template results to get additional info\n            templateNameMatches = intfMatchResult[\"matched_templates\"]\n            templateList = [\"interface_desc\"]\n            matchingNvPairs = getIntfMatchNvPairs(matchResult, entityName, templateList)\n            if matchingNvPairs:\n                vpcPeerLinkPoNvPairs.update({\"DESC\" : matchingNvPairs[\"interface_desc\"][\"DESC\"]})\n\n            if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                Wrapper.print(\"Device [%s] Found unaccounted cfg for portchannel intf [%s]\" % (devSerial, portChannelIntf))\n\n                # we need to scan and extract the trunk native vlan from the unaccounted config\n                vpcPeerLinkPoNvPairs[\"NATIVE_VLAN\"], updatedFFCfgList = getNativeVlanAndUpdatedUnacctCfgList(\n                                        intfMatchResult[\"unaccounted_cmds\"])\n\n                # set the updated extra config\n                vpcPeerLinkPoNvPairs.update({\"CONF\": Util.newLine().join(updatedFFCfgList)}) \n\n            templateList = [\n                            \"interface_speed\",\n                            \"interface_no_nego_auto\",\n                            \"bpduguard_disable\", \n                            \"bpduguard_enable\", \n                            \"porttype_fast_trunk\",\n                            \"porttype_fast_enable\",\n                            \"access_vlan\",\n                            \"cdp_disable_interface_11_1\"\n                           ]\n\n            configList = unaccCfgFromTemplates(portChannelIntf, templateList, intfMatchResult, matchResult)\n            if vpcPeerLinkPoNvPairs[\"CONF\"] and configList:\n                vpcPeerLinkPoNvPairs[\"CONF\"] = vpcPeerLinkPoNvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                vpcPeerLinkPoNvPairs[\"CONF\"] = Util.newLine().join(configList)\n            Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"% \n                         (devSerial, portChannelIntf, vpcPeerLinkPoNvPairs.get(\"CONF\")))\n\n         # lookup the vpc peer link peer members\n        templateName = \"vpc_peer_link_member_interface\"\n        nvPairList = getTemplateMatchResults(matchResult, templateName)\n        vpcPeerLinkMemberInterfaces = []\n        if (nvPairList != None):\n            for memberNvPair in nvPairList:\n                if (vpcMCTPoId != memberNvPair[\"PCID\"]):\n                    # this interface does not belong to the MCT\n                    continue\n\n                entityType = getEType(templateName)\n                entityName = getEntityName(devSerial, entityType, memberNvPair, templateName)\n                intfMatchResult = interfacesRes[entityName]\n\n                # mark the interface as being processed\n                intfMatchResult.update({\"isProcessed\" : True})\n                Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(entityName, sys._getframe().f_lineno))\n\n                vpcPeerLinkMemberInterfaces.append(entityName)\n            \n                # check to see if we need the peer serial\n                try:\n                    if (vpcPairInfo[\"peerSerialNum\"] != None):\n                        # we have the info already... skip\n                        continue\n                except:\n                    # the 'peerSerialNum' key does not exist.. \n                    peerSerial = topologyDataObj.getNeighborDeviceSN(devSerial, entityName)\n                    if not (peerSerial == \"\" or peerSerial == 0):\n                        # we have a valid peer... check if it's state is complete\n                        if not isSwitchInUnderlayMigration(peerSerial):\n                            # the expected PTIs should be in place\n                            Wrapper.print(\"vPC: peer serial %s\" % peerSerial)\n                            vpcPairInfo.update({\"peerSerialNum\" : peerSerial})\n                        else:\n                            Wrapper.print(\"vPC: Found peer [%s], but, not migrated\" % peerSerial)\n\n            vpcPeerLinkPoNvPairs.update({\"MEMBER_INTERFACES\" : \",\".join(vpcPeerLinkMemberInterfaces)})\n        if vpcPairInfo.get(\"vpcFabricPair\"):\n            peerSerial = getVPCPeerDeviceSN(devSerial, vpcSrcToDstMacMap)\n            if not (peerSerial == \"\" or peerSerial == 0):\n                # we have a valid peer... check if it's state is complete\n                if not isSwitchInUnderlayMigration(peerSerial):\n                    # the expected PTIs should be in place\n                    Wrapper.print(\"vPC: peer serial %s\" % peerSerial)\n                    vpcPairInfo.update({\"peerSerialNum\" : peerSerial})\n                else:\n                    Wrapper.print(\"vPC: Found peer [%s], but, not migrated\" % peerSerial)\n            vpcPeerLinkPoNvPairs.update({\"MEMBER_INTERFACES\" : \"\"})\n            \n        if VPC_PEER_LINK_ALL_VLAN_DISABLE == \"true\":\n            vpcPeerLinkPoNvPairs.update({\"ALLOWED_VLANS\":\"none\"})\n        # we will go ahead and create the vpc peer link PO policy\n        createPTI(devSerial, vpcPeerLinkPoNvPairs, \"int_vpc_peer_link_po\", \n                  vpcPeerLinkPoNvPairs[\"PO_ID\"], \"\", pcRmId)\n        ptiTemplate = \"int_vpc_peer_link_po_member_11_1\"\n        poMemberDescAndFFUpd(devSerial, vpcPeerLinkMemberInterfaces, ptiTemplate, \n                             vpcMCTPoId, matchResult, interfacesRes, portChannelIntf)\n\n        # take care of setting the vPC related resouces in RM\n        # check if we have the peer serial number\n        peerSerial = \"\"\n        try:\n            peerSerial = vpcPairInfo[\"peerSerialNum\"]\n        except:\n            Wrapper.print(\"vPC: peer serial # does not exist.. skip setting up resources\")\n\n        if (peerSerial != \"\"):\n\n            # check that the roles of the two peers are consistent before making them a vpcPair\n            peerSwitchRole = topologyDataObj.getSwitchRole(peerSerial)\n            if switchRole != peerSwitchRole:\n                respObj.addErrorReport(getFabErrEntity(funcName, \"VPC_PAIR_ROLE\"),\n                    \"Inconsistent Role [%s] with vPC Peer switch [%s] Role [%s]. Please set roles correctly and \"\n                    \"retry.\" % (switchRole, getFormattedSwitchName(peerSerial), peerSwitchRole), devSerial)\n                respObj.setFailureRetCode()\n            else:\n                # mark the pair as a vPC\n                Wrapper.print(\"vPC: Marking [%s:%s] a pair\" % (devSerial, peerSerial))\n                if vpcPairInfo.get(\"vpcFabricPair\"):\n                    Util.exe(VpcWrapper.create(devSerial, peerSerial, \"true\"))\n                else:\n                    Util.exe(VpcWrapper.create(devSerial, peerSerial))\n\n                vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n                serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n                if ENABLE_FABRIC_VPC_DOMAIN_ID == \"false\":\n                    # Fabric setting is for unique vpc domain ids.. set the vPC domain ID in RM\n                    Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: vPC: VPC_DOMAIN_ID [%s]\"% \n                                  (FABRIC_NAME, vpcPairSerialKey, vpcPairInfo[\"domainId\"]))\n                    Util.exe(RM.set(FABRIC_NAME, \"VPC_DOMAIN_ID\", vpcPairSerialKey, vpcPairInfo[\"domainId\"]))\n\n                # dummy PTIs to check in easy fabric\n                createPTI(devSerial, {\"VPC_SERIAL\":vpcPairSerialKey}, \"vpc_serial_simulated\", \"SWITCH\", \"\" , -1)\n                createPTI(peerSerial, {\"VPC_SERIAL\":vpcPairSerialKey}, \"vpc_serial_simulated\", \"SWITCH\", \"\" , -1)\n\n    try:\n        ECLdeviceUpgradeIntf(gVarDictObj, matchResult, interfacesRes, isValidVPC, device_overlay_vlans, vpcPairInfo, respObj)\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error during interface migration\" % getFormattedSwitchName(devSerial))\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":INTERFACE_MIGRATION\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n\n    if not respObj.isRetCodeFailure():\n        # create the IFCs\n        createIFCs(dictionaryObj, switchOverlayInfo, interfacesRes, respObj)\n\n    if not respObj.isRetCodeFailure():\n        if (doOverlayMigr and (migrateMode == \"brownAdd\")):\n            # save the switch overlay info to a file\n            writeToFile(dictionaryObj[\"overlayInfoFileName\"], json.dumps(switchOverlayInfo, indent=4, sort_keys=True), respObj)\n\n        takeSwitchOutOfUnderlayMigrMode(FABRIC_NAME, devSerial)\n\n    Wrapper.print(\"%s: Device [%s]. Success = [%r]\" % (funcName, devSerial, respObj.isRetCodeSuccess()))\n    return respObj\n\ndef ECLcheckOspfAuthAndIntfs(devSerial, matchResult, interfacesRes, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    if VRF_LITE_PROTOCOL != \"ospf\":\n        return\n\n    if LINK_STATE_ROUTING_TAG != \"\":\n        nvPairList = getTemplateMatchResults(matchResult, \"base_ospf_auth\")\n        if (nvPairList != None):\n            # there could be multiple OSPF instances.. look for the one matching the fabric setting\n            for nvPair in nvPairList:\n                if nvPair[\"OSPF_TAG\"] == LINK_STATE_ROUTING_TAG:\n                    if nvPair[\"OSPF_AREA_ID\"] != OSPF_AREA_ID:\n                        # OSPF Area Id for the OSPF instance does not match the fabric settings\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                            \"OSPF Message Digest Authentication found for default VRF, but Area Id for OSPF instance [%s] \"\n                            \"does not match the fabric settings. Expected Area Id [%s], default VRF has [%s].\" %\n                            (LINK_STATE_ROUTING_TAG, OSPF_AREA_ID, nvPair[\"OSPF_AREA_ID\"]), devSerial)\n                        respObj.setFailureRetCode()\n                    break\n\n        nvPairList = getTemplateMatchResults(matchResult, \"vrf_ospf_auth\")\n        if (nvPairList != None):\n            # there could be multiple OSPF instances.. look for the one matching the fabric setting\n            for nvPair in nvPairList:\n                if nvPair[\"OSPF_TAG\"] == LINK_STATE_ROUTING_TAG:\n                    if nvPair[\"OSPF_AREA_ID\"] != OSPF_AREA_ID:\n                        # OSPF Area Id for the OSPF instance does not match the fabric settings\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF_AUTH\"),\n                            \"OSPF Message Digest Authentication found for VRF [%s], but Area Id for OSPF instance [%s] \"\n                            \"does not match the fabric settings. Expected Area Id [%s], VRF has [%s].\" %\n                            (nvPair[\"VRF_NAME\"], LINK_STATE_ROUTING_TAG, OSPF_AREA_ID, nvPair[\"OSPF_AREA_ID\"]), devSerial)\n                        respObj.setFailureRetCode()\n\n        for intfName in sorted(interfacesRes.keys()):\n            nvPair = getIntfTemplateNvpair(intfName, \"ospf_interface_11_1\", matchResult)\n            if nvPair:\n                if ((nvPair[\"OSPF_TAG\"] != LINK_STATE_ROUTING_TAG) or (nvPair[\"OSPF_AREA_ID\"] != OSPF_AREA_ID)):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF\"),\n                        \"Interface [%s]: OSPF related configuration mismatch. Found Process ID/Area [%s, %s], Expected [%s, %s]\" %\n                        (intfName, nvPair[\"OSPF_TAG\"], nvPair[\"OSPF_AREA_ID\"], LINK_STATE_ROUTING_TAG, OSPF_AREA_ID), devSerial)\n                    respObj.setFailureRetCode()\n\n    if OSPFv3_ROUTING_TAG != \"\":\n        for intfName in sorted(interfacesRes.keys()):\n            nvPair = getIntfTemplateNvpair(intfName, \"v6_ospf_interface\", matchResult)\n            if nvPair:\n                if ((nvPair[\"OSPF_TAG\"] != OSPFv3_ROUTING_TAG) or (nvPair[\"OSPF_AREA_ID\"] != OSPFv3_AREA_ID)):\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPFv3\"),\n                        \"Interface [%s]: OSPFv3 related configuration mismatch. Found Process ID/Area [%s, %s], Expected [%s, %s]\" %\n                        (intfName, nvPair[\"OSPF_TAG\"], nvPair[\"OSPF_AREA_ID\"], OSPFv3_ROUTING_TAG, OSPFv3_AREA_ID), devSerial)\n                    respObj.setFailureRetCode()\n\ndef ECLfabricUpgrade(gVarDictObj, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    try:\n        dictionaryObj = gVarDictObj[\"DICTIONARY_OBJ\"]\n        devSerial = dictionaryObj[\"deviceSerial\"]\n        topologyDataObj = gVarDictObj[\"topologyObj\"]\n        matchResult = dictionaryObj[\"matchResult\"]\n        interfacesRes = dictionaryObj[\"interfacesRes\"]\n\n        # build a dictionary of the BGP neighbors so that we can validate only BGP related entries that match our AS#.\n        # Note: this will be used in deviceUpgrade\n        bgpNeighborDict = {}\n        dictionaryObj[\"bgpNeighborDict\"] = bgpNeighborDict\n\n        switchRole = dictionaryObj[\"switchRole\"]\n        hostName = dictionaryObj[\"hostName\"]\n        formattedName = dictionaryObj[\"fmtName\"]\n        model = dictionaryObj[\"deviceModel\"]\n\n        Wrapper.print(\"==========ACTION: FAB [%s]: Start: %s: Switch [%s] Model [%s] Role [%s]  isN9KTahoe [%r]\" %\n                (FABRIC_NAME, funcName, formattedName, model, switchRole, (not dictionaryObj[\"n9kIsNotTahoe\"])))\n\n        # port-profiles are not supported... look for them and report error\n        features_info = matchResult[\"FEATURES_INFO\"]\n        global_unaccounted = features_info[\"GLOBAL_UNACCTED\"][\"unaccounted\"]\n        isCdpError = False\n        isPortProfileFound = False\n        for line in global_unaccounted:\n            depth = (len(line) - len(line.lstrip(' '))) / 2\n            if depth == 0:\n                if (line.startswith(\"port-profile\")):\n                    # port-profiles are not supported\n                    isPortProfileFound = True\n                elif ((line == \"no cdp enable\") or (line.startswith(\"cdp format device-id\"))):\n                    # CDP is disabled or system id is not in expected format\n                    isCdpError = True\n\n        if isPortProfileFound:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":PORT_PROFILE\"),\n                \"Port-Profiles are not supported. Please unconfigure all the port-profiles and retry.\",\n                devSerial)\n            respObj.setFailureRetCode()\n\n        if isCdpError:\n            respObj.addErrorReport(getFabErrEntity(funcName, devSerial + \":CDP\"),\n                \"CDP is disabled and/or system id is in unexpected format. Please check documentation \"\n                \" for CDP requirements to update the switch configuration and retry.\", devSerial)\n            respObj.setFailureRetCode()\n\n        vPCInfo = {\"virtualVPC\" : False, \"userPeerLinkVlanPtiId\" : None, \"peerLinkVlan\" : VPC_PEER_LINK_VLAN}\n        vPCInfo[\"hasVpcConfig\"], vPCInfo[\"domainId\"] = getVpcDomainId(devSerial, matchResult)\n        dictionaryObj[\"vpcInfo\"] = vPCInfo\n\n        if vPCInfo[\"domainId\"]:\n            #   - check to make sure we have atleast one match for each of the vPC related templates\n            vpcTemplates = getECLVpcMandatoryTemplateList(dictionaryObj[\"n9kIsNotTahoe\"])\n            for templateName in vpcTemplates:\n                if (getTemplateMatchResults(matchResult, templateName) == None):\n                    # did not find any matches... vPC config is inconsistent\n                    Wrapper.print(\"%s: Switch [%s] Did not find a match for vPC template [%s]\" % (funcName, formattedName, templateName))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC\"),\n                               \"Did not find expected vPC configuration for [%s] template.\" % (templateName), devSerial)\n                    respObj.setFailureRetCode()\n                    isValidVPC = False\n            vPCInfo[\"virtualVPC\"] = False\n        else:\n            if vPCInfo[\"hasVpcConfig\"]:\n                # we did not find the vPC domain config match, report an error\n                templateName = \"base_vpc_domain_11_1\"\n                domainId = \"1000\"\n                if ENABLE_FABRIC_VPC_DOMAIN_ID == \"true\":\n                    domainId = FABRIC_VPC_DOMAIN_ID\n                params = {\"DOMAIN_ID\" : domainId}\n                cfg = ConfigTemplateHandler.getInstance().getPopulatedCommandsNew(templateName, params, False, None)\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":vPC\"),\n                       \"Please ensure the following vPC domain configuration exists: %s%s\" % (Util.newLine(), cfg), devSerial)\n                respObj.setFailureRetCode()\n\n        Wrapper.print(\"%s: Switch [%s] vPC Info [%s]\" % (funcName, formattedName, vPCInfo))\n\n        if switchRole.lower() == \"aggregation\":\n            # check the Fabric Settings for VRF_LITE_PROTOCOL related configured values\n            if VRF_LITE_PROTOCOL == \"ospf\":\n                if LINK_STATE_ROUTING_TAG != \"\":\n                    ospfInstanceNvpair = None\n                    nvPairList = getTemplateMatchResults(matchResult, \"router_ospf\")\n                    if (nvPairList != None):\n                        # there could be multiple OSPF instances.. look for the one matching the fabric setting\n                        for nvPair in nvPairList:\n                            if nvPair[\"OSPF_TAG\"] == LINK_STATE_ROUTING_TAG:\n                                ospfInstanceNvpair = nvPair\n                                break\n\n                    if not ospfInstanceNvpair:\n                        # we did not find the expected OSPF instance\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPF Routing Tag\"),\n                           \"Did not find OSPF instance [%s] that matches the fabric settings. \"\n                           \"Please ensure device has expected configuration of 'router ospf'.\" %\n                           (LINK_STATE_ROUTING_TAG), devSerial)\n                        respObj.setFailureRetCode()\n\n                if OSPFv3_ROUTING_TAG != \"\":\n                    ospfInstanceNvpair = None\n                    nvPairList = getTemplateMatchResults(matchResult, \"router_ospfv3\")\n                    if (nvPairList != None):\n                        # there could be multiple OSPF instances.. look for the one matching the fabric setting\n                        for nvPair in nvPairList:\n                            if nvPair[\"OSPF_TAG\"] == OSPFv3_ROUTING_TAG:\n                                ospfInstanceNvpair = nvPair\n                                break\n\n                    if not ospfInstanceNvpair:\n                        # we did not find the expected OSPFv3 instance\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":OSPFv3 Routing Tag\"),\n                           \"Did not find OSPFv3 instance [%s] that matches the fabric settings. \"\n                           \"Please ensure device has expected configuration of 'router ospfv3'.\" %\n                           (OSPFv3_ROUTING_TAG), devSerial)\n                        respObj.setFailureRetCode()\n            elif VRF_LITE_PROTOCOL == \"ebgp\":\n                # check if the BGP AS # matches the configured value\n                bgpConfigFound = False\n                # use base bgp if router id is there which is optional for vlan fabric\n                nvPairList = getTemplateMatchResults(matchResult, \"base_bgp\")\n                if (nvPairList != None):\n                    bgpConfigFound = True\n                    # we expect only one\n                    switchBgpAs = nvPairList[0][\"BGP_AS\"].strip()\n                    if switchBgpAs != BGP_AS:\n                        Wrapper.print(\"Switch is Aggregation, but no BGP config configured\")\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AS\"),\n                                               \"BGP AS # [%s] on the device is not matching with \"\n                                               \"fabric setting BGP AS # [%s]\" % (switchBgpAs, BGP_AS), devSerial)\n                        respObj.setFailureRetCode()\n                        # proceed to next error check\n                else:\n                    bgpAsUnacc = \"\"\n                    for bgpCmd in features_info[\"BGP_BLOCK\"]:\n                        if \"router bgp \" in bgpCmd:\n                             bgpAsUnacc = bgpCmd.split(\"router bgp \")[1].strip()\n                             break\n                    if bgpAsUnacc != \"\" and bgpAsUnacc != BGP_AS:\n                        Wrapper.print(\"Switch is Aggregation, but no BGP config configured in unaccounted also\")\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AS\"),\n                                               \"BGP AS # [%s] on the device is not matching with \"\n                                               \"fabric setting BGP AS # [%s]\" % (bgpAsUnacc, BGP_AS), devSerial)\n                        respObj.setFailureRetCode()\n                    elif bgpAsUnacc == \"\":\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":BGP_AS\"),\n                                               \"ebgp routing protocol is enabled in fabric settings, \"\n                                               \"please ensure device also has expected bgp configuration\", devSerial)\n                        respObj.setFailureRetCode()\n\n            ECLcheckOspfAuthAndIntfs(devSerial, matchResult, interfacesRes, respObj)\n\n    except Exception as e:\n        msg = (\"Switch [%s]: Unexpected error during configuration consistency check\" % formattedName)\n        if isinstance(e, respObjError):\n            processUpgradeRespObjWithMsg(devSerial + \":CONFIG_CHECK\", msg, respObj, e.value)\n        else:\n            Util.handleException(msg, e, respObj)\n    finally:\n        Wrapper.print(\"==========ACTION: FAB [%s]: Finish: %s: Switch [%s]. Success = [%r]\" % (FABRIC_NAME,\n            funcName, formattedName, respObj.isRetCodeSuccess()))\n        return respObj\n\ndef getMatchResultObjFromGOI(fabricName, deviceSn, globalOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n    Wrapper.print(\"switchDict [%s]\"%(switchDict))\n    matchResult = Util.exe(getJSONFileContents(switchDict[\"matchResultsFileName\"]))\n    return matchResult\n   \n\ndef ECLhandleVlanFF(fabricName, deviceSn, globalOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n    overlayVlansList = switchOverlayInfo[\"OVERLAY_VLANS\"]\n    matchResult = getMatchResultObjFromGOI(fabricName, deviceSn, globalOverlayInfo)\n    Wrapper.print(\"matchResult [%s]\"%(matchResult))\n    if not matchResult:\n        return \n    featuresInfo = matchResult[\"FEATURES_INFO\"]\n\n    globalUnaccounted = featuresInfo[\"GLOBAL_UNACCTED\"][\"unaccounted\"]\n    vlanInfoDict = featuresInfo[\"VLAN_BLOCK\"]\n    Wrapper.print(\"%s: Switch [%s] collecting (%d) Networks/ (%d) Vrfs\" % \n                  (funcName, deviceSn, len(switchOverlayInfo[\"NETWORKS_BY_ID\"]),\n                   len(switchOverlayInfo[\"VRFS_BY_ID\"])))\n    Wrapper.print(\"vlanInfoDict [%s] overlayVlansList [%s]\"%(vlanInfoDict, overlayVlansList))\n    vlanIdFFDict = {}\n    overlayVlansStrList = map(str, overlayVlansList)\n    for vlanIdCmd in vlanInfoDict:\n        #Wrapper.print(\"vlan cmd [%s] \"%(vlanIdCmd))\n        vlanId = vlanIdCmd.lstrip(\"vlan \")\n        vlanCmdsDict = vlanInfoDict.get(vlanIdCmd)\n        #Wrapper.print(\"vlan  [%s] cmdInfoDict %s\"%(vlanId, vlanCmdsDict))\n        unacctdPresent = False\n        if vlanId in overlayVlansStrList:\n            l1 = vlanIdMatchedCmdsList = vlanCmdsDict[\"show_run\"]\n            l2 = vlanIdUnaccCmdsList = vlanCmdsDict[\"unaccounted\"]\n            #Wrapper.print(\"vlan  [%s] vlanIdMatchedCmdsList %s\"%(vlanId, vlanIdMatchedCmdsList))\n            #Wrapper.print(\"vlan  [%s] vlanIdUnaccCmdsList %s\"%(vlanId, vlanIdUnaccCmdsList))\n            isVlanIdBlock = False\n            vlanCmdsListForFF = []\n            pairs = itertools.izip_longest(l1, l2)\n            for (i,j) in pairs:\n                if i == j:\n                    vlanCmdsListForFF.append(i) \n                elif i:\n                    vlanCmdsListForFF.append(i)\n                elif j:\n                    vlanCmdsListForFF.append(j)\n            #Wrapper.print(\"vlanId [%s] vlanCmdsListForFF [%s]\"%(vlanId, vlanCmdsListForFF))\n            if len(vlanCmdsListForFF) < 2:\n                #vlan id command alone is not needed\n                continue\n            vlanIdFFDict[vlanId] = []\n            vlanIdFFList = vlanIdFFDict[vlanId]\n            for line in vlanCmdsListForFF:\n                depth = (len(line) - len(line.lstrip(' '))) / 2\n                if depth == 0:\n                    if isVlanIdBlock:\n                        # we are out of the Vlan configuration block\n                        isVlanIdBlock = False\n                    if line.startswith(\"vlan \"):\n                        vlanIdFFList.append(line)\n                        isVlanIdBlock = True\n                        continue\n                if isVlanIdBlock and line not in vlanIdFFList:\n                    unacctdPresent = True\n                    vlanIdFFList.append(line)\n            Wrapper.print(\"vlan id [%s] vlanIdFFList [%s]\"%(vlanId, vlanIdFFDict[vlanId]))\n    Wrapper.print(\"vlanIdFFDict [%s]\"%(vlanIdFFDict))\n\n    vlanConfigFFDict = {}\n    vlanConfigOverlayFFDict = {}\n    vlanConfigNoOverlayFFDict = {}\n    isVlanConfigBlock = False\n    vlanConfigFFList = []\n    vlanConfigId = \"\"\n    for line in globalUnaccounted:\n        depth = (len(line) - len(line.lstrip(' '))) / 2\n        if depth == 0:\n            if isVlanConfigBlock:\n                # we are out of the Vlan configuration block\n                isVlanConfigBlock = False\n            if line.startswith(\"vlan configuration \"):\n                vlanConfigId = line.lstrip(\"vlan configuration \") \n                #Wrapper.print(\"vlanConfigId [%s]  line [%s]\"%(vlanConfigId, line))\n                if vlanConfigId in overlayVlansStrList:\n                    vlanConfigFFDict = vlanConfigOverlayFFDict \n                else:\n                    vlanConfigFFDict = vlanConfigNoOverlayFFDict \n                vlanConfigFFDict[vlanConfigId] = []\n                vlanConfigFFList = vlanConfigFFDict[vlanConfigId]\n                vlanConfigFFList.append(line)\n                isVlanConfigBlock = True\n                continue\n        if isVlanConfigBlock and vlanConfigId:\n            #Wrapper.print(\"isVlanConfigBlock [%s] vlanConfigId [%s]  line [%s]\"%(isVlanConfigBlock, vlanConfigId, line))\n            vlanConfigFFList = vlanConfigFFDict[vlanConfigId]\n            vlanConfigFFList.append(line)\n            continue\n        Wrapper.print(\"vlanConfigFFList [%s]\"%(vlanConfigFFList))\n    Wrapper.print(\"vlanConfigFFDict [%s]\"%(vlanConfigFFDict)) \n    \n    vlaIdFreeformDict = {} \n    finalFreeformDict = mergeNestedDict(vlanIdFFDict, vlanConfigFFDict)\n\n    Wrapper.print(\"finalFreeformDict [%s]\"%(finalFreeformDict))\n    for vlanId in finalFreeformDict:\n        finalVlanIdFreeform = finalFreeformDict[vlanId]\n        vlanFreeformStr = \"\"\n        if vlanId in overlayVlansStrList and len(finalVlanIdFreeform) == 2:\n            vlanIdFFStr = Util.newLine().join(finalVlanIdFreeform[0])\n            vlanConfigFFStr = Util.newLine().join(finalFreeformDict[vlanId][1])\n            vlanFreeformStr = vlanIdFFStr + Util.newLine() + vlanConfigFFStr\n            Wrapper.print(\"vlanIdFFStr [%s]\"%(vlanIdFFStr))\n            Wrapper.print(\"vlanConfigFFStr [%s]\"%(vlanConfigFFStr))\n        elif len(finalVlanIdFreeform) == 1:\n            # vlan configuration commands are combined with same subcommands\n            vlanFreeformStr = Util.newLine().join(finalVlanIdFreeform[0])\n        Wrapper.print(\"vlanFreeformStr [%s]\"%(vlanFreeformStr))\n        if vlanFreeformStr:\n            ptiDescription = \"Vlan %s extra configuration\"%(vlanId)\n            Util.exe(PTIWrapper.create(deviceSn, \"SWITCH\", \"SWITCH\", \"\", ConfigPriority.CONFIG_PRIO_INTF_PO - 5,\n                    \"switch_freeform\", {\"CONF\": vlanFreeformStr}, ptiDescription))\ndef mergeNestedDict(d1, d2):\n    d = {}\n    for key in set(list(d1.keys()) + list(d2.keys())):\n        try:\n            d.setdefault(key,[]).append(d1[key])        \n        except KeyError:\n            pass\n\n        try:\n            d.setdefault(key,[]).append(d2[key])          \n        except KeyError:\n            pass\n    return d\ndef ECLhandleOverlayMigrationInt(fabricName, devices, globalOverlayInfo, respObj, gVarDictObj, topologyDataObj, vrfSviInstanceValues):\n    funcName = sys._getframe(0).f_code.co_name\n    switchesNeedingOverlayMigration = []\n    borderSwitches = []\n    nonBorderSwitches = []\n    Wrapper.print(\"%s %s: Start - FABRIC [%s] OVERLAY_MODE [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, OVERLAY_MODE))\n\n    # at this point the underlay migration is complete for all switches and we are ready for the overlay migration\n    for deviceSn in devices:\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n\n        # skip access role switches for now\n        if switchDict[\"switchRole\"] == \"access\":\n            Wrapper.print(\"%s %s: handle access switch vlan freeform\"%(fabricName, deviceSn))\n            ECLhandleVlanFF(fabricName, deviceSn, globalOverlayInfo)\n            continue\n  \n        if not isSwitchInOverlayMigration(deviceSn):\n            continue\n        \n        # retrieve the switch overlay info from the file stored during the underlay migration\n        Wrapper.print(\"%s: Switch [%s] - Loading overlay info from file [%s]\" % (funcName, \n            switchDict[\"fmtName\"], switchDict[\"overlayInfoFileName\"]))\n        switchOverlayInfo = Util.exe(getJSONFileContents(switchDict[\"overlayInfoFileName\"]))\n\n        if switchOverlayInfo[\"doOverlayExtn\"] == \"true\":\n            borderSwitches.append(deviceSn)\n        else:\n            nonBorderSwitches.append(deviceSn)\n\n    # make the list such that all the border switches are at the end\n    switchesNeedingOverlayMigration = nonBorderSwitches + borderSwitches\n\n    # dictionary of all VRFs in the fabric. Key is the VRF vni (string)\n    allOverlayVrfs = {}\n\n    # dictionary of all networks in the fabric. Key is the network vni (integer)\n    allOverlayNets = {}\n\n    # process all the networks/vrf on the switches\n    for deviceSn in switchesNeedingOverlayMigration:\n        switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n        switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n\n        Wrapper.print(\"%s: Switch [%s] Role [%s] collecting (%d) Networks/ (%d) Vrfs\" % (funcName,\n            switchDict[\"fmtName\"], switchDict[\"switchRole\"], len(switchOverlayInfo[\"NETWORKS_BY_ID\"]), \n            len(switchOverlayInfo[\"VRFS_BY_ID\"])))\n\n        ECLsetOverlayVrfReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayVrfs)\n        ECLsetOverlayNetReferenceSwitch(fabricName, deviceSn, switchOverlayInfo, allOverlayNets, globalOverlayInfo, respObj)\n\n    profInfo = globalOverlayInfo['cfgProfileInfo']\n    if not profInfo[\"hasCfgProfile\"]:\n        # do some validations\n        #   - the vrfVlanName, maxBgpPaths, maxIbgpPaths must be the same on all switches\n        #   - the network must be L2 or L3 on every leaf switch (no missing SVI)\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", 70, \"Brownfield - Checking Overlay information consistency\") \n        for deviceSn in switchesNeedingOverlayMigration:\n            switchDict = globalOverlayInfo[\"SWITCH_INFO\"][deviceSn]\n            switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n\n            # check all the vrf entries for this switch with the vrf entry we plan to use to create\n            Wrapper.print(\"%s %s: Validating VRF params for switch [%s]\" % (OVERLAY_PREFIX, funcName, switchDict[\"fmtName\"]))\n            for vrfEntry in switchOverlayInfo[\"VRFS_BY_ID\"].values():\n                refVrfEntry = allOverlayVrfs[vrfEntry[\"name\"]]\n                if refVrfEntry[\"refSwitchSerial\"] == deviceSn:\n                    continue\n                refVrfTemplParams = refVrfEntry[\"vrfEntry\"][\"vrfTemplateParams\"]\n                allMatch = True\n                for param in refVrfTemplParams:\n                    if (param in [\"vrfDescription\"]):\n                        continue\n                    if param in vrfEntry[\"vrfTemplateParams\"]:\n                        if not checkOverlayParam(refVrfEntry[\"vrfEntry\"][\"name\"], param, refVrfEntry[\"refSwitchSerial\"], \n                            deviceSn, refVrfTemplParams[param], vrfEntry[\"vrfTemplateParams\"][param], respObj):\n                            allMatch = False\n                if not allMatch:\n                    Wrapper.print(\"%s: Fabric [%s] VRF param mismatch: Switch [%s] Ref [%s] - Params [%s] refVrfTemplParams [%s]\" %\n                        (funcName, FABRIC_NAME, switchDict[\"fmtName\"], refVrfEntry[\"refSwitchSerial\"], vrfEntry[\"vrfTemplateParams\"], refVrfTemplParams))\n\n            # check all the network entries for this switch with the network entry we plan to use to create\n            Wrapper.print(\"%s %s: Validating Network params for switch [%s] [%s]\" % (OVERLAY_PREFIX, funcName, switchDict[\"fmtName\"], allOverlayNets))\n            for netEntry in switchOverlayInfo[\"NETWORKS_BY_ID\"].values():\n                refNetEntry = allOverlayNets[netEntry[\"vlanId\"]]\n                if refNetEntry[\"refSwitchSerial\"] == deviceSn:\n                    continue\n                refNetTemplParams = refNetEntry[\"netEntry\"][\"netTemplateParams\"]\n\n                Wrapper.print(\"%s %s: netEntry[%s] refNetEntry[%s]\" % (funcName, switchDict[\"fmtName\"], netEntry, refNetEntry))\n\n                #\n                #Network should only be present on 2 Agg peers of a given vPC Agg pair\n                #RefEntry will have switch specific fields like pip1, ipv6_pip1, activePriority, intfDescription\n                #These fields from netEntry need to be populated to pip2, ipv6_pip2, standbyPriority, intfDescription2\n                #TODO: Handle various error cases\n                refNetTemplParams[\"pip2\"] = netEntry[\"netTemplateParams\"][\"pip1\"]\n                refNetTemplParams[\"ipv6_pip2\"] = netEntry[\"netTemplateParams\"][\"ipv6_pip1\"]\n                refNetTemplParams[\"standbyPriority\"] = \"100\" if not netEntry[\"netTemplateParams\"][\"activePriority\"] else netEntry[\"netTemplateParams\"][\"activePriority\"]\n                refNetTemplParams[\"intfDescription2\"] = netEntry[\"netTemplateParams\"][\"intfDescription\"]\n                \n \n                allMatch = True\n                for param in refNetTemplParams:\n\n                    if (param in [\"pip1\", \"pip2\", \"ipv6_pip1\", \"ipv6_pip2\", \"activePriority\", \"standbyPriority\", \"intfDescription\", \"intfDescription2\"]):\n                        continue                \n                    \n                    if param in netEntry[\"netTemplateParams\"]:\n                        if not checkOverlayParam(refNetEntry[\"netEntry\"][\"overlayNetName\"], param, refNetEntry[\"refSwitchSerial\"], \n                            deviceSn, refNetTemplParams[param], netEntry[\"netTemplateParams\"][param], respObj):\n                            allMatch = False\n\n                if not allMatch:\n                    Wrapper.print(\"%s: Fabric [%s] Net param mismatch: Switch [%s] Ref [%s] - Params [%s] refNetTemplParams [%s]\" %\n                        (funcName, FABRIC_NAME, switchDict[\"fmtName\"], refNetEntry[\"refSwitchSerial\"], netEntry[\"netTemplateParams\"], refNetTemplParams))\n\n    # do not proceed if there are errors\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    # process the attachments\n    for deviceSn in switchesNeedingOverlayMigration:\n        switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][deviceSn]\n        ECLprocessOverlayAttachments(deviceSn, switchOverlayInfo, globalOverlayInfo, allOverlayNets, topologyDataObj, vrfSviInstanceValues)\n\n\n    isFailure = False\n    \n    sortedVrfs = allOverlayVrfs.keys()\n    sortedNets = allOverlayNets.keys()\n\n    # create the vrfs if they do not exist\n    progressBase = 60\n    numEntries = len(sortedVrfs)\n    numProcessed = 0\n    Wrapper.print(\"%s %s: FABRIC [%s] VRF Creations [Total = %d]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries))\n    for vrf in sortedVrfs:\n        numProcessed += 1\n        progress = progressBase + int(float(numProcessed)/float(numEntries) * 5)\n\n        vrfEntry = allOverlayVrfs[vrf][\"vrfEntry\"]\n        vrfTemplateParams = vrfEntry[\"vrfTemplateParams\"]\n\n        FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Creating VRF [%s/%s]\" % (numProcessed, numEntries, vrf, vrfEntry[\"name\"])))\n\n        Wrapper.print(\"%s: FABRIC [%s]: [%d of %d] Creating TD VRF [%s/%s]. Params [%s]\" % (funcName, \n            FABRIC_NAME, numProcessed, numEntries, vrf, vrfEntry[\"name\"], vrfEntry[\"vrfTemplateParams\"]))\n\n        isDefaultVrf = False\n        # Check the TD DB to see if the VRF has been created already\n        tdVrf = Util.exe(TD.getVrf(FABRIC_NAME, vrf))\n        if tdVrf:\n            tdVrfName = tdVrf.getVrfName()\n            isDefaultVrf = tdVrfName == \"default\"\n            if not isDefaultVrf:\n                # entry exists...\n                Wrapper.print(\"%s: Fabric [%s] Skip Creating Existing TD VRF [%s/%s]\" %\n                          (funcName, FABRIC_NAME, vrf, vrfEntry[\"name\"]))\n                continue\n        updateVrf = False\n        if isDefaultVrf:\n            existingVrfTmptParams = json.loads(tdVrf.getVrfTemplateConfig())\n            bfIpVer = vrfTemplateParams[\"VRF_IP_VERSION\"]\n            existingVrfTmptParams.update({\"VRF_IP_VERSION\":bfIpVer})\n            vrfTemplateParams = existingVrfTmptParams\n            updateVrf = True\n        else:\n            tdVrf = LanVRF()\n            tdVrf.setFabric(FABRIC_NAME)\n            tdVrf.setVrfName(vrfEntry[\"name\"])\n            tdVrf.setVrfTemplate(globalOverlayInfo[\"vrfProfileName\"])\n        #tdVrf.setVrfExtensionTemplate(globalOverlayInfo[\"vrfExtProfileName\"])\n        tdVrf.setVrfTemplateConfig(json.dumps(vrfTemplateParams))\n\n        # create the VRF\n        newResp = TD.createOrUpdateVrf(FABRIC_NAME, tdVrf, updateVrf)\n        if not newResp.isRetCodeSuccess():\n            isFailure = True\n            Util.processRespObj(respObj, newResp)\n\n    if not isFailure:\n        # create the networks if they do not exist\n        progressBase = 65\n        numEntries = len(sortedNets)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: FABRIC [%s] Network Creations [Total = %d]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries))\n        for network in sortedNets:\n            numProcessed += 1\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 5)\n\n            netEntry = allOverlayNets[network][\"netEntry\"]\n            netName = netEntry[\"overlayNetName\"] if netEntry[\"overlayNetName\"] else netEntry[\"cfgProfileName\"]\n\n            #Adding network name to the template param list\n            netEntry[\"netTemplateParams\"][\"networkName\"] = netName\n            \n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Creating Network [%s/%s]\" % (numProcessed, numEntries, network, netName)))\n\n            Wrapper.print(\"%s: FABRIC [%s] [%d of %d] Creating TD Network [%s/%s] Params [%s]\" % (funcName,\n                FABRIC_NAME, numProcessed, numEntries, network, netName, netEntry[\"netTemplateParams\"]))\n\n            # Check the TD DB to see if the network has been created already\n            updateNetwork = False\n            tdNet = Util.exe(TD.getNetwork(FABRIC_NAME, netName))\n            if tdNet:\n                Wrapper.print(\"%s: Fabric [%s] Skip Creating Existing TD Network [%s/%s]\" % (funcName, FABRIC_NAME, network, netName))\n                continue\n\n            tdNet = LanNetwork()\n            tdNet.setFabric(FABRIC_NAME)\n            tdNet.setNetworkName(netName)\n            tdNet.setVrf(netEntry[\"vrfName\"])\n            tdNet.setNetworkTemplate(globalOverlayInfo[\"networkProfileName\"])\n            #tdNet.setNetworkExtensionTemplate(globalOverlayInfo[\"networkExtProfileName\"])\n            tdNet.setNetworkTemplateConfig(json.dumps(netEntry[\"netTemplateParams\"]))\n\n            # create the network\n            newResp = TD.createOrUpdateNetwork(FABRIC_NAME, tdNet, False)\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Util.processRespObj(respObj, newResp)\n\n    Wrapper.print(\"%s: Finished creating VRFs/Networks for FABRIC [%s] isFailure %s\" % (funcName, FABRIC_NAME, isFailure))\n    Wrapper.print(\"%s: VRFs %s Networks %s\" % (funcName, sortedVrfs, sortedNets))\n          \n    if not isFailure:\n        # do the VRF attach as needed\n        progressBase = 70\n        numEntries = len(sortedVrfs)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: Start - FABRIC [%s] Attaching VRFs [Total = %d] %s\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, numEntries, sortedVrfs))\n        for vrf in sortedVrfs:\n            numProcessed += 1\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 10)\n\n            #Skip default VRF attachments\n            #if vrf == DEFAULT_VRF_NAME:\n            #    continue\n              \n            vrfAttach = globalOverlayInfo[\"VRF_ATTACH\"][vrf]\n            vrfName = vrfAttach.getVrfName()\n\n            Wrapper.print(\"%s %s: Fabric [%s] [%d of %d] Attaching VRF [%s/%s] [Attach Count = %d] - Start\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME,\n                numProcessed, numEntries, vrf, vrfName, len(vrfAttach.getLanAttachList())))\n\n            for attachEntry in vrfAttach.getLanAttachList():\n                switchDict = globalOverlayInfo[\"SWITCH_INFO\"][attachEntry.getSerialNumber()]\n                Wrapper.print(\"-----[%s], Name [%s/%s], Vlan [%s], ExtensionVals [%s] InstanceVals [%s] FF [%s]\" % (switchDict[\"fmtName\"],\n                    attachEntry.getVrfName(), attachEntry.getProfileName(), attachEntry.getVlan(), attachEntry.getExtensionValues(),\n                    attachEntry.getInstanceValues(), attachEntry.getFreeformConfig()))\n\n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Attaching VRF [%s]\" % (numProcessed, numEntries, vrfName)))\n\n            newResp = TD.attachVrf(FABRIC_NAME, vrfAttach)\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Wrapper.print(\"%s: Fabric [%s] Attaching VRF [%s] - Failed\" % (funcName, FABRIC_NAME, vrfName))\n                Util.processRespObj(respObj, newResp)\n                continue\n\n            # there could still be a failure on a success return\n            respStr = newResp.getValue()\n            # check if the response contains \"invalid\" references which indicates some issue occured\n            if \"failed\" in respStr.lower():\n                isFailure = True\n                # we have a failure\n                Wrapper.print(\"%s: Fabric [%s] Attaching VRF [%s] - Failed with response [%s]\" %\n                    (funcName, FABRIC_NAME, vrfName, respStr))\n                respObj.addErrorReport(funcName,\n                    \"Error attaching overlay VRF [%s]. Response = [%s]\" % (vrfName, respStr))\n                respObj.setFailureRetCode()\n                continue\n\n        Wrapper.print(\"%s %s: End - FABRIC [%s] Attaching VRFs\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n    if not isFailure:\n        # do the overlay network attach in batches\n        batchInfo = {}\n        count = 0\n        batchIndex = 0\n        netAttachList = []\n        vlanIdList = []\n        for vlanId in sortedNets:\n            netAttachList.append(globalOverlayInfo[\"NETWORK_ATTACH\"][vlanId])\n            vlanIdList.append(vlanId)\n            count += 1\n            if count >= BF_NETWORK_ATTACH_BATCH_SIZE:\n                batchIndex += 1\n                batchInfo[batchIndex] = {\"vlanIdList\": vlanIdList, \"netAttachList\" : netAttachList}\n                Wrapper.print(\"%s %s: Added Batches %d. Num %d\" % (OVERLAY_PREFIX, funcName, batchIndex, len(netAttachList)))\n\n                # start a new batch\n                count = 0\n                netAttachList = []\n                vlanIdList = []\n\n        if len(netAttachList):\n            batchIndex += 1\n            batchInfo[batchIndex] = {\"vlanIdList\": vlanIdList, \"netAttachList\" : netAttachList}\n            Wrapper.print(\"%s %s: Added Batches %d. Num %d\" % (OVERLAY_PREFIX, funcName, batchIndex, len(netAttachList)))\n        netAttachList = None\n        vlanIdList = None\n\n        sortedBatchIndices = sorted(batchInfo)\n        # range is 80 - 95\n        progressBase = 80\n        numEntries = len(sortedNets)\n        numProcessed = 0\n        Wrapper.print(\"%s %s: Start - Fabric [%s] Attaching Networks [Total Entries %d, Batches = %d]\" % (OVERLAY_PREFIX, funcName,\n                                                FABRIC_NAME, numEntries, len(sortedBatchIndices)))\n\n        for index in sortedBatchIndices:\n            netAttachList = batchInfo[index][\"netAttachList\"]\n\n            numProcessed += len(netAttachList)\n            progress = progressBase + int(float(numProcessed)/float(numEntries) * 15)\n\n            FabricWrapper.sendProgress(FABRIC_NAME, \"configSave\", progress,\n                (\"Brownfield - %d of %d - Attaching Networks\" % (numProcessed, numEntries)))\n            \n            Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - Start - Networks (%d) %s\" % (OVERLAY_PREFIX, funcName,\n                                FABRIC_NAME, len(batchInfo[index][\"vlanIdList\"]), batchInfo[index][\"vlanIdList\"]))\n\n            # print the attachment details for this batch\n            Wrapper.print(\"%s %s: Fabric [%s] ===  Network Attachment Entries - Start ===\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n            for netAttach in netAttachList:\n                Wrapper.print(\"%s %s: Fabric [%s] Network [%s] Num Attachments [%d]\" % (OVERLAY_PREFIX, funcName,\n                                    FABRIC_NAME, netAttach.getNetworkName(), len(netAttach.getLanAttachList())))\n\n                printNetAttachList(FABRIC_NAME, globalOverlayInfo, netAttach.getLanAttachList())\n                \n            Wrapper.print(\"%s %s: Fabric [%s] ===  Network Attachment Entries - End ===\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n            newResp = TD.attachNetworks(FABRIC_NAME, netAttachList, False)\n            Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - End - isSuccess [%r]\" % (OVERLAY_PREFIX, funcName,\n                                FABRIC_NAME, newResp.isRetCodeSuccess()))\n            if not newResp.isRetCodeSuccess():\n                isFailure = True\n                Wrapper.print(\"%s: Fabric [%s] Attaching network failed for VNIs %s\" % (funcName, fabricName, batchInfo[index][\"vniList\"]))\n                Util.processRespObj(respObj, newResp)\n                continue\n\n            # check the return value\n            respDict = json.loads(newResp.getValue())\n            Wrapper.print(\"%s %s: Fabric [%s] Network Attach Batch - Networks %s\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, batchInfo[index][\"vlanIdList\"]))\n            for netIdKey in respDict:\n                Wrapper.print(\"Entry: [%-30s] -> [%s]\" % (netIdKey, respDict[netIdKey]))\n                statusStr = str(respDict[netIdKey])\n                if not statusStr.lower().startswith(\"success\"):\n                    isFailure = True\n                    msg = (\"%s: Fabric [%s] Network attachment [%s] failed with reason [%s]\" % (funcName,\n                                                fabricName, netIdKey, respDict[netIdKey]))\n                    Wrapper.print(msg)\n                    respObj.addErrorReport(getFabErrEntity(funcName, netIdKey+\":netAttach\"), msg)\n                    respObj.setFailureRetCode()\n                    continue\n\n        Wrapper.print(\"%s %s: End - Fabric [%s] Attaching Networks\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME))\n\n    Wrapper.print(\"%s %s: End - FABRIC [%s]. retcode [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, respObj.isRetCodeSuccess()))\n    return respObj\n\ndef ECLgetNetworkSviParams(interfacesRes, sviName, netEntry, switchOverlayInfo, overlayVrfMisconfigList, errDetectionDict, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n    devSerial = switchOverlayInfo[\"SERIAL\"]\n    switchRole = switchOverlayInfo[\"switchRole\"]\n\n    intfMatchResult = interfacesRes.get(sviName)\n    Wrapper.print(\"%s: Switch [%s] Role [%s] SVI [%s] Exists [%r] doOverlayExtn [%s]\" %\n            (funcName, devSerial, switchRole, sviName, (True if intfMatchResult else False), switchOverlayInfo[\"doOverlayExtn\"]))\n    #This is a layer-2 only network, so by default corresponds to a topdown vlan        \n    if intfMatchResult == None:\n        return True\n\n    #TODO: key and value are both vrfName\n    overlayVrfsNameToVrfName = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    #Key is vrfName, value is vrfEntry\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n   \n    netTemplateParams = netEntry[\"netTemplateParams\"]\n\n    #Assume default vrf by default for the SVI\n    vrfName = \"default\"\n\n    params = {}\n\n    # SVI exists.. need to check further\n    #   - must be enabled with FHRP as per fabric settings\n    #   - can belong to default or non-default VRF\n   \n    isValidFHRPSvi = False\n    dhcpServerList = []\n    ipAddrSecCount = 1\n    ip_addr_prefix_str = []\n    ipv6_addr_prefix_str = []\n    other_fhrp_subcmds = []\n    other_fhrpv6_subcmds = []\n    cur_fhrp_top_cli = \"\"\n    cur_fhrpv6_top_cli = \"\"\n    intf_unaccounted_cmds = intfMatchResult[\"unaccounted_cmds\"]\n    v4_fhrp_priority_cmd = None\n    v4_fhrp_priority = None\n    v6_fhrp_priority_cmd = None\n    v6_fhrp_priority = None\n\n    #Init ignorePriority to false as its the default value\n    params['ignorePriority'] = \"false\"\n    #VRRP shutdown is a default command that doesnt show up in show run. No shutdown shows up in show run.\n    if \"vrrp\" in FHRP_PROTOCOL:\n        if FHRP_PROTOCOL == \"vrrp\":\n            params['VRRP_ENABLE'] = \"false\"\n        else:\n            #VRRPv3 has a different default compared to vrrp wrt show run/show run all behavior\n            params['VRRP_ENABLE'] = \"true\"\n        #preempt is default with vrrp so it shows up in show run all and not show run\n        params[\"preempt\"]  = \"true\"\n    else:\n        #HSRP case, no preempt is default and shows up in show run all and not show run \n        params[\"preempt\"]  = \"false\"\n\n    '''\n    #Check whether this SVI corresponds to a VLAN that qualifies as a top down VLAN\n    if FHRP_PROTOCOL not in intfMatchResult[\"show_run_cmds\"]:\n        Wrapper.print(\"%s: Switch [%s] Role [%s] SVI [%s] does not correspond to a top-down VLAN\" % (funcName, devSerial, switchRole, sviName))      \n        return False\n    '''\n    \n    for line in intfMatchResult[\"show_run_cmds\"]:\n        orig_cmd = line\n        line = line.rstrip()\n        depth = (len(line) - len(line.lstrip(' '))) / 2\n        cmd = line.strip()\n        tokens = cmd.split()\n        if depth == 1:\n            # look for the expected top level commands\n            if cmd.startswith('vrf member '):\n                vrfName = tokens[2]\n                if vrfName.lower() not in overlayVrfsNameToVrfName:\n                    # invalid vrf??\n                    Wrapper.print(\"%s: ERROR - SVI [%s] Belongs to non-existent VRF [%s]\" % (funcName, sviName, vrfName))\n                    # check to ensure we report the error for the vrf only once\n                    if vrfName not in overlayVrfMisconfigList:\n                        isValidFHRPSvi = False\n                        overlayVrfMisconfigList.append(vrfName)\n                        respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"),\n                           \"Possible missing configuration(s) for Overlay VRF [%s]. Please resolve and retry Recalculate & Deploy\" %\n                           (vrfName), devSerial)\n                        respObj.setFailureRetCode()\n                    return\n            elif cmd.startswith('hsrp version '):\n                params['HSRP_VERSION'] = tokens[2]\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]\n            elif cmd.startswith('hsrp ') and tokens[1].isnumeric():\n                if FHRP_PROTOCOL != \"hsrp\":\n                    errorMsg = (\"Switch has hsrp configuration in SVI [%s], but First Hop Redundancy Protocol (FHRP) in Fabric Settings is set to [%s]. <br>\"\n                                \"Please select the appropriate FHRP protocol or change switch configuration accordingly and retry Recalculate & Deploy.\"%(sviName, FHRP_PROTOCOL))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"), errorMsg, devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                if \"ipv6\" in cmd:\n                    context = \"hsrpv6\"\n                    cur_fhrpv6_top_cli = orig_cmd\n                    params['GROUP_V6'] = tokens[1]\n                    if 'GROUP' not in params:\n                        params['GROUP'] = tokens[1]\n                else:\n                    context = \"hsrpv4\"\n                    cur_fhrp_top_cli = orig_cmd\n                    params['GROUP'] = tokens[1]\n                isValidFHRPSvi = True\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]\n            elif cmd.startswith('vrrp ') and tokens[1].isnumeric():\n                if FHRP_PROTOCOL != \"vrrp\":\n                    errorMsg = (\"Switch has vrrp configuration in SVI [%s], but First Hop Redundancy Protocol (FHRP) in Fabric Settings is set to [%s]. <br>\"\n                                \"Please select the appropriate FHRP protocol or change switch configuration accordingly and retry Recalculate & Deploy.\"%(sviName, FHRP_PROTOCOL))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"), errorMsg, devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                context = \"vrrpv4\"\n                isValidFHRPSvi = True\n                cur_fhrp_top_cli = orig_cmd\n                params['GROUP'] = tokens[1]\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]\n            elif cmd.startswith('vrrpv3 ') and tokens[1].isnumeric():\n                if FHRP_PROTOCOL != \"vrrp3\":\n                    errorMsg = (\"Switch has vrrp3 configuration in SVI [%s], but First Hop Redundancy Protocol (FHRP) in Fabric Settings is set to [%s]. <br>\"\n                                \"Please select the appropriate FHRP protocol or change switch configuration accordingly and retry Recalculate & Deploy.\"%(sviName, FHRP_PROTOCOL))\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"), errorMsg, devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                if \"ipv6\" in cmd:\n                    context = \"vrrpv6\"\n                    cur_fhrpv6_top_cli = orig_cmd\n                    params['GROUP_V6'] = tokens[1]\n                    if 'GROUP' not in params:\n                        params['GROUP'] = tokens[1]\n                else:\n                    context = \"vrrpv4\"\n                    cur_fhrp_top_cli = orig_cmd\n                    params['GROUP'] = tokens[1]\n                isValidFHRPSvi = True\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]                       \n            elif cmd.startswith('ip address '):\n                #If there are secondary IPv4 addresses under this SVI so let it go to interface freeform\n                if \"secondary\" not in cmd:\n                    # primary IPv4 address with prefix\n                    ip_addr_prefix_str = tokens[2].split(\"/\")\n                    params['pip1'] = ip_addr_prefix_str[0]\n                    if \"tag\" in cmd:\n                        params['tag'] = tokens[4]\n                else:\n                    #needs to generate freeform intent for this additional v6 address\n                    intfMatchResult[\"unaccounted_cmds\"].append(line)\n                    continue        \n            elif cmd.startswith('ipv6 address '):\n                #If there are additional IPv6 addresses under this SVI so let it go to interface freeform\n                if 'ipv6_pip1' not in params:\n                    ipv6_addr_prefix_str = tokens[2].split(\"/\")\n                    params['ipv6_pip1'] = ipv6_addr_prefix_str[0]\n                    if \"tag\" in cmd:\n                        params['tag'] = tokens[4]\n                else:\n                    #needs to generate freeform intent for this additional v6 address\n                    intfMatchResult[\"unaccounted_cmds\"].append(line)\n                    continue\n            elif cmd.startswith('ip ospf message-digest-key '):\n                if VRF_LITE_PROTOCOL != \"ospf\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"),\n                       \"OSPF Authentication Key found on SVI [%s], but VRF-Lite Routing Protocol is not ospf\" %\n                       (sviName), devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                params['VRF_LITE_PROTOCOL'] = \"ospf\"\n                params['OSPF_AUTH_ENABLE'] = \"true\"\n                params['OSPF_AUTH_KEY_ID'] = tokens[3]\n                params['OSPF_AUTH_KEY'] = tokens[6]\n            elif cmd.startswith('ip ospf passive-interface'):\n                if VRF_LITE_PROTOCOL != \"ospf\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"),\n                       \"OSPF Passive Interface found on SVI [%s], but VRF-Lite Routing Protocol is not ospf\" %\n                       (sviName), devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                params['VRF_LITE_PROTOCOL'] = \"ospf\"\n                params['enableOspfPassive'] = \"true\"\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]\n            elif cmd.startswith('ospfv3 passive-interface'):\n                if VRF_LITE_PROTOCOL != \"ospf\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":Network\"),\n                       \"OSPFv3 Passive Interface found on SVI [%s], but VRF-Lite Routing Protocol is not ospf\" %\n                       (sviName), devSerial)\n                    respObj.setFailureRetCode()\n                    return\n                params['VRF_LITE_PROTOCOL'] = \"ospf\"\n                params['enableOspfv3Passive'] = \"true\"\n                if orig_cmd in intf_unaccounted_cmds:\n                    index = intf_unaccounted_cmds.index(orig_cmd)\n                    del intf_unaccounted_cmds[index]\n            elif cmd.startswith('ip dhcp relay address ') or cmd.startswith('ipv6 dhcp relay address '):\n                if len(dhcpServerList) >= NET_PROFILE_DHCP_SERVERS_MAX:\n                    intfMatchResult[\"unaccounted_cmds\"].append(line)\n                    continue\n                dhcpServerList.append({\"srvrAddr\" : tokens[4], \"srvrVrf\" : (tokens[6] if (\"use-vrf\" in cmd) else \"\")})\n            elif cmd.startswith('ip flow monitor ') and cmd.endswith('input'):\n                params['ENABLE_NETFLOW'] = \"true\"\n                params['SVI_NETFLOW_MONITOR'] = tokens[3]                \n            elif cmd.startswith('description '):\n                params['intfDescription'] = cmd[len('description '):]\n            elif cmd.startswith('mtu '):\n                params['mtu'] = cmd[len('mtu '):]\n        elif depth == 2:\n            if \"hsrp\" in context or \"vrrp\" in context:\n                if cmd.startswith('ip ') and context == \"hsrpv4\" and 'gatewayIpAddress' not in params and len(ip_addr_prefix_str) == 2:\n                    params['gatewayIpAddress'] = tokens[1] + \"/\" + ip_addr_prefix_str[1]\n                elif cmd.startswith('ip ') and isValidV6IpAddr(tokens[1]) and context == \"hsrpv6\" and 'gatewayIpV6Address' not in params and len(ipv6_addr_prefix_str) == 2:\n                    #There is another command that starts with 'ip': ip autoconfig\n\n                    #Check VIP and parent v6_pip are in the same subnet\n                    if getV6NetworkFromCIDR(tokens[1], ipv6_addr_prefix_str[1]) == getV6NetworkFromCIDR(ipv6_addr_prefix_str[0], ipv6_addr_prefix_str[1]):\n                        #v6 VIP is in the same subnet as the v6 primary address\n                        params['gatewayIpV6Address'] = tokens[1] + \"/\" + ipv6_addr_prefix_str[1]\n                    else:    \n                        #FHRP v6 VIP config should go into freeform \n                        other_fhrpv6_subcmds.append(orig_cmd)\n                elif cmd.startswith('address ') and context == \"vrrpv4\" and 'gatewayIpAddress' not in params and len(ip_addr_prefix_str) == 2:\n                    if FHRP_PROTOCOL == \"vrrpv3\":\n                        if \"primary\" in cmd:\n                            params['gatewayIpAddress'] = tokens[1] + \"/\" + ip_addr_prefix_str[1]\n                    else:\n                        params['gatewayIpAddress'] = tokens[1] + \"/\" + ip_addr_prefix_str[1]\n                    #These must be additional IPv4 secondary addresses\n                    if \"secondary\" in cmd:\n                        other_fhrp_subcmds.append(orig_cmd)\n                elif cmd.startswith('address ') and context == \"vrrpv6\" and len(ipv6_addr_prefix_str) == 2:\n                    if \"primary\" not in cmd:\n                        if 'gatewayIpV6Address' not in params:\n                            params['gatewayIpV6Address'] = tokens[1] + \"/\" + ipv6_addr_prefix_str[1]\n                        else:\n                            #These must be additional IPv6 addresses\n                            other_fhrpv6_subcmds.append(orig_cmd)\n                    else:\n                        params['ipv6_linklocal_vip'] = tokens[1]\n                elif cmd.startswith('preempt') and len(tokens) < 2:\n                    params['preempt'] = \"true\"\n                elif cmd.startswith('no preempt'):\n                    params['preempt'] = \"false\"                    \n                elif cmd.startswith(\"priority\"):\n                    if len(tokens) < 3 and params['ignorePriority'] != \"true\":\n                        #Depending on group id, either v4 or v6 fhrp commands may appear first. Lower group id comes first in show run.\n                        params['activePriority'] = tokens[1]\n                        if context == \"hsrpv4\" or context == \"vrrpv4\":\n                            #Store v4 priority cmd to use in case v6 fhrp has a custom priority\n                            v4_fhrp_priority_cmd = orig_cmd\n                            #Store v4 priority to compare it later with v6 priority. If mismatch detected, both should go to freeform\n                            v4_fhrp_priority = params['activePriority']\n                            \n                            #Check if v4 and v6 fhrp priorities are matching\n                            if v6_fhrp_priority and v6_fhrp_priority != params['activePriority']:\n                                #priority will need to go into freeform\n                                params['ignorePriority'] = \"true\"\n                                other_fhrp_subcmds.append(orig_cmd)\n                                if v6_fhrp_priority_cmd:\n                                    other_fhrpv6_subcmds.append(v6_fhrp_priority_cmd)\n                        else:\n                            #Store v6 priority cmd to use in case v4 fhrp has a custom priority\n                            v6_fhrp_priority_cmd = orig_cmd\n                            #Store v6 priority to compare it later with v4 priority. If mismatch detected, both should go to freeform\n                            v6_fhrp_priority = params['activePriority']\n                            \n                            #Check if v4 and v6 fhrp priorities are matching\n                            if v4_fhrp_priority and v4_fhrp_priority != params['activePriority']:\n                                #priority will need to go into freeform\n                                params['ignorePriority'] = \"true\"\n                                other_fhrpv6_subcmds.append(orig_cmd)\n                                if v4_fhrp_priority_cmd:\n                                    other_fhrp_subcmds.append(v4_fhrp_priority_cmd)\n                    else:\n                        #this means there is a custom priority command\n                        params['ignorePriority'] = \"true\"\n                        if context == \"hsrpv4\" or context == \"vrrpv4\":\n                            #Handle custom priority command under hsrp/vrrp sub mode for v4 scenarios\n                            other_fhrp_subcmds.append(orig_cmd)\n                            if v6_fhrp_priority_cmd:\n                                other_fhrpv6_subcmds.append(v6_fhrp_priority_cmd)\n                        else:\n                            #Handle custom priority command under hsrp/vrrp sub mode for v6 scenarios\n                            other_fhrpv6_subcmds.append(orig_cmd)\n                            if v4_fhrp_priority_cmd:\n                                other_fhrp_subcmds.append(v4_fhrp_priority_cmd)\n                                \n                elif cmd.startswith(\"mac-address\"):\n                    params['mac'] = tokens[1]\n                elif \"no shutdown\" in cmd:\n                    params['VRRP_ENABLE'] = \"true\"\n                else:\n                    if context == \"hsrpv4\" or context == \"vrrpv4\":\n                        if not cmd.startswith(\"exit\"):\n                            #Handle other unmatched commands under hsrp/vrrp sub mode for v4 scenarios\n                            other_fhrp_subcmds.append(orig_cmd)\n                    else:\n                        if not cmd.startswith(\"exit\"):\n                            #Handle other unmatched commands under hsrp/vrrp sub mode for v6 scenarios\n                            other_fhrpv6_subcmds.append(orig_cmd)\n                        \n            if orig_cmd in intf_unaccounted_cmds:\n                index = intf_unaccounted_cmds.index(orig_cmd)\n                del intf_unaccounted_cmds[index]\n\n    if isValidFHRPSvi:\n        if vrfName == \"\":\n            return False\n\n        params[\"vrfName\"] = vrfName\n        params[NET_PROFILE_DHCP_SERVERS_VAR] = buildOverlayNetDhcpStructString(dhcpServerList, vrfName)\n        errDetectionDict.update({sviName:{\"params\":params}})\n        \n        #this means no priority was configured under fhrp\n        if \"activePriority\" not in params:\n            params['ignorePriority'] = \"true\"\n            \n        # move the params to the network template params\n        for paramName in params.keys():\n            netTemplateParams[paramName] = params[paramName]\n\n        netEntry[\"vrfName\"] = netTemplateParams[\"vrfName\"]\n        netTemplateParams[\"isLayer2Only\"] = \"false\"\n\n        # add this network to the VRF network membership list\n        overlayVrfsInfoById[vrfName][\"networks\"].append(str(netEntry[\"vlanId\"]))\n\n        if len(other_fhrp_subcmds) > 0:\n            intf_unaccounted_cmds.append(cur_fhrp_top_cli)\n            intf_unaccounted_cmds = intf_unaccounted_cmds + other_fhrp_subcmds\n        if len(other_fhrpv6_subcmds) > 0:\n            intf_unaccounted_cmds.append(cur_fhrpv6_top_cli)\n            intf_unaccounted_cmds = intf_unaccounted_cmds + other_fhrpv6_subcmds            \n        intfMatchResult[\"unaccounted_cmds\"] = intf_unaccounted_cmds\n        Wrapper.print(\"%s: Switch [%s] Role [%s] SVI [%s] intf_unaccounted_cmds %s other_fhrp_subcmds %s other_fhrpv6_subcmds %s\" %\n            (funcName, devSerial, switchRole, sviName, intf_unaccounted_cmds, other_fhrp_subcmds, other_fhrpv6_subcmds))\n            \n        return True\n    else:\n        return False  \n        \ndef ECLgatherNwkVrfInfo(topologyDataObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, \n                        switchOverlayInfo, migrateMode, device_overlay_vlans, respObj, dcnmUser):\n    funcName = sys._getframe(0).f_code.co_name\n    switchInfo = globalOverlayInfo[\"SWITCH_INFO\"][devSerial]\n    role = switchInfo['switchRole']\n    formattedName = switchInfo[\"fmtName\"]\n    vPCInfo = switchInfo[\"vpcInfo\"]\n\n    Wrapper.print(\"%s %s: Start - FABRIC [%s] Switch [%s] Role [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, formattedName, role))\n\n    # get a list of all vlans on the switch\n    vlanMatchRes = matchResults[\"FEATURES_INFO\"][\"VLAN_BLOCK\"]\n    for vlanStr in vlanMatchRes.keys():\n        vlanListStr = vlanStr[5:]\n        vlanList = Util.getIntegerRange(vlanListStr)\n        isMultiVlans = False\n        if len(vlanMatchRes) == 1:\n            # we have a single entry....this has to be set of all vlans on switch\n            isMultiVlans = True\n        else:\n            if len(vlanList) > 1:\n                # this has to be set of multiple vlans on switch\n                isMultiVlans = True\n        if isMultiVlans:\n            switchOverlayInfo[\"ALL_VLANS\"].extend(vlanList)\n\n    utilObj = Util()\n    allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n\n    numVlans = len(switchOverlayInfo[\"ALL_VLANS\"])\n    Wrapper.print(\"%s: Switch [%s] Role [%s] migrateMode [%s]  Vlans (%d)[%s]\" % (funcName,\n        formattedName, role, migrateMode, numVlans, allVlansOnSwitchStr))\n\n    hasCfgProfiles = False\n    Wrapper.print(\"%s: Switch [%s] hasCfgProfiles [%r] All Vlans = [%d] [%s]\" % (funcName, formattedName, \n        hasCfgProfiles, len(switchOverlayInfo[\"ALL_VLANS\"]), switchOverlayInfo[\"ALL_VLANS\"]))\n        \n    vrfEntries = []\n    if role.lower() == \"aggregation\":\n        #Get a list of all VRFs from the switch\n        sshObj = None\n        newRespObj = WrappersResp.getRespObj()\n        newRespObj.setSuccessRetCode()\n        try:\n            sshObj = Util.exe(getOptSSHConnection(FABRIC_NAME, devSerial, dcnmUser))\n        except Exception as e:\n            Wrapper.print(\"PDM: Failed to get SSH connection for : [%s] [%s]. Will skip\" % (devSerial, str(e)))\n            respObj.addErrorReport(getFabErrEntity(\"PDM\", devSerial+\":SSH\"),\n                                  \"Failed to get SSH connection. \"\n                                  \"Please ensure LAN credentials and retry Recalculate & Deploy\", devSerial)\n            respObj.setFailureRetCode()\n        \n        shVrfJson = getSwitchCmdJsonOutput(sshObj, devSerial, \"show vrf | json\", newRespObj)\n    \n        if not newRespObj.isRetCodeSuccess():\n            Util.processRespObj(respObj, newRespObj)\n            return respObj    \n        sshObj.close()\n        sshObj = None    \n    \n        if (((shVrfJson is None) or (shVrfJson == \"\")) or \n            (\"TABLE_vrf\" not in shVrfJson)):\n            # something is wrong.. respObj must have the required error\n            Wrapper.print(\"%s: Switch [%s]: did not find any VRFs Overlays on switch\" % (funcName, formattedName))\n            return\n    \n        if not isinstance(shVrfJson[\"TABLE_vrf\"][\"ROW_vrf\"], list):\n            # this is a single entry.. make a list\n            vrfRows = [shVrfJson[\"TABLE_vrf\"][\"ROW_vrf\"]]\n        else:\n            # this is a list already!\n            vrfRows = shVrfJson[\"TABLE_vrf\"][\"ROW_vrf\"]\n    \n        Wrapper.print(\"%s: Switch [%s] vrfRows %s\" % (funcName, formattedName, vrfRows))\n        for vrfRow in vrfRows:\n            vrfStr = vrfRow[\"vrf_name\"]\n            #Special VRFs should be treated as non top down VRFs\n            if vrfStr == MGMT_VRF_NAME or vrfStr == EGRESS_LB_VRF:\n                continue\n    \n            vrfEntries.append(vrfRow)\n    \n    switchHasOverlays = True\n\n    #TODO:Handle upgrade later\n    if migrateMode == \"upgrade\":\n        switchOverlayInfo[\"OVERLAY_VLANS\"] = getAllTopDownVlans(devSerial, device_overlay_vlans)\n    elif migrateMode == \"brownAdd\":\n        if switchHasOverlays:\n            profInfo = globalOverlayInfo['cfgProfileInfo']\n            if profInfo[\"hasCfgProfile\"] == None:\n                # set the cfg profile status since this is the first time\n                profInfo[\"hasCfgProfile\"] = hasCfgProfiles\n                profInfo[\"refSwitch\"] = devSerial\n\n            Wrapper.print(\"%s: Switch [%s] cfgProfileInfo [%s]\" % (funcName, formattedName, profInfo))\n\n            ECLgatherCliNwkVrfs(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, switchOverlayInfo, vrfEntries)\n\n    if respObj.isRetCodeFailure():\n        return respObj\n\n    overlayVrfsNameToVni = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n    overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n    utilObj = Util()\n    allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n    overlayVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"OVERLAY_VLANS\"])\n\n    Wrapper.print(\"%s: Switch [%s] ALL_VLANS = [%d][%s] OVERLAY_VLANS = [%d][%s]\" %  (funcName, formattedName,\n            len(switchOverlayInfo[\"ALL_VLANS\"]), allVlansOnSwitchStr, \n            len(switchOverlayInfo[\"OVERLAY_VLANS\"]), overlayVlansOnSwitchStr))\n\n    localVlans = list(set(switchOverlayInfo[\"ALL_VLANS\"]) - set(switchOverlayInfo[\"OVERLAY_VLANS\"]))\n\n    Wrapper.print(\"%s: Switch [%s] local vlans = [%d][%s]\" % (funcName, formattedName, len(localVlans), localVlans))\n\n    # Process local SVIs in deviceUpgradeIntf() if the SVI vlan is in the vlan list\n    # Otherwise, put the local SVI configs into the FF\n    # Remove SVI vlans from the \"vlan xxx\" list as these vlans will be included in int_vlan\n    freeformSVICfg = []\n    updatedVlanList = copy.copy(localVlans)\n    for intfName in sorted(interfacesRes.keys()):\n        if not intfName.lower().startswith(\"vlan\"):\n            # not an SVI\n            continue\n\n        intfMatchResult = interfacesRes[intfName]\n\n        vlanIdStr = intfName[4:]\n        vlanId = int(vlanIdStr)\n        if (vlanId in switchOverlayInfo[\"OVERLAY_VLANS\"]):\n            # skip the overlay SVI, the VPC peer link vlan\n            intfMatchResult.update({\"isProcessed\" : True})\n            continue\n\n        if ((vlanId in switchOverlayInfo[\"ALL_VLANS\"]) and (vlanId != 1)):\n            Wrapper.print(\"%s: SVI vlan [%d] \" % (funcName, vlanId))\n            # remove the SVI vlan as the vlan will be included in int_vlan\n            updatedVlanList.remove(vlanId)\n\n        if isIntfProcessed(intfMatchResult):\n            continue\n\n        if ((vlanId not in switchOverlayInfo[\"ALL_VLANS\"]) or (vlanId == 1)):\n            Wrapper.print(\"%s: Local SVI [%s] that has no vlan config\" % (funcName, intfName))\n            freeformSVICfg.append(\"interface %s\" % intfName)\n            freeformSVICfg += intfMatchResult[\"show_run_cmds\"]\n            intfMatchResult.update({\"isProcessed\" : True})\n\n    Wrapper.print(\"%s: Switch [%s] updated local vlan list = [%d][%s]\" %\n                  (funcName, formattedName, len(updatedVlanList), updatedVlanList))\n\n    # build the toplevel vlan xxx config\n    freeformCfg = []\n    if len(updatedVlanList):\n        util = Util()\n        freeformCfg.append(\"vlan \" + util.vlanStrFromList(updatedVlanList))\n\n    for vlanId in localVlans:\n        vlanIdStr = str(vlanId)\n        vlanRec = getMatchingResultVlan(vlanIdStr, matchResults)\n        if vlanRec:\n            #Wrapper.print(\"%s: vlan [%s] is not an overlay vlan\" % (funcName, vlanIdStr))\n            isPvlan = False\n            for vlanCmd in vlanRec[\"show_run\"]:\n                if \"private-vlan\" in vlanCmd:\n                    isPvlan = True\n            if isPvlan:\n                Wrapper.print(\"%s: vlan [%s] has unsupported pvlan cmd: %s\" % (funcName, vlanIdStr, vlanCmd))\n                respObj.addErrorReport(getFabErrEntity(funcName, devSerial+\":PVLAN OVERLAY\"),\n                    \"Cannot have private-vlan config on VLANs.\", devSerial)\n                respObj.setFailureRetCode()\n                return\n            freeformCfg += vlanRec[\"show_run\"]\n\n    switchOverlayInfo[\"PRE_INTF_FF\"] += freeformCfg + freeformSVICfg\n    \n    freeformCfg = []\n    if role.lower() == \"aggregation\":\n        if \"VRF_LITE_PROTOCOL\" == \"ebgp\":\n            # form the 'router bgp <as>' key to lookup\n            routerBgpKey = \"router bgp \" + BGP_AS\n            if routerBgpKey in matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"]:\n                bgpVrfMatchRes = matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"][routerBgpKey]\n                freeformCfg = switchOverlayInfo[\"BGP_FF\"]\n                for bgpVrfName in bgpVrfMatchRes.keys():\n                    bgpvrfRec = bgpVrfMatchRes.get(bgpVrfName)\n                    if bgpVrfName == \"unaccounted\":\n                        continue\n                    vrfName = bgpVrfName.split(\" \")[1].strip()\n                    #Wrapper.print(\"%s: Processing BGP VRF [%s]\" % (funcName, vrfName))\n    \n                    if vrfName.lower() not in overlayVrfsNameToVni:\n                        #Wrapper.print(\"%s: BGP VRF [%s]: show run CLI processing\" % (funcName, vrfName))\n                        freeformCfg += bgpvrfRec[\"show_run\"]\n\n    switchOverlayInfo[\"POST_INTF_FF\"] += freeformCfg\n    Wrapper.print(\"%s %s: End - FABRIC [%s] Switch [%s] Role [%s]\" % (OVERLAY_PREFIX, funcName, FABRIC_NAME, formattedName, role))\n\ndef ECLgatherCliNwkVrfs(respObj, devSerial, matchResults, interfacesRes, globalOverlayInfo, switchOverlayInfo, vrfEntries):\n    funcName = sys._getframe(0).f_code.co_name\n    switchRole = switchOverlayInfo[\"switchRole\"]\n    vlanNameSupported = (globalOverlayInfo[\"overlayVlanNameSupported\"] == \"true\")\n    includeAllCfg = True\n    \n    Wrapper.print(\"%s: Switch [%s] Role [%s] vlanNameSupported [%r], includeAllCfg [%r]\" % \n        (funcName, devSerial, switchRole, vlanNameSupported, includeAllCfg))\n\n    sviVlanIdToVrfNameDict = {}\n    sviVlanIdToIp4Dict = {}\n    sviVlanIdToPrefix4Dict = {}\n    sviVlanIdToIp6Dict = {}\n    sviVlanIdToPrefix6Dict = {}\n\n    srchOpt = CtrlPolicySearch()\n    srchOpt.setSerialNumber(devSerial)\n    srchOpt.setTemplateName(\"int_vlan\")\n    srchOpt.setEntityType(\"INTERFACE\")\n    srchOpt.setSource(\"\")\n    sviPtis = Util.exe(PTIWrapper.getPTIs(srchOpt))\n    for pti in sviPtis:\n        if not pti.isDeleted():\n            ptiNvPairs = pti.getNvPairs()\n            vrfName = ptiNvPairs.get(\"INTF_VRF\")\n            intfName = ptiNvPairs.get(\"INTF_NAME\").lower()\n            vlanId = intfName.lstrip(\"Vlan\")\n            ip4 = ptiNvPairs.get(\"IP\")\n            prefix4 = ptiNvPairs.get(\"PREFIX\")\n            if ip4 and prefix4:\n                sviVlanIdToIp4Dict [vlanId] = ip4 \n                sviVlanIdToPrefix4Dict [vlanId] = prefix4 \n            ffConfList = ptiNvPairs.get(\"CONF\").splitlines()\n            for ffConf in ffConfList:\n                ffConf = ffConf.strip()\n                if \"ipv6 address\" in ffConf:\n                    ipPrefix6 = ffConf.lstrip(\"ipv6 address\")\n                    ip6, prefix6 = ipPrefix6.split(\"/\") \n                    if ip6 and prefix6:\n                        sviVlanIdToIp4Dict [vlanId] = ip6\n                        sviVlanIdToPrefix6Dict [vlanId] = prefix6 \n           \n\n            sviVlanIdToVrfNameDict[vlanId] = vrfName\n\n\n    #TODO:If private-vlan is enabled on the vlan then fail BF import or let it go to freeform?\n    vlanIdInfo = {}\n    nvPairList = getTemplateMatchResults(matchResults, \"vlan_name_11_1\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            # check to make sure the name is not the default\n            vlanIdInt = int(nvPair[\"VLAN\"])\n            vlanName = nvPair[\"NAME\"]\n            if vlanName == (\"VLAN%04d\" % vlanIdInt):\n                vlanName = \"\"\n            vlanIdInfo.update({nvPair[\"VLAN\"] : {\"name\" : vlanName}})\n\n    Wrapper.print(\"%s: Switch [%s] vlanIdInfo [%s]\" % (funcName, devSerial, vlanIdInfo))\n\n    #Check for netflow monitor attached to a VLAN\n    nvPairList = getTemplateMatchResults(matchResults, \"vlan_netflow\")\n    if (nvPairList != None):\n        for nvPair in nvPairList:\n            netflow_monitor_name = nvPair[\"NETFLOW_MONITOR_NAME\"]\n            #nvPair[\"VLAN\"] can be a vlan list with - and , like vlan configuration 8-9,12\n            #break it down so that we have an element in the vlanInfo dictionary for each vlan\n            vlan_config_list = nvPair[\"VLAN\"].split(',')\n            for elem in vlan_config_list:\n                if '-' in elem:\n                    start_vlan_range, end_vlan_range = elem.split('-')\n                    for v_int in range(int(start_vlan_range), int(end_vlan_range)+1):\n                        v = str(v_int)\n                        if v not in vlanIdInfo:\n                            vlanIdInfo.update({v : {\"vlan_netflow_monitor\" : netflow_monitor_name}})\n                        else:\n                            vlanNameElem = vlanIdInfo[v]\n                            vlanIdInfo.update({v : [ vlanNameElem, {'vlan_netflow_monitor': netflow_monitor_name}]})\n                else:\n                    v = elem\n                    if v not in vlanIdInfo:\n                        vlanIdInfo.update({v : {\"vlan_netflow_monitor\" : netflow_monitor_name}})\n                    else:\n                        vlanNameElem = vlanIdInfo[v]\n                        vlanIdInfo.update({v : [ vlanNameElem, {'vlan_netflow_monitor': netflow_monitor_name}]})\n            \n    Wrapper.print(\"%s: Switch [%s] vlanIdInfo [%s]\" % (funcName, devSerial, vlanIdInfo))\n\n    if switchRole.lower() == \"aggregation\":\n        \n        # dictionary of vrf name (key) and its description (value)\n        vrfDescInfo = {}\n        nvPairList = getTemplateMatchResults(matchResults, \"vrf_desc_11_1\")\n        if (nvPairList != None):\n            for nvPair in nvPairList:\n                vrfDescInfo.update({nvPair[\"VRF_NAME\"] : nvPair[\"DESC\"]})\n    \n        Wrapper.print(\"%s: Switch [%s] vrfDescInfo [%s]\" % (funcName, devSerial, vrfDescInfo))\n    \n        #TODO: key and value are both vrfName\n        overlayVrfsNameToVrfName = switchOverlayInfo[\"VRFS_NAME2VNI\"]\n        #Key is vrfName, value is vrfEntry\n        overlayVrfsInfoById = switchOverlayInfo[\"VRFS_BY_ID\"]\n    \n        # process the VRFs first\n        Wrapper.print(\"%s: **** Processing VRFs %s\" % (funcName, vrfEntries))\n    \n        for vrf in vrfEntries:\n            vrfName = vrf['vrf_name']\n            Wrapper.print(\"%s: **** Processing VRFs %s\" % (funcName, vrfName))\n\n            # parameters used during VRF create\n            vrfTemplateParams = {\n                \"vrfVlanId\" : \"\",\n                \"vrfName\": vrfName,\n                \"vrfVlanName\" : \"\",\n                \"vrfIntfDescription\" : \"\",\n                \"vrfDescription\" : vrfDescInfo[vrfName] if vrfDescInfo.get(vrfName) else \"\",\n                \"tag\" : \"\",\n                \"VRF_IP_VERSION\": \"IPv4_and_IPv6\",\n                \"enablePerVpcPeering\" : \"false\",\n                \"mtu\" : \"9216\",\n                \"SVI_CONF\" : \"\",\n                \"maxBgpPaths\" : \"1\",\n                \"vrfRouteMap\" : \"\",\n                \"configureStaticDefaultRouteFlag\" : \"false\",\n                \"BGP_AUTH_ENABLE\": \"false\",\n                \"bgpPassword\": \"\",\n                \"bgpPasswordKeyType\": \"3\",\n                \"VRF_LITE_PROTOCOL\": VRF_LITE_PROTOCOL,\n                \"asn\": \"\",\n                \"ENABLE_NETFLOW\": \"\",\n                \"NETFLOW_MONITOR\": \"\"\n            }\n    \n            if VRF_LITE_PROTOCOL == \"ospf\":\n                vrfTemplateParams.update(\n                  {\"OSPF_PROCESS_TAG\": LINK_STATE_ROUTING_TAG,\n                   \"OSPF_AREA_ID\": OSPF_AREA_ID,\n                   \"OSPFv3_PROCESS_TAG\": OSPFv3_ROUTING_TAG,\n                   \"OSPFv3_AREA_ID\": OSPFv3_AREA_ID,\n                   \"OSPF_AUTH_ENABLE\": \"false\",\n                   \"OSPF_AUTH_KEY_ID\": \"127\",\n                   \"OSPF_AUTH_KEY\": \"\"\n                  })\n\n            vrfEntry = {\n                        'name' : vrfName,\n                        'vlanId' : \"\",\n                        'vrfTemplateParams' : vrfTemplateParams,\n                        # list of network VLANs (integer) associated with this VRF\n                        'networks' : [],\n                        # VRF attach extension values\n                        'extensionVals' : \"\",\n                        # VRF attach instance values\n                        'instanceVals' : \"\",\n                        # the additional configuration that could not be accounted for in the config profile\n                        'freeformCfg' : None,\n                       }\n    \n            nvPairList = getTemplateMatchResults(matchResults, \"bgp_overlay_vrf_ipv4_redist_rmap_11_1\")\n            if (nvPairList != None):\n                for nvPair in nvPairList:\n                    if nvPair[\"VRF_NAME\"] == vrfName:\n                        vrfTemplateParams[\"vrfRouteMap\"] = nvPair[\"RMAP\"] \n                        break\n            nvPairList = getTemplateMatchResults(matchResults, \"bgp_overlay_vrf_ipv4_max_bgp_paths_11_1\")\n            if (nvPairList != None):\n                for nvPair in nvPairList:\n                    if nvPair[\"VRF_NAME\"] == vrfName:\n                        vrfTemplateParams[\"maxBgpPaths\"] = nvPair[\"MAX_PATHS\"]\n                        break\n\n            ip4AfPresent = False\n            ip6AfPresent = False\n            if vrfName == \"default\":\n                ip4AfPresent, ip6AfPresent = ECLGetVrfNeighborIp4OrIp6(devSerial, vrfName, overlayVrfsInfoById, matchResults)\n            else:\n                nvPairList = getTemplateMatchResults(matchResults, \"vrf_af\")\n                if (nvPairList != None):\n                    for nvPair in nvPairList:\n                        if nvPair[\"VRF_NAME\"] == vrfName:\n                            if nvPair[\"IP_VERSION\"] == \"ipv4\":\n                                ip4AfPresent = True\n                            else:\n                                ip6AfPresent = True\n\n            if ip4AfPresent and ip6AfPresent:\n                vrfTemplateParams[\"VRF_IP_VERSION\"] = \"IPv4_and_IPv6\"\n            elif ip4AfPresent:\n                vrfTemplateParams[\"VRF_IP_VERSION\"] = \"IPv4_only\"\n            elif ip6AfPresent:\n                vrfTemplateParams[\"VRF_IP_VERSION\"] = \"IPv6_only\"\n            vrfEntry[\"freeformCfg\"] = ECLgetVrfFreeformCfg(devSerial, vrfName, \"\", \n                                                           matchResults, interfacesRes, includeAllCfg, switchOverlayInfo)\n            overlayVrfsNameToVrfName[vrfEntry[\"name\"].lower()] = {\"origName\" : vrfEntry[\"name\"], \"vni\" : vrfEntry[\"name\"]}\n            overlayVrfsInfoById[vrfEntry[\"name\"]] = vrfEntry\n            Wrapper.print(\"%s: Switch [%s]. VRF VNI [%s]. Entry %s\" % (funcName, devSerial, vrfName, vrfEntry))\n            \n    # process the networks\n    Wrapper.print(\"%s: **** Processing Networks\" % (funcName))\n    networksInfo = switchOverlayInfo[\"NETWORKS_BY_ID\"]\n    overlayVrfMisconfigList = []\n\n    utilObj = Util()\n    allVlansOnSwitchStr = utilObj.vlanStrFromList(switchOverlayInfo[\"ALL_VLANS\"])\n    \n    #Assume all vlans can be configured from top down\n    vlanList = list(set(switchOverlayInfo[\"ALL_VLANS\"]) - set(switchOverlayInfo[\"OVERLAY_VLANS\"]))\n\n    Wrapper.print(\"%s: vlan List [%s] str [%s] allvlans [%s] overlayvlans [%s] post vrfs under consideration\" % \n                  (funcName, vlanList, allVlansOnSwitchStr, switchOverlayInfo[\"ALL_VLANS\"], switchOverlayInfo[\"OVERLAY_VLANS\"]))\n\n    errDetectionDict = {}\n    for vlanId in vlanList:\n        #TODO: Skip vlan 1 for now\n        if vlanId == 1:\n            continue\n          \n        Wrapper.print(\"%s: Network VLAN [%s] under consideration for top-down addition\" % (funcName, vlanId))\n\n        switchOverlayInfo[\"OVERLAY_VLANS\"].append(vlanId)\n        Wrapper.print(\"%s: switchOverlayVLANs so far [%s] vlanId[name] %s %s\" % (funcName, switchOverlayInfo[\"OVERLAY_VLANS\"], vlanIdInfo, vlanIdInfo.get(str(vlanId))))\n\n        vlanNameStr = \"\"\n        vlanNetflowMonitor = \"\"\n        netflowEnable = \"false\"\n        if vlanIdInfo.get(str(vlanId)):\n            vlanIdInfoelem = vlanIdInfo.get(str(vlanId))\n            if len(vlanIdInfoelem) > 1:\n                for x in vlanIdInfoelem:\n                    if \"name\" in x:\n                        vlanNameStr = x['name']\n                        continue\n        \n                    if \"vlan_netflow_monitor\" in x:\n                        netflowEnable = \"true\"\n                        vlanNetflowMonitor = x['vlan_netflow_monitor']\n                        continue\n            else:\n                if \"name\" in vlanIdInfoelem:\n                    vlanNameStr = vlanIdInfoelem['name']\n                elif \"vlan_netflow_monitor\" in vlanIdInfoelem:\n                    netflowEnable = \"true\"\n                    vlanNetflowMonitor = vlanIdInfoelem['vlan_netflow_monitor']\n    \n        netTemplateParams = {\n            # mandatory parameters\n            'vlanId' : \"\",\n            'vlanName' : vlanNameStr,\n            'tag' : \"\",\n            'vrfName' : \"NA\",\n            'gatewayIpAddress' : \"\",\n            'pip1' : \"\",\n            'pip2' : \"\",\n            'gatewayIpV6Address' : \"\",\n            'ipv6_pip1' : \"\",\n            'ipv6_pip2' : \"\",\n            'ipv6_linklocal_vip' : \"\",\n            'intfDescription' : \"\",\n            'intfDescription2' : \"\",\n            'mtu' : \"\",\n            'redundancyType' : FHRP_PROTOCOL,\n            'ignorePriority' : \"false\",\n            'activePriority' : \"\",\n            'standbyPriority' : \"\",\n            'preempt' : \"false\",\n            'GROUP' : \"\",\n            'GROUP_V6': \"\",\n            'mac' : \"\",\n            'VRRP_ENABLE' : \"false\",\n            'dhcpServers' : \"\",\n            \"ENABLE_NETFLOW\": netflowEnable,\n            \"SVI_NETFLOW_MONITOR\": \"\",            \n            \"VLAN_NETFLOW_MONITOR\": vlanNetflowMonitor,            \n            'HSRP_VERSION' : \"1\",\n            \"VRF_LITE_PROTOCOL\": VRF_LITE_PROTOCOL,\n            'isLayer2Only' : \"true\",\n            }\n\n        if VRF_LITE_PROTOCOL == \"ospf\":\n            netTemplateParams.update(\n              {\"OSPF_AUTH_ENABLE\": \"false\",\n               \"OSPF_AUTH_KEY_ID\": \"127\",\n               \"OSPF_AUTH_KEY\": \"\",\n               \"enableOspfPassive\": \"false\",\n               \"enableOspfv3Passive\": \"false\"\n              })\n\n        netEntry = {\n            # the 'overlayNetName' will be set later \n            'vlanId' : vlanId,\n            'vlanName' : netTemplateParams[\"vlanName\"],\n            \"netTemplateParams\" : netTemplateParams,\n            'vrfName' : \"NA\",\n            # Network attach extension values\n            'extensionVals' : \"\",\n            # the additional configuration that could not be accounted for in the config profile\n            'freeformCfg' : \"\",\n            # list of interface names. Collected from trunk and access host interfaces where the vlan is enabled explictly,\n            'attachInfo' : [],\n            # list of Tor/access interface names. Collected from trunk and access host interfaces where the vlan is enabled explictly,\n            # Tor/access devices are attached to the leaf/aggregation devices and their interfaces are listed as candidates when \n            # network is attached on the corresponding parent leaf/aggregation device.\n            'torPorts' : [],\n        }\n\n        #TODO: Do we need to handle case of spurious VLANs on access that are not on the aggregation layer?\n        if switchRole.lower() == \"aggregation\":\n            # need to check if a SVI exists for this vlan\n            sviName = 'Vlan'+ str(vlanId)\n            validTopDownNetworkFlag = ECLgetNetworkSviParams(interfacesRes, sviName, netEntry, switchOverlayInfo, overlayVrfMisconfigList, errDetectionDict, respObj)\n            if not validTopDownNetworkFlag:\n                switchOverlayInfo[\"OVERLAY_VLANS\"].remove(vlanId)\n                continue\n        \"\"\"\n        for entry in errDetectionDict:\n             entryParams = entry[\"params\"]\n        \"\"\"\n        if (netTemplateParams[\"vlanId\"] == \"\"):\n            # this is the first time we are initializing... set it to the vlan we find. Most likely the same vlan\n            # will be used in all switches. Note that the attach will be for the exact vlan found on the switches\n            netTemplateParams[\"vlanId\"] = netEntry[\"vlanId\"]\n        netEntry[\"freeformCfg\"] = ECLgetNetworkFreeformCfg(str(vlanId), matchResults, interfacesRes, False)\n        networksInfo[netEntry[\"vlanId\"]] = netEntry\n        switchOverlayInfo[\"NETWORKS_VLAN2VNI\"][netEntry[\"vlanId\"]] = netEntry[\"vlanId\"]\n         \ndef ECLgetVrfFreeformCfg(devSerial, vrfName, vrfVlanStr, matchResults, interfacesRes,\n                                                        includeAllCfg, switchOverlayInfo):\n    funcName = sys._getframe(0).f_code.co_name\n    Wrapper.print(\"%s: vrfName [%s] vrfVlanStr [%s] includeAllCfg [%r]\" % (funcName, vrfName, vrfVlanStr, includeAllCfg))\n    freeformCfg = getVlanCfg(vrfVlanStr, matchResults, includeAllCfg)\n    freeformCfg += getSviCfg(vrfVlanStr, interfacesRes, includeAllCfg, True, None)\n    freeformCfg += getVrfCfg(vrfName, matchResults, includeAllCfg)\n\n    filteredFF = [\"\"]\n    routerBgpKey = \"router bgp \" + BGP_AS\n    bgpRec = matchResults[\"FEATURES_INFO\"][\"BGP_BLOCK\"].get(routerBgpKey)\n    if bgpRec != None:\n        vrfKey = 'vrf ' + vrfName\n        vrfRec = bgpRec.get(vrfKey)\n        if vrfRec != None:\n            if includeAllCfg:\n                filteredFF.extend(vrfRec[\"show_run\"])\n            else:\n                if len(vrfRec[\"unaccounted\"]) > 0:\n                    filteredFF.extend(vrfRec[\"unaccounted\"])\n\n    if len(filteredFF):\n        freeformCfg += Util.newLine().join(filteredFF)\n\n    return freeformCfg.strip()\n\ndef ECLgetNetworkFreeformCfg(netVlanStr, matchResults, interfacesRes, includeAllCfg):\n    Wrapper.print(\"getNetworkFreeformCfg: netVlanStr [%s]\" % (netVlanStr))\n\n    freeformCfg = getVlanCfg(netVlanStr, matchResults, includeAllCfg)\n    freeformCfg += ECLgetSviCfg(netVlanStr, interfacesRes, includeAllCfg, False)\n\n    return freeformCfg.strip()\n\ndef getIpsFromNvPairs(templateNameMatches, matchResult, matchingNvPairs, intfName, inOutDict):\n    funcName = sys._getframe(0).f_code.co_name\n    poIp4               = inOutDict[\"poIp4\"] \n    poPrefix4           = inOutDict[\"poPrefix4\"]\n    poIp6               = inOutDict[\"poIp6\"]\n    poPrefix6           = inOutDict[\"poPrefix6\"]\n    poRoutingTag        = inOutDict[\"poRoutingTag\"]\n    unaccCfg6           = inOutDict[\"unaccCfg6\"]\n    unaccCfg6WithTag    = inOutDict[\"unaccCfg6WithTag\"]\n\n    isIp4TagPresent = isIp6TagPresent = False\n    poTag4 = poTag6 = \"\"\n    if \"interface_ipv4_tag_11_1\" in templateNameMatches:\n        poTag4 = matchingNvPairs[\"interface_ipv4_tag_11_1\"][\"TAG\"]\n        isIp4TagPresent = True\n    if \"interface_ipv6_tag_11_1\" in templateNameMatches:\n        poTag6 = matchingNvPairs[\"interface_ipv6_tag_11_1\"][\"TAG\"]\n        isIp6TagPresent = True\n\n    if isIp4TagPresent or isIp6TagPresent:\n        if poTag4:\n            poRoutingTag = poTag4\n        elif poTag6:\n            poRoutingTag = poTag6\n        else:\n            #default tag will be from v4\n            poRoutingTag = poTag4\n\n    if \"interface_ipv4_tag_11_1\" in templateNameMatches:\n        poIp4 = matchingNvPairs[\"interface_ipv4_tag_11_1\"][\"IP\"]\n        poPrefix4 = matchingNvPairs[\"interface_ipv4_tag_11_1\"][\"PREFIX\"]\n        Wrapper.print(\"Found ip [%s], prefix [%s]\"%(poIp4, poPrefix4))\n    elif \"interface_ipv4_11_1\" in templateNameMatches:\n        poIp4 = matchingNvPairs[\"interface_ipv4_11_1\"][\"IP\"]\n        poPrefix4 = matchingNvPairs[\"interface_ipv4_11_1\"][\"PREFIX\"]\n        Wrapper.print(\"Found ip [%s], prefix [%s]\"%(poIp4, poPrefix4))\n    if \"interface_ipv6_tag_11_1\" in templateNameMatches:\n        count = 1\n        matchingMultiNvPairs = getIntfMatchMultiNvPairs(matchResult, intfName, [\"interface_ipv6_tag_11_1\"])\n        for item in matchingMultiNvPairs[\"interface_ipv6_tag_11_1\"]:\n            tmpIp6 = item[\"IP\"]\n            tmpPrefix6 = item[\"PREFIX\"]\n            tmpTag = item[\"TAG\"]\n            if count == 1 and not poIp6 and tmpIp6 != poIp6: #not already accounted\n                poIp6 = tmpIp6\n                poPrefix6 = tmpPrefix6\n            else: # if not first and already accounted one is chosen\n                if tmpTag:\n                    ip6MaskTag = \"ipv6 address %s/%s tag %s\"%(ip6Tmp,prefix6Tmp, tmpTag)\n                else:\n                    ip6MaskTag = \"ipv6 address %s/%s\"%(ip6Tmp, prefix6Tmp)\n                if unaccCfg6WithTag:\n                    unaccCfg6WithTag = unaccCfg6WithTag + Util.newLine() + ip6MaskTag\n                else:\n                    unaccCfg6WithTag = ip6MaskTag\n            count = count+1\n        Wrapper.print(\"Found ip6 [%s], prefix6 [%s], tag [%s]\"%(poIp6, poPrefix6, poRoutingTag))\n        Wrapper.print(\"Found unaccCfg6WithTag [%s]\"%(unaccCfg6WithTag))\n    if \"interface_ipv6_11_1\" in templateNameMatches:\n        count = 1\n        matchingMultiNvPairs = getIntfMatchMultiNvPairs(matchResult, intfName, [\"interface_ipv6_11_1\"])\n        for item in matchingMultiNvPairs[\"interface_ipv6_11_1\"]:\n            tmpIp6 = item[\"IP\"]\n            tmpPrefix6 = item[\"PREFIX\"]\n            if count == 1 and not poIp6 and tmpIp6 != poIp6: #not already accounted\n                poIp6 = tmpIp6\n                poPrefix6 = tmpPrefix6\n            else:\n                ip6Mask = \"ipv6 address %s/%s\"%(tmpIp6, tmpPrefix6)\n                if unaccCfg6:\n                    unaccCfg6 = unaccCfg6 + Util.newLine() + ip6Mask\n                else:\n                    unaccCfg6 = ip6Mask\n            count = count+1\n        Wrapper.print(\"Found ip6 [%s], prefix6 [%s]\"%(poIp6, poPrefix6))\n        Wrapper.print(\"Found unaccCfg6 [%s]\"%(unaccCfg6))\n    inOutDict.update({\"poIp4\":poIp4, \"poPrefix4\":poPrefix4, \"poIp6\":poIp6, \"poPrefix6\":poPrefix6, \n                      \"poRoutingTag\": poRoutingTag, \"unaccCfg6\":unaccCfg6, \"unaccCfg6WithTag\":unaccCfg6WithTag})\n    Wrapper.print(\"%s(): L3 port-channel output dict [%s]\"%(funcName, str(inOutDict))) \n    return inOutDict\n\ndef ECLdeviceUpgradeIntf(gVarDictObj, matchResult, interfacesRes, isValidVPC, device_overlay_vlans, vpcPairInfo, respObj):\n    funcName = sys._getframe(0).f_code.co_name\n\n    topologyDataObj = gVarDictObj[\"topologyObj\"]\n    globalOverlayInfo = gVarDictObj[\"globalOverlayInfo\"]\n    switchInfo = gVarDictObj[\"DICTIONARY_OBJ\"]\n    devSerial = switchInfo[\"deviceSerial\"]\n    migrateMode = switchInfo[\"migrationMode\"]\n    fmtName = switchInfo[\"fmtName\"]\n    switchRole = switchInfo['switchRole']\n    fabricName = FABRIC_NAME\n    allFabricInterfaces = topologyDataObj.get(TopologyInfoType.ALL_FABRIC_INTFS, devSerial)\n    Wrapper.print(\"%s: [%s] all Fabric intf %s\" % (funcName, fmtName, allFabricInterfaces))\n\n    linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, devSerial,  Helper.getNbrTypeInternal()))\n    # collect the FEX IDs info\n    fexList = {}\n    nvPairList = getTemplateMatchResults(matchResult, \"base_fex\")\n    if (nvPairList != None):\n        # build the FEX dictionary\n        for nvPair in nvPairList:\n            fexList[nvPair[\"FEX_ID\"]] = nvPair\n    else:\n        nvPairList = getTemplateMatchResults(matchResult, \"base_fex_N7k\")\n        if (nvPairList != None):\n            # build the FEX dictionary\n            for nvPair in nvPairList:\n                fexList[nvPair[\"FEX_ID\"]] = nvPair\n    Wrapper.print(\"%s: [%s]  device %s fexList [%s]\" % (funcName, fmtName, devSerial, fexList))\n    vpcLinkMemberInterfaces = []\n    isVPC = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, devSerial))\n    vpcPairSerialKey = \"\"\n    if isVPC:\n        vpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, devSerial))\n        Wrapper.print(\"%s(): vPC: pair [%s]\" % (funcName, vpcPairSerialKey))\n        serials = vpcPairSerialKey.split(Helper.DELIMITER)\n        vpcSn = devSerial\n        vpcPeerSn = serials[1] if vpcSn == serials[0] else serials[0]\n        vpcLinkMemberInterfaces = topologyDataObj.get(TopologyInfoType.VPC_PEER_LINK_MEMBERS, vpcSn, vpcPeerSn)\n    Wrapper.print(\"%s: [%s] - vpc Link members [%s]\" % (funcName, fmtName, vpcLinkMemberInterfaces))\n\n    # special handling for breakout interfaces\n    templateName = \"breakout_interface\"\n    nvPairList = getTemplateMatchResults(matchResult, templateName)\n    if (nvPairList != None):\n        ptiSource = getSrc(templateName)\n        for nvPair in nvPairList:\n            Wrapper.print(\"Breakout: slot [%s], ports [%s]\" % (nvPair[\"SLOT\"], nvPair[\"PORT\"]))\n\n            # if the PORT is a range, then we need to unroll it into individual PTIs\n            ports = getIntegerRange(nvPair[\"PORT\"])\n\n            # create individual PTIs for each port\n            for port in ports:\n                # update the 'PORT' key value in the policy instance\n                nvPair[\"PORT\"] = str(port)\n                entityName = \"Ethernet\" + nvPair[\"SLOT\"] + \"/\" + nvPair[\"PORT\"]\n                createPTI(devSerial, nvPair, templateName, entityName, ptiSource, -1)\n\n    # process PO and vPC host ports\n    poInterfaces = {}\n\n    # gather the PO and vPC info in two passes\n    # pass 1: the main PO interfaces list\n    # pass 2: the corresponding members\n    for roundNum in range(1,3):\n        for intfName in sorted(interfacesRes.keys()):\n            # get the interface match results\n            intfMatchResult = interfacesRes[intfName]\n\n            # skip interfaces that have been processed\n            if isIntfProcessed(intfMatchResult):\n                continue\n\n            templateNameMatches = intfMatchResult[\"matched_templates\"]\n\n            if roundNum == 1:\n                # Pass 1 - gather the parent PO entries\n                if (intfName.lower().startswith(\"port-channel\")):\n                    isAccessPort = False\n                    isDot1qTunnel = False\n                    isFexPo = False\n                    isL3Po = False\n                    subIntf = False\n                    if (\"fex_port_channel_interface\" in templateNameMatches):\n                        # this is a FEX PO\n                        isFexPo = True\n                    elif((\"access_interface\" in templateNameMatches) or \n                         (\"access_interface_fex\" in templateNameMatches) or \n                         (\"port_channel_access_interface\" in templateNameMatches) or\n                         (\"port_channel_dot1q_tunnel_interface\" in templateNameMatches) or\n                         (\"dot1q_tunnel_interface\" in templateNameMatches)):\n                        # treat dot1q tunnel port as access\n                        isAccessPort = True\n\n                        if ((\"port_channel_dot1q_tunnel_interface\" in templateNameMatches) or\n                            (\"dot1q_tunnel_interface\" in templateNameMatches)):\n                            isDot1qTunnel = True\n                    elif (\"port_channel_routed_interface\" in templateNameMatches):\n                        isL3Po = True\n                    elif (\"interface_subintf\" in templateNameMatches):\n                        isL3Po = True\n                    elif not (\"port_channel_trunk_interface_11_1\" in templateNameMatches):\n                        # not a normal PO we understand\n                        Wrapper.print(\"Incomplete policy match - PO [%s]\" % intfName)\n                        continue\n                    \n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n                    Wrapper.print(\"Switch [%s] : Found PO [%s] isFexPo [%r] isAccessPort [%r] isDot1qTunnel [%r] isL3Po [%r] \" % (devSerial,\n                            intfName, isFexPo, isAccessPort, isDot1qTunnel, isL3Po))\n\n                    # record this PO, with the key as the PO id\n                    # extract the id\n                    portChannelIntf = intfName.lower()\n                    pc, pcid = portChannelIntf.split(\"port-channel\")\n\n                    poMtu = \"1500\"\n                    poSpeed = \"auto\"\n                    poAdminState = \"true\"\n                    poDesc = \"\"\n                    orphanPort = \"false\"\n                    bpduGuardState = \"no\"\n                    porttype_fast_enable = \"false\"\n                    porttype_fast_trunk = \"false\"\n                    vpcId = \"\"\n                    fexId = \"\"\n                    access_vlan = \"\"\n                    native_vlan = \"\"\n                    poIp4 = \"\"\n                    poPrefix4 = \"\"\n                    poIp6 = \"\"\n                    poPrefix6 = \"\"\n                    poRoutingTag = \"\"\n                    dot1qVlan = \"\"\n                    poVrf = \"\"\n                    unaccCfg6 = \"\" \n                    unaccCfg6WithTag = \"\" \n                    l3PoDict = {}\n                    if (\"interface_mtu\" in templateNameMatches):\n                        poMtu = matchingNvPairs[\"interface_mtu\"][\"MTU\"]\n                    if (\"interface_speed\" in templateNameMatches):\n                        poSpeed = matchingNvPairs[\"interface_speed\"][\"SPEED\"]\n                    if isFexPo:\n                        fexId = matchingNvPairs[\"fex_port_channel_interface\"][\"FEX_ID\"]\n                    if (\"shut_interface\" in templateNameMatches):\n                        poAdminState = \"false\"\n                    if (\"interface_desc\" in templateNameMatches):\n                        poDesc = matchingNvPairs[\"interface_desc\"][\"DESC\"]\n                    if (\"interface_orphan_port\" in templateNameMatches):\n                        orphanPort = \"true\"\n                    if (\"bpduguard_enable\" in templateNameMatches):\n                        bpduGuardState = \"true\"\n                    if (\"bpduguard_disable\" in templateNameMatches):\n                        bpduGuardState = \"false\"\n                    if (\"porttype_fast_trunk\" in templateNameMatches):\n                        porttype_fast_trunk = \"true\"\n                    if (\"porttype_fast_enable\" in templateNameMatches):\n                        porttype_fast_enable = \"true\"\n                    if (\"port_channel_vpc_id_11_1\" in templateNameMatches):\n                        vpcId = matchingNvPairs[\"port_channel_vpc_id_11_1\"][\"VPC_ID\"]\n                        Wrapper.print(\"Found vpcId [%s]\" % vpcId)\n                    if (\"access_vlan\" in templateNameMatches and matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"] !=1):\n                        access_vlan = processAccessIntfOverlayInfo(devSerial, migrateMode, \n                            intfName, matchingNvPairs[\"access_vlan\"][\"ACCESS_VLAN\"],\n                            globalOverlayInfo, device_overlay_vlans)\n                    if (\"native_vlan\" in templateNameMatches):\n                        native_vlan = matchingNvPairs[\"native_vlan\"][\"NATIVE_VLAN\"]\n                    if \"interface_ipv4_tag_11_1\" in templateNameMatches:\n                        isL3Po = True\n                    elif \"interface_ipv4_11_1\" in templateNameMatches:\n                        isL3Po = True\n                    if \"interface_ipv6_tag_11_1\" in templateNameMatches:\n                        isL3Po = True\n                    elif \"interface_ipv6_11_1\" in templateNameMatches:\n                        isL3Po = True\n\n                    if \"interface_subintf\" in templateNameMatches and \".\" in pcid:\n                        dot1qVlan = matchingNvPairs[\"interface_subintf\"][\"VLAN\"]\n                        Wrapper.print(\"Found dot1q Vlan [%s]\"%(dot1qVlan))\n                        isL3Po = True\n                        subIntf = True\n\n                    if isL3Po and \"interface_vrf\" in templateNameMatches:\n                        poVrf = matchingNvPairs[\"interface_vrf\"][\"INTF_VRF\"]\n                        Wrapper.print(\"Found po vrf [%s]\"%(poVrf))\n\n                    l3PoDict = {\"poIp4\": \"\", \"poPrefix4\":\"\", \"poIp6\": \"\", \"poPrefix6\":\"\", \n                                \"poRoutingTag\": \"\", \"unaccCfg6\":\"\", \"unaccCfg6WithTag\":\"\"}\n                    if isL3Po:\n                        getIpsFromNvPairs(templateNameMatches, matchResult, matchingNvPairs, intfName, l3PoDict)\n\n                    allowed_vlans = \"none\"\n                    allowed_vlan_orig = \"none\"\n                    if (\"port_channel_trunk_interface_11_1\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"port_channel_trunk_interface_11_1\"][\"ALLOWED_VLANS\"]\n                    elif (\"trunk_interface\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"trunk_interface\"][\"ALLOWED_VLANS\"]\n                    elif (\"trunk_interface_fex\" in templateNameMatches):\n                        allowed_vlan_orig = matchingNvPairs[\"trunk_interface_fex\"][\"ALLOWED_VLANS\"]\n                    elif (\"port_channel_routed_interface\" in templateNameMatches):\n                        isL3Po = True\n                    \n                    if not isAccessPort and not isL3Po:\n                        allowed_vlans = processTrunkIntfOverlayInfo(devSerial, migrateMode, intfName,\n                                    allowed_vlan_orig, globalOverlayInfo, device_overlay_vlans)\n                    unaccCfg = \"\"\n                    if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                        Wrapper.print(\"Device [%s]: Found unaccounted cfg for portchannel intf [%s]\" % (devSerial, intfName))\n                        unaccCfg = Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"]) \n\n                    templateList = [\n                                    \"bfd_interface_auth\",\n                                    \"bfd_no_echo_interface\", \n                                    \"ospf_p2p_interface\",\n                                    \"ospf_interface_auth\",\n                                    \"isis_p2p_inteface\",\n                                    \"isis_interface_auth\",\n                                    \"isis_interface_auth_no_lvl\",\n                                    \"vlan_interface_fwd_mode_11_1\",\n                                    \"interface_ipv6_11_1\",\n                                    \"interface_ipv6_tag_11_1\",\n                                    \"cdp_disable_interface_11_1\"\n                                   ]\n                    if isAccessPort:\n                        templateList.append(\"porttype_fast_trunk\")\n                    elif not isL3Po:\n                        templateList.append(\"access_vlan\")\n                        templateList.append(\"porttype_fast_enable\")\n                    elif isL3Po:\n                        templateList.remove(\"interface_ipv6_11_1\")\n                        templateList.remove(\"interface_ipv6_tag_11_1\")\n\n                    configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n                    if unaccCfg and configList:\n                        unaccCfg = unaccCfg + Util.newLine() + Util.newLine().join(configList)\n                    elif configList:\n                        unaccCfg = Util.newLine().join(configList)\n\n                    if isL3Po:\n                        unaccCfg6 = l3PoDict.get(\"unaccCfg6\", \"\")\n                        unaccCfg6WithTag = l3PoDict.get(\"unaccCfg6WithTag\", \"\")\n                        if unaccCfg6:\n                            unaccCfg = unaccCfg + Util.newLine() + unaccCfg6\n                        if unaccCfg6WithTag: \n                            unaccCfg = unaccCfg + Util.newLine() + unaccCfg6WithTag\n                    if not isL3Po:\n                        poInterfaces.update({pcid : {\"name\" : intfName,\n                                                     \"mtu\" : poMtu,\n                                                     \"speed\" : poSpeed,\n                                                     \"vpcId\" : vpcId,\n                                                     \"poMode\" : \"active\",\n                                                     \"poDesc\" : poDesc,\n                                                     \"orphanPort\" : orphanPort,\n                                                     \"adminState\" : poAdminState,\n                                                     \"bpduguard\" : bpduGuardState,\n                                                     \"porttype_fast_enable\" : porttype_fast_enable,\n                                                     \"porttype_fast_trunk\" : porttype_fast_trunk,\n                                                     \"fexId\" : fexId,\n                                                     \"allowed_vlans\": allowed_vlans,\n                                                     \"access_vlan\": access_vlan,\n                                                     \"native_vlan\": native_vlan,\n                                                     \"access_port\": isAccessPort,\n                                                     \"dot1q_tunnel\" : isDot1qTunnel,\n                                                     \"members\" : [],\n                                                     \"poConf\" : unaccCfg,\n                                                     \"isL3Po\"   : False\n                                                     }\n                                                     })\n                    else:\n                        poInterfaces.update({pcid : {\"name\"       : intfName,\n                                                     \"mtu\"        : poMtu,\n                                                     \"speed\"      : poSpeed,\n                                                     \"vpcId\"      : vpcId,\n                                                     \"fexId\"      : fexId,\n                                                     \"poDesc\"     : poDesc,\n                                                     \"ip4\"        : l3PoDict.get(\"poIp4\", \"\"),\n                                                     \"prefix4\"    : l3PoDict.get(\"poPrefix4\", \"\"),\n                                                     \"ip6\"        : l3PoDict.get(\"poIp6\", \"\"),\n                                                     \"prefix6\"    : l3PoDict.get(\"poPrefix6\", \"\"),\n                                                     \"tag\"        : l3PoDict.get(\"poRoutingTag\", \"\"),\n                                                     \"vrf\"        : poVrf,\n                                                     \"dot1qVlan\"  : dot1qVlan,\n                                                     \"poMode\"     : \"active\",\n                                                     \"poDesc\"     : poDesc,\n                                                     \"adminState\" : poAdminState,\n                                                     \"members\"    : [],\n                                                     \"poConf\"     : unaccCfg,\n                                                     \"isL3Po\"     : True,\n                                                     \"isSubIntf\"  : True if (\".\" in pcid or subIntf) else False\n                                                     }\n                                                     })\n\n                    Wrapper.print(\"Switch [%s] : Added entry for l3Po [%s] PO [%s] id [%s]\" % (devSerial, isL3Po, intfName, pcid))\n                    Wrapper.print(\"Switch [%s] : Added entry [%r]\" % (devSerial, poInterfaces))\n\n            else:\n                # Pass 2 - gather the PO/vPC member entries\n                if ((\"port_channel_mode_on\" in templateNameMatches) or\n                    (\"port_channel_mode\" in templateNameMatches)):\n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    # TODO: check if this a host vPC or regular PO based on the 'vpc' config\n                    templatesToCheck = [\"port_channel_mode_on\",\n                                        \"port_channel_mode\"\n                                       ]\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templatesToCheck)\n\n                    pcid = \"\"\n                    mode = \"\"\n                    for templateName in matchingNvPairs:\n                        if (\"port_channel_mode_on\" == templateName):\n                            # record the PO mode\n                            pcid = matchingNvPairs[templateName][\"PCID\"]\n                            mode = \"on\"\n                            break\n                        elif (\"port_channel_mode\" == templateName):\n                            # record the PO mode\n                            pcid = matchingNvPairs[templateName][\"PCID\"]\n                            mode = matchingNvPairs[templateName][\"PC_MODE\"]\n                            break\n\n                    Wrapper.print(\"Switch [%s] - Found PO member intf [%s] mode [%s] parent PO id [%s]\" %\n                        (devSerial, intfName, mode, pcid))\n                    # lookup the main PO dictionary object\n                    try:\n                        parentPo = poInterfaces[pcid]\n                        # update the PO mode\n                        parentPo[\"poMode\"] = mode\n                        # add this interface as a member\n                        parentPo[\"members\"].append(intfName)\n                    except:\n                        intfMatchResult.update({\"isProcessed\" : False})\n                        Wrapper.print(\"ERROR: Switch [%s] Did not find parent PO for intf [%s] id [%s]\" % \n                                                    (devSerial, intfName, pcid))\n                elif (\"fex_po_member_interface\" in templateNameMatches):\n                    Wrapper.print(\"Found FEX member [%s]\" % intfName)\n                    #Wrapper.print(str(templateNameMatches))\n\n                    # mark the interface as being processed\n                    intfMatchResult.update({\"isProcessed\" : True})\n                    Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n                    matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, [\"fex_po_member_interface\"])\n\n                    # lookup the main PO dictionary object\n                    pcid = matchingNvPairs[\"fex_po_member_interface\"][\"PCID\"]\n                    try:\n                        parentPo = poInterfaces[pcid]\n                        Wrapper.print(\"PO: [%s]. adding fex member [%s]\" % (pcid, intfName))\n\n                        # add this interface as a member\n                        parentPo[\"members\"].append(intfName)\n                    except:\n                        intfMatchResult.update({\"isProcessed\" : False})\n                        Wrapper.print(\"ERROR: Did not find parent FEX PO for intf [%s] id [%s]\" % \n                                                (intfName, pcid))\n\n    # create the host PO and VPCs\n    for pcid in poInterfaces:\n        poEntry = poInterfaces[pcid]\n        poName = poEntry[\"name\"]\n        vpcIntfName = \"vPC\" + poEntry[\"vpcId\"]\n        isL3Po = poEntry[\"isL3Po\"]\n        isL3SubIfPo = poEntry[\"isSubIntf\"] if isL3Po else False\n\n        Wrapper.print(\"poName [%s] isL3Po [%s] isL3SubIfPo [%s] process poEntry [%r]\" % (poName, isL3Po, isL3SubIfPo, poEntry))\n\n        intfMatchResult = interfacesRes[poName]\n        if (poEntry[\"fexId\"] != \"\"):\n            if (poEntry[\"vpcId\"] != \"\"):\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: VPC_ID [%s] FEX_ID :[%s]\" % (FABRIC_NAME, key, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n\n                # check if we have the peer serial number\n                peerSerial = \"\"\n                try:\n                    peerSerial = vpcPairInfo[\"peerSerialNum\"]\n                    Wrapper.print(\"AAFEX: peer device [%s] is found for device[%s].\"%(peerSerial, devSerial))\n                except:\n                    Wrapper.print(\"AAFEX: peer serial # is empty. create PTIs to save vpc host info for later use\")\n                    \"\"\"\n                    memberIntfParams = {}\n                    for member in poEntry[\"members\"]:\n                        templatesToCheck = [\"interface_desc\"]\n                        matchingNvPairs = getIntfMatchNvPairs(matchResult, member, templatesToCheck)\n                        if \"interface_desc\" in matchingNvPairs:\n                            desc = matchingNvPairs[\"interface_desc\"][\"DESC\"]\n                        else:\n                            desc = \"\"\n                        if (len(intfMatchResult[\"unaccounted_cmds\"]) > 0):\n                            Wrapper.print(\"AAFEX: Device [%s]: Found unaccounted cfg for aa fex po intf [%s]\" % (devSerial, member))\n                            unaccCfgMember = Util.newLine().join(intfMatchResult[\"unaccounted_cmds\"])\n                        else:\n                            unaccCfgMember = \"\"\n                        memberIntfParams.update({member: {\"SN\": devSerial, \"DESC\": desc, \"CONF\": unaccCfgMember}}) \n                    \"\"\"\n\n                    nvPairs = {\"PO_ID\": poName,\n                               \"FEX_ID\" : poEntry[\"fexId\"],\n                               \"MTU\": Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                               \"PO_DESC\": poEntry[\"poDesc\"],\n                               \"ADMIN_STATE\": poEntry[\"adminState\"],\n                               \"DESC\": fexList[poEntry[\"fexId\"]][\"DESC\"],\n                               \"MEMBER_INTERFACES\": \",\".join(poEntry[\"members\"]),\n                               \"INTF_NAME\": vpcIntfName,\n                               \"PO_CONF\":poEntry[\"poConf\"]\n                              }\n                    templateList = [\n                                    \"access_vlan\", \n                                    \"porttype_fast_enable\",\n                                    \"porttype_fast_trunk\",\n                                    \"interface_ipv4_tag_11_1\"\n                                    ]\n                    configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n                    if nvPairs[\"PO_CONF\"] and configList:\n                        nvPairs[\"PO_CONF\"] = nvPairs[\"PO_CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                    elif configList:\n                        nvPairs[\"PO_CONF\"] = Util.newLine().join(configList)\n\n                    # create the vpc host PO trunk jython policy\n                    Wrapper.print(\"Creating standalone fex host PO [%s] vpc [%s] fexid [%s] policy\" % (poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                    createPTI(devSerial, nvPairs, \"int_aa_fex_standalone_11_1\", vpcIntfName, \"temp\", -1)\n                    #need to delete PTI if peer not found in the end\n                    continue\n\n                # vpc host case\n                Wrapper.print(\"AAFEX: Creating AA host PO [%s] vpc [%s] fexid [%s] policy\" %(poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                # we also need to get the vPC trunk host intf info of the peer\n                peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\",\n                                                          vpcIntfName, \"temp\",\n                                                          \"int_aa_fex_standalone_11_1\"))\n\n                peer_member_intfs = \"\"\n                peer_po_desc = \"\"\n                peer_po_conf = \"\"\n                peer_pcid = \"\"\n                peer_fex_desc = \"\"\n                peer_fex_id = \"\"\n                for peervPCpti in peerIntfvPCPTIs:\n                    peer_member_intfs = peervPCpti.getNvPairs()[\"MEMBER_INTERFACES\"]\n                    peer_fex_desc = peervPCpti.getNvPairs()[\"DESC\"]\n                    peer_fex_id =  peervPCpti.getNvPairs()[\"FEX_ID\"]\n                    peer_po_desc = peervPCpti.getNvPairs()[\"PO_DESC\"]\n                    peer_po_conf = peervPCpti.getNvPairs()[\"PO_CONF\"]\n                    discard, peer_pcid = peervPCpti.getNvPairs()[\"PO_ID\"].split(\"port-channel\")\n                    Wrapper.print(\"Deleting peer fex intf [%s] PTIs\" % peer_member_intfs)\n                    Wrapper.print(\"peer fex_desc:[%s], fex_id:[%s], po_desc:[%s], po_id:[%s]\" %\n                                  (peer_fex_desc, peer_fex_id, peer_po_desc, peer_pcid))\n                    Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n                    break\n\n                # get the vPC pair key with the internal serial1:serial2 format\n                vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n                Wrapper.print(\"AA Host PO: pair string [%s]\" % (vpcPairSerialKey))\n                serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n                nvPairs = {\"INTF_NAME\" : vpcIntfName,\n                           \"ADMIN_STATE\": poEntry[\"adminState\"],\n                           \"PEER1_PCID\": \"\",\n                           \"PEER2_PCID\": \"\",\n                           \"PEER1_MEMBER_INTERFACES\": \"\",\n                           \"PEER2_MEMBER_INTERFACES\": \"\",\n                           \"DESC\": \"\",\n                           \"PC_MODE\" : poEntry[\"poMode\"],\n                           \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"PEER1_PO_DESC\": \"\",\n                           \"PEER2_PO_DESC\": \"\",\n                           \"PEER1_PO_CONF\": \"\",\n                           \"PEER2_PO_CONF\": \"\",\n                           \"createVpc\" : \"true\",\n                           \"FEX_ID\" : \"\",\n                           \"FABRIC_NAME\" : FABRIC_NAME\n                          }\n\n                nvPairs[\"FEX_ID\"] = poEntry[\"fexId\"]\n                nvPairs[\"DESC\"] = fexList[poEntry[\"fexId\"]][\"DESC\"]\n                if (serials[0] == devSerial):\n                    nvPairs[\"PEER1_SN\"] = devSerial\n                    nvPairs[\"PEER1_PCID\"] = pcid\n                    nvPairs[\"PEER1_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                    nvPairs[\"PEER1_PO_DESC\"] = poEntry[\"poDesc\"]\n                    nvPairs[\"PEER1_PO_CONF\"] = poEntry[\"poConf\"]\n\n                    nvPairs[\"PEER2_SN\"] = peerSerial\n                    nvPairs[\"PEER2_PCID\"] = peer_pcid\n                    nvPairs[\"PEER2_MEMBER_INTERFACES\"] = peer_member_intfs\n                    nvPairs[\"PEER2_PO_DESC\"] = peer_po_desc\n                    nvPairs[\"PEER2_PO_CONF\"] = peer_po_conf\n\n                else:\n                    nvPairs[\"PEER1_SN\"] = peerSerial\n                    nvPairs[\"PEER1_PCID\"] = peer_pcid\n                    nvPairs[\"PEER1_MEMBER_INTERFACES\"] = peer_member_intfs\n                    nvPairs[\"PEER1_PO_DESC\"] = peer_po_desc\n                    nvPairs[\"PEER1_PO_CONF\"] = peer_po_conf\n\n                    nvPairs[\"PEER2_SN\"] = devSerial\n                    nvPairs[\"PEER2_PCID\"] = pcid\n                    nvPairs[\"PEER2_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                    nvPairs[\"PEER2_PO_DESC\"] = poEntry[\"poDesc\"]\n                    nvPairs[\"PEER2_PO_CONF\"] = poEntry[\"poConf\"]\n\n                Wrapper.print(\"SN:[%s] PEER_SN:[%s] - AA host nvPairs [%s]\"% (devSerial, peerSerial, nvPairs))\n\n                #Sanity to ensure valid AA fex config\n                if (nvPairs[\"PEER1_PCID\"] == \"\" or\n                    nvPairs[\"PEER2_PCID\"] == \"\" or\n                    nvPairs[\"FEX_ID\"] == \"\" ):\n                    Wrapper.print(\"Orphan AA!!! bail out\")\n                    \"\"\"\n                    respObj.setWarningRetCode()\n                    respObj.addWarnReport(getFabErrEntity(unaccountedConfigError.__name__, devSerial+ \":vpc \" +poEntry[\"vpcId\"]),\n                                  \"SN: [%s] FEX with vPC ID [%s] configuration is not correct !!! Either vPC po on Peer or FEX_ID [%s] is missing\"%\n                                  (devSerial, poEntry[\"vpcId\"], nvPairs[\"FEX_ID\"]))\n                    \"\"\"\n                    intfMatchResult.update({\"isProcessed\" : False})\n                    continue\n\n                key = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, peerSerial, vpcIntfName))\n                ignore, vpcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", devSerial, key, poEntry[\"vpcId\"]))\n                ignore, vpcRmId2 = Util.exeRM(RM.findRMDetails(FABRIC_NAME, \"VPC_ID\", key, peerSerial, poEntry[\"vpcId\"]))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s]: VPC_ID [%s] rmId [%s], peer rmId [%s]\" % (FABRIC_NAME, key, poEntry[\"vpcId\"], vpcRmId1, vpcRmId2))\n\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                ignore, pcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+pcid, pcid))\n                ignore, fexRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s] FEX_ID [%s] fexRmId [%s]\"\n                              % (FABRIC_NAME, key, pcid, \"port-channel\"+pcid, pcRmId1, poEntry[\"fexId\"], fexRmId1))\n\n                key = Util.exe(Helper.getKey(\"Device\", peerSerial))\n                ignore, pcRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+peer_pcid, peer_pcid))\n                ignore, fexRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                #Wrapper.print(\"FAB [%s] RM SET: Key [%s]: PORT_CHANNEL_ID [%s] rmId [%s] FEX_ID [%s] fexRmId [%s]\" % (FABRIC_NAME, key, peer_pcid, pcRmId2, poEntry[\"fexId\"], fexRmId2))\n\n                rmIds = [vpcRmId1] + [vpcRmId2] + [fexRmId1] + [fexRmId2]+ [pcRmId1] + [pcRmId2]\n\n                # create the AA fex vpc host PO trunk jython policy\n                Wrapper.print(\"Creating AA FEX vpc host PO [%s] vpc [%s] fexid [%s] policy\" % (poName, poEntry[\"vpcId\"], poEntry[\"fexId\"]))\n                createPTI(vpcPairSerialKey, nvPairs, \"int_port_channel_aa_fex\", vpcIntfName,\n                          getSrc(\"int_port_channel_aa_fex\"), rmIds)\n\n                sn1 = sn2 = memberIntfsPeer1 = memberIntfsPeer2 =  poPCIdPeer1 = poPCIdPeer2 = \"\"\n                if nvPairs[\"PEER1_SN\"] == devSerial:\n                    sn1 = devSerial\n                    sn2 = peerSerial\n                    memberIntfsPeer1 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                    memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                    memberIntfsPeer2 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                    memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                    poPCIdPeer1 = nvPairs[\"PEER1_PCID\"]\n                    poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n                elif nvPairs[\"PEER2_SN\"] == devSerial:\n                    sn1 = devSerial\n                    sn2 = peerSerial\n                    memberIntfsPeer1 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                    memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                    memberIntfsPeer2 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                    memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                    poPCIdPeer1 = nvPairs[\"PEER2_PCID\"]\n                    poPCIdPeer2 = nvPairs[\"PEER1_PCID\"]\n                ptiTemplate = \"int_fex_po_member_11_1\"\n                peerMatchResult, peerInterfacesRes = getSwitchMatchResults(peerSerial)\n                poMemberDescAndFFUpd(sn1, memberIntfsPeer1List, ptiTemplate, \n                                     poPCIdPeer1, matchResult, interfacesRes, vpcIntfName)\n                poMemberDescAndFFUpd(sn2, memberIntfsPeer2List, ptiTemplate,\n                                     poPCIdPeer2, peerMatchResult, peerInterfacesRes, vpcIntfName)\n            else:\n                Wrapper.print(\"====%s(): devSerial %s poEntry[%s]\"%(funcName, devSerial, poEntry))\n                # standalone fex\n                nvPairs = {\"PO_ID\" : poName,\n                           \"FEX_ID\" : poEntry[\"fexId\"],\n                           \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"PO_DESC\" : poEntry[\"poDesc\"],\n                           \"ADMIN_STATE\" : poEntry[\"adminState\"],\n                           \"DESC\" : fexList[poEntry[\"fexId\"]][\"DESC\"],\n                           \"CONF\" : poEntry[\"poConf\"],\n                           \"MEMBER_INTERFACES\" : \",\".join(poEntry[\"members\"]),\n                           \"FABRIC_NAME\" : FABRIC_NAME\n                          }\n\n                templateList = [\n                                \"access_vlan\", \n                                \"porttype_fast_enable\",\n                                \"porttype_fast_trunk\",\n                                \"interface_ipv4_tag_11_1\"\n                               ]\n                configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n                if nvPairs[\"CONF\"] and configList:\n                    nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n                elif configList:\n                    nvPairs[\"CONF\"] = Util.newLine().join(configList)\n\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]: FEX_ID [%s]\" % (FABRIC_NAME, key, pcid, poEntry[\"fexId\"]))\n                ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n                ignore, fexRmId = Util.exeRM(RM.set(FABRIC_NAME, \"FEX_ID\", key, \"fex-\"+poEntry[\"fexId\"], poEntry[\"fexId\"]))\n                rmIds = [pcRmId] + [fexRmId]\n                # create the FEX PO policy\n                Wrapper.print(\"Creating FEX [%s] policy\" % poName)\n                createPTI(devSerial, nvPairs, \"int_port_channel_fex\", poName, \"\", rmIds)\n\n                memberIntfs = nvPairs.get(\"MEMBER_INTERFACES\")\n                memberIntfsList = memberIntfs.split(\",\") if memberIntfs else []\n                ignore, poPCId = poName.split(\"port-channel\")\n                ptiTemplate = \"int_fex_po_member_11_1\"\n                poMemberDescAndFFUpd(devSerial, memberIntfsList, ptiTemplate, \n                                     poPCId, matchResult, interfacesRes, poName)\n        elif (poEntry[\"vpcId\"] != \"\"):\n\n            # check if we have the peer serial number\n            peerSerial = \"\"\n            try:\n                peerSerial = vpcPairInfo[\"peerSerialNum\"]\n            except:\n                Wrapper.print(\"vPC: peer serial # is empty. create PTIs to save vpc host info for later use\")\n                nvPairs = {\"INTF_NAME\": vpcIntfName,\n                           \"ADMIN_STATE\": poEntry[\"adminState\"],\n                           \"PEER1_MEMBER_INTERFACES\": \"\" if (len(poEntry[\"members\"]) == 0) else (\",\".join(poEntry[\"members\"])),\n                           \"PC_MODE\": poEntry[\"poMode\"],\n                           \"BPDUGUARD_ENABLED\": poEntry[\"bpduguard\"],\n                           \"MTU\": Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                           \"SPEED\": Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]),\n                           \"PO_ID\": poName,\n                           \"PO_DESC\": poEntry[\"poDesc\"],\n                           \"PO_CONF\":poEntry[\"poConf\"],\n                           \"ALLOWED_VLANS\" : poEntry[\"allowed_vlans\"],\n                           \"ACCESS_VLAN\" : poEntry[\"access_vlan\"],\n                           \"NATIVE_VLAN\" : poEntry[\"native_vlan\"],\n                           \"createVpc\": \"true\"\n                           }\n                # create the vpc host PO trunk jython policy\n                Wrapper.print(\"Creating standalone vpc host PO [%s] vpc [%s] policy\" % (poName, poEntry[\"vpcId\"]))\n                if poEntry[\"access_port\"]:\n                    templateName = \"int_vpc_access_host_standalone_11_1\"\n                else:\n                    nvPairs[\"NATIVE_VLAN\"] = poEntry[\"native_vlan\"] if poEntry[\"native_vlan\"] != \"\" else \"1\"\n                    templateName = \"int_vpc_trunk_host_standalone_11_1\"\n                createPTI(devSerial, nvPairs, templateName, vpcIntfName, \"temp\", -1)\n                #need to delete PTI if peer not found in the end\n                continue\n\n            # vpc host case\n            Wrapper.print(\"Switch [%s] : vPC: Creating vpc host PO [%s] vpc [%s] policy\" % (devSerial, poName, poEntry[\"vpcId\"]))\n            # we also need to get the vPC host intf info of the peer\n            if poEntry[\"access_port\"]:\n                templateName = \"int_vpc_access_host_standalone_11_1\"\n            else:\n                templateName = \"int_vpc_trunk_host_standalone_11_1\"\n            peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\", vpcIntfName, \"temp\", templateName))\n\n            peer_member_intfs = \"\"\n            peer_po_desc = \"\"\n            peer_po_conf = \"\"\n            peer_pcid = \"\"\n            peer_po_mtu = \"\"\n            peer_po_speed = \"Auto\"\n            peer_allowed_vlan = \"all\"\n            peer_access_vlan = \"\"\n            peer_native_vlan = \"\"\n            po_mode = poEntry[\"poMode\"]\n            for peervPCpti in peerIntfvPCPTIs:\n                peerNvPairs = peervPCpti.getNvPairs()\n                peer_member_intfs = peerNvPairs[\"PEER1_MEMBER_INTERFACES\"]\n                if len(peer_member_intfs) > 0:\n                    # the po mode must be valid on the peer.. use that\n                    po_mode = peerNvPairs[\"PC_MODE\"]\n                peer_po_desc = peerNvPairs[\"PO_DESC\"]\n                peer_po_conf = peerNvPairs[\"PO_CONF\"]\n                peer_po_mtu = peerNvPairs[\"MTU\"]\n                peer_po_speed = peerNvPairs[\"SPEED\"]\n                discard, peer_pcid = peerNvPairs[\"PO_ID\"].split(\"port-channel\")\n                peer_allowed_vlan = peerNvPairs[\"ALLOWED_VLANS\"]\n                peer_access_vlan = peerNvPairs[\"ACCESS_VLAN\"]\n                peer_native_vlan = peerNvPairs[\"NATIVE_VLAN\"]\n                Wrapper.print(\"Deleting peer vpc intf [%s] PTIs\" % peer_member_intfs)\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n                break\n\n            # get the vPC pair key with the internal serial1:serial2 format\n            vpcPairSerialKey = Util.exe(Helper.getKey(\"DevicePair\", devSerial, peerSerial))\n            Wrapper.print(\"vPC Host PO: pair string [%s]\" % (vpcPairSerialKey))\n            serials = vpcPairSerialKey.split(Helper.DELIMITER)\n\n            # Check the vPC port-channel speed config between the vPC peers.\n            # If not the same, add the speed config to the interface freeform and let users fix the config.\n            # Set the SPEED param to \"Auto\" so that no interface_speed policy will be created for the po.\n            addSpeedConfig = []\n            peerAddSpeedConfig = []\n            if Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]) == peer_po_speed:\n                vpcSpeed = peer_po_speed\n            else:\n                vpcSpeed = \"Auto\"\n                if poEntry[\"speed\"] != \"auto\":\n                    addSpeedConfig.append(\"%sspeed %s\" %(INTF_FIRST_LVL_SPACING, poEntry[\"speed\"]))\n                if peer_po_speed != \"Auto\":\n                    peerAddSpeedConfig.append(\"%sspeed %s\" %(INTF_FIRST_LVL_SPACING, Util.mapEnumToSwitchSpeed(peer_po_speed)))\n            \n            nvPairs = {\"INTF_NAME\" : vpcIntfName,\n                       \"ENABLE_MIRROR_CONFIG\": \"false\",\n                       \"ADMIN_STATE\": poEntry[\"adminState\"],\n                       \"PEER1_PCID\": \"\",\n                       \"PEER2_PCID\": \"\",\n                       \"PEER1_MEMBER_INTERFACES\": \"\",\n                       \"PEER2_MEMBER_INTERFACES\": \"\",\n                       \"PEER1_PO_DESC\": \"\",\n                       \"PEER2_PO_DESC\": \"\",\n                       \"PEER1_PO_CONF\": \"\",\n                       \"PEER2_PO_CONF\": \"\",\n                       \"PC_MODE\" : po_mode,\n                       \"BPDUGUARD_ENABLED\": poEntry[\"bpduguard\"],\n                       \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                       \"SPEED\": vpcSpeed,\n                       \"createVpc\" : \"true\"\n                      }\n\n            if (serials[0] == devSerial):\n                nvPairs[\"PEER1_SN\"] = devSerial\n                nvPairs[\"PEER1_PCID\"] = pcid\n                nvPairs[\"PEER1_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                nvPairs[\"PEER1_PO_DESC\"] = poEntry[\"poDesc\"]\n                nvPairs[\"PEER1_ALLOWED_VLANS\"] = poEntry[\"allowed_vlans\"]\n                nvPairs[\"PEER1_ACCESS_VLAN\"] = poEntry[\"access_vlan\"]\n                nvPairs[\"PEER1_NATIVE_VLAN\"] = \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"]\n                nvPairs[\"PEER1_PO_CONF\"] = poEntry[\"poConf\"] \n                if addSpeedConfig:\n                    nvPairs[\"PEER1_PO_CONF\"] = nvPairs[\"PEER1_PO_CONF\"] + Util.newLine() + Util.newLine().join(addSpeedConfig)\n\n                nvPairs[\"PEER2_SN\"] = peerSerial\n                nvPairs[\"PEER2_PCID\"] = peer_pcid\n                nvPairs[\"PEER2_MEMBER_INTERFACES\"] = peer_member_intfs\n                nvPairs[\"PEER2_PO_DESC\"] = peer_po_desc\n                nvPairs[\"PEER2_ALLOWED_VLANS\"] = peer_allowed_vlan\n                nvPairs[\"PEER2_ACCESS_VLAN\"] = peer_access_vlan\n                nvPairs[\"PEER2_NATIVE_VLAN\"] = \"\" if peer_native_vlan == \"1\" else peer_native_vlan\n                nvPairs[\"PEER2_PO_CONF\"] = peer_po_conf\n                if peerAddSpeedConfig:\n                    nvPairs[\"PEER2_PO_CONF\"] = nvPairs[\"PEER2_PO_CONF\"] + Util.newLine() + Util.newLine().join(peerAddSpeedConfig)\n            else:\n                nvPairs[\"PEER1_SN\"] = peerSerial\n                nvPairs[\"PEER1_PCID\"] = peer_pcid\n                nvPairs[\"PEER1_MEMBER_INTERFACES\"] = peer_member_intfs\n                nvPairs[\"PEER1_PO_DESC\"] = peer_po_desc\n                nvPairs[\"PEER1_ALLOWED_VLANS\"] = peer_allowed_vlan\n                nvPairs[\"PEER1_ACCESS_VLAN\"] = peer_access_vlan\n                nvPairs[\"PEER1_NATIVE_VLAN\"] = \"\" if peer_native_vlan == \"1\" else peer_native_vlan\n                nvPairs[\"PEER1_PO_CONF\"] = peer_po_conf\n                if peerAddSpeedConfig:\n                    nvPairs[\"PEER1_PO_CONF\"] = nvPairs[\"PEER1_PO_CONF\"] + Util.newLine() + Util.newLine().join(peerAddSpeedConfig)\n\n                nvPairs[\"PEER2_SN\"] = devSerial\n                nvPairs[\"PEER2_PCID\"] = pcid\n                nvPairs[\"PEER2_MEMBER_INTERFACES\"] = \",\".join(poEntry[\"members\"])\n                nvPairs[\"PEER2_PO_DESC\"] = poEntry[\"poDesc\"]\n                nvPairs[\"PEER2_ALLOWED_VLANS\"] = poEntry[\"allowed_vlans\"]\n                nvPairs[\"PEER2_ACCESS_VLAN\"] = poEntry[\"access_vlan\"]\n                nvPairs[\"PEER2_NATIVE_VLAN\"] = \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"]\n                nvPairs[\"PEER2_PO_CONF\"] = poEntry[\"poConf\"] \n                if addSpeedConfig:\n                    nvPairs[\"PEER2_PO_CONF\"] = nvPairs[\"PEER2_PO_CONF\"] + Util.newLine() + Util.newLine().join(addSpeedConfig)\n            Wrapper.print(\"SN:[%s] PEER_SN:[%s] - vPC host nvPairs [%s]\"% (devSerial, peerSerial, nvPairs))\n\n            #Sanity to ensure valid vPC host config\n            if (nvPairs[\"PEER1_PCID\"] == \"\" or\n                nvPairs[\"PEER2_PCID\"] == \"\" ):\n                Wrapper.print(\"Orphan vPC host!!! bail out\")\n                \"\"\"\n                respObj.setWarningRetCode()\n                respObj.addWarnReport(getFabErrEntity(unaccountedConfigError.__name__, devSerial+ \":vpc \" +poEntry[\"vpcId\"]),\n                                      \"SN: [%s] vpc [%s] configuration is not correct !!! peer vpc po is missing\"%\n                                      (devSerial, poEntry[\"vpcId\"]))\n                \"\"\"\n                intfMatchResult.update({\"isProcessed\" : False})\n                continue\n\n            entityName = Util.exe(Helper.getKey(\"DeviceInterface\", devSerial, peerSerial, vpcIntfName))\n            ignore, vpcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", devSerial, entityName, poEntry[\"vpcId\"]))\n            ignore, vpcRmId2 = Util.exeRM(RM.findRMDetails(FABRIC_NAME, \"VPC_ID\", entityName, peerSerial, poEntry[\"vpcId\"]))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s]: VPC_ID [%s] rmId [%s] peer rmId [%s]\" % (FABRIC_NAME, entityName, poEntry[\"vpcId\"], vpcRmId1, vpcRmId2))\n\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            ignore, pcRmId1 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s]\" % (FABRIC_NAME, key, pcid, poName, pcRmId1))\n\n            key = Util.exe(Helper.getKey(\"Device\", peerSerial))\n            ignore, pcRmId2 = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, \"port-channel\"+peer_pcid, peer_pcid))\n            Wrapper.print(\"FAB [%s] RM SET: Key [%s] PORT_CHANNEL_ID [%s], poName [%s] rmId [%s]\" % (FABRIC_NAME, key, pcid, \"port-channel\"+peer_pcid, pcRmId2))\n\n            rmIds = [vpcRmId1] + [vpcRmId2] + [pcRmId1] + [pcRmId2]\n            \n            # create the vpc host PO trunk jython policy\n            #Wrapper.print(\"Creating vpc host PO [%s] vpc [%s] policy\" % (poName, poEntry[\"vpcId\"]))\n            if poEntry[\"access_port\"]:\n                if poEntry[\"dot1q_tunnel\"]:\n                    templateName = \"int_vpc_dot1q_tunnel\"\n                    ptiTemplate = \"int_vpc_dot1q_tunnel_po_member_11_1\"\n                else:\n                    templateName = \"int_vpc_access_host\"\n                    ptiTemplate = \"int_vpc_access_po_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_enable\"]\n            else:\n                templateName = \"int_vpc_trunk_host\"\n                ptiTemplate = \"int_vpc_trunk_po_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_trunk\"]\n                  \n            createPTI(vpcPairSerialKey, nvPairs, templateName, vpcIntfName, getSrc(templateName), rmIds)\n\n            sn1 = sn2 = memberIntfsPeer1 = memberIntfsPeer2 =  poPCIdPeer1 = poPCIdPeer2 = \"\"\n            if nvPairs[\"PEER1_SN\"] == devSerial:\n                sn1 = devSerial\n                sn2 = peerSerial\n                memberIntfsPeer1 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                memberIntfsPeer2 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                poPCIdPeer1 = nvPairs[\"PEER1_PCID\"]\n                poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n            elif nvPairs[\"PEER2_SN\"] == devSerial:\n                sn1 = devSerial\n                sn2 = peerSerial\n                memberIntfsPeer1 = nvPairs.get(\"PEER2_MEMBER_INTERFACES\")\n                memberIntfsPeer1List = memberIntfsPeer1.split(\",\") if memberIntfsPeer1 else []\n                memberIntfsPeer2 = nvPairs.get(\"PEER1_MEMBER_INTERFACES\")\n                memberIntfsPeer2List = memberIntfsPeer2.split(\",\") if memberIntfsPeer2 else []\n                poPCIdPeer2 = nvPairs[\"PEER2_PCID\"]\n                poPCIdPeer2 = nvPairs[\"PEER1_PCID\"]\n            \n            peerMatchResult, peerInterfacesRes = getSwitchMatchResults(peerSerial)\n            poMemberDescAndFFUpd(sn1, memberIntfsPeer1List, ptiTemplate, \n                                 poPCIdPeer1, matchResult, interfacesRes, vpcIntfName)\n            poMemberDescAndFFUpd(sn2, memberIntfsPeer2List, ptiTemplate, \n                                 poPCIdPeer2, peerMatchResult, peerInterfacesRes, vpcIntfName)\n        elif isL3Po or isL3SubIfPo:\n            # regular PO case\n            Wrapper.print(\"FAB [%s]: isL3Po [%s] isL3SubIfPo [%s], create l3 po for [%r]\" % (FABRIC_NAME, isL3Po, isL3SubIfPo, poEntry))\n            nvPairs = {\n                       \"INTF_VRF\"       : poEntry[\"vrf\"],\n                       \"IP\"             : poEntry[\"ip4\"],\n                       \"PREFIX\"         : poEntry[\"prefix4\"],\n                       \"IPv6\"           : poEntry[\"ip6\"],\n                       \"IPv6_PREFIX\"    : poEntry[\"prefix6\"],\n                       \"ROUTING_TAG\"    : poEntry[\"tag\"],\n                       \"MTU\"            : poEntry[\"mtu\"],\n                       \"SPEED\"          : Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]),\n                       \"DESC\"           : poEntry[\"poDesc\"],\n                       \"ADMIN_STATE\"    : poEntry[\"adminState\"],\n                       \"CONF\"           : poEntry[\"poConf\"],\n                      }\n            pcRmId = -1\n            if not isL3SubIfPo:\n                nvPairs.update({\"PO_ID\": poName})\n                nvPairs.update({\"PC_MODE\": poEntry[\"poMode\"]})\n                nvPairs.update({\"MEMBER_INTERFACES\" : \"\" if (len(poEntry[\"members\"]) == 0) else (\",\".join(poEntry[\"members\"]))})\n                nvPairs.update({\"SPEED\": Util.mapSwitchSpeedToEnum(poEntry[\"speed\"])})\n                key = Util.exe(Helper.getKey(\"Device\", devSerial))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]\" % (FABRIC_NAME, key, pcid))\n                ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n                Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]: PC rmId [%s]\" % (FABRIC_NAME, key, pcid, pcRmId))\n            else:\n                nvPairs.update({\"INTF_NAME\": poName})\n                dot1qVlan = poEntry[\"dot1qVlan\"]\n                nvPairs.update({\"VLAN\": dot1qVlan})\n                rmIds = [setDot1qRMResource(fabricName, devSerial, poName, dot1qVlan)]\n                Wrapper.print(\"%s: Switch [%s] poName [%s] dot1qVlan [%s] rmIds [%s]\" % (funcName, devSerial, poName, dot1qVlan, rmIds))\n\n            # create the L3 Port-channel jython policy\n            Wrapper.print(\"Creating L3 PO [%s] policy\" % poName)\n            templateList = [\n                            \"cdp_disable_interface_11_1\",\n                            \"interface_no_nego_auto\",\n                            \"isis_interface\",\n                            \"v6_isis_interface\",\n                            \"ospf_interface_11_1\",\n                            \"v6_ospf_interface\",\n                            \"ospf_p2p_interface\",\n                            \"isis_p2p_interface\",\n                            \"pim_interface\",\n                            \"ospf_interface_auth\",\n                            \"pim_interface_hello_auth\",\n                            \"isis_interface_auth\",\n                            \"isis_interface_auth_no_lvl\",\n                            \"routed_interface_no_ip_redirects\",\n                            \"bfd_interface_auth\",\n                           ]\n            if not isL3SubIfPo:\n                templateName = \"int_l3_port_channel\"\n                ptiTemplate  = \"int_l3_port_channel_member\"\n            else:\n                templateName = \"int_subif\"\n\n            configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n            Wrapper.print(\"device [%s] Interface [%s] nvPairs [%s] freeform config[%s]\"%(devSerial, poName,nvPairs, nvPairs.get(\"CONF\")))\n            createPTI(devSerial, nvPairs, templateName, poName, getSrc(templateName), pcRmId)\n\n            if not isL3SubIfPo:\n                memberIntfs = nvPairs.get(\"MEMBER_INTERFACES\")\n                memberIntfsList = memberIntfs.split(\",\") if memberIntfs else []\n                ignore, poPCId = poName.split(\"port-channel\")\n                poMemberDescAndFFUpd(devSerial, memberIntfsList, ptiTemplate, \n                                     poPCId, matchResult, interfacesRes, poName)\n        else:\n            # regular L2 PO case\n            nvPairs = {\"PO_ID\" : poName, \"PC_MODE\" : poEntry[\"poMode\"],\n                       \"MTU\" : Util.getHostIntfMTUStrFromParsedInfo(poEntry[\"mtu\"]),\n                       \"SPEED\": Util.mapSwitchSpeedToEnum(poEntry[\"speed\"]),\n                       \"DESC\" : poEntry[\"poDesc\"],\n                       \"ENABLE_ORPHAN_PORT\" : poEntry[\"orphanPort\"],\n                       \"ADMIN_STATE\" : poEntry[\"adminState\"],\n                       \"BPDUGUARD_ENABLED\" : poEntry[\"bpduguard\"],\n                       \"ALLOWED_VLANS\" : poEntry[\"allowed_vlans\"],\n                       \"PORTTYPE_FAST_ENABLED\": poEntry[\"porttype_fast_enable\"],\n                       \"ACCESS_VLAN\" : poEntry[\"access_vlan\"],\n                       \"NATIVE_VLAN\" : \"\" if poEntry[\"native_vlan\"] == \"1\" else poEntry[\"native_vlan\"],\n                       \"CONF\" : poEntry[\"poConf\"],\n                       \"MEMBER_INTERFACES\" : \",\".join(poEntry[\"members\"])\n                      }\n\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]\" % (FABRIC_NAME, key, pcid))\n            ignore, pcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", key, poName, pcid))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: PORT_CHANNEL_ID [%s]: rmId [%s]\" % (FABRIC_NAME, key, pcid, pcRmId))\n\n            # create the host PO trunk jython policy\n            Wrapper.print(\"Creating PO [%s] policy\" % poName)\n            templateList = [\n                            \"interface_ipv4_tag_11_1\",\n                           ]\n            if poEntry[\"access_port\"]:\n                templateList.append(\"porttype_fast_trunk\")\n                if poEntry[\"dot1q_tunnel\"]:\n                    templateName = \"int_port_channel_dot1q_tunnel_host\"\n                    ptiTemplate = \"int_port_channel_dot1q_tunnel_member_11_1\"\n                else:\n                    templateName = \"int_port_channel_access_host\"\n                    ptiTemplate = \"int_port_channel_access_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_enable\"]\n            else:\n                templateList.append(\"access_vlan\") \n                templateList.append(\"porttype_fast_enable\")\n                templateName = \"int_port_channel_trunk_host\"\n                ptiTemplate = \"int_port_channel_trunk_member_11_1\"\n                nvPairs[\"PORTTYPE_FAST_ENABLED\"] = poEntry[\"porttype_fast_trunk\"]\n                \n            configList = unaccCfgFromTemplates(poName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n            Wrapper.print(\"device [%s] Interface [%s] freeform config[%s]\"%(devSerial, poName, nvPairs.get(\"CONF\")))\n            createPTI(devSerial, nvPairs, templateName, poName, getSrc(templateName), pcRmId)\n\n            memberIntfs = nvPairs.get(\"MEMBER_INTERFACES\")\n            memberIntfsList = memberIntfs.split(\",\") if memberIntfs else []\n            ignore, poPCId = poName.split(\"port-channel\")\n            poMemberDescAndFFUpd(devSerial, memberIntfsList, ptiTemplate, \n                                 poPCId, matchResult, interfacesRes, poName)\n    # delete dangling standalone vpc PTI.\n    peerSerial = \"\"\n    try:\n        peerSerial = vpcPairInfo[\"peerSerialNum\"]\n    except:\n        pass\n    if peerSerial:\n        peerIntfvPCPTIs = Util.exe(PTIWrapper.get(peerSerial, \"temp\"))\n        for peervPCpti in peerIntfvPCPTIs:\n            vpcIntf = peervPCpti.getEntityName()\n            Wrapper.print(\"Standalone AA/vPC host policy found with %s\"%(vpcIntf))\n            if vpcIntf:\n                ptiListPeer1 = Util.exe(PTIWrapper.get(devSerial, \"INTERFACE\", vpcIntf))\n                ptiListPeer2 = Util.exe(PTIWrapper.get(peerSerial, \"INTERFACE\", vpcIntf))\n                po1 = ptiListPeer1[0].nvPairs.get(\"PO_ID\") if ptiListPeer1 else \"\"\n                po2 = ptiListPeer2[0].nvPairs.get(\"PO_ID\") if ptiListPeer2 else \"\"\n                Wrapper.print(\"vpc [%s] with po1 [%s] and po2 [%s]\"%(vpcIntf, po1, po2))\n                if not ptiListPeer1 or not ptiListPeer2:\n                    errorEntity = getFabErrEntity(funcName, devSerial+ \":vpc \" + peerSerial)\n                    Wrapper.print(\"vpcPair %s:%s - doesn't have proper vpc id %s or port-channel configuration \"\n                                  \"for interface %s,%s \"%(devSerial, peerSerial, vpcIntf.strip(\"vPC\"), po1, po2))\n                    #respObj.setWarningRetCode()\n                    #respObj.addWarnReport(errorEntity, \"vpcPair %s:%s - doesn't have proper vpc id %s or port-channel configuration \"\n            if peervPCpti.getTemplateName() == \"int_aa_fex_standalone_11_1\":\n                Wrapper.print(\"deleting AA standalone host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n            if peervPCpti.getTemplateName() == \"int_vpc_trunk_host_standalone_11_1\":\n                Wrapper.print(\"deleting vPC standalone trunk host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n            if peervPCpti.getTemplateName() == \"int_vpc_access_host_standalone_11_1\":\n                Wrapper.print(\"deleting vPC standalone access host PO Policy\")\n                Util.exe(PTIWrapper.deleteInstance(peervPCpti.getPolicyId()))\n\n    # process rest of the interfaces\n    for intfName in sorted(interfacesRes.keys()):\n        lowerIntfName = intfName.lower()\n        intfMatchResult = interfacesRes[intfName]\n        Wrapper.print(\"Processing intf [%s]. Processed = %r\" % \n                      (intfName, isIntfProcessed(intfMatchResult)))\n\n        if isIntfProcessed(intfMatchResult):\n            continue\n\n        templateNameMatches = intfMatchResult[\"matched_templates\"]\n        # remove some mutually exclusive matches\n        if (\"trunk_interface\" in templateNameMatches):\n            if (\"trunk_interface_fex\" in templateNameMatches):\n                # we will delete this since it is redundant\n                templateNameMatches.remove(\"trunk_interface\")\n\n        #Wrapper.print(\"%s(): Matched templates [%s]\"%(funcName, templateNameMatches))\n        matchingNvPairs = getIntfMatchNvPairs(matchResult, intfName, templateNameMatches)\n\n        #TODO:Revisit for scenarios where access/agg may be connected without port-channels\n        if ((intfName in allFabricInterfaces) and (intfName not in vpcLinkMemberInterfaces)):\n            # processs the fabric interfaces\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is fabric interface, marked as processed at line [%s]\"%(intfName,\n                sys._getframe().f_lineno))\n            continue\n          \n        #TODO: Handle Vlan 1 for ECL fabrics\n        if (lowerIntfName.startswith(\"vlan\")):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            ignore, rmId = Util.exeRM(RM.set(FABRIC_NAME, \"TOP_DOWN_NETWORK_VLAN\", key, lowerIntfName, lowerIntfName[4:]))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: TOP_DOWN_NETWORK_VLAN [%s] intfName [%s] rmId [%s]\" %\n                          (FABRIC_NAME, key, lowerIntfName[4:], lowerIntfName, rmId))\n            nvPairs = getVlanIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n            createPTI(devSerial, nvPairs, \"int_vlan\", intfName, getSrc(\"int_vlan\"), rmId)\n            continue\n        elif (intfName.startswith(\"mgmt\")):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getMgmtIntfNvpairs(switchInfo, intfName, matchingNvPairs)\n            PTIWrapper.createOrUpdate(devSerial, \"INTERFACE\", intfName, \"\", ConfigPriority.INTF_MGMT,\n                                \"int_mgmt\", nvPairs)\n            continue\n        elif ((\"p2p_routed_interface\" in templateNameMatches or \"interface_ipv6_11_1\" in templateNameMatches) and\n              (intfName in vpcLinkMemberInterfaces)):\n            # this is a vpc peer keep alive interface\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is vpc peer keep alive interface, marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getFabricIntfNvPairs(FABRIC_NAME, devSerial, intfName, matchingNvPairs, \n                                           LINK_STATE_ROUTING, REPLICATION_MODE, \n                                           intfMatchResult, matchResult, True)\n            nvPairs[\"IS_COMPLETE\"] = \"false\"\n            nvPairs[\"RMID_LIST\"] = \"\"\n            # check to see if the peer device is in the topology and get its details\n            peerIntf, peerSerialNum = getPoPeerDeviceSN(topologyDataObj, devSerial, intfName)\n            dictObj = {}\n            dictObj[\"FABRIC_NAME\"] = FABRIC_NAME\n            dictObj[\"FABRIC_INTERFACE\"] = FABRIC_NAME\n            dictObj[\"localSerialNum\"] = devSerial\n            dictObj[\"localIntfName\"] = intfName\n            dictObj[\"peerSerialNum\"] = peerSerialNum\n            dictObj[\"peerIntfName\"] = peerIntf\n            dictObj[\"localHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, devSerial)\n            dictObj[\"peerHostName\"] = topologyDataObj.get(TopologyInfoType.HOSTNAME, peerSerialNum)\n            dictObj[\"linkNbrList\"] = linkNbrList\n\n            templateList = [\n                        \"interface_speed\",\n                        \"interface_no_nego_auto\",\n                        \"interface_ipv4_tag_11_1\",\n                        \"interface_ipv6_tag_11_1\",\n                        \"cdp_disable_interface_11_1\",\n                        \"routed_interface_no_ip_redirects\"\n                        ]\n            configList = unaccCfgFromTemplates(intfName, templateList, intfMatchResult, matchResult)\n            if nvPairs[\"CONF\"] and configList:\n                nvPairs[\"CONF\"] = nvPairs[\"CONF\"] + Util.newLine() + Util.newLine().join(configList) \n            elif configList:\n                nvPairs[\"CONF\"] = Util.newLine().join(configList)\n\n            dictObj[\"localNvPairs\"] = nvPairs\n            Util.exe(manageVPCPKAIntf(dictObj))\n            continue\n        elif (intfName.startswith(\"loopback\")):\n            #TODO: Need to handle loopback interface properly with IP/ID in RM tracked for BF for both default and non-default VRF\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # get the id\n            loopbackId = intfName[8:]\n            #Wrapper.print(\"Found loopback ID: [%s]\" % loopbackId)\n\n            rmId = -1\n            key = Util.exe(Helper.getKey(\"Device\", devSerial))\n            ignore, rmId = Util.exeRM(RM.set(FABRIC_NAME, \"LOOPBACK_ID\", key, intfName, loopbackId))\n            Wrapper.print(\"FAB [%s]: RM SET: Key [%s]: LOOPBACK_ID [%s] intfName [%s] rmId [%s]\" %\n                          (FABRIC_NAME, key, loopbackId, intfName, rmId))\n            createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME, rmId)\n            continue\n        elif (\"access_interface\" in templateNameMatches or \n              \"access_interface_fex\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the host port jython policy\n            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            templateName = \"int_access_host\"\n            createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n            continue\n        elif (\"dot1q_tunnel_interface\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the host port jython policy\n            nvPairs = getAccessIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            templateName = \"int_dot1q_tunnel_host\"\n            createPTI(devSerial, nvPairs, templateName, intfName, getSrc(templateName), -1)\n            continue\n        elif ((\"trunk_interface\" in templateNameMatches) or\n              (\"trunk_interface_fex\" in templateNameMatches)):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            nvPairs = getTrunkIntfNvpairs(switchInfo, intfName, matchingNvPairs, globalOverlayInfo, device_overlay_vlans)\n            createPTI(devSerial, nvPairs, \"int_trunk_host\", intfName, getSrc(\"int_trunk_host\"), -1)\n            continue\n        elif (\"routed_interface\" in templateNameMatches):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Routed Intf: [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n            createRoutedIntf(switchInfo, intfName, matchingNvPairs, True)\n            continue\n        elif ((\"eth_sub_interface\" in templateNameMatches) or\n              (\"eth_sub_interface_tag\" in templateNameMatches)):\n            # mark the interface as being processed\n            intfMatchResult.update({\"isProcessed\" : True})\n            Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n            # create the sub-interface jython policy\n            Wrapper.print(\"Creating Sub-interface policy for [%s]\" % intfName)\n            dot1qID, nvPairs = getSubIntfNvPairs(switchInfo, intfName, matchingNvPairs)\n            if dot1qID:\n                Wrapper.print(\"%s: Switch [%s] intfName [%s] dot1qID [%s] \" % (funcName, devSerial, intfName, dot1qID))\n                rmId = setDot1qRMResource(fabricName, devSerial, intfName, dot1qID)\n            createPTI(devSerial, nvPairs, \"int_subif\", intfName, getSrc(\"int_subif\"), rmId)\n            continue\n        else:\n            createFreeformIntfPolicy(switchInfo, intfName, matchingNvPairs, FABRIC_NAME)\n\n        # mark the interface as being processed\n        intfMatchResult.update({\"isProcessed\" : True})\n        Wrapper.print(\"Interface [%s] is marked as processed at line [%s]\"%(intfName, sys._getframe().f_lineno))\n\n    Wrapper.print(\"%s: [%s] Success = [%r]\" % (funcName, fmtName, respObj.isRetCodeSuccess()))\n    return respObj\n\n# \n# Determine the connectivity between access & agg switches. \n# Topologies to be handled: \n# 1. vPC access attached to vPC agg (topo 4)\n# 2. standalone access dual-attached to vPC agg (topo 2)\n# 3. standalone access single attached via eth/trunk to one of the vPC agg peers (topo 3a)\n# 4. standalone access single attached via layer-2 port-channel/trunk to one of the vPC agg peers (topo 3b)\n#\ndef accessAggPairingBF(topologyDataObj, respObj):\n    try:\n        funcName = sys._getframe(0).f_code.co_name\n\n        Wrapper.print(\"=========== %s ========\" % (funcName))\n\n        aggs = topologyDataObj.get(TopologyInfoType.AGGS)\n        if not aggs:\n            Wrapper.print(\"%s: No aggregations in the fabric, skip\")\n            respObj.setSuccessRetCode()\n            return respObj\n\n        # access device that peers with the agg vpc peer.\n        # Access in this list will be ignored if it has been processed for auto-pair already\n        # either because of its vpc peer, or it was processed by a previous agg\n        accessPairedList = []\n\n        for aggSn in aggs:\n\n            aggVpcPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, FABRIC_NAME, aggSn))\n\n            Wrapper.print(\"%s: aggSn %s, vpc peer %s\" % (funcName, aggSn, aggVpcPeerSn))\n\n            linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, aggSn, Helper.getNbrTypeInternal()))\n\n            for nbrLink in linkNbrList:\n                if nbrLink[\"link-type\"] not in [\"ethisl\", \"lan_planned_link\"]:\n                    Wrapper.print(\"%s: Link for node: %s is not ethisl or lan_planned_link: %s IGNORE\" %\n                                    (funcName, aggSn, nbrLink[\"link-type\"]))\n                    continue\n\n                sw1_sn, sw2_sn = getSNsFromNbrList(nbrLink)\n\n                if sw1_sn == aggSn:\n                    nbrSn = sw2_sn\n                else:\n                    nbrSn = sw1_sn\n\n                nbrSwitchRole = topologyDataObj.getSwitchRole(nbrSn)\n                if nbrSwitchRole != \"access\":\n                    Wrapper.print(\"%s: skip %s role %s\" % (funcName, nbrSn, nbrSwitchRole))\n                    continue\n\n                if nbrSn in accessPairedList:\n                    Wrapper.print(\"%s: %s already paired, skip\" % (funcName, nbrSn))\n                    continue\n\n                device_fabric_name = Util.exe(InventoryWrapper.getFabricNameForSwitch(nbrSn))\n                if device_fabric_name != FABRIC_NAME:\n                    Wrapper.print(\"%s: skip %s in fabric %s\" % (funcName, nbrSn, device_fabric_name))\n                    continue\n\n                Util.exe(handleOneAccessAggPairingBF(topologyDataObj, nbrSn, aggSn, aggVpcPeerSn, accessPairedList, respObj))\n                accessPairedList.append(nbrSn)\n\n        Wrapper.print(\"%s: end of pairing, paired list %s\" % (funcName, accessPairedList))\n\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef handleOneAccessAggPairingBF(topologyDataObj, accessSn, aggSn, aggPeerSn, accessPairedList, respObj):\n    try:\n        funcName = sys._getframe(0).f_code.co_name\n        Wrapper.print(\"%s:%s agg <%s, %s>\" % (funcName, accessSn, aggSn, aggPeerSn))\n\n        isAccessVpc = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, accessSn))\n        if isAccessVpc:\n            # topology 4\n            accessVpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, accessSn))\n            aggSnPaired = Util.exe(ToRWrapper.getTorAssociation(accessVpcPairSerialKey))\n\n            accessPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, FABRIC_NAME, accessSn))\n\n            if aggSnPaired and aggSn in aggSnPaired:\n                # Access VPC already paired with agg VPC, no change\n                Wrapper.print(\"%s: topo #4, pair present <%s, %s> - <%s, %s>, no change\" % (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n                accessPairedList.append(accessPeerSn)\n                return respObj\n\n            # pair (accessSn, accessPeerSn) with (aggSn, aggPeerSn)\n            Wrapper.print(\"%s: topo #4, pair <%s, %s> - <%s, %s>\" %\n                           (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n            Util.exe(addAccessAggPairingBF(aggSn, aggPeerSn, accessSn, accessPeerSn, respObj))\n            accessPairedList.append(accessPeerSn)\n        else:\n            accessPeerSn = \"\"\n            aggSnPaired = Util.exe(ToRWrapper.getTorAssociation(accessSn))\n            aggVpcPeerConnected = isSwitchConnected(topologyDataObj, accessSn, aggPeerSn)\n\n            Wrapper.print(\"%s:%s aggSnPaired %s, aggVpcPeerConnected %s\" % (funcName, accessSn, aggSnPaired, aggVpcPeerConnected))\n            if aggSnPaired and aggSn in aggSnPaired:\n                # Access is already paired with agg, no change\n                Wrapper.print(\"%s: topo #2 or #3 <%s, %s> - <%s, %s>, no change but should not come here!\" % (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n                return respObj\n                \n            if aggVpcPeerConnected:\n                # topology 2, pair (accessSn) with (aggSn, aggPeerSn)\n                Wrapper.print(\"%s: topo #2, pair <%s, %s> - <%s>\" % (funcName, aggSn, aggPeerSn, accessSn))\n                Util.exe(addAccessAggPairingBF(aggSn, aggPeerSn, accessSn, \"\", respObj))\n            else:\n                # topology 3, pair (accessSn) with (aggSn)\n                Wrapper.print(\"%s: topo #3, pair <%s> - <%s>\" % (funcName, aggSn, accessSn))\n                Util.exe(addAccessAggPairingBF(aggSn, \"\", accessSn, \"\", respObj))\n\n        return respObj\n    except respObjError as e:\n        return e.value\n\ndef addAccessAggPairingBF(aggSn, aggPeerSn, accessSn, accessPeerSn, respObj):\n    try:\n        funcName = sys._getframe(0).f_code.co_name\n        Wrapper.print(\"%s <%s,%s>: <%s, %s>\"% (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n\n        # re-order aggSn/aggPeerSn, accessSn/accessPeerSn if order matters\n        if accessPeerSn:\n            if accessSn < accessPeerSn:\n                accessSNs = accessSn + \",\" + accessPeerSn\n            else:\n                accessSNs = accessPeerSn + \",\" + accessSn\n        else:\n            accessSNs = accessSn\n\n        torImpl = TorImpl()\n        one_entry = ToRLeaf()\n        pairing_data = []\n\n        one_entry.setLeafSN(aggSn)\n        one_entry.setTorSNs(accessSNs)\n        pairing_data.append(one_entry)\n\n        if aggPeerSn:\n            second_entry = ToRLeaf()\n            second_entry.setLeafSN(aggPeerSn)\n            second_entry.setTorSNs(accessSNs)\n            pairing_data.append(second_entry)\n\n        Wrapper.print(\"pairing_data %s\"% pairing_data)\n        torImpl.insertOrUpdateTorPair(FABRIC_NAME, pairing_data)\n\n        return respObj\n    except respObjError as e:\n        return e.value\n\n#For a given network and a given agg device, this function should return the list of all ports attached to the network \n#on the access devices that are paired with this agg device. \n#This goes into the \"torPorts\" parameter during network attach for this agg\ndef getAggTorPorts(topologyDataObj, aggSn, networkId, respObj, globalOverlayInfo):\n    try:\n        funcName = sys._getframe(0).f_code.co_name\n        Wrapper.print(\"=========== %s ========\" % (funcName))\n\n        aggPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, FABRIC_NAME, aggSn))\n        Wrapper.print(\"%s: aggSn %s, vpc peer %s\" % (funcName, aggSn, aggPeerSn))\n\n        torPorts = []\n\n        accesses = topologyDataObj.get(TopologyInfoType.ACCESSES)\n        if not accesses:\n            Wrapper.print(\"%s: No access devices in the fabric, skip\")\n            respObj.setSuccessRetCode()\n            return torPorts\n        \n        #Determine if accessSn is paired to the aggSn    \n        for accessSn in accesses:\n            switchDict = globalOverlayInfo[\"SWITCH_INFO\"][accessSn]\n            switchOverlayInfo = globalOverlayInfo[\"SWITCH_OVERLAYS\"][accessSn]\n\n            #Wrapper.print(\"%s: aggSn %s accessSn %s switchDict %s switchOverlayInfo %s\" % (funcName, aggSn, accessSn, switchDict, switchOverlayInfo))\n\n            #Extract the right network entry for this accessSn\n            if networkId in switchOverlayInfo[\"NETWORKS_BY_ID\"]:\n                netEntry = switchOverlayInfo[\"NETWORKS_BY_ID\"][networkId]\n            else:\n                Wrapper.print(\"%s: aggSn %s accessSn %s Ignoring network with vlanId %s\" % (funcName, aggSn, accessSn, networkId))\n                return torPorts\n                \n            Wrapper.print(\"%s: aggSn %s accessSn %s netEntry %s\" % (funcName, aggSn, accessSn, netEntry))\n  \n            isAccessVpc = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, accessSn))\n            if isAccessVpc:\n                # topology 4\n                accessVpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, accessSn))\n                aggSnPaired = Util.exe(ToRWrapper.getTorAssociation(accessVpcPairSerialKey))\n    \n                accessPeerSn = Util.exe(VpcWrapper.get(VPCMetaDataType.PEER_DEVICE_SN, FABRIC_NAME, accessSn))\n    \n                if aggSnPaired and aggSn in aggSnPaired:\n                    # Access VPC is b2b paired with with agg VPC\n                    Wrapper.print(\"%s: topo #4, pair present <%s, %s> - <%s, %s>, no change\" % (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n\n                    #Need to filter out access uplink ports that are part of the uplink_access policies \n                    #These are the interfaces connected between access-agg based on the b2b vpc\n                    Wrapper.print(\"%s: device %s[%s] attachInfo %s UplinkInts %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, netEntry[\"attachInfo\"], switchDict[\"accessUplinkIntfs\"]))\n                    \n                    accessNetAttachInfo = set(netEntry[\"attachInfo\"]) - set(switchDict[\"accessUplinkIntfs\"])\n                    Wrapper.print(\"%s: device %s[%s] accessNetAttachInfo %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, accessNetAttachInfo))\n\n                    accessNetAttachInfoStr = \",\".join(accessNetAttachInfo)\n\n                    formattedAccessNetAttachInfo = switchDict[\"hostName\"] + \"(\" + accessNetAttachInfoStr + \")\"\n                    Wrapper.print(\"%s: device %s[%s] fmtattachInfo %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, formattedAccessNetAttachInfo))\n                    \n                    torPorts.append(formattedAccessNetAttachInfo)\n            else:\n                accessPeerSn = \"\"\n                aggSnPaired = Util.exe(ToRWrapper.getTorAssociation(accessSn))\n                aggVpcPeerConnected = isSwitchConnected(topologyDataObj, accessSn, aggPeerSn)\n    \n                Wrapper.print(\"%s:%s aggSnPaired %s, aggVpcPeerConnected %s\" % (funcName, accessSn, aggSnPaired, aggVpcPeerConnected))\n                if aggSnPaired and aggSn in aggSnPaired:\n                    # Access is paired with agg\n                    Wrapper.print(\"%s: topo #2 or #3 <%s, %s> - <%s, %s>\" % (funcName, aggSn, aggPeerSn, accessSn, accessPeerSn))\n\n                    if aggVpcPeerConnected:\n                        # topology 2, (accessSn) is dual-attached/paired with (aggSn, aggPeerSn)\n                        Wrapper.print(\"%s: topo #2, pair <%s, %s> - <%s>\" % (funcName, aggSn, aggPeerSn, accessSn))\n                    else:\n                        # topology 3, (accessSn) is only paired with (aggSn)\n                        Wrapper.print(\"%s: topo #3, pair <%s> - <%s>\" % (funcName, aggSn, accessSn))\n\n                    #Need to filter out access uplink ports that are part of the uplink_access policies \n                    #These are the interfaces connected between access-agg\n                    Wrapper.print(\"%s: device %s[%s] attachInfo %s UplinkInts %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, netEntry[\"attachInfo\"], switchDict[\"accessUplinkIntfs\"]))\n                    \n                    accessNetAttachInfo = set(netEntry[\"attachInfo\"]) - set(switchDict[\"accessUplinkIntfs\"])\n                    Wrapper.print(\"%s: device %s[%s] accessNetAttachInfo %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, accessNetAttachInfo))\n\n                    accessNetAttachInfoStr = \",\".join(accessNetAttachInfo)\n\n                    formattedAccessNetAttachInfo = switchDict[\"hostName\"] + \"(\" + accessNetAttachInfoStr + \")\"\n                    Wrapper.print(\"%s: device %s[%s] fmtattachInfo %s\" % \n                                (funcName, switchDict[\"fmtName\"], accessSn, formattedAccessNetAttachInfo))\n                    \n                    torPorts.append(formattedAccessNetAttachInfo)\n\n        return torPorts\n    except respObjError as e:\n        #TODO: Handle exception properly\n        Wrapper.print(\"%s:Exception while processing agg torPorts for %s %s\" % (funcName, aggSn, e))\n        return []\n\ndef handleTorLeafPairingBF(topologyDataObj, torSn, respObj, globalOverlayInfo):\n    try:\n        funcName = sys._getframe(0).f_code.co_name\n        Wrapper.print(\"=========== Entering %s(): ========\" % (funcName))\n        #Wrapper.print(\"=========== %s ========%s\" % (funcName, globalOverlayInfo))\n        policyIdNum = 0\n        switchInfo = globalOverlayInfo[\"SWITCH_INFO\"]\n        leafSn = leafVpcPeerSn = \"\"\n        torVpcPeerSn = \"\"\n        leafPcRmId = leafVpcPeerPcRmId = leafVpcRmId = leafVpcPeerVpcRmId = -1\n        torPcRmId = torVpcPeerPcRmId = torVpcRmId = torVpcPeerVpcRmId = -1\n        leafMemberList = []\n        leafVpcPeerMemberList = []\n        torMemberList = []\n        torVpcPeerMemberList = []\n        shutInterfaceList = []\n        torVpcPairSerialKey = leafVpcPairSerialKey = \"\"\n        isTorVpc = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, torSn))\n        if isTorVpc:\n            torVpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, torSn))\n            serials = torVpcPairSerialKey.split(Helper.DELIMITER)\n            torSn = serials[0]\n            torVpcPeerSn = serials[1]\n            leafSns = Util.exe(ToRWrapper.getTorAssociation(torVpcPairSerialKey))\n            Wrapper.print(\"%s(): accessSn %s accessVpcPairSerialKey %s aggSns %s\" % (funcName, torSn, torVpcPairSerialKey, leafSns))\n        else:\n            leafSns = Util.exe(ToRWrapper.getTorAssociation(torSn))\n            Wrapper.print(\"%s(): accessSn %s aggSns %s\" % (funcName, torSn, leafSns))\n\n        sn0 = sn1 = \"\"\n        if leafSns == None or len(leafSns) == 0:\n            respObj.addErrorReport(getFabErrEntity(funcName, torSn),\n                                   \"Aggregation devices are not present in the fabric \"\n                                   \"or connections between Aggregation and Access devices are not proper, \"\n                                   \"please have the valid topology and try again\",torSn)\n            respObj.setFailureRetCode()\n            return respObj\n        elif len(leafSns) == 1:\n            for sn in leafSns:\n                leafSn = sn\n            isLeafVpc = False\n        elif len(leafSns) == 2:\n            for sn in leafSns:\n                if not sn0:\n                    sn0 = sn\n                if sn0 is not sn:\n                    sn1 = sn\n                    break\n            isLeafVpc = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, sn0))\n            if not isLeafVpc:\n                vpcFeaturePtiList = Util.exe(PTI.get(sn0, \"SWITCH\", \"SWITCH\", \"UNDERLAY\", \"base_feature_vpc\"))\n                if vpcFeaturePtiList:\n                    Wrapper.print(\"%s(): was a vpc!!! \")\n                    leafSn = sn0\n                    leafVpcPeerSn = sn1 \n            else:\n                Wrapper.print(\"%s(): is a vpc!!! \")\n                leafVpcPairSerialKey = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, sn0))\n                serials = leafVpcPairSerialKey.split(Helper.DELIMITER)\n                leafSn = serials[0]\n                leafVpcPeerSn = serials[1]\n        else:\n            Wrapper.print(\"%s(): ERROR!!! accessSn %s getAccessAssociation() returns aggSns %s (size=%d)\" %\n                          (funcName, torSn, leafSns, len(leafSns)))\n            return respObj\n            \n        Wrapper.print(\"%s(): accessSn:[%s] accessVpcPeerSn:[%s] aggSn:[%s] aggVpcPeerSn:[%s] isAggVpc:%r isAccessVpc:%r\" %\n                      (funcName, torSn, torVpcPeerSn, leafSn, leafVpcPeerSn, isLeafVpc, isTorVpc))\n\n        leafPcId = \"\"\n        torPcId = \"\"\n        leafVpcPeerPcId = \"\"\n        torVpcPeerPcId = \"\"\n        leafVpcId = \"\"\n        torVpcId = \"\"\n\n        linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, torSn, Helper.getNbrTypeInternal()))\n        torNetworkIntfs = getTorNetworkIntfsFromNbrList(torSn, linkNbrList)\n\n        for torIntf in torNetworkIntfs:\n            torNbrInfo = getTorNbrInfo(torSn, torIntf, linkNbrList)\n            Wrapper.print(\"%s() accessSn %s accessIntf %s accessNbrInfo %s\" %(funcName, torSn, torIntf, torNbrInfo))\n\n            if not torNbrInfo.get(\"nbrSn\"):\n                continue\n\n            #Given the torIntf, determine the PC ID or vPC ID/PC ID associated with its parent interface on the access\n            #That must already have been reserved in RM for the vanilla port-channel or vpc interfaces\n            #Need to free up that RM before doing allocating new RM Id and associating it with the uplink_access PTI\n            ptiList = Util.exe(PTIWrapper.getPTIs(torSn, \"INTERFACE\", torIntf, \"PYTHON\"))\n            for pti in ptiList:\n                intf_source = pti.getSource()\n                Wrapper.print(\"%s() accessSn %s accessIntf %s accessNbrInfo %s source %s\" %(funcName, torSn, torIntf, torNbrInfo, intf_source))\n                if intf_source.lower().find(\"port-channel\") != -1:\n                    #means its a layer-2 port-channel scenario\n                    torPcId = intf_source.split('port-channel')[1]\n                elif intf_source.lower().find(\"vpc\") != -1:\n                    #means its a vPC host port scenario\n                    torVpcId = intf_source.split('vPC')[1]\n                    if not torVpcPairSerialKey:\n                        respObj.addErrorReport(getFabErrEntity(funcName, torSn),\n                                   \"Incorrect vpc configuration found in port-channel%s between Aggregation and Access devices. <br>\"\n                                   \"Please correct this interface configuration and try again.\"%(torVpcId) ,torSn)\n                        respObj.setFailureRetCode()\n                        return respObj\n                    #means its a vPC host port scenario\n                    torVpcIntf = \"vPC\" + torVpcId\n                    #Determine the corresponding PC Id for each vpc peer\n                    ptiList1 = Util.exe(PTIWrapper.getPTIs(torVpcPairSerialKey, \"INTERFACE\", torVpcIntf, \"PYTHON\"))\n                    for pti1 in ptiList1:\n                        nvPairs = pti1.getNvPairs()\n                        torPcId = nvPairs.get(\"PEER1_PCID\",\"\")\n                        torVpcPeerPcId = nvPairs.get(\"PEER2_PCID\",\"\")\n                        break    \n                else:\n                    #standalone interface which is NOT expected between agg-access\n                    Wrapper.print(\"%s(): Ethernet interface scenario: accessSn %s accessIntf %s accessNbrInfo %s\" %(funcName, torSn, torIntf, torNbrInfo))\n                break\n\n            nbrSn = torNbrInfo.get(\"nbrSn\")\n            nbrIntf = torNbrInfo.get(\"nbrIntf\")\n            #Given the nbrIntf, determine the PC ID or vPC ID/PC ID associated with its parent interface on the agg\n            #That must already have been reserved in RM for the vanilla port-channel or vpc interfaces\n            #Need to free up that RM before doing allocating new RM Id and associating it with the uplink_access PTI\n            ptiList = Util.exe(PTIWrapper.getPTIs(nbrSn, \"INTERFACE\", nbrIntf, \"PYTHON\"))\n            for pti in ptiList:\n                intf_source = pti.getSource()\n                Wrapper.print(\"%s() aggSn %s aggIntf %s source %s\" %(funcName, nbrSn, nbrIntf, intf_source))\n                if intf_source.lower().find(\"port-channel\") != -1:\n                    #means its a layer-2 port-channel scenario\n                    leafPcId = intf_source.split('port-channel')[1]\n                elif intf_source.lower().find(\"vpc\") != -1:\n                    #means its a vPC host port scenario\n                    leafVpcId = intf_source.split('vPC')[1]\n                    if not leafVpcPairSerialKey:\n                        respObj.addErrorReport(getFabErrEntity(funcName, nbrSn),\n                                   \"Incorrect vpc configuration found in port-channel%s between Aggregation and Access devices. <br>\"\n                                   \"Please correct this interface configuration and try again.\"%(leafVpcId) ,nbrSn)\n                        respObj.setFailureRetCode()\n                        return respObj\n\n                    leafVpcIntf = \"vPC\" + leafVpcId\n                    #Determine the corresponding PC Id for each vpc peer\n                    ptiList1 = Util.exe(PTIWrapper.getPTIs(leafVpcPairSerialKey, \"INTERFACE\", leafVpcIntf, \"PYTHON\"))\n                    for pti1 in ptiList1:\n                        nvPairs = pti1.getNvPairs()\n                        leafPcId = nvPairs.get(\"PEER1_PCID\",\"\")\n                        leafVpcPeerPcId = nvPairs.get(\"PEER2_PCID\",\"\")\n                        break    \n                else:\n                    #standalone interface which is NOT expected between agg-access\n                    Wrapper.print(\"%s(): Ethernet interface scenario: aggSn %s aggIntf %s\" %(funcName, nbrSn, nbrIntf))\n                break\n\n            Wrapper.print(\"%s() leafPcId %s torPcId %s leafVpcPeerPcId %s torVpcPeerPcId %s leafVpcId %s torVpcId %s\" %\n                              (funcName, leafPcId, torPcId, leafVpcPeerPcId, torVpcPeerPcId, leafVpcId, torVpcId))\n            if not isTorVpc:\n                torPOIntf = \"port-channel\" + torPcId\n                leafVpcIntf = \"vPC\" + leafVpcId\n                leafPOIntf = \"port-channel\" + leafPcId\n                leafVpcPeerPOIntf = \"port-channel\" + leafVpcPeerPcId\n                \n                '''\n                entityName = Helper.getUUIDBySerialNumber(torSn)\n                #torPcId, torPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, entityName))\n                ignore, torPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, entityName, torPcId))\n                torPOIntf = \"port-channel\" + torPcId\n                if not isLeafVpc:\n                    leafUUID = Helper.getUUIDBySerialNumber(leafSn)\n                    torUUID = Helper.getUUIDBySerialNumber(torSn)\n                    entityName = (\"%s%s%s\" % (leafUUID, Helper.DELIMITER, torUUID))\n                    #leafPcId, leafPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, entityName))\n                    ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, entityName, leafPcId))\n                else:\n                    entityName = (\"%s%s%s\" % (leafVpcPairSerialKey, Helper.CARET_JYTHON, torSn))\n                    #leafVpcId, leafVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafSn, entityName))\n                    ignore, leafVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafSn, entityName, leafVpcId))\n                    ignore, leafVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafVpcPeerSn, entityName, leafVpcId))\n                    leafVpcIntf = \"vPC\" + leafVpcId\n                    ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafVpcIntf, leafPcId))\n                    ignore, leafVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafVpcPeerSn, leafVpcIntf, leafVpcPeerPcId))\n                '''    \n            else:\n                Wrapper.print(\"%s() pass RM handling here\" %(funcName))\n                leafVpcIntf = \"vPC\" + leafVpcId\n                torVpcIntf = \"vPC\" + torVpcId\n                torPOIntf = \"port-channel\" + torPcId\n                leafPOIntf = \"port-channel\" + leafPcId\n                torVpcPeerPOIntf = \"port-channel\" + torVpcPeerPcId\n                leafVpcPeerPOIntf = \"port-channel\" + leafVpcPeerPcId\n                \n                '''\n                # Leaf must also be VPC\n                entityName = (\"%s%s%s\" % (leafVpcPairSerialKey, Helper.CARET_JYTHON, torVpcPairSerialKey))\n                #leafVpcId, leafVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafSn, entityName))\n                ignore, leafVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafSn, entityName, leafVpcId))\n                ignore, leafVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafVpcPeerSn, entityName, leafVpcId))\n                Wrapper.print(\"%s() Back-to-back VPC: accessSn %s entityName %s aggVpcId %s\" %\n                              (funcName, torSn, entityName, leafVpcId))\n\n                #torVpcId, torVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", torSn, torVpcPairSerialKey))\n                ignore, torVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", torSn, torVpcPairSerialKey, torVpcId))\n                ignore, torVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", torVpcPeerSn, torVpcPairSerialKey, torVpcId))\n                leafVpcIntf = \"vPC\" + leafVpcId\n                torVpcIntf = \"vPC\" + torVpcId\n                Wrapper.print(\"%s() Back-to-back VPC: accessSn %s accessVpcPairSerialKey %s accessVpcId %s\" %\n                              (funcName, torSn, torVpcPairSerialKey, torVpcId))\n\n                ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafVpcIntf, leafPcId))\n                ignore, leafVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafVpcPeerSn, leafVpcIntf, leafVpcPeerPcId))\n\n                ignore, torPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, torVpcIntf, torPcId))\n                ignore, torVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torVpcPeerSn, torVpcIntf, torVpcPeerPcId))\n                '''\n                \n            if nbrSn == leafSn:\n                leafMemberList.append(nbrIntf)\n                torMemberList.append(torIntf)\n            elif nbrSn == leafVpcPeerSn:\n                leafVpcPeerMemberList.append(nbrIntf)\n                torMemberList.append(torIntf)\n\n        if torVpcPeerSn != \"\":\n            torVpcPeerLinkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, torVpcPeerSn, Helper.getNbrTypeInternal()))\n            torVpcPeerNetworkIntfs = getTorNetworkIntfsFromNbrList(torVpcPeerSn, torVpcPeerLinkNbrList)\n            for torIntf in torVpcPeerNetworkIntfs:\n                torNbrInfo = getTorNbrInfo(torVpcPeerSn, torIntf, torVpcPeerLinkNbrList)\n                Wrapper.print(\"%s() accessVpcPeerSn %s accessIntf %s accessNbrInfo %s\" %(funcName, torVpcPeerSn, torIntf, torNbrInfo))\n\n                if not torNbrInfo.get(\"nbrSn\"):\n                    continue\n\n                nbrSn = torNbrInfo.get(\"nbrSn\")\n                nbrIntf = torNbrInfo.get(\"nbrIntf\")\n                if nbrSn == leafSn:\n                    leafMemberList.append(nbrIntf)\n                    torVpcPeerMemberList.append(torIntf)\n                elif nbrSn == leafVpcPeerSn:\n                    leafVpcPeerMemberList.append(nbrIntf)\n                    torVpcPeerMemberList.append(torIntf)\n\n        if (not torMemberList or not leafMemberList or\n            (isLeafVpc and not leafVpcPeerMemberList) or\n            (isTorVpc and not torVpcPeerMemberList)):\n            Wrapper.print(\"%s(): Not all Aggregation-Access port-channels have members between Aggregation device [%s] and Access device [%s]\"%\n                          (funcName, leafVpcPairSerialKey if isLeafVpc else leafSn, torVpcPairSerialKey if isTorVpc else torSn))\n            respObj.addErrorReport(getFabErrEntity(funcName, torSn),\n                                   \"Not all Aggregation-Access port-channels have members between Aggregation device [%s] and Access device [%s]\"%\n                                   (leafVpcPairSerialKey if isLeafVpc else leafSn, torVpcPairSerialKey if isTorVpc else torSn), torSn)\n            respObj.setFailureRetCode()\n            return respObj\n\n        torHostName = Util.exe(InventoryWrapper.getHostName(torSn))\n        leafHostName = Util.exe(InventoryWrapper.getHostName(leafSn))\n        leafVpcPeerHostName = Util.exe(InventoryWrapper.getHostName(leafVpcPeerSn)) if leafVpcPeerSn != \"\" else \"\"\n        torVpcPeerHostName = Util.exe(InventoryWrapper.getHostName(torVpcPeerSn)) if torVpcPeerSn != \"\" else \"\"\n        torVpcPairHostName = torHostName + \"~\" + torVpcPeerHostName if torVpcPeerHostName != \"\" else \"\"\n        leafVpcPairHostName = leafHostName + \"~\" + leafVpcPeerHostName if leafVpcPeerHostName != \"\" else \"\"\n\n        aggAccPOTemplates = [\"int_port_channel_trunk_member_11_1\", \"int_vpc_trunk_po_member_11_1\",\n                             \"int_port_channel_uplink_access_member\", \"int_vpc_uplink_access_po_member\"]\n        if len(torMemberList) > 0:\n            intf_source = \"\"\n            ref_pcId = \"\"\n            errorMsg = \"\"\n            for intf in torMemberList:\n                ptiList = Util.exe(PTIWrapper.getPTIs(torSn, \"INTERFACE\", intf, \"PYTHON\"))\n                if ptiList:\n                    if ptiList[0].isDeleted():\n                        continue\n                    intf_source = ptiList[0].getSource()\n                    templateName = ptiList[0].getTemplateName()\n                    if templateName in aggAccPOTemplates:\n                        PO_ID = ptiList[0].getNvPairs()[\"PO_ID\"]\n                        pcId = PO_ID.lower().split('port-channel')[1]\n                        if ref_pcId == \"\":\n                            ref_pcId = pcId\n                        elif pcId != ref_pcId:\n                            errorMsg = (\"Found more than 1 port-channel between Aggregation [%s/%s] and Access [%s/%s]. \"\n                                        \"Please check the member interface(s) on Access: %s\" %\n                                        (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                         torHostName, torSn, \",\".join(torMemberList)))\n                    else:\n                        errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                    \"Please check this interface on Access: %s\" %\n                                    (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                     torHostName, torSn, intf))\n                else:\n                    Wrapper.print(\"SN %s: torMember intf [%s] has no policy attached\" % (torSn, intf))\n                    errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                \"Please check this interface on Access: %s\" %\n                                (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                 torHostName, torSn, intf))\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, torSn), errorMsg, torSn)\n                    respObj.setFailureRetCode()\n                    break\n\n            if errorMsg == \"\":\n                if isTorVpc and intf_source.lower().find(\"port-channel\") != -1:\n                    errorMsg = (\"Access is in vPC but the uplink access port-channel [%s] is not a vPC port-channel\" % intf_source.lower())\n                elif not isTorVpc and intf_source.lower().find(\"vpc\") != -1:\n                    errorMsg = (\"Access is not in vPC but the uplink access port-channel [%s] is a vPC port-channel\" % intf_source)\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, torSn), errorMsg, torSn)\n                    respObj.setFailureRetCode()\n\n        if len(leafMemberList) > 0:\n            intf_source = \"\"\n            ref_pcId = \"\"\n            errorMsg = \"\"\n            for intf in leafMemberList:\n                ptiList = Util.exe(PTIWrapper.getPTIs(leafSn, \"INTERFACE\", intf, \"PYTHON\"))\n                if ptiList:\n                    if ptiList[0].isDeleted():\n                        continue\n                    intf_source = ptiList[0].getSource()\n                    templateName = ptiList[0].getTemplateName()\n                    if templateName in aggAccPOTemplates:\n                        PO_ID = ptiList[0].getNvPairs()[\"PO_ID\"]\n                        pcId = PO_ID.lower().split('port-channel')[1]\n                        if ref_pcId == \"\":\n                            ref_pcId = pcId\n                        elif pcId != ref_pcId:\n                            errorMsg = (\"Found more than 1 port-channel between Aggregation [%s/%s] and Access [%s/%s]. \"\n                                        \"Please check the member interface(s) on Aggregation: %s\" %\n                                        (leafHostName, leafSn,\n                                         torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn,\n                                         \",\".join(leafMemberList)))\n                    else:\n                        errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                    \"Please check this interface on Aggregation: %s\" %\n                                    (leafHostName, leafSn,\n                                     torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn, intf))\n                else:\n                    Wrapper.print(\"SN %s: leafMember intf [%s] has no policy attached\" % (leafSn, intf))\n                    errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                \"Please check this interface on Aggregation: %s\" %\n                                (leafHostName, leafSn,\n                                 torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn, intf))\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, leafSn), errorMsg, leafSn)\n                    respObj.setFailureRetCode()\n                    break\n\n            if errorMsg == \"\":\n                if isLeafVpc and intf_source.lower().find(\"port-channel\") != -1:\n                    errorMsg = (\"Aggregation is in vPC but the uplink access port-channel [%s] is not a vPC port-channel\" % intf_source.lower())\n                elif not isLeafVpc and intf_source.lower().find(\"vpc\") != -1:\n                    errorMsg = (\"Aggregation is not in vPC but the uplink access port-channel [%s] is a vPC port-channel\" % intf_source)\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, leafSn), errorMsg, leafSn)\n                    respObj.setFailureRetCode()\n\n        if isLeafVpc and len(leafVpcPeerMemberList) > 0:\n            intf_source = \"\"\n            ref_pcId = \"\"\n            errorMsg = \"\"\n            for intf in leafVpcPeerMemberList:\n                ptiList = Util.exe(PTIWrapper.getPTIs(leafVpcPeerSn, \"INTERFACE\", intf, \"PYTHON\"))\n                if ptiList:\n                    if ptiList[0].isDeleted():\n                        continue\n                    intf_source = ptiList[0].getSource()\n                    templateName = ptiList[0].getTemplateName()\n                    if templateName in aggAccPOTemplates:\n                        PO_ID = ptiList[0].getNvPairs()[\"PO_ID\"]\n                        pcId = PO_ID.lower().split('port-channel')[1]\n                        if ref_pcId == \"\":\n                            ref_pcId = pcId\n                        elif pcId != ref_pcId:\n                            errorMsg = (\"Found more than 1 port-channel between Aggregation [%s/%s] and Access [%s/%s]. \"\n                                        \"Please check the member interface(s) on Aggregation: %s\" %\n                                        (leafVpcPeerHostName, leafVpcPeerSn,\n                                         torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn,\n                                         \",\".join(leafVpcPeerMemberList)))\n                    else:\n                        errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                    \"Please check this interface on Aggregation: %s\" %\n                                    (leafVpcPeerHostName, leafVpcPeerSn,\n                                     torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn, intf))\n                else:\n                    Wrapper.print(\"SN %s: leafVpcPeerMember intf [%s] has no policy attached\" % (leafVpcPeerSn, intf))\n                    errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                \"Please check this interface on Aggregation: %s\" %\n                                (leafVpcPeerHostName, leafVpcPeerSn,\n                                 torVpcPairHostName if isTorVpc else torHostName, torVpcPairSerialKey if isTorVpc else torSn, intf))\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, leafVpcPeerSn), errorMsg, leafVpcPeerSn)\n                    respObj.setFailureRetCode()\n                    break\n\n            if errorMsg == \"\":\n                if intf_source.lower().find(\"port-channel\") != -1:\n                    errorMsg = (\"Aggregation is in vPC but the uplink access port-channel [%s] is not a vPC port-channel\" % intf_source.lower())\n                    respObj.addErrorReport(getFabErrEntity(funcName, leafVpcPeerSn), errorMsg, leafVpcPeerSn)\n                    respObj.setFailureRetCode()\n\n        if isTorVpc and len(torVpcPeerMemberList) > 0:\n            intf_source = \"\"\n            ref_pcId = \"\"\n            errorMsg = \"\"\n            for intf in torVpcPeerMemberList:\n                ptiList = Util.exe(PTIWrapper.getPTIs(torVpcPeerSn, \"INTERFACE\", intf, \"PYTHON\"))\n                if ptiList:\n                    if ptiList[0].isDeleted():\n                        continue\n                    intf_source = ptiList[0].getSource()\n                    templateName = ptiList[0].getTemplateName()\n                    if templateName in aggAccPOTemplates:\n                        PO_ID = ptiList[0].getNvPairs()[\"PO_ID\"]\n                        pcId = PO_ID.lower().split('port-channel')[1]\n                        if ref_pcId == \"\":\n                            ref_pcId = pcId\n                        elif pcId != ref_pcId:\n                            errorMsg = (\"Found more than 1 port-channel between Aggregation [%s/%s] and Access [%s/%s]. \"\n                                        \"Please check the member interface(s) on Access: %s\" %\n                                        (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                         torVpcPeerHostName, torVpcPeerSn, \",\".join(torVpcPeerMemberList)))\n                    else:\n                        errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                    \"Please check this interface on Access: %s\" %\n                                    (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                     torVpcPeerHostName, torVpcPeerSn, intf))\n                else:\n                    Wrapper.print(\"SN %s: torVpcPeerMember intf [%s] has no policy attached\" % (torVpcPeerSn, intf))\n                    errorMsg = (\"Found an interface between Aggregation [%s/%s] and Access [%s/%s] not a member of the uplink access port-channel. \"\n                                \"Please check this interface on Access: %s\" %\n                                (leafVpcPairHostName if isLeafVpc else leafHostName, leafVpcPairSerialKey if isLeafVpc else leafSn,\n                                 torVpcPeerHostName, torVpcPeerSn, intf))\n                if errorMsg != \"\":\n                    respObj.addErrorReport(getFabErrEntity(funcName, torVpcPeerSn), errorMsg, torVpcPeerSn)\n                    respObj.setFailureRetCode()\n                    break\n\n            if errorMsg == \"\":\n                if intf_source.lower().find(\"port-channel\") != -1:\n                    errorMsg = (\"Access is in vPC but the uplink access port-channel [%s] is not a vPC port-channel\" % intf_source.lower())\n                    respObj.addErrorReport(getFabErrEntity(funcName, torVpcPeerSn), errorMsg, torVpcPeerSn)\n                    respObj.setFailureRetCode()\n\n        if respObj.isRetCodeFailure():\n            entityName = (\"%s%s%s\" % (torVpcPairSerialKey if isTorVpc else torSn, Helper.CARET_JYTHON, leafVpcPairSerialKey if isLeafVpc else leafSn))\n            respObj.addErrorReport(getFabErrEntity(funcName, entityName),\n                \"Unsupported Topology: Found multiple port-channels or vPC interfaces<br> for links \"\n                \"between aggregation and access switches. <br>All links between aggregation and access switches \"\n                \"<br>should be part of a single port-channel or vPC interface. <br>\"\n                \"Please correct the configuration and try again.\")\n            return respObj\n\n        torMemberIntfs = \",\".join(torMemberList)\n        leafMemberIntfs = \",\".join(leafMemberList)\n\n        srchOpt = CtrlPolicySearch()\n        if not isTorVpc:\n            srchOpt.setSerialNumber(torSn)\n            srchOpt.setEntityType(\"INTERFACE\")\n            srchOpt.setEntityName(torPOIntf)\n            srchOpt.setTemplateContentType(\"PYTHON\")\n            srchOpt.setTemplateName(\"int_port_channel_trunk_host\")\n            ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            if ptiList:\n                pti = ptiList[0]\n                nvPairs = copy.deepcopy(pti.getNvPairs())\n\n                Wrapper.print(\"%s(): accessSn [%s] Deleting trunk PO [%s] with policyId %s, nvPairs [%s]\" %\n                              (funcName, torSn, torPOIntf, pti.getPolicyId(), nvPairs))\n\n                #Get old RM associated with the tor PC and delete it               \n                ignore, oldTorPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, torPOIntf))\n                PTI.deleteInstance(pti.getPolicyId())\n                RM.deleteResource(oldTorPcRmId)\n\n                Wrapper.print(\"%s(): Deleted RMIds [%s]\" % (funcName, oldTorPcRmId))\n                \n                entityName = Helper.getUUIDBySerialNumber(torSn)\n                #torPcId, torPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, entityName))\n                policyIdNum = Util.exe(PTIWrapper.getPolicyID())\n\n                Wrapper.print(\"%s(): PolicyId number for not tor vPC [%s]\" %(funcName, policyIdNum))\n                ignore, torPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, entityName, torPcId))\n                RM.linkResource(policyIdNum, torPcRmId)\n\n                if not isLeafVpc:\n                    nvPairs.update({\"SWITCH_ROLE\": \"access\", \"NBR_SERIAL_NUMBER\": leafSn, \"NBR_INTF_NAME\": leafPOIntf})\n                else:\n                    nvPairs.update({\"SWITCH_ROLE\": \"access\", \"NBR_SERIAL_NUMBER\": leafVpcPairSerialKey, \"NBR_INTF_NAME\": leafVpcIntf})\n\n                nvPairs.pop(\"POLICY_ID\", \"ignore if not found\")\n                torPcRmIdList = [torPcRmId]\n                #should be called with List of rm Id\n                Util.exe(PTI.createOrUpdate(torSn, \"INTERFACE\", torPOIntf, \"\",\n                                            ConfigPriority.CONFIG_PRIO_INTF_PO, torPcRmIdList,\n                                            \"int_port_channel_uplink_access\", nvPairs, policyIdNum))\n                Wrapper.print(\"%s(): accessSn [%s] Created access PO [%s] with nvPairs [%s], accessPcRmId %s\" %\n                              (funcName, torSn, torPOIntf, nvPairs, torPcRmIdList))\n\n        # In the case of topo 3, access single attached to one of the 2 aggs of an agg vpc pair, isLeafVpc == False\n        nvPairs = {}\n        if not isLeafVpc:\n            srchOpt.setSerialNumber(leafSn)\n            srchOpt.setEntityType(\"INTERFACE\")\n            srchOpt.setEntityName(leafPOIntf)\n            srchOpt.setTemplateContentType(\"PYTHON\")\n            srchOpt.setTemplateName(\"int_port_channel_trunk_host\")\n            ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            if ptiList:\n                pti = ptiList[0]\n                nvPairs = copy.deepcopy(ptiList[0].getNvPairs())\n\n                Wrapper.print(\"%s(): leafSn [%s] Deleting leaf PO [%s] with policyId %s, nvPairs [%s]\" %\n                              (funcName, leafSn, leafPOIntf, pti.getPolicyId(), nvPairs))\n\n                #Get old RM associated with the leaf PC and delete it               \n                ignore, oldLeafPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafPOIntf))\n                PTI.deleteInstance(pti.getPolicyId())\n                RM.deleteResource(oldLeafPcRmId)\n                \n                #Do RM set for the leaf port-channel interface\n                leafUUID = Helper.getUUIDBySerialNumber(leafSn)\n                torUUID = Helper.getUUIDBySerialNumber(torSn)\n                entityName = (\"%s%s%s\" % (leafUUID, Helper.DELIMITER, torUUID))\n                policyIdNum = Util.exe(PTIWrapper.getPolicyID())\n                Wrapper.print(\"%s(): PolicyId number for not leaf vPC [%s]\" %(funcName, policyIdNum))\n                ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, entityName, leafPcId))\n                RM.linkResource(policyIdNum, leafPcRmId)\n\n                nvPairs.pop(\"POLICY_ID\", \"ignore if not found\")\n                nvPairs.update({\"SWITCH_ROLE\": \"aggregation\", \"NBR_SERIAL_NUMBER\": torSn, \"NBR_INTF_NAME\": torPOIntf})\n                leafPcRmIdList = [leafPcRmId]\n                #should be called with List of rm Id\n                Util.exe(PTI.createOrUpdate(leafSn, \"INTERFACE\", leafPOIntf, \"\",\n                                            ConfigPriority.CONFIG_PRIO_INTF_PO, leafPcRmIdList,\n                                            \"int_port_channel_uplink_access\", nvPairs, policyIdNum))\n                Wrapper.print(\"%s(): leafSn [%s] Created leaf PO [%s] with nvPairs [%s], leafPcRmId %s\" %\n                              (funcName, leafSn, leafPOIntf, nvPairs, leafPcRmIdList))\n                              \n        nvPairs = {}\n        if isLeafVpc:\n            leafVpcPeerMemberIntfs = \",\".join(leafVpcPeerMemberList)\n            srchOpt.setSerialNumber(leafVpcPairSerialKey)\n            srchOpt.setEntityType(\"INTERFACE\")\n            srchOpt.setEntityName(leafVpcIntf)\n            srchOpt.setTemplateContentType(\"PYTHON\")\n            srchOpt.setTemplateName(\"int_vpc_trunk_host\")\n            ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            if ptiList:\n                pti = ptiList[0]\n                nvPairs = copy.deepcopy(ptiList[0].getNvPairs())\n                #nvPairs[\"PEER1_MEMBER_INTERFACES\"] = leafMemberIntfs\n                #nvPairs[\"PEER2_MEMBER_INTERFACES\"] = leafVpcPeerMemberIntfs\n                #Delete the previous vpc host interface PTI\n                Wrapper.print(\"%s(): vPC-agg [%s] Deleting vPC-agg intf [%s] with policyId %s, nvPairs [%s]\" %\n                              (funcName, leafVpcPairSerialKey, leafVpcIntf, pti.getPolicyId(), nvPairs))\n                              \n                #Get old RM associated with the vPC and delete it               \n                ignore, oldLeafVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafSn, leafVpcPairSerialKey))\n                ignore, oldLeafVpcPeerRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafVpcPeerSn, leafVpcPairSerialKey))\n                ignore, oldLeafPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafPOIntf))\n                ignore, oldLeafVpcPeerPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafVpcPeerSn, leafVpcPeerPOIntf))\n\n                PTI.deleteInstance(pti.getPolicyId())\n                RM.deleteResource(oldLeafVpcRmId)\n                RM.deleteResource(oldLeafVpcPeerRmId)\n                RM.deleteResource(oldLeafPcRmId)\n                RM.deleteResource(oldLeafVpcPeerPcRmId)\n                \n                Wrapper.print(\"%s(): Deleted RMIds [%s] [%s] [%s] [%s]\" %\n                              (funcName, oldLeafVpcRmId, oldLeafVpcPeerRmId, oldLeafPcRmId, oldLeafVpcPeerPcRmId))\n                \n                if not isTorVpc:\n                    nvPairs.update({\"SWITCH_ROLE\": \"aggregation\", \"NBR_SERIAL_NUMBER\": torSn, \"NBR_INTF_NAME\": torPOIntf})\n\n\n                    entityName = (\"%s%s%s\" % (leafVpcPairSerialKey, Helper.CARET_JYTHON, torSn))\n                    policyIdNum = Util.exe(PTIWrapper.getPolicyID())\n                    Wrapper.print(\"%s(): PolicyId number for not tor vPC [%s]\" %(funcName, policyIdNum))\n                    #leafVpcId, leafVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafSn, entityName))\n                    ignore, leafVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafSn, entityName, leafVpcId))\n                    RM.linkResource(policyIdNum, leafVpcRmId)\n                    ignore, leafVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafVpcPeerSn, entityName, leafVpcId))\n                    RM.linkResource(policyIdNum, leafVpcPeerVpcRmId)\n                    Wrapper.print(\"%s() Back-to-back VPC: accessSn %s entityName %s aggVpcId %s\" %\n                                  (funcName, torSn, entityName, leafVpcId))\n    \n                    ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafVpcIntf, leafPcId))\n                    RM.linkResource(policyIdNum, leafPcRmId)\n                    ignore, leafVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafVpcPeerSn, leafVpcIntf, leafVpcPeerPcId))\n                    RM.linkResource(policyIdNum, leafVpcPeerPcRmId)\n                        \n                    leafRmIdList = [leafPcRmId] + [leafVpcPeerPcRmId] + [leafVpcRmId] + [leafVpcPeerVpcRmId]\n                    nvPairs.pop(\"POLICY_ID\", \"ignore if not found\")\n                    #should be called with List of rm Id\n                    Util.exe(PTI.createOrUpdate(leafVpcPairSerialKey, \"INTERFACE\", leafVpcIntf, \"\",\n                                                ConfigPriority.CONFIG_PRIO_INTF_PO, leafRmIdList,\n                                                \"int_vpc_uplink_access\", nvPairs, policyIdNum))\n                    Wrapper.print(\"%s(): vPC-agg [%s] Created vPC-agg intf [%s] with nvPairs [%s], aggRmId %s\" %\n                                  (funcName, leafVpcPairSerialKey, leafVpcIntf, nvPairs, leafRmIdList))\n\n                else:\n                    nvPairs.update({\"SWITCH_ROLE\": \"aggregation\", \"NBR_SERIAL_NUMBER\": torVpcPairSerialKey, \"NBR_INTF_NAME\": torVpcIntf})\n\n                    entityName = (\"%s%s%s\" % (leafVpcPairSerialKey, Helper.CARET_JYTHON, torVpcPairSerialKey))\n                    #leafVpcId, leafVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", leafSn, entityName))\n                    policyIdNum = Util.exe(PTIWrapper.getPolicyID())\n                    Wrapper.print(\"%s(): PolicyId number for not leaf vPC [%s]\" %(funcName, policyIdNum))\n                    ignore, leafVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafSn, entityName, leafVpcId))\n                    RM.linkResource(policyIdNum, leafVpcRmId)\n\n                    ignore, leafVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", leafVpcPeerSn, entityName, leafVpcId))\n                    RM.linkResource(policyIdNum, leafVpcPeerVpcRmId)\n                    Wrapper.print(\"%s() Back-to-back VPC: accessSn %s entityName %s aggVpcId %s\" %\n                                  (funcName, torSn, entityName, leafVpcId))\n    \n                    ignore, leafPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafSn, leafVpcIntf, leafPcId))\n                    RM.linkResource(policyIdNum, leafPcRmId)\n                    ignore, leafVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", leafVpcPeerSn, leafVpcIntf, leafVpcPeerPcId))\n                    RM.linkResource(policyIdNum, leafVpcPeerPcRmId)\n \n                    leafRmIdList = [leafPcRmId] + [leafVpcPeerPcRmId] + [leafVpcRmId] + [leafVpcPeerVpcRmId]\n                    nvPairs.pop(\"POLICY_ID\", \"ignore if not found\")\n                    #should be called with List of rm Id\n                    Util.exe(PTI.createOrUpdate(leafVpcPairSerialKey, \"INTERFACE\", leafVpcIntf, \"\",\n                                                ConfigPriority.CONFIG_PRIO_INTF_PO, leafRmIdList,\n                                                \"int_vpc_uplink_access\", nvPairs, policyIdNum))\n                    Wrapper.print(\"%s(): vPC-agg [%s] Created vPC-agg intf [%s] with nvPairs [%s], aggRmId %s\" %\n                                  (funcName, leafVpcPairSerialKey, leafVpcIntf, nvPairs, leafRmIdList))\n\n        nvPairs = {}\n        if isTorVpc:\n            torVpcPeerMemberIntfs = \",\".join(torVpcPeerMemberList)\n            srchOpt.setSerialNumber(torVpcPairSerialKey)\n            srchOpt.setEntityType(\"INTERFACE\")\n            srchOpt.setEntityName(torVpcIntf)\n            srchOpt.setTemplateContentType(\"PYTHON\")\n            srchOpt.setTemplateName(\"int_vpc_trunk_host\")\n            ptiList = Util.exe(PTIWrapper.getPTIs(srchOpt))\n            if ptiList:\n                pti = ptiList[0]\n                nvPairs = copy.deepcopy(ptiList[0].getNvPairs())\n                #nvPairs[\"PEER1_MEMBER_INTERFACES\"] = torMemberIntfs\n                #nvPairs[\"PEER2_MEMBER_INTERFACES\"] = torVpcPeerMemberIntfs\n                Wrapper.print(\"%s(): vPC-access [%s] Deleting vPC-access intf [%s] with policyId %s, nvPairs [%s]\" %\n                              (funcName, torVpcPairSerialKey, torVpcIntf, pti.getPolicyId(), nvPairs))\n\n                #Get old RM associated with the vPC and delete it               \n                ignore, oldTorVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", torSn, torVpcPairSerialKey))\n                ignore, oldTorVpcPeerRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", torVpcPeerSn, torVpcPairSerialKey))\n                ignore, oldTorPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, torPOIntf))\n                ignore, oldTorVpcPeerPcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"PORT_CHANNEL_ID\", torVpcPeerSn, torVpcPeerPOIntf))\n                PTI.deleteInstance(pti.getPolicyId())\n                RM.deleteResource(oldTorVpcRmId)\n                RM.deleteResource(oldTorVpcPeerRmId)\n                RM.deleteResource(oldTorPcRmId)\n                RM.deleteResource(oldTorVpcPeerPcRmId)\n\n                Wrapper.print(\"%s(): Deleted RMIds [%s] [%s] [%s] [%s]\" %\n                              (funcName, oldTorVpcRmId, oldTorVpcPeerRmId, oldTorPcRmId, oldTorVpcPeerPcRmId))\n                              \n                #torVpcId, torVpcRmId = Util.exeRM(RM.get(FABRIC_NAME, \"VPC_ID\", torSn, torVpcPairSerialKey))\n\n                policyIdNum = Util.exe(PTIWrapper.getPolicyID())\n                Wrapper.print(\"%s(): PolicyId number for not torVpc vPC [%s]\" %(funcName, policyIdNum))\n                ignore, torVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", torSn, torVpcPairSerialKey, torVpcId))\n                RM.linkResource(policyIdNum, torVpcRmId)\n\n                ignore, torVpcPeerVpcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"VPC_ID\", torVpcPeerSn, torVpcPairSerialKey, torVpcId))\n                RM.linkResource(policyIdNum, torVpcPeerVpcRmId)\n                leafVpcIntf = \"vPC\" + leafVpcId\n                torVpcIntf = \"vPC\" + torVpcId\n                Wrapper.print(\"%s() Back-to-back VPC: accessSn %s accessVpcPairSerialKey %s accessVpcId %s\" %\n                              (funcName, torSn, torVpcPairSerialKey, torVpcId))\n\n                ignore, torPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torSn, torVpcIntf, torPcId))\n                RM.linkResource(policyIdNum, torPcRmId)\n                ignore, torVpcPeerPcRmId = Util.exeRM(RM.set(FABRIC_NAME, \"PORT_CHANNEL_ID\", torVpcPeerSn, torVpcIntf, torVpcPeerPcId))\n                RM.linkResource(policyIdNum, torVpcPeerPcRmId)\n                \n                \n                torRmIdList = [torPcRmId] + [torVpcPeerPcRmId] + [torVpcRmId] + [torVpcPeerVpcRmId]\n                nvPairs.update({\"SWITCH_ROLE\": \"access\", \"NBR_SERIAL_NUMBER\": leafVpcPairSerialKey, \"NBR_INTF_NAME\": leafVpcIntf})\n                nvPairs.pop(\"POLICY_ID\", \"ignore if not found\")\n                #should be called with List of rm Id\n                Util.exe(PTI.createOrUpdate(torVpcPairSerialKey, \"INTERFACE\", torVpcIntf, \"\",\n                                            ConfigPriority.CONFIG_PRIO_INTF_PO, torRmIdList,\n                                            \"int_vpc_uplink_access\", nvPairs, policyIdNum))\n                Wrapper.print(\"%s(): vPC-access [%s] Created vPC-access intf [%s] with nvPairs [%s], accessRmId %s\" %\n                              (funcName, torVpcPairSerialKey, torVpcIntf, nvPairs, torRmIdList))\n        \n        if not isTorVpc:\n            if not isLeafVpc:\n                Util.exe(ToRWrapper.setLeafTorAssociation(leafSn, leafPOIntf, torSn, torPOIntf))\n                Wrapper.print(\"%s(): setAggAccessAssociation: aggSn %s aggPOIntf %s accessSn %s accessPOIntf %s\" %\n                              (funcName, leafSn, leafPOIntf, torSn, torPOIntf))\n                switchInfo[leafSn][\"accessUplinkIntfs\"].append(leafPOIntf.capitalize())\n                switchInfo[torSn][\"accessUplinkIntfs\"].append(torPOIntf.capitalize())\n            else:   \n                Util.exe(ToRWrapper.setLeafTorAssociation(leafSn, \"port-channel\"+leafPcId, torSn, torPOIntf))\n                Util.exe(ToRWrapper.setLeafTorAssociation(leafVpcPeerSn, \"port-channel\"+leafVpcPeerPcId, torSn, torPOIntf))\n                Wrapper.print(\"%s(): setAggAccessAssociation: aggSn %s aggPOIntf %s accessSn %s accessPOIntf %s\" %\n                              (funcName, leafSn, \"port-channel\"+leafPcId, torSn, torPOIntf))\n                Wrapper.print(\"%s(): setAggAccessAssociation: aggVpcPeerSn %s aggVpcPeerPOIntf %s accessSn %s accessPOIntf %s\" %\n                              (funcName, leafVpcPeerSn, \"port-channel\"+leafVpcPeerPcId, torSn, torPOIntf))\n                switchInfo[leafSn][\"accessUplinkIntfs\"].append((\"port-channel\"+leafPcId).capitalize())\n                switchInfo[leafVpcPeerSn][\"accessUplinkIntfs\"].append((\"port-channel\"+leafVpcPeerPcId).capitalize())\n                switchInfo[torSn][\"accessUplinkIntfs\"].append(torPOIntf.capitalize())\n        else:\n            Util.exe(ToRWrapper.setLeafTorAssociation(leafSn, \"port-channel\"+leafPcId, torSn, \"port-channel\"+torPcId))\n            Util.exe(ToRWrapper.setLeafTorAssociation(leafSn, \"port-channel\"+leafPcId, torVpcPeerSn, \"port-channel\"+torVpcPeerPcId))\n            Util.exe(ToRWrapper.setLeafTorAssociation(leafVpcPeerSn, \"port-channel\"+leafVpcPeerPcId, torSn, \"port-channel\"+torPcId))\n            Util.exe(ToRWrapper.setLeafTorAssociation(leafVpcPeerSn, \"port-channel\"+leafVpcPeerPcId, torVpcPeerSn, \"port-channel\"+torVpcPeerPcId))\n            switchInfo[leafSn][\"accessUplinkIntfs\"].append((\"port-channel\"+leafPcId).capitalize())\n            switchInfo[leafVpcPeerSn][\"accessUplinkIntfs\"].append((\"port-channel\"+leafVpcPeerPcId).capitalize())\n            switchInfo[torSn][\"accessUplinkIntfs\"].append((\"port-channel\"+torPcId).capitalize())\n            switchInfo[torVpcPeerSn][\"accessUplinkIntfs\"].append((\"port-channel\"+torVpcPeerPcId).capitalize())\n        return respObj\n    except Exception as e:\n        if policyIdNum and policyIdNum > 0:\n            Wrapper.print(\"%s(): clean resource for pid %s\"%(funcName, policyIdNum))\n            PTIWrapper.deletePtiVsRMForPolicyId(policyIdNum) \n        if isinstance(e, respObjError):\n            return e.value\n        else:\n            errorMsg = (\"Unexpected error in Access/Aggregation pairing for Access switch [%s], switches are still in migration mode\"%(torSn))\n            Util.handleException(errorMsg, e, respObj)\n\ndef getTorNetworkIntfsFromNbrList(sn, linkNbrList):\n    funcName = sys._getframe(0).f_code.co_name\n    linkType = \"\"\n    intraISLIntfs = []\n    Wrapper.print(\"=======%s():-Start for [%s]=======\"%(funcName, sn))\n    for linkNbr in linkNbrList:\n        sw1Info = json.loads(linkNbr.get(\"sw2-info\"))\n        sw2Info = json.loads(linkNbr.get(\"sw1-info\"))\n        sw2_sn, sw1_sn = getSNsFromNbrList(linkNbr)\n        Wrapper.print(\"==%s(): SWITCH1 INFO==[%s]\"%(funcName, sw1Info))\n        Wrapper.print(\"==%s(): SWITCH2 INFO==[%s]\"%(funcName, sw2Info))\n        linkType = linkNbr.get(\"link-type\")\n        operState = linkNbr.get(\"is-present\")\n        isSwitchVPC = isVPCPair(sw1_sn, sw2_sn)\n        Wrapper.print (\"%s(): vpcPair [%s] linkType [%s] oper [%s] \"\n                       \"SN1:SN2:IFNAME1:IFNAME2 [%s:%s-%s:%s] SwRole1:SwRole2 [%s:%s] fabric1:fabric2 [%s:%s]\" %\n                       (funcName, isSwitchVPC, linkType, operState,\n                        sw1_sn, sw2_sn,\n                        sw1Info.get(\"if-name\"), sw2Info.get(\"if-name\"),\n                        sw1Info.get(\"switch-role\"), sw2Info.get(\"switch-role\"),\n                        sw1Info.get(\"fabric-name\"), sw2Info.get(\"fabric-name\")))\n\n        #TODO: Need to handle deletion of int_pre_provisioned_fabric_link PTI when using planned_link\n        if isSwitchVPC or (linkType != \"ethisl\" and linkType != \"lan_planned_link\"):\n            continue\n\n        intraIntf = nbrSwitchRole = \"\"\n        if (sw1_sn == sn):\n            intraIntf = sw1Info.get(\"if-name\")\n            nbrSwitchRole = sw2Info.get(\"switch-role\")\n        elif (sw2_sn == sn):\n            intraIntf = sw2Info.get(\"if-name\")\n            nbrSwitchRole = sw1Info.get(\"switch-role\")\n\n        if intraIntf and \"Ethernet\" in intraIntf and nbrSwitchRole == \"aggregation\":\n            intraISLIntfs.append(intraIntf)\n\n    Wrapper.print(\"===%s() All ethisl/planned links:[%s]===\"%(funcName, intraISLIntfs))\n    Wrapper.print(\"===%s()-End for [%s]===\"%(funcName, sn))\n    return (intraISLIntfs)\n\ndef getTorNbrInfo(sn, intf, linkNbrList):\n    funcName = sys._getframe(0).f_code.co_name\n    nbrInfo = {\"nbrSn\":\"\", \"nbrIntf\":\"\"}\n    nbrSn = nbrIntf = \"\"\n    for linkNbr in linkNbrList:\n        sw1Info = json.loads(linkNbr.get(\"sw2-info\"))\n        sw2Info = json.loads(linkNbr.get(\"sw1-info\"))\n        linkType = linkNbr.get(\"link-type\")\n        operState = linkNbr.get(\"is-present\")\n        Wrapper.print(\"%s() sn %s intf %s linkType %s operState %s sw1Info %s sw2Info %s\" %\n                      (funcName, sn, intf, linkType, operState, sw1Info, sw2Info))\n        #if linkType != \"ethisl\" or operState == \"false\":\n        if linkType != \"ethisl\" and linkType != \"lan_planned_link\":\n            continue\n        sw2_sn, sw1_sn = getSNsFromNbrList(linkNbr)\n        if (sw1_sn == sn and sw1Info.get(\"if-name\") == intf):\n            fabric = sw1Info.get(\"fabric-name\")\n            nbrIntf = sw2Info.get(\"if-name\")\n            nbrSn = sw2_sn\n        if (sw2_sn == sn and sw2Info.get(\"if-name\") == intf):\n            fabric = sw2Info.get(\"fabric-name\")\n            nbrIntf = sw1Info.get(\"if-name\")\n            nbrSn = sw1_sn\n        if nbrIntf and nbrSn:\n            Wrapper.print(\"%s() fab: %s link [%s] [%s] <---> [%s] [%s]\" %\n                          (funcName, fabric, sn, intf, nbrIntf, nbrSn))\n            nbrInfo.update({\"nbrSn\":nbrSn, \"nbrIntf\":nbrIntf})\n            break\n    return nbrInfo\n\ndef getSNsFromNbrList(nbrLink):\n    sw1_info = json.loads(nbrLink[\"sw1-info\"])\n    sw2_info = json.loads(nbrLink[\"sw2-info\"])\n\n    if \"is-vdc\" in sw1_info and sw1_info[\"is-vdc\"] == \"true\":\n        sw1_sn = Util.getVDCSn(sw1_info)\n    else:\n        sw1_sn = sw1_info[\"sw-serial-number\"]\n\n    if \"is-vdc\" in sw2_info and sw2_info[\"is-vdc\"] == \"true\":\n        sw2_sn = Util.getVDCSn(sw2_info)\n    else:\n        sw2_sn = sw2_info[\"sw-serial-number\"]\n\n    return sw1_sn, sw2_sn\n\ndef isSwitchConnected(topologyDataObj, deviceSn1, deviceSn2):\n    funcName = sys._getframe(0).f_code.co_name\n    linkNbrList = Util.exe(Helper.getNbrList(FABRIC_NAME, deviceSn1, Helper.getNbrTypeInternal()))\n\n    for nbrLink in linkNbrList:\n        if nbrLink[\"link-type\"] not in [\"ethisl\", \"lan_planned_link\"]:\n            Wrapper.print(\"%s: Link for node: %s is not ethisl or lan_planned_link: %s IGNORE\" %\n                            (funcName, deviceSn1, nbrLink[\"link-type\"]))\n            continue\n\n        sw1_sn, sw2_sn = getSNsFromNbrList(nbrLink)\n\n        if sw1_sn == deviceSn2 or sw2_sn == deviceSn2:\n            Wrapper.print(\"%s: access-agg <%s, %s> connected\" % (funcName, deviceSn1, deviceSn2))\n            return True\n\n    Wrapper.print(\"%s: access-agg <%s, %s> NOT connected\" % (funcName, deviceSn1, deviceSn2))\n    return False\n\ndef isVPCPair(sn1, sn2):\n    isSwitchVPC1 = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, sn1))\n    isSwitchVPC2 = Util.exe(VpcWrapper.isVpc(FABRIC_NAME, sn2))\n    if not isSwitchVPC1 or not isSwitchVPC2:\n        return False\n    vpcPairSerialKey1 = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, sn1))\n    vpcPairSerialKey2 = Util.exe(VpcWrapper.get(VPCMetaDataType.VPC_PAIR, FABRIC_NAME, sn2))\n    if vpcPairSerialKey1 == vpcPairSerialKey2:\n        return True\n    return False\n\ndef ECLgetSviCfg(vlanIdStr, interfacesRes, includeAllCfg, isVrf):\n    funcName = sys._getframe(0).f_code.co_name\n    freeformCfg = \"\"\n    sviName = 'Vlan'+ vlanIdStr\n    intfMatchResult = interfacesRes.get(sviName)\n    if intfMatchResult != None:\n        if includeAllCfg:\n            ffList = [\"interface \" + sviName]\n            ffList += intfMatchResult[\"show_run_cmds\"]\n            freeformCfg += (Util.newLine() + Util.newLine().join(ffList))\n        else:\n            if len(intfMatchResult[\"unaccounted_cmds\"]) > 0:\n                Wrapper.print(\"%s: sviName [%s]. Unaccounted [%s]\" % (funcName, sviName, intfMatchResult[\"unaccounted_cmds\"]))\n\n                sviUnacctCmds = []\n\n                # - these commands have issues with negation. Ex: to remove 'no ip redirects' CC will issue 'ip redirects'\n                #   which causes the command to actually get removed on switch\n                overlaySpecialSviCmds = [\"no ip redirects\", \"no ipv6 redirects\"]\n                sviHasOtherUnaccCmds = False\n\n                # special case some overlay SVI commands.. the redirect and forward related configs do not\n                # have policies to match\n                overlaySviCmds = [\"no shutdown\"]\n                for cmd in intfMatchResult[\"unaccounted_cmds\"]:\n                    strippedCmd = cmd.strip()\n                    if strippedCmd in overlaySviCmds:\n                        continue\n                    elif strippedCmd not in overlaySpecialSviCmds:\n                        sviHasOtherUnaccCmds = True\n\n                    sviUnacctCmds.append(cmd)\n\n                '''\n                if \"vlan_interface\" in intfMatchResult[\"matched_templates\"]:\n                    # this policy being present indicates both the CLI are present.. add them \n                    for cmd in overlaySpecialSviCmds:\n                        sviUnacctCmds.append(INTF_FIRST_LVL_SPACING + cmd)\n                '''\n                \n                Wrapper.print(\"%s: sviName [%s]. sviUnacctCmds [%s]\" % (funcName, sviName, sviUnacctCmds))\n                if len(sviUnacctCmds) > 0:\n                    finalCfgToAddToFreeform = None\n                    if sviHasOtherUnaccCmds:\n                        finalCfgToAddToFreeform = sviUnacctCmds\n\n                    if finalCfgToAddToFreeform:\n                        cfg = Util.newLine().join(finalCfgToAddToFreeform)\n                        freeformCfg += (Util.newLine() + \"interface \" + sviName + Util.newLine() + cfg)\n\n                        '''\n                        # we need to add the 'no shutdown' config to avoid an issue seen with CC trying to\n                        # remove individual config lines.. otherwise CC will generate 'shutdown' to negate 'no shutdown'\n                        if \"no_shut_interface\" in intfMatchResult[\"matched_templates\"]:\n                            freeformCfg += (Util.newLine() + (\"%sno shutdown\" % INTF_FIRST_LVL_SPACING))\n                        '''    \n                        Wrapper.print(\"%s: sviName [%s]. freeformCfg [%s]\" % (funcName, sviName, freeformCfg))\n    return freeformCfg\n    \n##\n","fileName":"fabric_upgrade_11_1.template","templateType":"POLICY","contentType":"PYTHON","templateSubType":"NA","_implements":"","dependencies":"","referenceCount":0,"published":false,"timestamp":"2023-08-18 08:10:43","importedTemplates":null,"implements":""}